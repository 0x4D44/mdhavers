{"files":[{"path":["/","home","md","language","mdhavers","benchmarks","large_scale","rust","fib_large.rs"],"content":"// Large-Scale Fibonacci Benchmark (Rust)\nuse std::time::Instant;\n\nfn fib_iter(n: u64) -> u64 {\n    if n < 2 {\n        return n;\n    }\n    let mut a = 0u64;\n    let mut b = 1u64;\n    for _ in 2..=n {\n        let temp = a.wrapping_add(b);\n        a = b;\n        b = temp;\n    }\n    b\n}\n\nfn main() {\n    println!(\"=== Large-Scale Fibonacci Benchmark (Rust) ===\");\n\n    println!(\"Correctness check:\");\n    println!(\"  fib(10) = {}\", fib_iter(10));\n    println!(\"  fib(20) = {}\", fib_iter(20));\n    println!(\"  fib(50) = {}\", fib_iter(50));\n\n    println!(\"\\nLarge-scale iterative tests:\");\n\n    let start = Instant::now();\n    let _ = fib_iter(1000);\n    let elapsed = start.elapsed();\n    println!(\"  fib_iter(1000): {} us\", elapsed.as_micros());\n\n    let start = Instant::now();\n    let _ = fib_iter(10000);\n    let elapsed = start.elapsed();\n    println!(\"  fib_iter(10000): {} us\", elapsed.as_micros());\n\n    let start = Instant::now();\n    let _ = fib_iter(50000);\n    let elapsed = start.elapsed();\n    println!(\"  fib_iter(50000): {} us\", elapsed.as_micros());\n\n    let start = Instant::now();\n    let _ = fib_iter(100000);\n    let elapsed = start.elapsed();\n    println!(\"  fib_iter(100000): {} us\", elapsed.as_micros());\n\n    println!(\"\\nStress test (10000 calls to fib_iter(100)):\");\n    let start = Instant::now();\n    for _ in 0..10000 {\n        let _ = fib_iter(100);\n    }\n    let elapsed = start.elapsed();\n    println!(\"  10000x fib_iter(100): {} ms\", elapsed.as_millis());\n\n    println!(\"\\n=== Fibonacci large-scale complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","large_scale","rust","primes_large.rs"],"content":"// Large-Scale Prime Sieve Benchmark (Rust)\nuse std::time::Instant;\n\nfn count_primes(limit: usize) -> usize {\n    let mut is_prime = vec![true; limit + 1];\n    is_prime[0] = false;\n    if limit > 0 {\n        is_prime[1] = false;\n    }\n\n    let mut p = 2;\n    while p * p <= limit {\n        if is_prime[p] {\n            let mut multiple = p * p;\n            while multiple <= limit {\n                is_prime[multiple] = false;\n                multiple += p;\n            }\n        }\n        p += 1;\n    }\n\n    is_prime.iter().filter(|&&x| x).count()\n}\n\nfn sieve(limit: usize) -> Vec<usize> {\n    let mut is_prime = vec![true; limit + 1];\n    is_prime[0] = false;\n    if limit > 0 {\n        is_prime[1] = false;\n    }\n\n    let mut p = 2;\n    while p * p <= limit {\n        if is_prime[p] {\n            let mut multiple = p * p;\n            while multiple <= limit {\n                is_prime[multiple] = false;\n                multiple += p;\n            }\n        }\n        p += 1;\n    }\n\n    is_prime.iter().enumerate()\n        .filter(|(_, &is_p)| is_p)\n        .map(|(i, _)| i)\n        .collect()\n}\n\nfn main() {\n    println!(\"=== Large-Scale Prime Sieve Benchmark (Rust) ===\");\n\n    println!(\"Correctness check:\");\n    let small = sieve(100);\n    println!(\"  Primes to 100: {} primes\", small.len());\n    println!(\"  First 10: {:?}\", &small[..10]);\n\n    println!(\"\\nScaling tests:\");\n\n    let start = Instant::now();\n    let c = count_primes(10000);\n    let elapsed = start.elapsed();\n    println!(\"  sieve(10K): {} primes in {} us\", c, elapsed.as_micros());\n\n    let start = Instant::now();\n    let c = count_primes(50000);\n    let elapsed = start.elapsed();\n    println!(\"  sieve(50K): {} primes in {} us\", c, elapsed.as_micros());\n\n    let start = Instant::now();\n    let c = count_primes(100000);\n    let elapsed = start.elapsed();\n    println!(\"  sieve(100K): {} primes in {} ms\", c, elapsed.as_millis());\n\n    let start = Instant::now();\n    let c = count_primes(500000);\n    let elapsed = start.elapsed();\n    println!(\"  sieve(500K): {} primes in {} ms\", c, elapsed.as_millis());\n\n    let start = Instant::now();\n    let c = count_primes(1000000);\n    let elapsed = start.elapsed();\n    println!(\"  sieve(1M): {} primes in {} ms\", c, elapsed.as_millis());\n\n    println!(\"\\n=== Prime sieve large-scale complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","large_scale","rust","sort_stress.rs"],"content":"// Sort Stress Test Benchmark (Rust)\nuse std::time::Instant;\n\nstruct Rng {\n    seed: u64,\n}\n\nimpl Rng {\n    fn new(seed: u64) -> Self {\n        Rng { seed }\n    }\n\n    fn next(&mut self) -> u64 {\n        self.seed = (self.seed.wrapping_mul(1103515245).wrapping_add(12345)) % 2147483648;\n        self.seed % 10000\n    }\n}\n\nfn make_random_list(n: usize, rng: &mut Rng) -> Vec<u64> {\n    (0..n).map(|_| rng.next()).collect()\n}\n\nfn is_sorted(lst: &[u64]) -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    println!(\"=== Sort Stress Test Benchmark (Rust) ===\");\n\n    println!(\"Correctness check:\");\n    let mut rng = Rng::new(12345);\n    let small: Vec<u64> = (0..10).map(|_| rng.next()).collect();\n    println!(\"  Unsorted: {:?}\", small);\n    let mut sorted_small = small.clone();\n    sorted_small.sort();\n    println!(\"  Sorted: {:?}\", sorted_small);\n    println!(\"  Is sorted: {}\", is_sorted(&sorted_small));\n\n    println!(\"\\nScaling tests:\");\n\n    let mut rng = Rng::new(12345);\n    let start = Instant::now();\n    let mut lst = make_random_list(1000, &mut rng);\n    let gen_time = start.elapsed();\n    let start = Instant::now();\n    lst.sort();\n    let sort_time = start.elapsed();\n    println!(\"  1K elements: gen={}us, sort={}us, valid={}\",\n             gen_time.as_micros(), sort_time.as_micros(), is_sorted(&lst));\n\n    let mut rng = Rng::new(12345);\n    let start = Instant::now();\n    let mut lst = make_random_list(5000, &mut rng);\n    let gen_time = start.elapsed();\n    let start = Instant::now();\n    lst.sort();\n    let sort_time = start.elapsed();\n    println!(\"  5K elements: gen={}us, sort={}us, valid={}\",\n             gen_time.as_micros(), sort_time.as_micros(), is_sorted(&lst));\n\n    let mut rng = Rng::new(12345);\n    let start = Instant::now();\n    let mut lst = make_random_list(10000, &mut rng);\n    let gen_time = start.elapsed();\n    let start = Instant::now();\n    lst.sort();\n    let sort_time = start.elapsed();\n    println!(\"  10K elements: gen={}us, sort={}us, valid={}\",\n             gen_time.as_micros(), sort_time.as_micros(), is_sorted(&lst));\n\n    let mut rng = Rng::new(12345);\n    let start = Instant::now();\n    let mut lst = make_random_list(50000, &mut rng);\n    let gen_time = start.elapsed();\n    let start = Instant::now();\n    lst.sort();\n    let sort_time = start.elapsed();\n    println!(\"  50K elements: gen={}us, sort={}ms, valid={}\",\n             gen_time.as_micros(), sort_time.as_millis(), is_sorted(&lst));\n\n    let mut rng = Rng::new(12345);\n    let start = Instant::now();\n    let mut lst = make_random_list(100000, &mut rng);\n    let gen_time = start.elapsed();\n    let start = Instant::now();\n    lst.sort();\n    let sort_time = start.elapsed();\n    println!(\"  100K elements: gen={}us, sort={}ms, valid={}\",\n             gen_time.as_micros(), sort_time.as_millis(), is_sorted(&lst));\n\n    println!(\"\\n=== Sort stress complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","large_scale","rust","string_large.rs"],"content":"// Large-Scale String Processing Benchmark (Rust)\nuse std::time::Instant;\n\nfn build_string(n: usize) -> String {\n    let mut result = String::new();\n    for _ in 0..n {\n        result.push('x');\n    }\n    result\n}\n\nfn build_pattern_string(n: usize) -> String {\n    let mut result = String::new();\n    for _ in 0..n {\n        result.push_str(\"abc,\");\n    }\n    result\n}\n\nfn main() {\n    println!(\"=== Large-Scale String Processing Benchmark (Rust) ===\");\n\n    println!(\"Correctness check:\");\n    let small = build_string(10);\n    println!(\"  build_string(10): len={}\", small.len());\n    let pattern = build_pattern_string(5);\n    println!(\"  build_pattern_string(5): {}\", pattern);\n\n    println!(\"\\nString building scaling:\");\n\n    let start = Instant::now();\n    let s = build_string(100);\n    let elapsed = start.elapsed();\n    println!(\"  build_string(100): {} us, len={}\", elapsed.as_micros(), s.len());\n\n    let start = Instant::now();\n    let s = build_string(500);\n    let elapsed = start.elapsed();\n    println!(\"  build_string(500): {} us, len={}\", elapsed.as_micros(), s.len());\n\n    let start = Instant::now();\n    let s = build_string(1000);\n    let elapsed = start.elapsed();\n    println!(\"  build_string(1000): {} us, len={}\", elapsed.as_micros(), s.len());\n\n    let start = Instant::now();\n    let s = build_string(2000);\n    let elapsed = start.elapsed();\n    println!(\"  build_string(2000): {} us, len={}\", elapsed.as_micros(), s.len());\n\n    println!(\"\\nSplit/join on pattern strings:\");\n\n    let start = Instant::now();\n    let pattern = build_pattern_string(100);\n    let elapsed = start.elapsed();\n    println!(\"  Build 100 patterns: {} us, len={}\", elapsed.as_micros(), pattern.len());\n\n    let start = Instant::now();\n    let parts: Vec<&str> = pattern.split(',').collect();\n    let elapsed = start.elapsed();\n    println!(\"  Split 100 patterns: {} us, parts={}\", elapsed.as_micros(), parts.len());\n\n    let start = Instant::now();\n    let joined = parts.join(\"-\");\n    let elapsed = start.elapsed();\n    println!(\"  Join 100 parts: {} us, len={}\", elapsed.as_micros(), joined.len());\n\n    let start = Instant::now();\n    let pattern = build_pattern_string(500);\n    let elapsed = start.elapsed();\n    println!(\"  Build 500 patterns: {} us, len={}\", elapsed.as_micros(), pattern.len());\n\n    let start = Instant::now();\n    let parts: Vec<&str> = pattern.split(',').collect();\n    let elapsed = start.elapsed();\n    println!(\"  Split 500 patterns: {} us, parts={}\", elapsed.as_micros(), parts.len());\n\n    let start = Instant::now();\n    let joined = parts.join(\"-\");\n    let elapsed = start.elapsed();\n    println!(\"  Join 500 parts: {} us, len={}\", elapsed.as_micros(), joined.len());\n\n    println!(\"\\nString operations on large strings:\");\n\n    let mut large = String::from(\"The quick brown fox jumps over the lazy dog. \");\n    for _ in 0..5 {\n        large = format!(\"{}{}\", large, large.clone());\n    }\n    println!(\"  Built string of length: {}\", large.len());\n\n    let start = Instant::now();\n    let u = large.to_uppercase();\n    let elapsed = start.elapsed();\n    println!(\"  upper(): {} us\", elapsed.as_micros());\n    drop(u);\n\n    let start = Instant::now();\n    let l = large.to_lowercase();\n    let elapsed = start.elapsed();\n    println!(\"  lower(): {} us\", elapsed.as_micros());\n    drop(l);\n\n    let start = Instant::now();\n    let found = large.contains(\"fox\");\n    let elapsed = start.elapsed();\n    println!(\"  contains('fox'): {} in {} us\", found, elapsed.as_micros());\n\n    let start = Instant::now();\n    let found = large.contains(\"xyz\");\n    let elapsed = start.elapsed();\n    println!(\"  contains('xyz'): {} in {} us\", found, elapsed.as_micros());\n\n    println!(\"\\n=== String large-scale complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","factorial.rs"],"content":"use std::time::Instant;\n\nfn factorial(n: u64) -> u64 {\n    if n <= 1 {\n        return 1;\n    }\n    n * factorial(n - 1)\n}\n\nfn factorial_iter(n: u64) -> u64 {\n    let mut result = 1u64;\n    for i in 2..=n {\n        result *= i;\n    }\n    result\n}\n\npub fn run() {\n    // Test correctness\n    println!(\"Testing correctness...\");\n    println!(\"0! = {}\", factorial(0));\n    println!(\"1! = {}\", factorial(1));\n    println!(\"5! = {}\", factorial(5));\n    println!(\"10! = {}\", factorial(10));\n\n    // Benchmark\n    println!(\"\\nComputing 20!...\");\n    let start = Instant::now();\n    let result = factorial(20);\n    let elapsed = start.elapsed();\n    println!(\"20! = {} ({:?})\", result, elapsed);\n\n    // Iterative\n    println!(\"\\nComputing factorial iteratively...\");\n    let start = Instant::now();\n    for i in 1..=20 {\n        let f = factorial_iter(i);\n        println!(\"{}! = {}\", i, f);\n    }\n    let elapsed = start.elapsed();\n    println!(\"Total time: {:?}\", elapsed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","fibonacci.rs"],"content":"use std::time::Instant;\n\nfn fib_naive(n: u64) -> u64 {\n    if n <= 1 {\n        return n;\n    }\n    fib_naive(n - 1) + fib_naive(n - 2)\n}\n\nfn fib_iter(n: u64) -> u64 {\n    if n <= 1 {\n        return n;\n    }\n    let (mut a, mut b) = (0u64, 1u64);\n    for _ in 2..=n {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    b\n}\n\npub fn run() {\n    // Test correctness\n    println!(\"Testing correctness...\");\n    println!(\"fib(0) = {}\", fib_iter(0));\n    println!(\"fib(1) = {}\", fib_iter(1));\n    println!(\"fib(10) = {}\", fib_iter(10));\n    println!(\"fib(20) = {}\", fib_iter(20));\n\n    // Iterative benchmark\n    println!(\"\\nIterative fib(40)...\");\n    let start = Instant::now();\n    let result = fib_iter(40);\n    let elapsed = start.elapsed();\n    println!(\"fib_iter(40) = {} ({:?})\", result, elapsed);\n\n    // Naive recursive benchmark\n    println!(\"\\nNaive recursive fib(30)...\");\n    let start = Instant::now();\n    let result = fib_naive(30);\n    let elapsed = start.elapsed();\n    println!(\"fib_naive(30) = {} ({:?})\", result, elapsed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","gcd.rs"],"content":"use std::time::Instant;\n\nfn gcd(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        return a;\n    }\n    gcd(b, a % b)\n}\n\nfn gcd_iter(mut a: i64, mut b: i64) -> i64 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\nfn lcm(a: i64, b: i64) -> i64 {\n    (a * b) / gcd(a, b)\n}\n\nfn gcd_list(arr: &[i64]) -> i64 {\n    if arr.is_empty() {\n        return 0;\n    }\n    if arr.len() == 1 {\n        return arr[0];\n    }\n    let mut result = arr[0];\n    for &x in arr.iter().skip(1) {\n        result = gcd(result, x);\n    }\n    result\n}\n\npub fn run() {\n    // Test correctness\n    println!(\"Testing correctness...\");\n    println!(\"gcd(48, 18) = {}\", gcd(48, 18));\n    println!(\"gcd(54, 24) = {}\", gcd(54, 24));\n    println!(\"gcd(17, 13) = {}\", gcd(17, 13));\n    println!(\"gcd(100, 35) = {}\", gcd(100, 35));\n\n    println!(\"\\nTesting LCM...\");\n    println!(\"lcm(4, 6) = {}\", lcm(4, 6));\n    println!(\"lcm(21, 6) = {}\", lcm(21, 6));\n\n    // Stress test\n    println!(\"\\nComputing 1000 GCDs...\");\n    let start = Instant::now();\n    let mut sum: i64 = 0;\n    for i in 1..=1000 {\n        let g = gcd_iter(i * 7, i * 5);\n        sum += g;\n    }\n    let elapsed = start.elapsed();\n    println!(\"Sum of 1000 GCDs: {} ({:?})\", sum, elapsed);\n\n    // Large numbers\n    println!(\"\\nTesting with large numbers...\");\n    println!(\"gcd(123456789, 987654321) = {}\", gcd(123456789, 987654321));\n    println!(\"gcd(1000000007, 998244353) = {}\", gcd(1000000007, 998244353));\n\n    // GCD of list\n    println!(\"\\nGCD of [48, 36, 24, 12]...\");\n    let numbers = vec![48, 36, 24, 12];\n    println!(\"gcd_list = {}\", gcd_list(&numbers));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","main.rs"],"content":"// Rust benchmark implementations for comparison with mdhavers\n// Run with: cargo run --release\n\nuse std::time::Instant;\n\nmod fibonacci;\nmod factorial;\nmod gcd;\nmod primes;\nmod quicksort;\nmod mergesort;\n\nfn main() {\n    println!(\"=== Rust Benchmarks ===\\n\");\n\n    println!(\"--- Fibonacci ---\");\n    fibonacci::run();\n    println!();\n\n    println!(\"--- Factorial ---\");\n    factorial::run();\n    println!();\n\n    println!(\"--- GCD ---\");\n    gcd::run();\n    println!();\n\n    println!(\"--- Primes ---\");\n    primes::run();\n    println!();\n\n    println!(\"--- Quicksort ---\");\n    quicksort::run();\n    println!();\n\n    println!(\"--- Mergesort ---\");\n    mergesort::run();\n    println!();\n\n    println!(\"=== Rust Benchmarks Complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","mergesort.rs"],"content":"use std::time::Instant;\n\nfn mergesort(arr: &[i64]) -> Vec<i64> {\n    if arr.len() <= 1 {\n        return arr.to_vec();\n    }\n\n    let mid = arr.len() / 2;\n    let left = mergesort(&arr[..mid]);\n    let right = mergesort(&arr[mid..]);\n\n    merge(&left, &right)\n}\n\nfn merge(left: &[i64], right: &[i64]) -> Vec<i64> {\n    let mut result = Vec::with_capacity(left.len() + right.len());\n    let (mut i, mut j) = (0, 0);\n\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] {\n            result.push(left[i]);\n            i += 1;\n        } else {\n            result.push(right[j]);\n            j += 1;\n        }\n    }\n\n    result.extend_from_slice(&left[i..]);\n    result.extend_from_slice(&right[j..]);\n    result\n}\n\nfn is_sorted(arr: &[i64]) -> bool {\n    arr.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn make_array(size: usize) -> Vec<i64> {\n    let mut arr = Vec::with_capacity(size);\n    let mut seed: i64 = 42;\n    for _ in 0..size {\n        seed = (seed.wrapping_mul(1103515245).wrapping_add(12345)) % 2147483648;\n        arr.push(seed % 1000);\n    }\n    arr\n}\n\npub fn run() {\n    // Test correctness\n    println!(\"Testing correctness...\");\n    let test = vec![38, 27, 43, 3, 9, 82, 10];\n    println!(\"Original: {:?}\", test);\n    let sorted = mergesort(&test);\n    println!(\"Sorted: {:?}\", sorted);\n\n    // Small benchmark\n    println!(\"\\nSorting 50 elements...\");\n    let arr50 = make_array(50);\n    let start = Instant::now();\n    let sorted50 = mergesort(&arr50);\n    let elapsed = start.elapsed();\n    println!(\"Sorted 50 elements, is_sorted: {} ({:?})\", is_sorted(&sorted50), elapsed);\n\n    // Medium benchmark\n    println!(\"\\nSorting 200 elements...\");\n    let arr200 = make_array(200);\n    let start = Instant::now();\n    let sorted200 = mergesort(&arr200);\n    let elapsed = start.elapsed();\n    println!(\"Sorted 200 elements, is_sorted: {} ({:?})\", is_sorted(&sorted200), elapsed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","primes.rs"],"content":"use std::time::Instant;\n\nfn sieve(n: usize) -> Vec<usize> {\n    let mut is_prime = vec![true; n + 1];\n    if n >= 0 {\n        is_prime[0] = false;\n    }\n    if n >= 1 {\n        is_prime[1] = false;\n    }\n\n    let mut p = 2;\n    while p * p <= n {\n        if is_prime[p] {\n            let mut j = p * p;\n            while j <= n {\n                is_prime[j] = false;\n                j += p;\n            }\n        }\n        p += 1;\n    }\n\n    is_prime\n        .iter()\n        .enumerate()\n        .filter(|(_, &is_p)| is_p)\n        .map(|(i, _)| i)\n        .collect()\n}\n\nfn is_prime(n: i64) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    let mut i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n\npub fn run() {\n    // Test correctness\n    println!(\"Testing primality...\");\n    println!(\"is_prime(2) = {}\", is_prime(2));\n    println!(\"is_prime(17) = {}\", is_prime(17));\n    println!(\"is_prime(18) = {}\", is_prime(18));\n    println!(\"is_prime(97) = {}\", is_prime(97));\n\n    // Sieve benchmark\n    println!(\"\\nSieve of Eratosthenes up to 100...\");\n    let start = Instant::now();\n    let primes100 = sieve(100);\n    let elapsed = start.elapsed();\n    println!(\"Found {} primes ({:?})\", primes100.len(), elapsed);\n    println!(\n        \"First 10: {:?}\",\n        primes100.iter().take(10).collect::<Vec<_>>()\n    );\n\n    println!(\"\\nSieve up to 1000...\");\n    let start = Instant::now();\n    let primes1000 = sieve(1000);\n    let elapsed = start.elapsed();\n    println!(\"Found {} primes up to 1000 ({:?})\", primes1000.len(), elapsed);\n\n    println!(\"\\nSieve up to 5000...\");\n    let start = Instant::now();\n    let primes5000 = sieve(5000);\n    let elapsed = start.elapsed();\n    println!(\"Found {} primes up to 5000 ({:?})\", primes5000.len(), elapsed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","rust","src","quicksort.rs"],"content":"use std::time::Instant;\n\nfn quicksort(arr: &mut [i64]) {\n    if arr.len() <= 1 {\n        return;\n    }\n\n    let pivot_idx = partition(arr);\n    let (left, right) = arr.split_at_mut(pivot_idx);\n    quicksort(left);\n    quicksort(&mut right[1..]);\n}\n\nfn partition(arr: &mut [i64]) -> usize {\n    let pivot = arr[arr.len() - 1];\n    let mut i = 0;\n    for j in 0..arr.len() - 1 {\n        if arr[j] <= pivot {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    arr.swap(i, arr.len() - 1);\n    i\n}\n\nfn is_sorted(arr: &[i64]) -> bool {\n    arr.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn make_test_array(size: usize) -> Vec<i64> {\n    let mut arr = Vec::with_capacity(size);\n    let mut seed: i64 = 12345;\n    for _ in 0..size {\n        seed = (seed.wrapping_mul(1103515245).wrapping_add(12345)) % 2147483648;\n        arr.push(seed % 1000);\n    }\n    arr\n}\n\npub fn run() {\n    // Test correctness\n    println!(\"Testing correctness...\");\n    let mut small = vec![5, 2, 8, 1, 9, 3, 7, 4, 6];\n    println!(\"Original: {:?}\", small);\n    quicksort(&mut small);\n    println!(\"Sorted: {:?}\", small);\n    println!(\"Is sorted: {}\", is_sorted(&small));\n\n    // Medium benchmark\n    println!(\"\\nSorting 100 elements...\");\n    let mut medium = make_test_array(100);\n    let start = Instant::now();\n    quicksort(&mut medium);\n    let elapsed = start.elapsed();\n    println!(\"Sorted 100 elements, is_sorted: {} ({:?})\", is_sorted(&medium), elapsed);\n\n    // Large benchmark\n    println!(\"\\nSorting 500 elements...\");\n    let mut large = make_test_array(500);\n    let start = Instant::now();\n    quicksort(&mut large);\n    let elapsed = start.elapsed();\n    println!(\"Sorted 500 elements, is_sorted: {} ({:?})\", is_sorted(&large), elapsed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","stress","rust","fib_stress.rs"],"content":"// Fibonacci Stress Test - Rust Implementation\n\nuse std::time::Instant;\n\nfn fib_naive(n: u64) -> u64 {\n    if n <= 1 { return n; }\n    fib_naive(n - 1) + fib_naive(n - 2)\n}\n\nfn fib_iter(n: u64) -> u64 {\n    if n <= 1 { return n; }\n    let mut a = 0u64;\n    let mut b = 1u64;\n    for _ in 2..=n {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    b\n}\n\nfn main() {\n    println!(\"=== Fibonacci Stress Test (Rust) ===\");\n    \n    // Correctness\n    println!(\"Correctness check:\");\n    println!(\"  fib(10) = {}\", fib_iter(10));\n    println!(\"  fib(20) = {}\", fib_iter(20));\n    \n    // Iterative stress\n    println!(\"\\nIterative stress test:\");\n    let start = Instant::now();\n    let result = fib_iter(10000);\n    let elapsed = start.elapsed();\n    println!(\"  fib_iter(10000) completed in {} us\", elapsed.as_micros());\n    \n    // Many iterations\n    let start2 = Instant::now();\n    for _ in 0..1000 {\n        let _ = fib_iter(1000);\n    }\n    let elapsed2 = start2.elapsed();\n    println!(\"  1000x fib_iter(1000) in {} ms\", elapsed2.as_millis());\n    \n    // Recursive stress\n    println!(\"\\nRecursive stress test:\");\n    let start3 = Instant::now();\n    let r30 = fib_naive(30);\n    let elapsed3 = start3.elapsed();\n    println!(\"  fib_naive(30) = {} in {} ms\", r30, elapsed3.as_millis());\n    \n    println!(\"\\n=== Fibonacci stress complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","stress","rust","primes_stress.rs"],"content":"// Primes Stress Test - Rust Implementation\n\nuse std::time::Instant;\n\nfn sieve(n: usize) -> Vec<usize> {\n    let mut is_prime = vec![true; n + 1];\n    if n >= 0 { is_prime[0] = false; }\n    if n >= 1 { is_prime[1] = false; }\n    \n    let mut p = 2;\n    while p * p <= n {\n        if is_prime[p] {\n            let mut j = p * p;\n            while j <= n {\n                is_prime[j] = false;\n                j += p;\n            }\n        }\n        p += 1;\n    }\n    \n    (2..=n).filter(|&k| is_prime[k]).collect()\n}\n\nfn main() {\n    println!(\"=== Primes Stress Test (Rust) ===\");\n    \n    // Correctness\n    println!(\"Correctness check:\");\n    let p100 = sieve(100);\n    println!(\"  Primes to 100: {} primes\", p100.len());\n    \n    // Scale tests\n    println!(\"\\nScalability tests:\");\n    \n    let start1 = Instant::now();\n    let p1k = sieve(1000);\n    let t1 = start1.elapsed();\n    println!(\"  sieve(1000): {} primes in {} us\", p1k.len(), t1.as_micros());\n    \n    let start2 = Instant::now();\n    let p5k = sieve(5000);\n    let t2 = start2.elapsed();\n    println!(\"  sieve(5000): {} primes in {} us\", p5k.len(), t2.as_micros());\n    \n    let start3 = Instant::now();\n    let p10k = sieve(10000);\n    let t3 = start3.elapsed();\n    println!(\"  sieve(10000): {} primes in {} us\", p10k.len(), t3.as_micros());\n    \n    let start4 = Instant::now();\n    let p20k = sieve(20000);\n    let t4 = start4.elapsed();\n    println!(\"  sieve(20000): {} primes in {} us\", p20k.len(), t4.as_micros());\n    \n    // Scaling\n    println!(\"\\nScaling analysis:\");\n    println!(\"  5K/1K time ratio: {:.2}\", t2.as_nanos() as f64 / t1.as_nanos() as f64);\n    println!(\"  10K/5K time ratio: {:.2}\", t3.as_nanos() as f64 / t2.as_nanos() as f64);\n    println!(\"  20K/10K time ratio: {:.2}\", t4.as_nanos() as f64 / t3.as_nanos() as f64);\n    \n    println!(\"\\n=== Primes stress complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","benchmarks","stress","rust","string_stress.rs"],"content":"// String Stress Test - Rust Implementation\n\nuse std::time::Instant;\n\nfn main() {\n    println!(\"=== String Stress Test (Rust) ===\");\n    \n    // String concatenation\n    println!(\"String concatenation:\");\n    let start1 = Instant::now();\n    let mut s = String::new();\n    for _ in 0..1000 {\n        s.push('x');\n    }\n    let t1 = start1.elapsed();\n    println!(\"  1000 single-char concats: {} us, len={}\", t1.as_micros(), s.len());\n    \n    let start2 = Instant::now();\n    let mut s2 = String::new();\n    for _ in 0..100 {\n        s2.push_str(\"hello world \");\n    }\n    let t2 = start2.elapsed();\n    println!(\"  100 multi-char concats: {} us, len={}\", t2.as_micros(), s2.len());\n    \n    // String operations\n    println!(\"\\nString operations:\");\n    let test_str = \"The quick brown fox jumps over the lazy dog\";\n    \n    let start3 = Instant::now();\n    for _ in 0..1000 {\n        let _ = test_str.to_uppercase();\n    }\n    let t3 = start3.elapsed();\n    println!(\"  1000x upper(): {} us\", t3.as_micros());\n    \n    let start4 = Instant::now();\n    for _ in 0..1000 {\n        let _ = test_str.to_lowercase();\n    }\n    let t4 = start4.elapsed();\n    println!(\"  1000x lower(): {} us\", t4.as_micros());\n    \n    // Split/join\n    println!(\"\\nSplit/Join operations:\");\n    let csv_line = \"field1,field2,field3,field4,field5,field6,field7,field8,field9,field10\";\n    \n    let start5 = Instant::now();\n    for _ in 0..1000 {\n        let _: Vec<&str> = csv_line.split(',').collect();\n    }\n    let t5 = start5.elapsed();\n    println!(\"  1000x split(): {} us\", t5.as_micros());\n    \n    let words = vec![\"one\", \"two\", \"three\", \"four\", \"five\"];\n    let start6 = Instant::now();\n    for _ in 0..1000 {\n        let _ = words.join(\"-\");\n    }\n    let t6 = start6.elapsed();\n    println!(\"  1000x join(): {} us\", t6.as_micros());\n    \n    // Contains\n    println!(\"\\nContains operations:\");\n    let long_str = \"Lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor\";\n    \n    let start7 = Instant::now();\n    for _ in 0..1000 {\n        let _ = long_str.contains(\"tempor\");\n    }\n    let t7 = start7.elapsed();\n    println!(\"  1000x contains(): {} us\", t7.as_micros());\n    \n    println!(\"\\n=== String stress complete ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","build.rs"],"content":"use std::process::Command;\n\nfn main() {\n    // Tell cargo to rerun this script if the runtime source changes\n    println!(\"cargo:rerun-if-changed=runtime/mdh_runtime.c\");\n    println!(\"cargo:rerun-if-changed=runtime/mdh_runtime.h\");\n\n    // Compile the runtime\n    let status = Command::new(\"gcc\")\n        .args([\n            \"-c\",\n            \"-O2\",\n            \"-fPIC\",\n            \"runtime/mdh_runtime.c\",\n            \"-o\",\n            \"runtime/mdh_runtime.o\",\n        ])\n        .status()\n        .expect(\"Failed to run gcc\");\n\n    if !status.success() {\n        panic!(\"Failed to compile runtime\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","playground","src","lib.rs"],"content":"//! mdhavers Playground WASM Bindings\n//!\n//! This crate provides WebAssembly bindings for running mdhavers\n//! code in the browser.\n\nuse wasm_bindgen::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n// Initialize panic hook for better error messages in browser\n#[wasm_bindgen(start)]\npub fn init() {\n    #[cfg(feature = \"console_error_panic_hook\")]\n    console_error_panic_hook::set_once();\n}\n\n/// Result of running mdhavers code\n#[derive(Serialize, Deserialize)]\npub struct RunResult {\n    /// Whether execution was successful\n    pub success: bool,\n    /// The result value (as string)\n    pub result: String,\n    /// Output from blether statements\n    pub output: Vec<String>,\n    /// Error message if execution failed\n    pub error: Option<String>,\n}\n\n/// Run mdhavers code and return the result as JSON\n///\n/// # Arguments\n/// * `code` - The mdhavers source code to execute\n///\n/// # Returns\n/// A JSON string containing the RunResult\n#[wasm_bindgen]\npub fn run(code: &str) -> String {\n    let result = run_internal(code);\n    serde_json::to_string(&result).unwrap_or_else(|e| {\n        format!(r#\"{{\"success\":false,\"error\":\"Serialization error: {}\",\"result\":\"\",\"output\":[]}}\"#, e)\n    })\n}\n\nfn run_internal(code: &str) -> RunResult {\n    // Parse the code\n    let program = match mdhavers::parse(code) {\n        Ok(p) => p,\n        Err(e) => {\n            return RunResult {\n                success: false,\n                result: String::new(),\n                output: vec![],\n                error: Some(format!(\"{}\", e)),\n            };\n        }\n    };\n\n    // Create interpreter and run\n    let mut interpreter = mdhavers::Interpreter::new();\n\n    match interpreter.interpret(&program) {\n        Ok(value) => {\n            let output = interpreter.get_output().to_vec();\n            RunResult {\n                success: true,\n                result: format!(\"{}\", value),\n                output,\n                error: None,\n            }\n        }\n        Err(e) => {\n            let output = interpreter.get_output().to_vec();\n            RunResult {\n                success: false,\n                result: String::new(),\n                output,\n                error: Some(format!(\"{}\", e)),\n            }\n        }\n    }\n}\n\n/// Check mdhavers code for syntax errors without running\n///\n/// # Arguments\n/// * `code` - The mdhavers source code to check\n///\n/// # Returns\n/// A JSON string with success status and any error message\n#[wasm_bindgen]\npub fn check(code: &str) -> String {\n    match mdhavers::parse(code) {\n        Ok(_) => r#\"{\"success\":true,\"error\":null}\"#.to_string(),\n        Err(e) => {\n            let error = format!(\"{}\", e).replace('\"', \"\\\\\\\"\");\n            format!(r#\"{{\"success\":false,\"error\":\"{}\"}}\"#, error)\n        }\n    }\n}\n\n/// Format mdhavers code\n///\n/// # Arguments\n/// * `code` - The mdhavers source code to format\n///\n/// # Returns\n/// The formatted code or original code if formatting fails\n#[wasm_bindgen]\npub fn format(code: &str) -> String {\n    mdhavers::format_source(code).unwrap_or_else(|_| code.to_string())\n}\n\n/// Compile mdhavers code to JavaScript\n///\n/// # Arguments\n/// * `code` - The mdhavers source code to compile\n///\n/// # Returns\n/// A JSON string with success status and compiled code or error\n#[wasm_bindgen]\npub fn compile_to_js(code: &str) -> String {\n    match mdhavers::compile_to_js(code) {\n        Ok(js) => {\n            let js_escaped = js.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\").replace('\\n', \"\\\\n\");\n            format!(r#\"{{\"success\":true,\"code\":\"{}\",\"error\":null}}\"#, js_escaped)\n        }\n        Err(e) => {\n            let error = format!(\"{}\", e).replace('\"', \"\\\\\\\"\");\n            format!(r#\"{{\"success\":false,\"code\":null,\"error\":\"{}\"}}\"#, error)\n        }\n    }\n}\n\n/// Get version information\n#[wasm_bindgen]\npub fn version() -> String {\n    \"0.1.0\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_run_simple() {\n        let result = run(\"blether 42\");\n        assert!(result.contains(\"success\\\":true\"));\n    }\n\n    #[test]\n    fn test_run_error() {\n        let result = run(\"undefined_var\");\n        assert!(result.contains(\"success\\\":false\"));\n    }\n\n    #[test]\n    fn test_check_valid() {\n        let result = check(\"ken x = 42\");\n        assert!(result.contains(\"success\\\":true\"));\n    }\n\n    #[test]\n    fn test_check_invalid() {\n        let result = check(\"ken = \");\n        assert!(result.contains(\"success\\\":false\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","playground","target","debug","build","serde-e59866aa333d97d3","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","playground","target","debug","build","serde_core-6be66d68a6221a2f","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","playground","target","wasm32-unknown-unknown","release","build","serde-b109098af36061c0","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","playground","target","wasm32-unknown-unknown","release","build","serde_core-275de7c4436992d8","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","src","ast.rs"],"content":"use std::fmt;\n\n/// Log levels for the logging system\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]\npub enum LogLevel {\n    /// Silent - no output\n    Wheesht = 0,\n    /// Error level - serious issues\n    Roar = 1,\n    /// Warning level - potential problems\n    Holler = 2,\n    /// Info level - normal operation (DEFAULT)\n    #[default]\n    Blether = 3,\n    /// Debug level - detailed information\n    Mutter = 4,\n    /// Trace level - most verbose\n    Whisper = 5,\n}\n\nimpl LogLevel {\n    /// Get the log level name for display\n    pub fn name(&self) -> &'static str {\n        match self {\n            LogLevel::Wheesht => \"WHEESHT\",\n            LogLevel::Roar => \"ROAR\",\n            LogLevel::Holler => \"HOLLER\",\n            LogLevel::Blether => \"BLETHER\",\n            LogLevel::Mutter => \"MUTTER\",\n            LogLevel::Whisper => \"WHISPER\",\n        }\n    }\n\n    /// Parse a log level from a string (case-insensitive)\n    pub fn parse_level(s: &str) -> Option<LogLevel> {\n        match s.to_lowercase().as_str() {\n            \"wheesht\" => Some(LogLevel::Wheesht),\n            \"roar\" => Some(LogLevel::Roar),\n            \"holler\" => Some(LogLevel::Holler),\n            \"blether\" => Some(LogLevel::Blether),\n            \"mutter\" => Some(LogLevel::Mutter),\n            \"whisper\" => Some(LogLevel::Whisper),\n            _ => None,\n        }\n    }\n}\n\nimpl fmt::Display for LogLevel {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.name())\n    }\n}\n\n/// Span information for error reporting\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Span {\n    pub line: usize,\n    pub column: usize,\n}\n\nimpl Span {\n    pub fn new(line: usize, column: usize) -> Self {\n        Span { line, column }\n    }\n}\n\n/// A program is a list of statements\n#[derive(Debug, Clone)]\npub struct Program {\n    pub statements: Vec<Stmt>,\n}\n\nimpl Program {\n    pub fn new(statements: Vec<Stmt>) -> Self {\n        Program { statements }\n    }\n}\n\n/// Statements in mdhavers\n#[derive(Debug, Clone)]\npub enum Stmt {\n    /// Variable declaration: ken x = 5\n    VarDecl {\n        name: String,\n        initializer: Option<Expr>,\n        span: Span,\n    },\n\n    /// Expression statement: blether \"hello\"\n    Expression { expr: Expr, span: Span },\n\n    /// Block of statements: { ... }\n    Block { statements: Vec<Stmt>, span: Span },\n\n    /// If statement: gin x > 5 { ... } ither { ... }\n    If {\n        condition: Expr,\n        then_branch: Box<Stmt>,\n        else_branch: Option<Box<Stmt>>,\n        span: Span,\n    },\n\n    /// While loop: whiles x < 10 { ... }\n    While {\n        condition: Expr,\n        body: Box<Stmt>,\n        span: Span,\n    },\n\n    /// For loop: fer i in 1..10 { ... }\n    For {\n        variable: String,\n        iterable: Expr,\n        body: Box<Stmt>,\n        span: Span,\n    },\n\n    /// Function definition: dae greet(name) { ... }\n    /// Supports default parameter values: dae greet(name, greeting = \"Hullo\") { ... }\n    Function {\n        name: String,\n        params: Vec<Param>,\n        body: Vec<Stmt>,\n        span: Span,\n    },\n\n    /// Return statement: gie value\n    Return { value: Option<Expr>, span: Span },\n\n    /// Print statement: blether \"hello\"\n    Print { value: Expr, span: Span },\n\n    /// Break statement: brak\n    Break { span: Span },\n\n    /// Continue statement: haud\n    Continue { span: Span },\n\n    /// Class definition: kin Animal { ... }\n    Class {\n        name: String,\n        superclass: Option<String>,\n        methods: Vec<Stmt>,\n        span: Span,\n    },\n\n    /// Struct definition: thing Point { x, y }\n    Struct {\n        name: String,\n        fields: Vec<String>,\n        span: Span,\n    },\n\n    /// Import statement: fetch \"module\"\n    Import {\n        path: String,\n        alias: Option<String>,\n        span: Span,\n    },\n\n    /// Try-catch: hae_a_bash { ... } gin_it_gangs_wrang e { ... }\n    TryCatch {\n        try_block: Box<Stmt>,\n        error_name: String,\n        catch_block: Box<Stmt>,\n        span: Span,\n    },\n\n    /// Match statement: keek value { whan 1 -> ..., whan 2 -> ... }\n    Match {\n        value: Expr,\n        arms: Vec<MatchArm>,\n        span: Span,\n    },\n\n    /// Assert statement: mak_siccar condition, \"message\"\n    Assert {\n        condition: Expr,\n        message: Option<Expr>,\n        span: Span,\n    },\n\n    /// Destructuring assignment: ken [a, b, ...rest] = list\n    Destructure {\n        patterns: Vec<DestructPattern>,\n        value: Expr,\n        span: Span,\n    },\n\n    /// Log statement: log_whisper/log_mutter/log_blether/log_holler/log_roar message\n    Log {\n        level: LogLevel,\n        message: Expr,\n        span: Span,\n    },\n\n    /// Hurl statement: throw/raise an exception with a message\n    Hurl { message: Expr, span: Span },\n}\n\n/// A match arm: whan pattern -> body\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct MatchArm {\n    pub pattern: Pattern,\n    pub body: Stmt,\n    pub span: Span,\n}\n\n/// Patterns for matching\n#[derive(Debug, Clone)]\npub enum Pattern {\n    /// Literal value\n    Literal(Literal),\n    /// Identifier (binds the value)\n    Identifier(String),\n    /// Wildcard (_)\n    Wildcard,\n    /// Range pattern: 1..10\n    Range { start: Box<Expr>, end: Box<Expr> },\n}\n\n/// A function parameter with optional default value\n#[derive(Debug, Clone)]\npub struct Param {\n    pub name: String,\n    pub default: Option<Expr>,\n}\n\n/// Destructuring pattern fer unpacking lists\n#[derive(Debug, Clone)]\npub enum DestructPattern {\n    /// Single variable: x\n    Variable(String),\n    /// Rest pattern: ...rest (captures remaining elements)\n    Rest(String),\n    /// Ignore: _ (skip this element)\n    Ignore,\n}\n\n/// Expressions in mdhavers\n#[derive(Debug, Clone)]\npub enum Expr {\n    /// Literal values\n    Literal { value: Literal, span: Span },\n\n    /// Variable reference\n    Variable { name: String, span: Span },\n\n    /// Assignment: x = 5\n    Assign {\n        name: String,\n        value: Box<Expr>,\n        span: Span,\n    },\n\n    /// Binary operation: x + y\n    Binary {\n        left: Box<Expr>,\n        operator: BinaryOp,\n        right: Box<Expr>,\n        span: Span,\n    },\n\n    /// Unary operation: -x, nae x\n    Unary {\n        operator: UnaryOp,\n        operand: Box<Expr>,\n        span: Span,\n    },\n\n    /// Logical operation: x an y, x or y\n    Logical {\n        left: Box<Expr>,\n        operator: LogicalOp,\n        right: Box<Expr>,\n        span: Span,\n    },\n\n    /// Function call: greet(\"world\")\n    Call {\n        callee: Box<Expr>,\n        arguments: Vec<Expr>,\n        span: Span,\n    },\n\n    /// Property access: obj.property\n    Get {\n        object: Box<Expr>,\n        property: String,\n        span: Span,\n    },\n\n    /// Property assignment: obj.property = value\n    Set {\n        object: Box<Expr>,\n        property: String,\n        value: Box<Expr>,\n        span: Span,\n    },\n\n    /// Index access: arr[0]\n    Index {\n        object: Box<Expr>,\n        index: Box<Expr>,\n        span: Span,\n    },\n\n    /// Index assignment: arr[0] = value\n    IndexSet {\n        object: Box<Expr>,\n        index: Box<Expr>,\n        value: Box<Expr>,\n        span: Span,\n    },\n\n    /// Slice expression: arr[1:3] or arr[:3] or arr[1:] or arr[::2]\n    Slice {\n        object: Box<Expr>,\n        start: Option<Box<Expr>>,\n        end: Option<Box<Expr>>,\n        step: Option<Box<Expr>>,\n        span: Span,\n    },\n\n    /// List literal: [1, 2, 3]\n    List { elements: Vec<Expr>, span: Span },\n\n    /// Dictionary literal: {key: value}\n    Dict {\n        pairs: Vec<(Expr, Expr)>,\n        span: Span,\n    },\n\n    /// Range: 1..10\n    Range {\n        start: Box<Expr>,\n        end: Box<Expr>,\n        inclusive: bool,\n        span: Span,\n    },\n\n    /// Grouping: (x + y)\n    Grouping { expr: Box<Expr>, span: Span },\n\n    /// Lambda/anonymous function: |x, y| x + y\n    Lambda {\n        params: Vec<String>,\n        body: Box<Expr>,\n        span: Span,\n    },\n\n    /// Self reference: masel\n    Masel { span: Span },\n\n    /// Input: speir \"What's yer name?\"\n    Input { prompt: Box<Expr>, span: Span },\n\n    /// Format string: f\"Hullo {name}!\"\n    FString { parts: Vec<FStringPart>, span: Span },\n\n    /// Spread expression: ...list (skail = scatter in Scots)\n    Spread { expr: Box<Expr>, span: Span },\n\n    /// Pipe forward: x |> f means f(x) - fer fluent chaining\n    Pipe {\n        left: Box<Expr>,\n        right: Box<Expr>,\n        span: Span,\n    },\n\n    /// Ternary/conditional expression: gin condition than truthy ither falsy\n    Ternary {\n        condition: Box<Expr>,\n        then_expr: Box<Expr>,\n        else_expr: Box<Expr>,\n        span: Span,\n    },\n}\n\n/// Parts of an f-string\n#[derive(Debug, Clone)]\npub enum FStringPart {\n    /// Literal text\n    Text(String),\n    /// Interpolated expression\n    Expr(Box<Expr>),\n}\n\n/// Literal values\n#[derive(Debug, Clone, PartialEq)]\npub enum Literal {\n    Integer(i64),\n    Float(f64),\n    String(String),\n    Bool(bool),\n    Nil,\n}\n\nimpl fmt::Display for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Literal::Integer(n) => write!(f, \"{}\", n),\n            Literal::Float(n) => write!(f, \"{}\", n),\n            Literal::String(s) => write!(f, \"\\\"{}\\\"\", s),\n            Literal::Bool(true) => write!(f, \"aye\"),\n            Literal::Bool(false) => write!(f, \"nae\"),\n            Literal::Nil => write!(f, \"naething\"),\n        }\n    }\n}\n\n/// Binary operators\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BinaryOp {\n    Add,\n    Subtract,\n    Multiply,\n    Divide,\n    Modulo,\n    Equal,\n    NotEqual,\n    Less,\n    LessEqual,\n    Greater,\n    GreaterEqual,\n}\n\nimpl fmt::Display for BinaryOp {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            BinaryOp::Add => write!(f, \"+\"),\n            BinaryOp::Subtract => write!(f, \"-\"),\n            BinaryOp::Multiply => write!(f, \"*\"),\n            BinaryOp::Divide => write!(f, \"/\"),\n            BinaryOp::Modulo => write!(f, \"%\"),\n            BinaryOp::Equal => write!(f, \"==\"),\n            BinaryOp::NotEqual => write!(f, \"!=\"),\n            BinaryOp::Less => write!(f, \"<\"),\n            BinaryOp::LessEqual => write!(f, \"<=\"),\n            BinaryOp::Greater => write!(f, \">\"),\n            BinaryOp::GreaterEqual => write!(f, \">=\"),\n        }\n    }\n}\n\n/// Unary operators\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum UnaryOp {\n    Negate,\n    Not,\n}\n\nimpl fmt::Display for UnaryOp {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            UnaryOp::Negate => write!(f, \"-\"),\n            UnaryOp::Not => write!(f, \"nae\"),\n        }\n    }\n}\n\n/// Logical operators\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum LogicalOp {\n    And,\n    Or,\n}\n\nimpl fmt::Display for LogicalOp {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            LogicalOp::And => write!(f, \"an\"),\n            LogicalOp::Or => write!(f, \"or\"),\n        }\n    }\n}\n\nimpl Expr {\n    pub fn span(&self) -> Span {\n        match self {\n            Expr::Literal { span, .. } => *span,\n            Expr::Variable { span, .. } => *span,\n            Expr::Assign { span, .. } => *span,\n            Expr::Binary { span, .. } => *span,\n            Expr::Unary { span, .. } => *span,\n            Expr::Logical { span, .. } => *span,\n            Expr::Call { span, .. } => *span,\n            Expr::Get { span, .. } => *span,\n            Expr::Set { span, .. } => *span,\n            Expr::Index { span, .. } => *span,\n            Expr::IndexSet { span, .. } => *span,\n            Expr::Slice { span, .. } => *span,\n            Expr::List { span, .. } => *span,\n            Expr::Dict { span, .. } => *span,\n            Expr::Range { span, .. } => *span,\n            Expr::Grouping { span, .. } => *span,\n            Expr::Lambda { span, .. } => *span,\n            Expr::Masel { span } => *span,\n            Expr::Input { span, .. } => *span,\n            Expr::FString { span, .. } => *span,\n            Expr::Spread { span, .. } => *span,\n            Expr::Pipe { span, .. } => *span,\n            Expr::Ternary { span, .. } => *span,\n        }\n    }\n}\n\nimpl Stmt {\n    pub fn span(&self) -> Span {\n        match self {\n            Stmt::VarDecl { span, .. } => *span,\n            Stmt::Expression { span, .. } => *span,\n            Stmt::Block { span, .. } => *span,\n            Stmt::If { span, .. } => *span,\n            Stmt::While { span, .. } => *span,\n            Stmt::For { span, .. } => *span,\n            Stmt::Function { span, .. } => *span,\n            Stmt::Return { span, .. } => *span,\n            Stmt::Print { span, .. } => *span,\n            Stmt::Break { span } => *span,\n            Stmt::Continue { span } => *span,\n            Stmt::Class { span, .. } => *span,\n            Stmt::Struct { span, .. } => *span,\n            Stmt::Import { span, .. } => *span,\n            Stmt::TryCatch { span, .. } => *span,\n            Stmt::Match { span, .. } => *span,\n            Stmt::Assert { span, .. } => *span,\n            Stmt::Destructure { span, .. } => *span,\n            Stmt::Log { span, .. } => *span,\n            Stmt::Hurl { span, .. } => *span,\n        }\n    }\n}\n\n#[cfg(test)]\n#[allow(clippy::approx_constant)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_span_new() {\n        let span = Span::new(5, 10);\n        assert_eq!(span.line, 5);\n        assert_eq!(span.column, 10);\n    }\n\n    #[test]\n    fn test_program_new() {\n        let stmts = vec![Stmt::Break {\n            span: Span::new(1, 1),\n        }];\n        let program = Program::new(stmts);\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_literal_display_integer() {\n        assert_eq!(format!(\"{}\", Literal::Integer(42)), \"42\");\n        assert_eq!(format!(\"{}\", Literal::Integer(-17)), \"-17\");\n        assert_eq!(format!(\"{}\", Literal::Integer(0)), \"0\");\n    }\n\n    #[test]\n    fn test_literal_display_float() {\n        assert_eq!(format!(\"{}\", Literal::Float(3.15)), \"3.15\");\n        assert_eq!(format!(\"{}\", Literal::Float(-2.5)), \"-2.5\");\n    }\n\n    #[test]\n    fn test_literal_display_string() {\n        assert_eq!(\n            format!(\"{}\", Literal::String(\"hello\".to_string())),\n            \"\\\"hello\\\"\"\n        );\n        assert_eq!(format!(\"{}\", Literal::String(\"\".to_string())), \"\\\"\\\"\");\n    }\n\n    #[test]\n    fn test_literal_display_bool() {\n        assert_eq!(format!(\"{}\", Literal::Bool(true)), \"aye\");\n        assert_eq!(format!(\"{}\", Literal::Bool(false)), \"nae\");\n    }\n\n    #[test]\n    fn test_literal_display_nil() {\n        assert_eq!(format!(\"{}\", Literal::Nil), \"naething\");\n    }\n\n    #[test]\n    fn test_binary_op_display() {\n        assert_eq!(format!(\"{}\", BinaryOp::Add), \"+\");\n        assert_eq!(format!(\"{}\", BinaryOp::Subtract), \"-\");\n        assert_eq!(format!(\"{}\", BinaryOp::Multiply), \"*\");\n        assert_eq!(format!(\"{}\", BinaryOp::Divide), \"/\");\n        assert_eq!(format!(\"{}\", BinaryOp::Modulo), \"%\");\n        assert_eq!(format!(\"{}\", BinaryOp::Equal), \"==\");\n        assert_eq!(format!(\"{}\", BinaryOp::NotEqual), \"!=\");\n        assert_eq!(format!(\"{}\", BinaryOp::Less), \"<\");\n        assert_eq!(format!(\"{}\", BinaryOp::LessEqual), \"<=\");\n        assert_eq!(format!(\"{}\", BinaryOp::Greater), \">\");\n        assert_eq!(format!(\"{}\", BinaryOp::GreaterEqual), \">=\");\n    }\n\n    #[test]\n    fn test_unary_op_display() {\n        assert_eq!(format!(\"{}\", UnaryOp::Negate), \"-\");\n        assert_eq!(format!(\"{}\", UnaryOp::Not), \"nae\");\n    }\n\n    #[test]\n    fn test_logical_op_display() {\n        assert_eq!(format!(\"{}\", LogicalOp::And), \"an\");\n        assert_eq!(format!(\"{}\", LogicalOp::Or), \"or\");\n    }\n\n    #[test]\n    fn test_param() {\n        let param_no_default = Param {\n            name: \"x\".to_string(),\n            default: None,\n        };\n        assert_eq!(param_no_default.name, \"x\");\n        assert!(param_no_default.default.is_none());\n\n        let param_with_default = Param {\n            name: \"y\".to_string(),\n            default: Some(Expr::Literal {\n                value: Literal::Integer(42),\n                span: Span::new(1, 1),\n            }),\n        };\n        assert_eq!(param_with_default.name, \"y\");\n        assert!(param_with_default.default.is_some());\n    }\n\n    #[test]\n    fn test_expr_span() {\n        let span = Span::new(5, 10);\n\n        let lit = Expr::Literal {\n            value: Literal::Integer(42),\n            span,\n        };\n        assert_eq!(lit.span(), span);\n\n        let var = Expr::Variable {\n            name: \"x\".to_string(),\n            span,\n        };\n        assert_eq!(var.span(), span);\n\n        let assign = Expr::Assign {\n            name: \"x\".to_string(),\n            value: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(assign.span(), span);\n\n        let binary = Expr::Binary {\n            left: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            operator: BinaryOp::Add,\n            right: Box::new(Expr::Literal {\n                value: Literal::Integer(2),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(binary.span(), span);\n\n        let unary = Expr::Unary {\n            operator: UnaryOp::Negate,\n            operand: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(unary.span(), span);\n\n        let logical = Expr::Logical {\n            left: Box::new(Expr::Literal {\n                value: Literal::Bool(true),\n                span,\n            }),\n            operator: LogicalOp::And,\n            right: Box::new(Expr::Literal {\n                value: Literal::Bool(false),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(logical.span(), span);\n\n        let call = Expr::Call {\n            callee: Box::new(Expr::Variable {\n                name: \"f\".to_string(),\n                span,\n            }),\n            arguments: vec![],\n            span,\n        };\n        assert_eq!(call.span(), span);\n\n        let get = Expr::Get {\n            object: Box::new(Expr::Variable {\n                name: \"obj\".to_string(),\n                span,\n            }),\n            property: \"prop\".to_string(),\n            span,\n        };\n        assert_eq!(get.span(), span);\n\n        let set = Expr::Set {\n            object: Box::new(Expr::Variable {\n                name: \"obj\".to_string(),\n                span,\n            }),\n            property: \"prop\".to_string(),\n            value: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(set.span(), span);\n\n        let index = Expr::Index {\n            object: Box::new(Expr::Variable {\n                name: \"arr\".to_string(),\n                span,\n            }),\n            index: Box::new(Expr::Literal {\n                value: Literal::Integer(0),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(index.span(), span);\n\n        let index_set = Expr::IndexSet {\n            object: Box::new(Expr::Variable {\n                name: \"arr\".to_string(),\n                span,\n            }),\n            index: Box::new(Expr::Literal {\n                value: Literal::Integer(0),\n                span,\n            }),\n            value: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(index_set.span(), span);\n\n        let slice = Expr::Slice {\n            object: Box::new(Expr::Variable {\n                name: \"arr\".to_string(),\n                span,\n            }),\n            start: None,\n            end: None,\n            step: None,\n            span,\n        };\n        assert_eq!(slice.span(), span);\n\n        let list = Expr::List {\n            elements: vec![],\n            span,\n        };\n        assert_eq!(list.span(), span);\n\n        let dict = Expr::Dict {\n            pairs: vec![],\n            span,\n        };\n        assert_eq!(dict.span(), span);\n\n        let range = Expr::Range {\n            start: Box::new(Expr::Literal {\n                value: Literal::Integer(0),\n                span,\n            }),\n            end: Box::new(Expr::Literal {\n                value: Literal::Integer(10),\n                span,\n            }),\n            inclusive: false,\n            span,\n        };\n        assert_eq!(range.span(), span);\n\n        let grouping = Expr::Grouping {\n            expr: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(grouping.span(), span);\n\n        let lambda = Expr::Lambda {\n            params: vec![\"x\".to_string()],\n            body: Box::new(Expr::Variable {\n                name: \"x\".to_string(),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(lambda.span(), span);\n\n        let masel = Expr::Masel { span };\n        assert_eq!(masel.span(), span);\n\n        let input = Expr::Input {\n            prompt: Box::new(Expr::Literal {\n                value: Literal::String(\"?\".to_string()),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(input.span(), span);\n\n        let fstring = Expr::FString {\n            parts: vec![],\n            span,\n        };\n        assert_eq!(fstring.span(), span);\n\n        let spread = Expr::Spread {\n            expr: Box::new(Expr::Variable {\n                name: \"arr\".to_string(),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(spread.span(), span);\n\n        let pipe = Expr::Pipe {\n            left: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            right: Box::new(Expr::Variable {\n                name: \"f\".to_string(),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(pipe.span(), span);\n\n        let ternary = Expr::Ternary {\n            condition: Box::new(Expr::Literal {\n                value: Literal::Bool(true),\n                span,\n            }),\n            then_expr: Box::new(Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            }),\n            else_expr: Box::new(Expr::Literal {\n                value: Literal::Integer(0),\n                span,\n            }),\n            span,\n        };\n        assert_eq!(ternary.span(), span);\n    }\n\n    #[test]\n    fn test_stmt_span() {\n        let span = Span::new(3, 5);\n\n        let var_decl = Stmt::VarDecl {\n            name: \"x\".to_string(),\n            initializer: None,\n            span,\n        };\n        assert_eq!(var_decl.span(), span);\n\n        let expr_stmt = Stmt::Expression {\n            expr: Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            },\n            span,\n        };\n        assert_eq!(expr_stmt.span(), span);\n\n        let block = Stmt::Block {\n            statements: vec![],\n            span,\n        };\n        assert_eq!(block.span(), span);\n\n        let if_stmt = Stmt::If {\n            condition: Expr::Literal {\n                value: Literal::Bool(true),\n                span,\n            },\n            then_branch: Box::new(Stmt::Block {\n                statements: vec![],\n                span,\n            }),\n            else_branch: None,\n            span,\n        };\n        assert_eq!(if_stmt.span(), span);\n\n        let while_stmt = Stmt::While {\n            condition: Expr::Literal {\n                value: Literal::Bool(true),\n                span,\n            },\n            body: Box::new(Stmt::Block {\n                statements: vec![],\n                span,\n            }),\n            span,\n        };\n        assert_eq!(while_stmt.span(), span);\n\n        let for_stmt = Stmt::For {\n            variable: \"i\".to_string(),\n            iterable: Expr::Literal {\n                value: Literal::Integer(0),\n                span,\n            },\n            body: Box::new(Stmt::Block {\n                statements: vec![],\n                span,\n            }),\n            span,\n        };\n        assert_eq!(for_stmt.span(), span);\n\n        let func = Stmt::Function {\n            name: \"foo\".to_string(),\n            params: vec![],\n            body: vec![],\n            span,\n        };\n        assert_eq!(func.span(), span);\n\n        let ret = Stmt::Return { value: None, span };\n        assert_eq!(ret.span(), span);\n\n        let print = Stmt::Print {\n            value: Expr::Literal {\n                value: Literal::String(\"hi\".to_string()),\n                span,\n            },\n            span,\n        };\n        assert_eq!(print.span(), span);\n\n        let brk = Stmt::Break { span };\n        assert_eq!(brk.span(), span);\n\n        let cont = Stmt::Continue { span };\n        assert_eq!(cont.span(), span);\n\n        let class = Stmt::Class {\n            name: \"Foo\".to_string(),\n            superclass: None,\n            methods: vec![],\n            span,\n        };\n        assert_eq!(class.span(), span);\n\n        let strct = Stmt::Struct {\n            name: \"Bar\".to_string(),\n            fields: vec![],\n            span,\n        };\n        assert_eq!(strct.span(), span);\n\n        let import = Stmt::Import {\n            path: \"lib\".to_string(),\n            alias: None,\n            span,\n        };\n        assert_eq!(import.span(), span);\n\n        let try_catch = Stmt::TryCatch {\n            try_block: Box::new(Stmt::Block {\n                statements: vec![],\n                span,\n            }),\n            error_name: \"e\".to_string(),\n            catch_block: Box::new(Stmt::Block {\n                statements: vec![],\n                span,\n            }),\n            span,\n        };\n        assert_eq!(try_catch.span(), span);\n\n        let match_stmt = Stmt::Match {\n            value: Expr::Literal {\n                value: Literal::Integer(1),\n                span,\n            },\n            arms: vec![],\n            span,\n        };\n        assert_eq!(match_stmt.span(), span);\n\n        let assert = Stmt::Assert {\n            condition: Expr::Literal {\n                value: Literal::Bool(true),\n                span,\n            },\n            message: None,\n            span,\n        };\n        assert_eq!(assert.span(), span);\n\n        let destruct = Stmt::Destructure {\n            patterns: vec![],\n            value: Expr::List {\n                elements: vec![],\n                span,\n            },\n            span,\n        };\n        assert_eq!(destruct.span(), span);\n    }\n\n    #[test]\n    fn test_pattern_variants() {\n        let lit_pattern = Pattern::Literal(Literal::Integer(42));\n        let id_pattern = Pattern::Identifier(\"x\".to_string());\n        let wildcard = Pattern::Wildcard;\n        let span = Span::new(1, 1);\n        let range_pattern = Pattern::Range {\n            start: Box::new(Expr::Literal {\n                value: Literal::Integer(0),\n                span,\n            }),\n            end: Box::new(Expr::Literal {\n                value: Literal::Integer(10),\n                span,\n            }),\n        };\n\n        // Just verify they can be created and matched\n        match lit_pattern {\n            Pattern::Literal(Literal::Integer(42)) => {}\n            _ => panic!(\"Expected integer literal pattern\"),\n        }\n        match id_pattern {\n            Pattern::Identifier(ref name) => assert_eq!(name, \"x\"),\n            _ => panic!(\"Expected identifier pattern\"),\n        }\n        match wildcard {\n            Pattern::Wildcard => {}\n            _ => panic!(\"Expected wildcard\"),\n        }\n        match range_pattern {\n            Pattern::Range { .. } => {}\n            _ => panic!(\"Expected range pattern\"),\n        }\n    }\n\n    #[test]\n    fn test_destruct_pattern_variants() {\n        let var = DestructPattern::Variable(\"x\".to_string());\n        let rest = DestructPattern::Rest(\"remaining\".to_string());\n        let ignore = DestructPattern::Ignore;\n\n        match var {\n            DestructPattern::Variable(ref name) => assert_eq!(name, \"x\"),\n            _ => panic!(\"Expected variable pattern\"),\n        }\n        match rest {\n            DestructPattern::Rest(ref name) => assert_eq!(name, \"remaining\"),\n            _ => panic!(\"Expected rest pattern\"),\n        }\n        match ignore {\n            DestructPattern::Ignore => {}\n            _ => panic!(\"Expected ignore pattern\"),\n        }\n    }\n\n    #[test]\n    fn test_fstring_part_variants() {\n        let text = FStringPart::Text(\"hello \".to_string());\n        let span = Span::new(1, 1);\n        let expr = FStringPart::Expr(Box::new(Expr::Variable {\n            name: \"name\".to_string(),\n            span,\n        }));\n\n        match text {\n            FStringPart::Text(ref s) => assert_eq!(s, \"hello \"),\n            _ => panic!(\"Expected text part\"),\n        }\n        match expr {\n            FStringPart::Expr(_) => {}\n            _ => panic!(\"Expected expr part\"),\n        }\n    }\n\n    #[test]\n    fn test_match_arm() {\n        let span = Span::new(1, 1);\n        let arm = MatchArm {\n            pattern: Pattern::Wildcard,\n            body: Stmt::Break { span },\n            span,\n        };\n        assert_eq!(arm.span, span);\n    }\n}\n","traces":[{"line":23,"address":[56087568],"length":1,"stats":{"Line":1}},{"line":24,"address":[54375285],"length":1,"stats":{"Line":1}},{"line":25,"address":[54375316],"length":1,"stats":{"Line":1}},{"line":26,"address":[54375339],"length":1,"stats":{"Line":1}},{"line":27,"address":[55235586],"length":1,"stats":{"Line":0}},{"line":28,"address":[54375385],"length":1,"stats":{"Line":0}},{"line":29,"address":[54375408],"length":1,"stats":{"Line":0}},{"line":30,"address":[55405719],"length":1,"stats":{"Line":0}},{"line":35,"address":[54374816,54375265,54375259],"length":1,"stats":{"Line":1}},{"line":36,"address":[55235146,55235060],"length":1,"stats":{"Line":2}},{"line":37,"address":[55235228,55235162],"length":1,"stats":{"Line":2}},{"line":38,"address":[55405269,55405306,55405345],"length":1,"stats":{"Line":3}},{"line":39,"address":[56087398,56087359,56087322],"length":1,"stats":{"Line":0}},{"line":40,"address":[55235311,55235384,55235345],"length":1,"stats":{"Line":0}},{"line":41,"address":[54375137,54375171,54375210],"length":1,"stats":{"Line":0}},{"line":42,"address":[55235458,55235445,55235411],"length":1,"stats":{"Line":0}},{"line":43,"address":[54375227],"length":1,"stats":{"Line":0}},{"line":49,"address":[55400816],"length":1,"stats":{"Line":0}},{"line":50,"address":[56082818],"length":1,"stats":{"Line":0}},{"line":62,"address":[54373856],"length":1,"stats":{"Line":30}},{"line":74,"address":[55405072],"length":1,"stats":{"Line":7}},{"line":401,"address":[55228752],"length":1,"stats":{"Line":10}},{"line":402,"address":[55228784,55229188],"length":1,"stats":{"Line":12}},{"line":403,"address":[55398943],"length":1,"stats":{"Line":2}},{"line":404,"address":[54368753],"length":1,"stats":{"Line":2}},{"line":405,"address":[55399161],"length":1,"stats":{"Line":2}},{"line":406,"address":[54369109],"length":1,"stats":{"Line":2}},{"line":407,"address":[55229255],"length":1,"stats":{"Line":2}},{"line":408,"address":[54369003],"length":1,"stats":{"Line":2}},{"line":430,"address":[56082192],"length":1,"stats":{"Line":2}},{"line":431,"address":[55230155],"length":1,"stats":{"Line":2}},{"line":432,"address":[55400266],"length":1,"stats":{"Line":2}},{"line":433,"address":[55230229],"length":1,"stats":{"Line":2}},{"line":434,"address":[56082336],"length":1,"stats":{"Line":2}},{"line":435,"address":[55230315],"length":1,"stats":{"Line":2}},{"line":436,"address":[55400444],"length":1,"stats":{"Line":2}},{"line":437,"address":[54370205],"length":1,"stats":{"Line":2}},{"line":438,"address":[54370254],"length":1,"stats":{"Line":2}},{"line":439,"address":[54370303],"length":1,"stats":{"Line":2}},{"line":440,"address":[56082624],"length":1,"stats":{"Line":2}},{"line":441,"address":[55230606],"length":1,"stats":{"Line":2}},{"line":442,"address":[54370444],"length":1,"stats":{"Line":2}},{"line":455,"address":[55229968],"length":1,"stats":{"Line":2}},{"line":456,"address":[54369785],"length":1,"stats":{"Line":2}},{"line":457,"address":[55400129],"length":1,"stats":{"Line":2}},{"line":458,"address":[54369800],"length":1,"stats":{"Line":2}},{"line":471,"address":[54371808],"length":1,"stats":{"Line":2}},{"line":472,"address":[54371833],"length":1,"stats":{"Line":2}},{"line":473,"address":[56084177],"length":1,"stats":{"Line":2}},{"line":474,"address":[55402136],"length":1,"stats":{"Line":2}},{"line":480,"address":[54372848],"length":1,"stats":{"Line":5}},{"line":481,"address":[54372862],"length":1,"stats":{"Line":5}},{"line":482,"address":[55233150],"length":1,"stats":{"Line":3}},{"line":483,"address":[54372966],"length":1,"stats":{"Line":5}},{"line":484,"address":[56085294],"length":1,"stats":{"Line":4}},{"line":485,"address":[56085334],"length":1,"stats":{"Line":2}},{"line":486,"address":[54373086],"length":1,"stats":{"Line":2}},{"line":487,"address":[55403414],"length":1,"stats":{"Line":2}},{"line":488,"address":[55233390],"length":1,"stats":{"Line":3}},{"line":489,"address":[55403494],"length":1,"stats":{"Line":3}},{"line":490,"address":[56085534],"length":1,"stats":{"Line":3}},{"line":491,"address":[56085574],"length":1,"stats":{"Line":2}},{"line":492,"address":[54373326],"length":1,"stats":{"Line":3}},{"line":493,"address":[55403654],"length":1,"stats":{"Line":2}},{"line":494,"address":[56085693],"length":1,"stats":{"Line":2}},{"line":495,"address":[55403733],"length":1,"stats":{"Line":2}},{"line":496,"address":[56085773],"length":1,"stats":{"Line":2}},{"line":497,"address":[55233749],"length":1,"stats":{"Line":2}},{"line":498,"address":[55233789],"length":1,"stats":{"Line":2}},{"line":499,"address":[55403893],"length":1,"stats":{"Line":2}},{"line":500,"address":[55403933],"length":1,"stats":{"Line":2}},{"line":501,"address":[55403973],"length":1,"stats":{"Line":2}},{"line":502,"address":[54373722],"length":1,"stats":{"Line":2}},{"line":503,"address":[54373759],"length":1,"stats":{"Line":2}},{"line":504,"address":[54373796],"length":1,"stats":{"Line":2}},{"line":510,"address":[54373888],"length":1,"stats":{"Line":2}},{"line":511,"address":[56086190],"length":1,"stats":{"Line":2}},{"line":512,"address":[56086264],"length":1,"stats":{"Line":2}},{"line":513,"address":[55404304],"length":1,"stats":{"Line":2}},{"line":514,"address":[55234280],"length":1,"stats":{"Line":2}},{"line":515,"address":[56086384],"length":1,"stats":{"Line":2}},{"line":516,"address":[56086424],"length":1,"stats":{"Line":2}},{"line":517,"address":[54374176],"length":1,"stats":{"Line":2}},{"line":518,"address":[55404504],"length":1,"stats":{"Line":2}},{"line":519,"address":[55234480],"length":1,"stats":{"Line":2}},{"line":520,"address":[54374296],"length":1,"stats":{"Line":2}},{"line":521,"address":[55404624],"length":1,"stats":{"Line":2}},{"line":522,"address":[56086664],"length":1,"stats":{"Line":2}},{"line":523,"address":[55404704],"length":1,"stats":{"Line":2}},{"line":524,"address":[55234679],"length":1,"stats":{"Line":2}},{"line":525,"address":[55404783],"length":1,"stats":{"Line":2}},{"line":526,"address":[56086823],"length":1,"stats":{"Line":2}},{"line":527,"address":[55404863],"length":1,"stats":{"Line":2}},{"line":528,"address":[55234839],"length":1,"stats":{"Line":2}},{"line":529,"address":[54374652],"length":1,"stats":{"Line":2}},{"line":530,"address":[55404977],"length":1,"stats":{"Line":0}},{"line":531,"address":[55405014],"length":1,"stats":{"Line":0}}],"covered":84,"coverable":97},{"path":["/","home","md","language","mdhavers","src","compiler.rs"],"content":"use crate::ast::*;\nuse crate::error::HaversResult;\n\n/// Compiler - transpiles mdhavers tae JavaScript\npub struct Compiler {\n    indent: usize,\n    output: String,\n    match_counter: usize,\n}\n\nimpl Compiler {\n    pub fn new() -> Self {\n        Compiler {\n            indent: 0,\n            output: String::new(),\n            match_counter: 0,\n        }\n    }\n\n    /// Compile a program tae JavaScript\n    pub fn compile(&mut self, program: &Program) -> HaversResult<String> {\n        self.output.clear();\n\n        // Add runtime helpers\n        self.emit_runtime();\n\n        // Compile all statements\n        for stmt in &program.statements {\n            self.compile_stmt(stmt)?;\n        }\n\n        Ok(self.output.clone())\n    }\n\n    fn emit_runtime(&mut self) {\n        self.emit_line(\"// mdhavers runtime - pure havers, but working havers!\");\n        self.emit_line(\"const __havers = {\");\n        self.indent += 1;\n\n        // len function\n        self.emit_line(\"len: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof x === 'string' || Array.isArray(x)) return x.length;\");\n        self.emit_line(\"if (x && typeof x === 'object') return Object.keys(x).length;\");\n        self.emit_line(\"throw new Error('Och! Cannae get length o\\\\' that!');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // whit_kind (type) function\n        self.emit_line(\"whit_kind: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (x === null || x === undefined) return 'naething';\");\n        self.emit_line(\"if (Array.isArray(x)) return 'list';\");\n        self.emit_line(\"if (typeof x === 'object') return 'dict';\");\n        self.emit_line(\"return typeof x;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // tae_string function\n        self.emit_line(\"tae_string: (x) => String(x),\");\n\n        // tae_int function\n        self.emit_line(\"tae_int: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"const n = parseInt(x, 10);\");\n        self.emit_line(\"if (isNaN(n)) throw new Error(`Cannae turn '${x}' intae an integer`);\");\n        self.emit_line(\"return n;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // tae_float function\n        self.emit_line(\"tae_float: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"const n = parseFloat(x);\");\n        self.emit_line(\"if (isNaN(n)) throw new Error(`Cannae turn '${x}' intae a float`);\");\n        self.emit_line(\"return n;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // shove (push) function\n        self.emit_line(\"shove: (arr, val) => { arr.push(val); },\");\n\n        // yank (pop) function\n        self.emit_line(\"yank: (arr) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (arr.length === 0) throw new Error('Cannae yank fae an empty list!');\");\n        self.emit_line(\"return arr.pop();\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // keys function\n        self.emit_line(\"keys: (obj) => Object.keys(obj),\");\n\n        // values function\n        self.emit_line(\"values: (obj) => Object.values(obj),\");\n\n        // range function\n        self.emit_line(\"range: (start, end) => {\");\n        self.indent += 1;\n        self.emit_line(\"const result = [];\");\n        self.emit_line(\"for (let i = start; i < end; i++) result.push(i);\");\n        self.emit_line(\"return result;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // abs function\n        self.emit_line(\"abs: Math.abs,\");\n\n        // min function\n        self.emit_line(\"min: Math.min,\");\n\n        // max function\n        self.emit_line(\"max: Math.max,\");\n\n        // floor function\n        self.emit_line(\"floor: Math.floor,\");\n\n        // ceil function\n        self.emit_line(\"ceil: Math.ceil,\");\n\n        // round function\n        self.emit_line(\"round: Math.round,\");\n\n        // sqrt function\n        self.emit_line(\"sqrt: Math.sqrt,\");\n\n        // split function\n        self.emit_line(\"split: (str, delim) => str.split(delim),\");\n\n        // join function\n        self.emit_line(\"join: (arr, delim) => arr.join(delim),\");\n\n        // contains function\n        self.emit_line(\"contains: (container, item) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof container === 'string') return container.includes(item);\");\n        self.emit_line(\"if (Array.isArray(container)) return container.includes(item);\");\n        self.emit_line(\"if (typeof container === 'object') return item in container;\");\n        self.emit_line(\"return false;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // reverse function\n        self.emit_line(\"reverse: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof x === 'string') return x.split('').reverse().join('');\");\n        self.emit_line(\"if (Array.isArray(x)) return [...x].reverse();\");\n        self.emit_line(\"throw new Error('reverse() expects a list or string');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // sort function\n        self.emit_line(\"sort: (arr) => [...arr].sort((a, b) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof a === 'number' && typeof b === 'number') return a - b;\");\n        self.emit_line(\"return String(a).localeCompare(String(b));\");\n        self.indent -= 1;\n        self.emit_line(\"}),\");\n\n        // blether (print) function\n        self.emit_line(\"blether: console.log,\");\n\n        // speir (input) - for Node.js\n        self.emit_line(\"speir: (prompt) => {\");\n        self.indent += 1;\n        self.emit_line(\"const fs = require('fs');\");\n        self.emit_line(\"process.stdout.write(String(prompt));\");\n        self.emit_line(\"const buf = Buffer.alloc(1024);\");\n        self.emit_line(\"const n = fs.readSync(0, buf);\");\n        self.emit_line(\"return buf.toString('utf8', 0, n).trim();\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // Scots-flavored functions\n\n        // heid - first element\n        self.emit_line(\"heid: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof x === 'string' || Array.isArray(x)) {\");\n        self.indent += 1;\n        self.emit_line(\n            \"if (x.length === 0) throw new Error('Cannae get heid o\\\\' an empty list!');\",\n        );\n        self.emit_line(\"return x[0];\");\n        self.indent -= 1;\n        self.emit_line(\"}\");\n        self.emit_line(\"throw new Error('heid() expects a list or string');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // tail - all but first\n        self.emit_line(\"tail: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof x === 'string') return x.slice(1);\");\n        self.emit_line(\"if (Array.isArray(x)) return x.slice(1);\");\n        self.emit_line(\"throw new Error('tail() expects a list or string');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // bum - last element\n        self.emit_line(\"bum: (x) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof x === 'string' || Array.isArray(x)) {\");\n        self.indent += 1;\n        self.emit_line(\n            \"if (x.length === 0) throw new Error('Cannae get bum o\\\\' an empty list!');\",\n        );\n        self.emit_line(\"return x[x.length - 1];\");\n        self.indent -= 1;\n        self.emit_line(\"}\");\n        self.emit_line(\"throw new Error('bum() expects a list or string');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // scran - slice\n        self.emit_line(\"scran: (x, start, end) => {\");\n        self.indent += 1;\n        self.emit_line(\n            \"if (typeof x === 'string' || Array.isArray(x)) return x.slice(start, end);\",\n        );\n        self.emit_line(\"throw new Error('scran() expects a list or string');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // slap - concatenate\n        self.emit_line(\"slap: (a, b) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof a === 'string' && typeof b === 'string') return a + b;\");\n        self.emit_line(\"if (Array.isArray(a) && Array.isArray(b)) return [...a, ...b];\");\n        self.emit_line(\"throw new Error('slap() expects two lists or two strings');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // sumaw - sum all\n        self.emit_line(\"sumaw: (arr) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (!Array.isArray(arr)) throw new Error('sumaw() expects a list');\");\n        self.emit_line(\"return arr.reduce((a, b) => a + b, 0);\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // coont - count occurrences\n        self.emit_line(\"coont: (x, item) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof x === 'string') return x.split(item).length - 1;\");\n        self.emit_line(\"if (Array.isArray(x)) return x.filter(e => e === item).length;\");\n        self.emit_line(\"throw new Error('coont() expects a list or string');\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // wheesht - trim whitespace\n        self.emit_line(\"wheesht: (str) => String(str).trim(),\");\n\n        // upper - uppercase\n        self.emit_line(\"upper: (str) => String(str).toUpperCase(),\");\n\n        // lower - lowercase\n        self.emit_line(\"lower: (str) => String(str).toLowerCase(),\");\n\n        // shuffle - randomly shuffle\n        self.emit_line(\"shuffle: (arr) => {\");\n        self.indent += 1;\n        self.emit_line(\"if (!Array.isArray(arr)) throw new Error('shuffle() expects a list');\");\n        self.emit_line(\"const result = [...arr];\");\n        self.emit_line(\"for (let i = result.length - 1; i > 0; i--) {\");\n        self.indent += 1;\n        self.emit_line(\"const j = Math.floor(Math.random() * (i + 1));\");\n        self.emit_line(\"[result[i], result[j]] = [result[j], result[i]];\");\n        self.indent -= 1;\n        self.emit_line(\"}\");\n        self.emit_line(\"return result;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // slice - slice with step (fer [start:end:step] syntax)\n        self.emit_line(\"slice: (x, start, end, step) => {\");\n        self.indent += 1;\n        self.emit_line(\"const len = x.length;\");\n        self.emit_line(\"const isStr = typeof x === 'string';\");\n        self.emit_line(\"const arr = isStr ? x.split('') : x;\");\n        self.emit_line(\"if (step === 0) throw new Error('Slice step cannae be zero, ya dafty!');\");\n        self.emit_line(\"// Handle defaults based on step direction\");\n        self.emit_line(\"const s = start !== null ? (start < 0 ? Math.max(len + start, 0) : Math.min(start, len)) : (step > 0 ? 0 : len - 1);\");\n        self.emit_line(\"const e = end !== null ? (end < 0 ? Math.max(len + end, step > 0 ? 0 : -1) : Math.min(end, len)) : (step > 0 ? len : -len - 1);\");\n        self.emit_line(\"const result = [];\");\n        self.emit_line(\"if (step > 0) {\");\n        self.indent += 1;\n        self.emit_line(\"for (let i = s; i < e; i += step) result.push(arr[i]);\");\n        self.indent -= 1;\n        self.emit_line(\"} else {\");\n        self.indent += 1;\n        self.emit_line(\"for (let i = s; i > e; i += step) result.push(arr[i]);\");\n        self.indent -= 1;\n        self.emit_line(\"}\");\n        self.emit_line(\"return isStr ? result.join('') : result;\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // Timing functions\n        self.emit_line(\"// Timing functions\");\n        self.emit_line(\"noo: () => Date.now(),\");\n        self.emit_line(\"tick: () => {\");\n        self.indent += 1;\n        self.emit_line(\"if (typeof process !== 'undefined' && process.hrtime) {\");\n        self.indent += 1;\n        self.emit_line(\"const [s, ns] = process.hrtime();\");\n        self.emit_line(\"return s * 1e9 + ns;\");\n        self.indent -= 1;\n        self.emit_line(\"}\");\n        self.emit_line(\"return Date.now() * 1e6; // Fallback for browser\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n        self.emit_line(\"bide: (ms) => {\");\n        self.indent += 1;\n        self.emit_line(\"const end = Date.now() + ms;\");\n        self.emit_line(\"while (Date.now() < end) {} // Busy wait (sync)\");\n        self.indent -= 1;\n        self.emit_line(\"},\");\n\n        // Higher-order functions\n        self.emit_line(\"// Higher-order functions\");\n        self.emit_line(\"gaun: (arr, fn) => arr.map(fn),\");\n        self.emit_line(\"sieve: (arr, fn) => arr.filter(fn),\");\n        self.emit_line(\"tumble: (arr, init, fn) => arr.reduce(fn, init),\");\n        self.emit_line(\"aw: (arr, fn) => arr.every(fn),\");\n        self.emit_line(\"ony: (arr, fn) => arr.some(fn),\");\n        self.emit_line(\"hunt: (arr, fn) => arr.find(fn),\");\n\n        self.indent -= 1;\n        self.emit_line(\"};\");\n        self.emit_line(\"\");\n\n        // Import runtime functions to global scope\n        self.emit_line(\"const { len, whit_kind, tae_string, tae_int, tae_float, shove, yank, keys, values, range, abs, min, max, floor, ceil, round, sqrt, split, join, contains, reverse, sort, blether, speir, heid, tail, bum, scran, slap, sumaw, coont, wheesht, upper, lower, shuffle, noo, tick, bide, gaun, sieve, tumble, aw, ony, hunt } = __havers;\");\n        self.emit_line(\"\");\n    }\n\n    fn compile_stmt(&mut self, stmt: &Stmt) -> HaversResult<()> {\n        match stmt {\n            Stmt::VarDecl {\n                name, initializer, ..\n            } => {\n                self.emit_indent();\n                self.output.push_str(&format!(\"let {} = \", name));\n                if let Some(init) = initializer {\n                    self.compile_expr(init)?;\n                } else {\n                    self.output.push_str(\"null\");\n                }\n                self.output.push_str(\";\\n\");\n            }\n\n            Stmt::Expression { expr, .. } => {\n                self.emit_indent();\n                self.compile_expr(expr)?;\n                self.output.push_str(\";\\n\");\n            }\n\n            Stmt::Block { statements, .. } => {\n                self.emit_line(\"{\");\n                self.indent += 1;\n                for stmt in statements {\n                    self.compile_stmt(stmt)?;\n                }\n                self.indent -= 1;\n                self.emit_line(\"}\");\n            }\n\n            Stmt::If {\n                condition,\n                then_branch,\n                else_branch,\n                ..\n            } => {\n                self.emit_indent();\n                self.output.push_str(\"if (\");\n                self.compile_expr(condition)?;\n                self.output.push_str(\") \");\n                self.compile_stmt_inline(then_branch)?;\n                if let Some(else_br) = else_branch {\n                    self.output.push_str(\" else \");\n                    self.compile_stmt_inline(else_br)?;\n                }\n                self.output.push('\\n');\n            }\n\n            Stmt::While {\n                condition, body, ..\n            } => {\n                self.emit_indent();\n                self.output.push_str(\"while (\");\n                self.compile_expr(condition)?;\n                self.output.push_str(\") \");\n                self.compile_stmt_inline(body)?;\n                self.output.push('\\n');\n            }\n\n            Stmt::For {\n                variable,\n                iterable,\n                body,\n                ..\n            } => {\n                self.emit_indent();\n                self.output\n                    .push_str(&format!(\"for (const {} of \", variable));\n                self.compile_expr(iterable)?;\n                self.output.push_str(\") \");\n                self.compile_stmt_inline(body)?;\n                self.output.push('\\n');\n            }\n\n            Stmt::Function {\n                name, params, body, ..\n            } => {\n                self.emit_indent();\n                let params_str = self.compile_params(params)?;\n                self.output\n                    .push_str(&format!(\"function {}({}) {{\\n\", name, params_str));\n                self.indent += 1;\n                for stmt in body {\n                    self.compile_stmt(stmt)?;\n                }\n                self.indent -= 1;\n                self.emit_line(\"}\");\n            }\n\n            Stmt::Return { value, .. } => {\n                self.emit_indent();\n                self.output.push_str(\"return\");\n                if let Some(expr) = value {\n                    self.output.push(' ');\n                    self.compile_expr(expr)?;\n                }\n                self.output.push_str(\";\\n\");\n            }\n\n            Stmt::Print { value, .. } => {\n                self.emit_indent();\n                self.output.push_str(\"blether(\");\n                self.compile_expr(value)?;\n                self.output.push_str(\");\\n\");\n            }\n\n            Stmt::Break { .. } => {\n                self.emit_line(\"break;\");\n            }\n\n            Stmt::Continue { .. } => {\n                self.emit_line(\"continue;\");\n            }\n\n            Stmt::Class {\n                name,\n                superclass,\n                methods,\n                ..\n            } => {\n                self.emit_indent();\n                self.output.push_str(&format!(\"class {}\", name));\n                if let Some(super_name) = superclass {\n                    self.output.push_str(&format!(\" extends {}\", super_name));\n                }\n                self.output.push_str(\" {\\n\");\n                self.indent += 1;\n\n                for method in methods {\n                    if let Stmt::Function {\n                        name: method_name,\n                        params,\n                        body,\n                        ..\n                    } = method\n                    {\n                        self.emit_indent();\n                        let js_name = if method_name == \"init\" {\n                            \"constructor\"\n                        } else {\n                            method_name\n                        };\n                        let params_str = self.compile_params(params)?;\n                        self.output\n                            .push_str(&format!(\"{}({}) {{\\n\", js_name, params_str));\n                        self.indent += 1;\n                        for stmt in body {\n                            self.compile_stmt(stmt)?;\n                        }\n                        self.indent -= 1;\n                        self.emit_line(\"}\");\n                    }\n                }\n\n                self.indent -= 1;\n                self.emit_line(\"}\");\n            }\n\n            Stmt::Struct { name, fields, .. } => {\n                // Compile struct as a class with a constructor\n                self.emit_indent();\n                self.output.push_str(&format!(\"class {} {{\\n\", name));\n                self.indent += 1;\n                self.emit_indent();\n                self.output\n                    .push_str(&format!(\"constructor({}) {{\\n\", fields.join(\", \")));\n                self.indent += 1;\n                for field in fields {\n                    self.emit_line(&format!(\"this.{} = {};\", field, field));\n                }\n                self.indent -= 1;\n                self.emit_line(\"}\");\n                self.indent -= 1;\n                self.emit_line(\"}\");\n            }\n\n            Stmt::Import { path, alias, .. } => {\n                let module_name = alias.clone().unwrap_or_else(|| {\n                    // Extract filename from path\n                    path.rsplit('/')\n                        .next()\n                        .unwrap_or(path)\n                        .replace(\".braw\", \"\")\n                        .replace(\".js\", \"\")\n                });\n                self.emit_line(&format!(\"const {} = require('{}');\", module_name, path));\n            }\n\n            Stmt::TryCatch {\n                try_block,\n                error_name,\n                catch_block,\n                ..\n            } => {\n                self.emit_indent();\n                self.output.push_str(\"try \");\n                self.compile_stmt_inline(try_block)?;\n                self.output.push_str(&format!(\" catch ({}) \", error_name));\n                self.compile_stmt_inline(catch_block)?;\n                self.output.push('\\n');\n            }\n\n            Stmt::Match { value, arms, .. } => {\n                // Compile match as switch or if-else chain\n                // Use unique variable name for each match statement\n                let match_var = format!(\"__match_val_{}\", self.match_counter);\n                self.match_counter += 1;\n\n                self.emit_indent();\n                self.output.push_str(&format!(\"const {} = \", match_var));\n                self.compile_expr(value)?;\n                self.output.push_str(\";\\n\");\n\n                for (i, arm) in arms.iter().enumerate() {\n                    self.emit_indent();\n                    if i == 0 {\n                        self.output.push_str(\"if (\");\n                    } else {\n                        self.output.push_str(\"else if (\");\n                    }\n                    self.compile_pattern(&arm.pattern, &match_var)?;\n                    self.output.push_str(\") {\\n\");\n                    self.indent += 1;\n\n                    // Bind pattern variable if identifier\n                    if let Pattern::Identifier(name) = &arm.pattern {\n                        self.emit_line(&format!(\"const {} = {};\", name, match_var));\n                    }\n\n                    // Compile the body - unwrap block to avoid double braces\n                    match &arm.body {\n                        Stmt::Block { statements, .. } => {\n                            for s in statements {\n                                self.compile_stmt(s)?;\n                            }\n                        }\n                        other => {\n                            self.compile_stmt(other)?;\n                        }\n                    }\n\n                    self.indent -= 1;\n                    self.emit_indent();\n                    self.output.push_str(\"} \");\n                }\n\n                if !arms.is_empty() {\n                    self.output.push_str(\"else {\\n\");\n                    self.indent += 1;\n                    self.emit_line(\"throw new Error('Nae match found!');\");\n                    self.indent -= 1;\n                    self.emit_line(\"}\");\n                }\n            }\n\n            Stmt::Assert {\n                condition, message, ..\n            } => {\n                self.emit_indent();\n                self.output.push_str(\"if (!(\");\n                self.compile_expr(condition)?;\n                self.output.push_str(\")) {\\n\");\n                self.indent += 1;\n                self.emit_indent();\n                if let Some(msg) = message {\n                    self.output.push_str(\"throw new Error(\");\n                    self.compile_expr(msg)?;\n                    self.output.push_str(\");\\n\");\n                } else {\n                    self.emit_line(\"throw new Error('Assertion failed');\");\n                }\n                self.indent -= 1;\n                self.emit_line(\"}\");\n            }\n\n            Stmt::Destructure {\n                patterns, value, ..\n            } => {\n                // JavaScript destructuring: const [a, b, ...rest] = value\n                self.emit_indent();\n                self.output.push_str(\"const [\");\n\n                for (i, pattern) in patterns.iter().enumerate() {\n                    if i > 0 {\n                        self.output.push_str(\", \");\n                    }\n                    match pattern {\n                        DestructPattern::Variable(name) => self.output.push_str(name),\n                        DestructPattern::Rest(name) => {\n                            self.output.push_str(\"...\");\n                            self.output.push_str(name);\n                        }\n                        DestructPattern::Ignore => self.output.push('_'),\n                    }\n                }\n\n                self.output.push_str(\"] = \");\n                self.compile_expr(value)?;\n                self.output.push_str(\";\\n\");\n            }\n\n            Stmt::Log { level, message, .. } => {\n                // Compile log to console.error with level prefix\n                let level_name = match level {\n                    crate::ast::LogLevel::Wheesht => return Ok(()), // Silent - no output\n                    crate::ast::LogLevel::Roar => \"ROAR\",\n                    crate::ast::LogLevel::Holler => \"HOLLER\",\n                    crate::ast::LogLevel::Blether => \"BLETHER\",\n                    crate::ast::LogLevel::Mutter => \"MUTTER\",\n                    crate::ast::LogLevel::Whisper => \"WHISPER\",\n                };\n                self.emit_indent();\n                self.output.push_str(&format!(\n                    \"console.error(`[{}] ${{new Date().toISOString()}} | ` + \",\n                    level_name\n                ));\n                self.compile_expr(message)?;\n                self.output.push_str(\");\\n\");\n            }\n\n            Stmt::Hurl { message, .. } => {\n                self.emit_indent();\n                self.output.push_str(\"throw new Error(\");\n                self.compile_expr(message)?;\n                self.output.push_str(\");\\n\");\n            }\n        }\n\n        Ok(())\n    }\n\n    fn compile_stmt_inline(&mut self, stmt: &Stmt) -> HaversResult<()> {\n        match stmt {\n            Stmt::Block { statements, .. } => {\n                self.output.push_str(\"{\\n\");\n                self.indent += 1;\n                for s in statements {\n                    self.compile_stmt(s)?;\n                }\n                self.indent -= 1;\n                self.emit_indent();\n                self.output.push('}');\n            }\n            _ => {\n                self.compile_stmt(stmt)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn compile_pattern(&mut self, pattern: &Pattern, match_var: &str) -> HaversResult<()> {\n        match pattern {\n            Pattern::Literal(lit) => {\n                self.output.push_str(&format!(\"{} === \", match_var));\n                match lit {\n                    Literal::Integer(n) => self.output.push_str(&n.to_string()),\n                    Literal::Float(f) => self.output.push_str(&f.to_string()),\n                    Literal::String(s) => self.output.push_str(&format!(\"\\\"{}\\\"\", s)),\n                    Literal::Bool(b) => self.output.push_str(if *b { \"true\" } else { \"false\" }),\n                    Literal::Nil => self.output.push_str(\"null\"),\n                }\n            }\n            Pattern::Identifier(_) => {\n                self.output.push_str(\"true\"); // Always matches\n            }\n            Pattern::Wildcard => {\n                self.output.push_str(\"true\"); // Always matches\n            }\n            Pattern::Range { start, end } => {\n                self.output.push_str(&format!(\"({} >= \", match_var));\n                self.compile_expr(start)?;\n                self.output.push_str(&format!(\" && {} < \", match_var));\n                self.compile_expr(end)?;\n                self.output.push(')');\n            }\n        }\n        Ok(())\n    }\n\n    /// Compile function parameters, handling default values\n    fn compile_params(&mut self, params: &[Param]) -> HaversResult<String> {\n        let mut result = Vec::new();\n        for param in params {\n            if let Some(default_expr) = &param.default {\n                // Compile the default value\n                let old_output = std::mem::take(&mut self.output);\n                self.compile_expr(default_expr)?;\n                let default_js = std::mem::replace(&mut self.output, old_output);\n                result.push(format!(\"{} = {}\", param.name, default_js));\n            } else {\n                result.push(param.name.clone());\n            }\n        }\n        Ok(result.join(\", \"))\n    }\n\n    fn compile_expr(&mut self, expr: &Expr) -> HaversResult<()> {\n        match expr {\n            Expr::Literal { value, .. } => {\n                match value {\n                    Literal::Integer(n) => self.output.push_str(&n.to_string()),\n                    Literal::Float(f) => self.output.push_str(&f.to_string()),\n                    Literal::String(s) => {\n                        // Escape the string properly\n                        let escaped = s\n                            .replace('\\\\', \"\\\\\\\\\")\n                            .replace('\"', \"\\\\\\\"\")\n                            .replace('\\n', \"\\\\n\")\n                            .replace('\\r', \"\\\\r\")\n                            .replace('\\t', \"\\\\t\");\n                        self.output.push_str(&format!(\"\\\"{}\\\"\", escaped));\n                    }\n                    Literal::Bool(true) => self.output.push_str(\"true\"),\n                    Literal::Bool(false) => self.output.push_str(\"false\"),\n                    Literal::Nil => self.output.push_str(\"null\"),\n                }\n            }\n\n            Expr::Variable { name, .. } => {\n                self.output.push_str(name);\n            }\n\n            Expr::Assign { name, value, .. } => {\n                self.output.push_str(&format!(\"({} = \", name));\n                self.compile_expr(value)?;\n                self.output.push(')');\n            }\n\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                self.output.push('(');\n                self.compile_expr(left)?;\n                let op_str = match operator {\n                    BinaryOp::Add => \" + \",\n                    BinaryOp::Subtract => \" - \",\n                    BinaryOp::Multiply => \" * \",\n                    BinaryOp::Divide => \" / \",\n                    BinaryOp::Modulo => \" % \",\n                    BinaryOp::Equal => \" === \",\n                    BinaryOp::NotEqual => \" !== \",\n                    BinaryOp::Less => \" < \",\n                    BinaryOp::LessEqual => \" <= \",\n                    BinaryOp::Greater => \" > \",\n                    BinaryOp::GreaterEqual => \" >= \",\n                };\n                self.output.push_str(op_str);\n                self.compile_expr(right)?;\n                self.output.push(')');\n            }\n\n            Expr::Unary {\n                operator, operand, ..\n            } => match operator {\n                UnaryOp::Negate => {\n                    self.output.push_str(\"(-\");\n                    self.compile_expr(operand)?;\n                    self.output.push(')');\n                }\n                UnaryOp::Not => {\n                    self.output.push_str(\"(!\");\n                    self.compile_expr(operand)?;\n                    self.output.push(')');\n                }\n            },\n\n            Expr::Logical {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                self.output.push('(');\n                self.compile_expr(left)?;\n                let op_str = match operator {\n                    LogicalOp::And => \" && \",\n                    LogicalOp::Or => \" || \",\n                };\n                self.output.push_str(op_str);\n                self.compile_expr(right)?;\n                self.output.push(')');\n            }\n\n            Expr::Call {\n                callee, arguments, ..\n            } => {\n                // Heuristic: If calling a variable with a capitalized name, assume it's a class constructor\n                if let Expr::Variable { name, .. } = &**callee {\n                    if name.chars().next().is_some_and(|c| c.is_uppercase()) {\n                        self.output.push_str(\"new \");\n                    }\n                }\n\n                self.compile_expr(callee)?;\n                self.output.push('(');\n                for (i, arg) in arguments.iter().enumerate() {\n                    if i > 0 {\n                        self.output.push_str(\", \");\n                    }\n                    self.compile_expr(arg)?;\n                }\n                self.output.push(')');\n            }\n\n            Expr::Get {\n                object, property, ..\n            } => {\n                self.compile_expr(object)?;\n                self.output.push('.');\n                self.output.push_str(property);\n            }\n\n            Expr::Set {\n                object,\n                property,\n                value,\n                ..\n            } => {\n                self.output.push('(');\n                self.compile_expr(object)?;\n                self.output.push('.');\n                self.output.push_str(property);\n                self.output.push_str(\" = \");\n                self.compile_expr(value)?;\n                self.output.push(')');\n            }\n\n            Expr::Index { object, index, .. } => {\n                self.compile_expr(object)?;\n                self.output.push('[');\n                self.compile_expr(index)?;\n                self.output.push(']');\n            }\n\n            Expr::IndexSet {\n                object,\n                index,\n                value,\n                ..\n            } => {\n                self.output.push('(');\n                self.compile_expr(object)?;\n                self.output.push('[');\n                self.compile_expr(index)?;\n                self.output.push_str(\"] = \");\n                self.compile_expr(value)?;\n                self.output.push(')');\n            }\n\n            Expr::Slice {\n                object,\n                start,\n                end,\n                step,\n                ..\n            } => {\n                // JavaScript: Use helper function fer step slices, or .slice() fer simple ones\n                if step.is_some() {\n                    // Need to use a helper function fer step slices\n                    self.output.push_str(\"__havers.slice(\");\n                    self.compile_expr(object)?;\n                    self.output.push_str(\", \");\n                    if let Some(s) = start {\n                        self.compile_expr(s)?;\n                    } else {\n                        self.output.push_str(\"null\");\n                    }\n                    self.output.push_str(\", \");\n                    if let Some(e) = end {\n                        self.compile_expr(e)?;\n                    } else {\n                        self.output.push_str(\"null\");\n                    }\n                    self.output.push_str(\", \");\n                    if let Some(st) = step {\n                        self.compile_expr(st)?;\n                    }\n                    self.output.push(')');\n                } else {\n                    // Simple slice: obj.slice(start, end)\n                    self.compile_expr(object)?;\n                    self.output.push_str(\".slice(\");\n                    if let Some(s) = start {\n                        self.compile_expr(s)?;\n                    } else {\n                        self.output.push('0');\n                    }\n                    if let Some(e) = end {\n                        self.output.push_str(\", \");\n                        self.compile_expr(e)?;\n                    }\n                    self.output.push(')');\n                }\n            }\n\n            Expr::List { elements, .. } => {\n                self.output.push('[');\n                for (i, elem) in elements.iter().enumerate() {\n                    if i > 0 {\n                        self.output.push_str(\", \");\n                    }\n                    self.compile_expr(elem)?;\n                }\n                self.output.push(']');\n            }\n\n            Expr::Dict { pairs, .. } => {\n                self.output.push('{');\n                for (i, (key, value)) in pairs.iter().enumerate() {\n                    if i > 0 {\n                        self.output.push_str(\", \");\n                    }\n                    self.compile_expr(key)?;\n                    self.output.push_str(\": \");\n                    self.compile_expr(value)?;\n                }\n                self.output.push('}');\n            }\n\n            Expr::Range { start, end, .. } => {\n                self.output.push_str(\"__havers.range(\");\n                self.compile_expr(start)?;\n                self.output.push_str(\", \");\n                self.compile_expr(end)?;\n                self.output.push(')');\n            }\n\n            Expr::Grouping { expr, .. } => {\n                self.output.push('(');\n                self.compile_expr(expr)?;\n                self.output.push(')');\n            }\n\n            Expr::Lambda { params, body, .. } => {\n                self.output.push('(');\n                self.output.push_str(&params.join(\", \"));\n                self.output.push_str(\") => \");\n                self.compile_expr(body)?;\n            }\n\n            Expr::Masel { .. } => {\n                self.output.push_str(\"this\");\n            }\n\n            Expr::Input { prompt, .. } => {\n                self.output.push_str(\"speir(\");\n                self.compile_expr(prompt)?;\n                self.output.push(')');\n            }\n\n            Expr::FString { parts, .. } => {\n                // Compile to JavaScript template literal\n                self.output.push('`');\n                for part in parts {\n                    match part {\n                        FStringPart::Text(text) => {\n                            // Escape backticks in the text\n                            for c in text.chars() {\n                                if c == '`' {\n                                    self.output.push_str(\"\\\\`\");\n                                } else if c == '$' {\n                                    self.output.push_str(\"\\\\$\");\n                                } else {\n                                    self.output.push(c);\n                                }\n                            }\n                        }\n                        FStringPart::Expr(expr) => {\n                            self.output.push_str(\"${\");\n                            self.compile_expr(expr)?;\n                            self.output.push('}');\n                        }\n                    }\n                }\n                self.output.push('`');\n            }\n\n            Expr::Spread { expr, .. } => {\n                self.output.push_str(\"...\");\n                self.compile_expr(expr)?;\n            }\n\n            Expr::Pipe { left, right, .. } => {\n                // In JavaScript, we transform left |> right to right(left)\n                self.compile_expr(right)?;\n                self.output.push('(');\n                self.compile_expr(left)?;\n                self.output.push(')');\n            }\n\n            Expr::Ternary {\n                condition,\n                then_expr,\n                else_expr,\n                ..\n            } => {\n                // JavaScript ternary: condition ? then : else\n                self.output.push('(');\n                self.compile_expr(condition)?;\n                self.output.push_str(\" ? \");\n                self.compile_expr(then_expr)?;\n                self.output.push_str(\" : \");\n                self.compile_expr(else_expr)?;\n                self.output.push(')');\n            }\n        }\n\n        Ok(())\n    }\n\n    fn emit_indent(&mut self) {\n        for _ in 0..self.indent {\n            self.output.push_str(\"  \");\n        }\n    }\n\n    fn emit_line(&mut self, line: &str) {\n        self.emit_indent();\n        self.output.push_str(line);\n        self.output.push('\\n');\n    }\n}\n\nimpl Default for Compiler {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Compile mdhavers source tae JavaScript\npub fn compile(source: &str) -> HaversResult<String> {\n    let program = crate::parser::parse(source)?;\n    let mut compiler = Compiler::new();\n    compiler.compile(&program)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ==================== Basic Tests ====================\n\n    #[test]\n    fn test_simple_compile() {\n        let result = compile(\"ken x = 5\").unwrap();\n        assert!(result.contains(\"let x = 5;\"));\n    }\n\n    #[test]\n    fn test_var_no_initializer() {\n        let result = compile(\"ken x\").unwrap();\n        assert!(result.contains(\"let x = null;\"));\n    }\n\n    #[test]\n    fn test_expression_statement() {\n        let result = compile(\"ken x = 1\\nx + 2\").unwrap();\n        assert!(result.contains(\"(x + 2);\"));\n    }\n\n    // ==================== Function Tests ====================\n\n    #[test]\n    fn test_function_compile() {\n        let result = compile(\n            r#\"\ndae add(a, b) {\n    gie a + b\n}\n\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"function add(a, b)\"));\n        assert!(result.contains(\"return\"));\n    }\n\n    #[test]\n    fn test_function_with_defaults() {\n        let result = compile(\n            r#\"dae greet(name, greeting = \"Hello\") {\n    gie greeting + name\n}\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"greeting = \\\"Hello\\\"\"));\n    }\n\n    #[test]\n    fn test_return_no_value() {\n        let result = compile(\"dae foo() {\\n    gie\\n}\").unwrap();\n        assert!(result.contains(\"return;\"));\n    }\n\n    // ==================== Control Flow Tests ====================\n\n    #[test]\n    fn test_if_compile() {\n        let result = compile(\n            r#\"\ngin x > 5 {\n    blether \"big\"\n}\n\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"if (\"));\n        assert!(result.contains(\"blether(\"));\n    }\n\n    #[test]\n    fn test_if_else_compile() {\n        let result = compile(r#\"gin x > 5 { blether \"big\" } ither { blether \"small\" }\"#).unwrap();\n        assert!(result.contains(\"if (\"));\n        assert!(result.contains(\"else\"));\n    }\n\n    #[test]\n    fn test_while_compile() {\n        let result = compile(\"whiles x < 10 { ken x = x + 1 }\").unwrap();\n        assert!(result.contains(\"while (\"));\n    }\n\n    #[test]\n    fn test_for_compile() {\n        let result = compile(\"fer i in 0..10 { blether i }\").unwrap();\n        assert!(result.contains(\"for (const i of\"));\n    }\n\n    #[test]\n    fn test_break_compile() {\n        let result = compile(\"whiles aye { brak }\").unwrap();\n        assert!(result.contains(\"break;\"));\n    }\n\n    #[test]\n    fn test_continue_compile() {\n        let result = compile(\"whiles aye { haud }\").unwrap();\n        assert!(result.contains(\"continue;\"));\n    }\n\n    // ==================== Block Tests ====================\n\n    #[test]\n    fn test_block_compile() {\n        let result = compile(\"{ ken x = 1\\n ken y = 2 }\").unwrap();\n        assert!(result.contains(\"let x = 1;\"));\n        assert!(result.contains(\"let y = 2;\"));\n    }\n\n    // ==================== Class Tests ====================\n\n    #[test]\n    fn test_class_compile() {\n        let result = compile(\n            r#\"\nkin Animal {\n    dae init(name) {\n        masel.name = name\n    }\n    dae speak() {\n        blether masel.name\n    }\n}\n\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"class Animal\"));\n        assert!(result.contains(\"constructor(name)\"));\n        assert!(result.contains(\"this.name\"));\n    }\n\n    #[test]\n    fn test_class_inheritance() {\n        let result = compile(\n            r#\"kin Dog fae Animal {\n    dae bark() {\n        blether \"woof\"\n    }\n}\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"class Dog extends Animal\"));\n    }\n\n    // ==================== Struct Tests ====================\n\n    #[test]\n    fn test_struct_compile() {\n        let result = compile(\"thing Point { x, y }\").unwrap();\n        assert!(result.contains(\"class Point\"));\n        assert!(result.contains(\"constructor(x, y)\"));\n        assert!(result.contains(\"this.x = x;\"));\n        assert!(result.contains(\"this.y = y;\"));\n    }\n\n    // ==================== Import Tests ====================\n\n    #[test]\n    fn test_import_compile() {\n        let result = compile(\"fetch \\\"math\\\"\").unwrap();\n        assert!(result.contains(\"require('math')\"));\n    }\n\n    #[test]\n    fn test_import_with_alias() {\n        let result = compile(\"fetch \\\"math\\\" tae m\").unwrap();\n        assert!(result.contains(\"const m = require('math')\"));\n    }\n\n    // ==================== Try-Catch Tests ====================\n\n    #[test]\n    fn test_try_catch_compile() {\n        let result =\n            compile(\"hae_a_bash { ken x = 1 } gin_it_gangs_wrang e { blether e }\").unwrap();\n        assert!(result.contains(\"try {\"));\n        assert!(result.contains(\"catch (e)\"));\n    }\n\n    // ==================== Match Tests ====================\n\n    #[test]\n    fn test_match_compile() {\n        let result = compile(\n            r#\"keek x {\n    whan 1 -> blether \"one\"\n    whan 2 -> blether \"two\"\n    whan _ -> blether \"other\"\n}\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"__match_val_\"));\n        assert!(result.contains(\"if (\"));\n        assert!(result.contains(\"else if (\"));\n    }\n\n    #[test]\n    fn test_match_literal_patterns() {\n        let result = compile(\n            r#\"keek x {\n    whan \"hello\" -> blether \"hi\"\n    whan 3.14 -> blether \"pi\"\n    whan aye -> blether \"true\"\n    whan naething -> blether \"nil\"\n}\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\"=== \\\"hello\\\"\"));\n        assert!(result.contains(\"=== 3.14\"));\n        assert!(result.contains(\"=== true\"));\n        assert!(result.contains(\"=== null\"));\n    }\n\n    #[test]\n    fn test_match_identifier_pattern() {\n        let result = compile(\n            r#\"keek x {\n    whan value -> blether value\n}\"#,\n        )\n        .unwrap();\n        // Identifier patterns bind the value\n        assert!(result.contains(\"const value =\"));\n    }\n\n    #[test]\n    fn test_match_range_pattern() {\n        let result = compile(\n            r#\"keek x {\n    whan 1..10 -> blether \"in range\"\n    whan _ -> blether \"out\"\n}\"#,\n        )\n        .unwrap();\n        assert!(result.contains(\">= \"));\n        assert!(result.contains(\"< \"));\n    }\n\n    // ==================== Assert Tests ====================\n\n    #[test]\n    fn test_assert_compile() {\n        let result = compile(\"mak_siccar x > 0\").unwrap();\n        assert!(result.contains(\"if (!(\"));\n        assert!(result.contains(\"throw new Error\"));\n    }\n\n    #[test]\n    fn test_assert_with_message() {\n        let result = compile(\"mak_siccar x > 0, \\\"x must be positive\\\"\").unwrap();\n        assert!(result.contains(\"throw new Error(\"));\n        assert!(result.contains(\"\\\"x must be positive\\\"\"));\n    }\n\n    // ==================== Destructuring Tests ====================\n\n    #[test]\n    fn test_destructure_compile() {\n        let result = compile(\"ken [a, b] = [1, 2]\").unwrap();\n        assert!(result.contains(\"const [a, b] = \"));\n    }\n\n    #[test]\n    fn test_destructure_rest() {\n        let result = compile(\"ken [first, ...rest] = [1, 2, 3]\").unwrap();\n        assert!(result.contains(\"const [first, ...rest] = \"));\n    }\n\n    #[test]\n    fn test_destructure_ignore() {\n        let result = compile(\"ken [_, second, _] = [1, 2, 3]\").unwrap();\n        assert!(result.contains(\"const [_, second, _] = \"));\n    }\n\n    // ==================== Expression Tests ====================\n\n    #[test]\n    fn test_assignment_compile() {\n        let result = compile(\"ken x = 1\\nx = 42\").unwrap();\n        assert!(result.contains(\"(x = 42)\"));\n    }\n\n    #[test]\n    fn test_unary_negate() {\n        let result = compile(\"-42\").unwrap();\n        assert!(result.contains(\"(-42)\"));\n    }\n\n    #[test]\n    fn test_unary_not() {\n        let result = compile(\"nae aye\").unwrap();\n        assert!(result.contains(\"(!true)\"));\n    }\n\n    #[test]\n    fn test_logical_and() {\n        let result = compile(\"aye an nae\").unwrap();\n        assert!(result.contains(\"&&\"));\n    }\n\n    #[test]\n    fn test_logical_or() {\n        let result = compile(\"aye or nae\").unwrap();\n        assert!(result.contains(\"||\"));\n    }\n\n    #[test]\n    fn test_call_compile() {\n        let result = compile(\"foo(1, 2, 3)\").unwrap();\n        assert!(result.contains(\"foo(1, 2, 3)\"));\n    }\n\n    #[test]\n    fn test_get_property() {\n        let result = compile(\"obj.prop\").unwrap();\n        assert!(result.contains(\"obj.prop\"));\n    }\n\n    #[test]\n    fn test_set_property() {\n        let result = compile(\"ken obj = {}\\nobj.prop = 42\").unwrap();\n        assert!(result.contains(\"obj.prop = 42\"));\n    }\n\n    #[test]\n    fn test_index_compile() {\n        let result = compile(\"list[0]\").unwrap();\n        assert!(result.contains(\"list[0]\"));\n    }\n\n    #[test]\n    fn test_index_set_compile() {\n        let result = compile(\"ken list = [1,2,3]\\nlist[0] = 99\").unwrap();\n        assert!(result.contains(\"list[0] = 99\"));\n    }\n\n    #[test]\n    fn test_slice_simple() {\n        let result = compile(\"list[1:3]\").unwrap();\n        assert!(result.contains(\".slice(\"));\n    }\n\n    #[test]\n    fn test_slice_with_step() {\n        let result = compile(\"list[::2]\").unwrap();\n        assert!(result.contains(\"__havers.slice(\"));\n    }\n\n    #[test]\n    fn test_slice_start_only() {\n        let result = compile(\"list[1:]\").unwrap();\n        assert!(result.contains(\".slice(1)\"));\n    }\n\n    #[test]\n    fn test_list_compile() {\n        let result = compile(\"[1, 2, 3]\").unwrap();\n        assert!(result.contains(\"[1, 2, 3]\"));\n    }\n\n    #[test]\n    fn test_dict_compile() {\n        let result = compile(\"ken d = {\\\"a\\\": 1, \\\"b\\\": 2}\").unwrap();\n        assert!(result.contains(\"{\"));\n        assert!(result.contains(\"}\"));\n    }\n\n    #[test]\n    fn test_range_compile() {\n        let result = compile(\"0..10\").unwrap();\n        assert!(result.contains(\"__havers.range(0, 10)\"));\n    }\n\n    #[test]\n    fn test_grouping_compile() {\n        let result = compile(\"(1 + 2) * 3\").unwrap();\n        assert!(result.contains(\"((1 + 2))\"));\n    }\n\n    #[test]\n    fn test_lambda_compile() {\n        let result = compile(\"|x, y| x + y\").unwrap();\n        assert!(result.contains(\"(x, y) =>\"));\n    }\n\n    #[test]\n    fn test_masel_compile() {\n        let result = compile(\"kin Foo { dae test() { gie masel } }\").unwrap();\n        assert!(result.contains(\"return this\"));\n    }\n\n    #[test]\n    fn test_input_compile() {\n        let result = compile(\"speir \\\"What? \\\"\").unwrap();\n        assert!(result.contains(\"speir(\\\"What? \\\")\"));\n    }\n\n    #[test]\n    fn test_fstring_compile() {\n        let result = compile(\"ken name = \\\"world\\\"\\nf\\\"Hello {name}!\\\"\").unwrap();\n        assert!(result.contains(\"`Hello ${name}!`\"));\n    }\n\n    #[test]\n    fn test_fstring_escapes() {\n        let result = compile(\"f\\\"cost: $5\\\"\").unwrap();\n        assert!(result.contains(\"`cost: \\\\$5`\"));\n    }\n\n    #[test]\n    fn test_spread_compile() {\n        let result = compile(\"[1, ...[2, 3]]\").unwrap();\n        assert!(result.contains(\"...[2, 3]\"));\n    }\n\n    #[test]\n    fn test_pipe_compile() {\n        let result = compile(\"ken dbl = |x| x * 2\\n5 |> dbl\").unwrap();\n        assert!(result.contains(\"dbl(5)\"));\n    }\n\n    #[test]\n    fn test_ternary_compile() {\n        let result = compile(\"ken x = gin aye than 1 ither 0\").unwrap();\n        assert!(result.contains(\"true ? 1 : 0\"));\n    }\n\n    // ==================== String Escaping Tests ====================\n\n    #[test]\n    fn test_string_escapes() {\n        let result = compile(\"ken s = \\\"line1\\\\nline2\\\"\").unwrap();\n        assert!(result.contains(\"\\\\n\"));\n    }\n\n    // ==================== Compiler Default Tests ====================\n\n    #[test]\n    fn test_compiler_default() {\n        let compiler = Compiler::default();\n        assert_eq!(compiler.indent, 0);\n        assert!(compiler.output.is_empty());\n    }\n\n    // ==================== Runtime Tests ====================\n\n    #[test]\n    fn test_runtime_emitted() {\n        let result = compile(\"ken x = 1\").unwrap();\n        assert!(result.contains(\"const __havers = {\"));\n        assert!(result.contains(\"len:\"));\n        assert!(result.contains(\"whit_kind:\"));\n        assert!(result.contains(\"blether:\"));\n    }\n}\n","traces":[{"line":12,"address":[53328560],"length":1,"stats":{"Line":2}},{"line":15,"address":[54873293],"length":1,"stats":{"Line":2}},{"line":21,"address":[53328640],"length":1,"stats":{"Line":2}},{"line":22,"address":[54873411],"length":1,"stats":{"Line":2}},{"line":25,"address":[53328701],"length":1,"stats":{"Line":2}},{"line":28,"address":[53328711,53328727],"length":1,"stats":{"Line":48}},{"line":29,"address":[53328789,53328935],"length":1,"stats":{"Line":18}},{"line":32,"address":[53328853],"length":1,"stats":{"Line":2}},{"line":35,"address":[55685136],"length":1,"stats":{"Line":2}},{"line":36,"address":[55685159],"length":1,"stats":{"Line":2}},{"line":37,"address":[54861776],"length":1,"stats":{"Line":2}},{"line":38,"address":[55685209,55685308],"length":1,"stats":{"Line":2}},{"line":41,"address":[54861845],"length":1,"stats":{"Line":2}},{"line":42,"address":[53317118,53317177,53317283],"length":1,"stats":{"Line":4}},{"line":43,"address":[54861933],"length":1,"stats":{"Line":2}},{"line":44,"address":[55685366],"length":1,"stats":{"Line":2}},{"line":45,"address":[53317231],"length":1,"stats":{"Line":2}},{"line":46,"address":[55685556,55685416,55685472],"length":1,"stats":{"Line":4}},{"line":47,"address":[53317316],"length":1,"stats":{"Line":2}},{"line":50,"address":[54862093],"length":1,"stats":{"Line":2}},{"line":51,"address":[53317560,53317366,53317425],"length":1,"stats":{"Line":4}},{"line":52,"address":[55685589],"length":1,"stats":{"Line":2}},{"line":53,"address":[54862206],"length":1,"stats":{"Line":2}},{"line":54,"address":[53317479],"length":1,"stats":{"Line":2}},{"line":55,"address":[54862256],"length":1,"stats":{"Line":2}},{"line":56,"address":[55685689,55685858,55685749],"length":1,"stats":{"Line":7}},{"line":57,"address":[53317593],"length":1,"stats":{"Line":2}},{"line":60,"address":[55685778],"length":1,"stats":{"Line":5}},{"line":63,"address":[54862395],"length":1,"stats":{"Line":2}},{"line":64,"address":[53317668,53317727,53317833],"length":1,"stats":{"Line":9}},{"line":65,"address":[54862483],"length":1,"stats":{"Line":7}},{"line":66,"address":[55685916],"length":1,"stats":{"Line":4}},{"line":67,"address":[53317781],"length":1,"stats":{"Line":9}},{"line":68,"address":[55685966,55686022,55686106],"length":1,"stats":{"Line":12}},{"line":69,"address":[54862618],"length":1,"stats":{"Line":5}},{"line":72,"address":[54862643],"length":1,"stats":{"Line":10}},{"line":73,"address":[55686076,55686135,55686245],"length":1,"stats":{"Line":17}},{"line":74,"address":[54862731],"length":1,"stats":{"Line":9}},{"line":75,"address":[54862756],"length":1,"stats":{"Line":14}},{"line":76,"address":[55686189],"length":1,"stats":{"Line":9}},{"line":77,"address":[55686274,55686379,55686214],"length":1,"stats":{"Line":24}},{"line":78,"address":[55686278],"length":1,"stats":{"Line":15}},{"line":81,"address":[55686303],"length":1,"stats":{"Line":9}},{"line":84,"address":[53318168],"length":1,"stats":{"Line":15}},{"line":85,"address":[53318193,53318333,53318248],"length":1,"stats":{"Line":24}},{"line":86,"address":[55686412],"length":1,"stats":{"Line":9}},{"line":87,"address":[54863029],"length":1,"stats":{"Line":15}},{"line":88,"address":[55686462,55686522,55686656],"length":1,"stats":{"Line":25}},{"line":89,"address":[53318366],"length":1,"stats":{"Line":9}},{"line":92,"address":[53318391],"length":1,"stats":{"Line":16}},{"line":95,"address":[55686576],"length":1,"stats":{"Line":9}},{"line":98,"address":[53318441],"length":1,"stats":{"Line":16}},{"line":99,"address":[55686685,55686626,55686795],"length":1,"stats":{"Line":25}},{"line":100,"address":[53318529],"length":1,"stats":{"Line":9}},{"line":101,"address":[54863306],"length":1,"stats":{"Line":16}},{"line":102,"address":[54863331],"length":1,"stats":{"Line":9}},{"line":103,"address":[53318664,53318604,53318973],"length":1,"stats":{"Line":25}},{"line":104,"address":[54863420],"length":1,"stats":{"Line":16}},{"line":107,"address":[53318693],"length":1,"stats":{"Line":9}},{"line":110,"address":[54863470],"length":1,"stats":{"Line":18}},{"line":113,"address":[53318743],"length":1,"stats":{"Line":11}},{"line":116,"address":[55686928],"length":1,"stats":{"Line":17}},{"line":119,"address":[53318793],"length":1,"stats":{"Line":9}},{"line":122,"address":[53318818],"length":1,"stats":{"Line":20}},{"line":125,"address":[55687003],"length":1,"stats":{"Line":9}},{"line":128,"address":[55687028],"length":1,"stats":{"Line":20}},{"line":131,"address":[53318893],"length":1,"stats":{"Line":9}},{"line":134,"address":[53318918],"length":1,"stats":{"Line":21}},{"line":135,"address":[54863695,54863885,54863754],"length":1,"stats":{"Line":31}},{"line":136,"address":[55687166],"length":1,"stats":{"Line":9}},{"line":137,"address":[53319031],"length":1,"stats":{"Line":28}},{"line":138,"address":[53319056],"length":1,"stats":{"Line":9}},{"line":139,"address":[54863833],"length":1,"stats":{"Line":32}},{"line":140,"address":[53319162,53319106,53319246],"length":1,"stats":{"Line":42}},{"line":141,"address":[55687326],"length":1,"stats":{"Line":9}},{"line":144,"address":[53319191],"length":1,"stats":{"Line":33}},{"line":145,"address":[54864027,54864133,54863968],"length":1,"stats":{"Line":42}},{"line":146,"address":[53319279],"length":1,"stats":{"Line":9}},{"line":147,"address":[53319304],"length":1,"stats":{"Line":33}},{"line":148,"address":[54864081],"length":1,"stats":{"Line":9}},{"line":149,"address":[55687650,55687514,55687570],"length":1,"stats":{"Line":44}},{"line":150,"address":[55687574],"length":1,"stats":{"Line":36}},{"line":153,"address":[53319439],"length":1,"stats":{"Line":9}},{"line":154,"address":[54864356,54864216,54864271],"length":1,"stats":{"Line":47}},{"line":155,"address":[54864275],"length":1,"stats":{"Line":38}},{"line":156,"address":[54864300],"length":1,"stats":{"Line":9}},{"line":157,"address":[53319633,53319742,53319573],"length":1,"stats":{"Line":46}},{"line":158,"address":[54864389],"length":1,"stats":{"Line":36}},{"line":161,"address":[53319662],"length":1,"stats":{"Line":11}},{"line":164,"address":[53319687],"length":1,"stats":{"Line":36}},{"line":165,"address":[53319712,53319927,53319771],"length":1,"stats":{"Line":47}},{"line":166,"address":[54864527],"length":1,"stats":{"Line":11}},{"line":167,"address":[53319800],"length":1,"stats":{"Line":36}},{"line":168,"address":[55687985],"length":1,"stats":{"Line":11}},{"line":169,"address":[54864602],"length":1,"stats":{"Line":36}},{"line":170,"address":[53319875],"length":1,"stats":{"Line":11}},{"line":171,"address":[55688196,55688116,55688060],"length":1,"stats":{"Line":47}},{"line":172,"address":[55688120],"length":1,"stats":{"Line":36}},{"line":177,"address":[55688145],"length":1,"stats":{"Line":11}},{"line":178,"address":[54864817,54864872,54864762],"length":1,"stats":{"Line":47}},{"line":179,"address":[53320069],"length":1,"stats":{"Line":36}},{"line":180,"address":[54864901,54864982,54864846],"length":1,"stats":{"Line":47}},{"line":181,"address":[53320153],"length":1,"stats":{"Line":11}},{"line":184,"address":[55688338],"length":1,"stats":{"Line":36}},{"line":185,"address":[53320340,53320259,53320203],"length":1,"stats":{"Line":47}},{"line":186,"address":[55688423],"length":1,"stats":{"Line":11}},{"line":187,"address":[54865040],"length":1,"stats":{"Line":37}},{"line":188,"address":[55688529,55688473,55688613],"length":1,"stats":{"Line":48}},{"line":189,"address":[54865125],"length":1,"stats":{"Line":11}},{"line":192,"address":[53320398],"length":1,"stats":{"Line":37}},{"line":193,"address":[54865234,54865175,54865340],"length":1,"stats":{"Line":48}},{"line":194,"address":[53320486],"length":1,"stats":{"Line":11}},{"line":195,"address":[54865263],"length":1,"stats":{"Line":37}},{"line":196,"address":[54865288],"length":1,"stats":{"Line":11}},{"line":197,"address":[53320697,53320561,53320617],"length":1,"stats":{"Line":48}},{"line":198,"address":[55688781],"length":1,"stats":{"Line":37}},{"line":201,"address":[53320646],"length":1,"stats":{"Line":11}},{"line":202,"address":[54865423,54865478,54865533],"length":1,"stats":{"Line":48}},{"line":203,"address":[53320730],"length":1,"stats":{"Line":37}},{"line":204,"address":[55688970,55688915,55689051],"length":1,"stats":{"Line":48}},{"line":205,"address":[54865566],"length":1,"stats":{"Line":11}},{"line":208,"address":[53320839],"length":1,"stats":{"Line":37}},{"line":209,"address":[54865672,54865753,54865616],"length":1,"stats":{"Line":48}},{"line":210,"address":[54865676],"length":1,"stats":{"Line":11}},{"line":211,"address":[53320949],"length":1,"stats":{"Line":37}},{"line":212,"address":[54865726,54865862,54865782],"length":1,"stats":{"Line":48}},{"line":213,"address":[55689194],"length":1,"stats":{"Line":11}},{"line":216,"address":[53321059],"length":1,"stats":{"Line":37}},{"line":217,"address":[54865836,54865891,54865972],"length":1,"stats":{"Line":48}},{"line":218,"address":[53321143],"length":1,"stats":{"Line":11}},{"line":221,"address":[53321168],"length":1,"stats":{"Line":36}},{"line":222,"address":[55689493,55689409,55689353],"length":1,"stats":{"Line":48}},{"line":223,"address":[54866005],"length":1,"stats":{"Line":12}},{"line":226,"address":[53321278],"length":1,"stats":{"Line":36}},{"line":227,"address":[55689522,55689463,55689628],"length":1,"stats":{"Line":48}},{"line":228,"address":[55689526],"length":1,"stats":{"Line":12}},{"line":229,"address":[53321391],"length":1,"stats":{"Line":36}},{"line":230,"address":[54866168],"length":1,"stats":{"Line":12}},{"line":231,"address":[53321441,53321497,53321577],"length":1,"stats":{"Line":48}},{"line":232,"address":[53321501],"length":1,"stats":{"Line":36}},{"line":235,"address":[54866278],"length":1,"stats":{"Line":12}},{"line":236,"address":[55689847,55689711,55689766],"length":1,"stats":{"Line":48}},{"line":237,"address":[55689770],"length":1,"stats":{"Line":36}},{"line":238,"address":[53321635],"length":1,"stats":{"Line":12}},{"line":239,"address":[53321660,53321800,53321716],"length":1,"stats":{"Line":48}},{"line":240,"address":[55689880],"length":1,"stats":{"Line":36}},{"line":243,"address":[54866497],"length":1,"stats":{"Line":12}},{"line":244,"address":[55689989,55690099,55689930],"length":1,"stats":{"Line":48}},{"line":245,"address":[55689993],"length":1,"stats":{"Line":36}},{"line":246,"address":[53321858],"length":1,"stats":{"Line":12}},{"line":247,"address":[53321883],"length":1,"stats":{"Line":34}},{"line":248,"address":[55690128,55690287,55690068],"length":1,"stats":{"Line":48}},{"line":249,"address":[55690132],"length":1,"stats":{"Line":14}},{"line":252,"address":[54866749],"length":1,"stats":{"Line":34}},{"line":255,"address":[54866774],"length":1,"stats":{"Line":14}},{"line":258,"address":[55690207],"length":1,"stats":{"Line":34}},{"line":261,"address":[53322072],"length":1,"stats":{"Line":14}},{"line":262,"address":[55690316,55690421,55690257],"length":1,"stats":{"Line":48}},{"line":263,"address":[54866912],"length":1,"stats":{"Line":33}},{"line":264,"address":[54866937],"length":1,"stats":{"Line":15}},{"line":265,"address":[55690370],"length":1,"stats":{"Line":33}},{"line":266,"address":[53322290,53322368,53322235],"length":1,"stats":{"Line":48}},{"line":267,"address":[53322294],"length":1,"stats":{"Line":15}},{"line":268,"address":[54867071],"length":1,"stats":{"Line":33}},{"line":269,"address":[55690554,55690632,55690504],"length":1,"stats":{"Line":48}},{"line":270,"address":[55690558],"length":1,"stats":{"Line":15}},{"line":271,"address":[55690583],"length":1,"stats":{"Line":33}},{"line":272,"address":[55690608,55690739,55690658],"length":1,"stats":{"Line":48}},{"line":273,"address":[53322502],"length":1,"stats":{"Line":15}},{"line":276,"address":[53322527],"length":1,"stats":{"Line":33}},{"line":277,"address":[55690712,55690765,55691017],"length":1,"stats":{"Line":48}},{"line":278,"address":[54867361],"length":1,"stats":{"Line":15}},{"line":279,"address":[55690794],"length":1,"stats":{"Line":33}},{"line":280,"address":[53322659],"length":1,"stats":{"Line":15}},{"line":281,"address":[55690844],"length":1,"stats":{"Line":33}},{"line":282,"address":[55690869],"length":1,"stats":{"Line":15}},{"line":283,"address":[55690894],"length":1,"stats":{"Line":33}},{"line":284,"address":[53322759],"length":1,"stats":{"Line":15}},{"line":285,"address":[55690944],"length":1,"stats":{"Line":23}},{"line":286,"address":[55690969],"length":1,"stats":{"Line":25}},{"line":287,"address":[55690994,55691043,55691096],"length":1,"stats":{"Line":48}},{"line":288,"address":[55691047],"length":1,"stats":{"Line":23}},{"line":289,"address":[54867714,54867664,54867766],"length":1,"stats":{"Line":48}},{"line":290,"address":[54867718],"length":1,"stats":{"Line":24}},{"line":291,"address":[53323093,53323040,53322991],"length":1,"stats":{"Line":48}},{"line":292,"address":[53323044],"length":1,"stats":{"Line":18}},{"line":293,"address":[55691361,55691229,55691279],"length":1,"stats":{"Line":48}},{"line":294,"address":[54867875],"length":1,"stats":{"Line":30}},{"line":295,"address":[54867900],"length":1,"stats":{"Line":18}},{"line":296,"address":[53323354,53323173,53323227],"length":1,"stats":{"Line":48}},{"line":297,"address":[54867983],"length":1,"stats":{"Line":30}},{"line":300,"address":[53323256],"length":1,"stats":{"Line":18}},{"line":301,"address":[55691441],"length":1,"stats":{"Line":30}},{"line":302,"address":[55691466],"length":1,"stats":{"Line":18}},{"line":303,"address":[53323331,53323432,53323380],"length":1,"stats":{"Line":48}},{"line":304,"address":[54868136],"length":1,"stats":{"Line":30}},{"line":305,"address":[53323409,53323458,53323536],"length":1,"stats":{"Line":48}},{"line":306,"address":[54868214],"length":1,"stats":{"Line":18}},{"line":307,"address":[53323487],"length":1,"stats":{"Line":30}},{"line":308,"address":[54868392,54868314,54868264],"length":1,"stats":{"Line":48}},{"line":309,"address":[54868318],"length":1,"stats":{"Line":18}},{"line":310,"address":[54868343],"length":1,"stats":{"Line":30}},{"line":311,"address":[54868495,54868418,54868368],"length":1,"stats":{"Line":47}},{"line":312,"address":[53323670],"length":1,"stats":{"Line":19}},{"line":313,"address":[54868447],"length":1,"stats":{"Line":29}},{"line":314,"address":[55691929,55691880,55692011],"length":1,"stats":{"Line":48}},{"line":315,"address":[54868525],"length":1,"stats":{"Line":18}},{"line":316,"address":[54868550],"length":1,"stats":{"Line":30}},{"line":317,"address":[55692037,55692265,55691983],"length":1,"stats":{"Line":48}},{"line":318,"address":[54868633],"length":1,"stats":{"Line":18}},{"line":321,"address":[54868658],"length":1,"stats":{"Line":30}},{"line":322,"address":[54868683],"length":1,"stats":{"Line":18}},{"line":323,"address":[55692116],"length":1,"stats":{"Line":30}},{"line":324,"address":[53323981],"length":1,"stats":{"Line":18}},{"line":325,"address":[55692166],"length":1,"stats":{"Line":30}},{"line":326,"address":[55692191],"length":1,"stats":{"Line":18}},{"line":327,"address":[55692216],"length":1,"stats":{"Line":30}},{"line":329,"address":[53324081,53324131,53324229],"length":1,"stats":{"Line":48}},{"line":330,"address":[55692295],"length":1,"stats":{"Line":18}},{"line":331,"address":[53324160],"length":1,"stats":{"Line":30}},{"line":334,"address":[53324182],"length":1,"stats":{"Line":18}},{"line":335,"address":[53324207],"length":1,"stats":{"Line":30}},{"line":338,"address":[55672969,55672975,55669168],"length":1,"stats":{"Line":30}},{"line":339,"address":[54845845],"length":1,"stats":{"Line":18}},{"line":340,"address":[53301024],"length":1,"stats":{"Line":6}},{"line":343,"address":[54845971],"length":1,"stats":{"Line":2}},{"line":344,"address":[54845976,54849184],"length":1,"stats":{"Line":6}},{"line":345,"address":[53304392],"length":1,"stats":{"Line":2}},{"line":346,"address":[54849344,54849442],"length":1,"stats":{"Line":6}},{"line":348,"address":[55672820],"length":1,"stats":{"Line":2}},{"line":350,"address":[54849506],"length":1,"stats":{"Line":3}},{"line":353,"address":[53301257],"length":1,"stats":{"Line":3}},{"line":354,"address":[54846189],"length":1,"stats":{"Line":5}},{"line":355,"address":[55672988,55669618],"length":1,"stats":{"Line":3}},{"line":356,"address":[55673052],"length":1,"stats":{"Line":2}},{"line":359,"address":[55669705],"length":1,"stats":{"Line":2}},{"line":360,"address":[55669725],"length":1,"stats":{"Line":2}},{"line":361,"address":[55673129,55669750,55673102],"length":1,"stats":{"Line":4}},{"line":362,"address":[53304846,53304809],"length":1,"stats":{"Line":4}},{"line":363,"address":[54849814,54849969],"length":1,"stats":{"Line":2}},{"line":365,"address":[54849956,54849889],"length":1,"stats":{"Line":2}},{"line":366,"address":[53305044],"length":1,"stats":{"Line":2}},{"line":369,"address":[53301526],"length":1,"stats":{"Line":3}},{"line":375,"address":[53301546],"length":1,"stats":{"Line":3}},{"line":376,"address":[55669878],"length":1,"stats":{"Line":3}},{"line":377,"address":[53301599,53305139],"length":1,"stats":{"Line":3}},{"line":378,"address":[55673499],"length":1,"stats":{"Line":3}},{"line":379,"address":[54850127],"length":1,"stats":{"Line":3}},{"line":380,"address":[55673763],"length":1,"stats":{"Line":3}},{"line":381,"address":[54850409],"length":1,"stats":{"Line":2}},{"line":382,"address":[55673906,55673845],"length":1,"stats":{"Line":4}},{"line":384,"address":[53305586],"length":1,"stats":{"Line":2}},{"line":387,"address":[53301687],"length":1,"stats":{"Line":3}},{"line":390,"address":[55670048],"length":1,"stats":{"Line":3}},{"line":391,"address":[54846653],"length":1,"stats":{"Line":3}},{"line":392,"address":[53305816,53301783],"length":1,"stats":{"Line":3}},{"line":393,"address":[54850767],"length":1,"stats":{"Line":4}},{"line":394,"address":[54850799],"length":1,"stats":{"Line":4}},{"line":395,"address":[55674435],"length":1,"stats":{"Line":4}},{"line":398,"address":[54846795],"length":1,"stats":{"Line":2}},{"line":404,"address":[54846838],"length":1,"stats":{"Line":2}},{"line":406,"address":[54846843,54851053],"length":1,"stats":{"Line":2}},{"line":407,"address":[54851165],"length":1,"stats":{"Line":2}},{"line":408,"address":[55674698],"length":1,"stats":{"Line":2}},{"line":409,"address":[55674730],"length":1,"stats":{"Line":2}},{"line":410,"address":[55674962],"length":1,"stats":{"Line":2}},{"line":413,"address":[54847036],"length":1,"stats":{"Line":3}},{"line":416,"address":[54847094],"length":1,"stats":{"Line":3}},{"line":417,"address":[54851580,54847107],"length":1,"stats":{"Line":3}},{"line":419,"address":[53306922,53306835],"length":1,"stats":{"Line":4}},{"line":420,"address":[53307284,53307205],"length":1,"stats":{"Line":2}},{"line":421,"address":[53307320,53307257],"length":1,"stats":{"Line":4}},{"line":422,"address":[54852310,54852445],"length":1,"stats":{"Line":5}},{"line":424,"address":[55675793,55675729],"length":1,"stats":{"Line":3}},{"line":425,"address":[55675774],"length":1,"stats":{"Line":4}},{"line":428,"address":[55670634],"length":1,"stats":{"Line":2}},{"line":429,"address":[53302339],"length":1,"stats":{"Line":2}},{"line":430,"address":[55670667],"length":1,"stats":{"Line":3}},{"line":431,"address":[55670699,55676017],"length":1,"stats":{"Line":6}},{"line":432,"address":[53307761],"length":1,"stats":{"Line":2}},{"line":433,"address":[55676058,55676157],"length":1,"stats":{"Line":3}},{"line":435,"address":[55676128],"length":1,"stats":{"Line":3}},{"line":438,"address":[55670757],"length":1,"stats":{"Line":4}},{"line":439,"address":[55670777],"length":1,"stats":{"Line":3}},{"line":440,"address":[54847382],"length":1,"stats":{"Line":4}},{"line":441,"address":[55676216,55670830],"length":1,"stats":{"Line":4}},{"line":442,"address":[53308022],"length":1,"stats":{"Line":5}},{"line":446,"address":[54847501],"length":1,"stats":{"Line":2}},{"line":450,"address":[54847531],"length":1,"stats":{"Line":2}},{"line":453,"address":[55671015],"length":1,"stats":{"Line":3}},{"line":459,"address":[55671035],"length":1,"stats":{"Line":3}},{"line":460,"address":[53308051,53302726],"length":1,"stats":{"Line":3}},{"line":461,"address":[55676416],"length":1,"stats":{"Line":3}},{"line":462,"address":[55676468,55676712],"length":1,"stats":{"Line":2}},{"line":464,"address":[54853246],"length":1,"stats":{"Line":2}},{"line":465,"address":[53308421,53308576,53308604],"length":1,"stats":{"Line":6}},{"line":467,"address":[54853437,54853473],"length":1,"stats":{"Line":6}},{"line":468,"address":[53308735],"length":1,"stats":{"Line":3}},{"line":469,"address":[53308847],"length":1,"stats":{"Line":3}},{"line":470,"address":[53308862],"length":1,"stats":{"Line":3}},{"line":471,"address":[53308885],"length":1,"stats":{"Line":3}},{"line":475,"address":[55677164],"length":1,"stats":{"Line":3}},{"line":476,"address":[54853819,54853765],"length":1,"stats":{"Line":5}},{"line":477,"address":[55677224],"length":1,"stats":{"Line":2}},{"line":479,"address":[53308935],"length":1,"stats":{"Line":2}},{"line":481,"address":[55677259],"length":1,"stats":{"Line":2}},{"line":483,"address":[55677484,55677571],"length":1,"stats":{"Line":5}},{"line":484,"address":[53309599,53309678],"length":1,"stats":{"Line":2}},{"line":485,"address":[53309715,53309651],"length":1,"stats":{"Line":5}},{"line":486,"address":[54854681,54854816],"length":1,"stats":{"Line":4}},{"line":488,"address":[55678163,55678099],"length":1,"stats":{"Line":3}},{"line":489,"address":[53309897],"length":1,"stats":{"Line":2}},{"line":493,"address":[53308818,53308751],"length":1,"stats":{"Line":4}},{"line":494,"address":[55677055],"length":1,"stats":{"Line":2}},{"line":497,"address":[54847825],"length":1,"stats":{"Line":2}},{"line":499,"address":[54847860],"length":1,"stats":{"Line":2}},{"line":500,"address":[53302959,53310132],"length":1,"stats":{"Line":2}},{"line":501,"address":[55678609,55678475],"length":1,"stats":{"Line":2}},{"line":502,"address":[54855116],"length":1,"stats":{"Line":2}},{"line":504,"address":[55678532,55678622],"length":1,"stats":{"Line":2}},{"line":505,"address":[54855521,54855597],"length":1,"stats":{"Line":2}},{"line":506,"address":[53310774,53310737],"length":1,"stats":{"Line":4}},{"line":507,"address":[53311271,53310863],"length":1,"stats":{"Line":2}},{"line":509,"address":[54855942,54856039],"length":1,"stats":{"Line":2}},{"line":510,"address":[53311151],"length":1,"stats":{"Line":2}},{"line":511,"address":[53311258,53311232,53311176],"length":1,"stats":{"Line":4}},{"line":512,"address":[55679474],"length":1,"stats":{"Line":2}},{"line":515,"address":[55671458],"length":1,"stats":{"Line":2}},{"line":516,"address":[55671501],"length":1,"stats":{"Line":4}},{"line":518,"address":[54165424,54165270],"length":1,"stats":{"Line":4}},{"line":519,"address":[54165307],"length":1,"stats":{"Line":2}},{"line":520,"address":[54640827],"length":1,"stats":{"Line":2}},{"line":521,"address":[53266603],"length":1,"stats":{"Line":2}},{"line":522,"address":[54640990],"length":1,"stats":{"Line":2}},{"line":524,"address":[55679647,55671558],"length":1,"stats":{"Line":4}},{"line":527,"address":[53303329],"length":1,"stats":{"Line":2}},{"line":533,"address":[55671670],"length":1,"stats":{"Line":2}},{"line":534,"address":[53303377],"length":1,"stats":{"Line":2}},{"line":535,"address":[54848311,54856540],"length":1,"stats":{"Line":4}},{"line":536,"address":[55680137],"length":1,"stats":{"Line":2}},{"line":537,"address":[53312179],"length":1,"stats":{"Line":2}},{"line":538,"address":[55680647],"length":1,"stats":{"Line":2}},{"line":541,"address":[53303456],"length":1,"stats":{"Line":4}},{"line":544,"address":[54848401],"length":1,"stats":{"Line":5}},{"line":545,"address":[53312451,53312462,53303629],"length":1,"stats":{"Line":9}},{"line":547,"address":[53312455],"length":1,"stats":{"Line":4}},{"line":548,"address":[54857359],"length":1,"stats":{"Line":5}},{"line":549,"address":[53312810,53315178],"length":1,"stats":{"Line":4}},{"line":550,"address":[54857805],"length":1,"stats":{"Line":5}},{"line":552,"address":[53313015],"length":1,"stats":{"Line":5}},{"line":553,"address":[54858153],"length":1,"stats":{"Line":6}},{"line":554,"address":[53313649],"length":1,"stats":{"Line":5}},{"line":555,"address":[54858523,54858463],"length":1,"stats":{"Line":12}},{"line":557,"address":[54858497,54858556],"length":1,"stats":{"Line":9}},{"line":559,"address":[53315173,53313733,53313798],"length":1,"stats":{"Line":12}},{"line":560,"address":[55682163],"length":1,"stats":{"Line":2}},{"line":561,"address":[55682197,55682257],"length":1,"stats":{"Line":2}},{"line":564,"address":[53314092,53314055],"length":1,"stats":{"Line":7}},{"line":565,"address":[55682437,55682306],"length":1,"stats":{"Line":4}},{"line":569,"address":[54858955],"length":1,"stats":{"Line":3}},{"line":570,"address":[55682704],"length":1,"stats":{"Line":0}},{"line":571,"address":[55682716,55682777],"length":1,"stats":{"Line":0}},{"line":572,"address":[53314749,53314703],"length":1,"stats":{"Line":0}},{"line":576,"address":[55683121,55682757,55683338],"length":1,"stats":{"Line":8}},{"line":580,"address":[54859502,54859876,54859865],"length":1,"stats":{"Line":10}},{"line":581,"address":[53315101],"length":1,"stats":{"Line":5}},{"line":582,"address":[53315137],"length":1,"stats":{"Line":6}},{"line":585,"address":[54858171],"length":1,"stats":{"Line":2}},{"line":586,"address":[54858206],"length":1,"stats":{"Line":2}},{"line":587,"address":[55681724,55681661],"length":1,"stats":{"Line":2}},{"line":588,"address":[54858303],"length":1,"stats":{"Line":5}},{"line":589,"address":[54858351,54858415],"length":1,"stats":{"Line":4}},{"line":590,"address":[54858396,54858436],"length":1,"stats":{"Line":11}},{"line":594,"address":[53303678],"length":1,"stats":{"Line":2}},{"line":597,"address":[54848608],"length":1,"stats":{"Line":2}},{"line":598,"address":[53303719],"length":1,"stats":{"Line":2}},{"line":599,"address":[53303759,53315183],"length":1,"stats":{"Line":2}},{"line":600,"address":[54860018],"length":1,"stats":{"Line":2}},{"line":601,"address":[54860138,54860050],"length":1,"stats":{"Line":2}},{"line":602,"address":[53315321],"length":1,"stats":{"Line":2}},{"line":603,"address":[53315334,53315400],"length":1,"stats":{"Line":4}},{"line":604,"address":[53315408],"length":1,"stats":{"Line":2}},{"line":605,"address":[55683617,55683708],"length":1,"stats":{"Line":2}},{"line":606,"address":[54860373],"length":1,"stats":{"Line":2}},{"line":608,"address":[53315521],"length":1,"stats":{"Line":2}},{"line":610,"address":[54860405,54860466],"length":1,"stats":{"Line":2}},{"line":611,"address":[54860444],"length":1,"stats":{"Line":2}},{"line":614,"address":[55672152],"length":1,"stats":{"Line":4}},{"line":618,"address":[53303890],"length":1,"stats":{"Line":5}},{"line":619,"address":[55672208],"length":1,"stats":{"Line":4}},{"line":621,"address":[54848836,54860479],"length":1,"stats":{"Line":9}},{"line":622,"address":[54860576],"length":1,"stats":{"Line":5}},{"line":623,"address":[54860843],"length":1,"stats":{"Line":4}},{"line":625,"address":[54860802],"length":1,"stats":{"Line":4}},{"line":626,"address":[55684276],"length":1,"stats":{"Line":3}},{"line":627,"address":[55684334],"length":1,"stats":{"Line":2}},{"line":628,"address":[54860949],"length":1,"stats":{"Line":2}},{"line":629,"address":[53316216],"length":1,"stats":{"Line":2}},{"line":631,"address":[53316257],"length":1,"stats":{"Line":2}},{"line":635,"address":[53315835],"length":1,"stats":{"Line":4}},{"line":636,"address":[53315875],"length":1,"stats":{"Line":4}},{"line":637,"address":[53316006],"length":1,"stats":{"Line":4}},{"line":640,"address":[55672354],"length":1,"stats":{"Line":0}},{"line":642,"address":[55672392],"length":1,"stats":{"Line":0}},{"line":643,"address":[55684451],"length":1,"stats":{"Line":0}},{"line":644,"address":[54861061],"length":1,"stats":{"Line":0}},{"line":645,"address":[55684492],"length":1,"stats":{"Line":0}},{"line":646,"address":[54861119],"length":1,"stats":{"Line":0}},{"line":647,"address":[55684550],"length":1,"stats":{"Line":0}},{"line":648,"address":[55684579],"length":1,"stats":{"Line":0}},{"line":650,"address":[55684614],"length":1,"stats":{"Line":0}},{"line":651,"address":[53316455,53316665],"length":1,"stats":{"Line":0}},{"line":655,"address":[53316709],"length":1,"stats":{"Line":0}},{"line":656,"address":[55685002],"length":1,"stats":{"Line":0}},{"line":659,"address":[54849040],"length":1,"stats":{"Line":0}},{"line":660,"address":[54849060],"length":1,"stats":{"Line":0}},{"line":661,"address":[55672477],"length":1,"stats":{"Line":0}},{"line":662,"address":[54861629,54849113],"length":1,"stats":{"Line":0}},{"line":663,"address":[54861696],"length":1,"stats":{"Line":0}},{"line":667,"address":[53304662],"length":1,"stats":{"Line":4}},{"line":670,"address":[53327920],"length":1,"stats":{"Line":4}},{"line":671,"address":[55696091],"length":1,"stats":{"Line":7}},{"line":672,"address":[54872740],"length":1,"stats":{"Line":3}},{"line":673,"address":[55696165],"length":1,"stats":{"Line":3}},{"line":674,"address":[53328186,53328066,53328208],"length":1,"stats":{"Line":10}},{"line":675,"address":[53328190,53328221],"length":1,"stats":{"Line":12}},{"line":676,"address":[54873000,54873153],"length":1,"stats":{"Line":6}},{"line":678,"address":[54873126,54873063],"length":1,"stats":{"Line":4}},{"line":679,"address":[54873097],"length":1,"stats":{"Line":5}},{"line":680,"address":[53328391],"length":1,"stats":{"Line":5}},{"line":683,"address":[53328099,53328499],"length":1,"stats":{"Line":0}},{"line":686,"address":[54873144],"length":1,"stats":{"Line":4}},{"line":689,"address":[53326795,53325504,53326789],"length":1,"stats":{"Line":6}},{"line":690,"address":[53325575],"length":1,"stats":{"Line":6}},{"line":691,"address":[55693764],"length":1,"stats":{"Line":3}},{"line":692,"address":[54870376,54870855],"length":1,"stats":{"Line":3}},{"line":693,"address":[54870962],"length":1,"stats":{"Line":3}},{"line":694,"address":[53326297,53326676],"length":1,"stats":{"Line":2}},{"line":695,"address":[53326808,53326376],"length":1,"stats":{"Line":2}},{"line":696,"address":[53326897,53326443],"length":1,"stats":{"Line":2}},{"line":697,"address":[54871344,54871721],"length":1,"stats":{"Line":2}},{"line":698,"address":[53326650],"length":1,"stats":{"Line":2}},{"line":702,"address":[53325825],"length":1,"stats":{"Line":2}},{"line":705,"address":[55694006],"length":1,"stats":{"Line":3}},{"line":707,"address":[54870635],"length":1,"stats":{"Line":2}},{"line":708,"address":[54870678,54871818],"length":1,"stats":{"Line":2}},{"line":709,"address":[54871922],"length":1,"stats":{"Line":2}},{"line":710,"address":[53327404],"length":1,"stats":{"Line":2}},{"line":711,"address":[53327652],"length":1,"stats":{"Line":2}},{"line":712,"address":[54872599],"length":1,"stats":{"Line":2}},{"line":715,"address":[53326777],"length":1,"stats":{"Line":2}},{"line":719,"address":[54870222,54869008,54870115],"length":1,"stats":{"Line":3}},{"line":720,"address":[53324312],"length":1,"stats":{"Line":3}},{"line":721,"address":[54869164,54869096],"length":1,"stats":{"Line":6}},{"line":722,"address":[55692877,55692673,55693514],"length":1,"stats":{"Line":7}},{"line":724,"address":[55692944,55692893],"length":1,"stats":{"Line":4}},{"line":725,"address":[53324812,53324860],"length":1,"stats":{"Line":4}},{"line":726,"address":[53325018],"length":1,"stats":{"Line":2}},{"line":727,"address":[55693313,55693226],"length":1,"stats":{"Line":4}},{"line":729,"address":[54870186,54869501],"length":1,"stats":{"Line":6}},{"line":732,"address":[53324575],"length":1,"stats":{"Line":2}},{"line":735,"address":[53287772,53284672,53287778],"length":1,"stats":{"Line":5}},{"line":736,"address":[55653205],"length":1,"stats":{"Line":7}},{"line":737,"address":[53284830],"length":1,"stats":{"Line":2}},{"line":738,"address":[54832604,54829861],"length":1,"stats":{"Line":10}},{"line":739,"address":[55655789,55656085],"length":1,"stats":{"Line":3}},{"line":740,"address":[54832785,54832428],"length":1,"stats":{"Line":0}},{"line":741,"address":[54832503],"length":1,"stats":{"Line":2}},{"line":743,"address":[54832988,54832570,54832511,54833116,54833244],"length":1,"stats":{"Line":11}},{"line":749,"address":[53288613],"length":1,"stats":{"Line":3}},{"line":751,"address":[53288936],"length":1,"stats":{"Line":4}},{"line":752,"address":[53288899],"length":1,"stats":{"Line":3}},{"line":753,"address":[53287633],"length":1,"stats":{"Line":0}},{"line":757,"address":[53284925],"length":1,"stats":{"Line":3}},{"line":758,"address":[54829945],"length":1,"stats":{"Line":5}},{"line":761,"address":[55653426],"length":1,"stats":{"Line":2}},{"line":762,"address":[53285013,53288965],"length":1,"stats":{"Line":2}},{"line":763,"address":[54834063],"length":1,"stats":{"Line":2}},{"line":764,"address":[55657708],"length":1,"stats":{"Line":2}},{"line":767,"address":[55653692],"length":1,"stats":{"Line":4}},{"line":773,"address":[53285264],"length":1,"stats":{"Line":4}},{"line":774,"address":[54834338,54830297],"length":1,"stats":{"Line":10}},{"line":775,"address":[53289551],"length":1,"stats":{"Line":3}},{"line":776,"address":[53289586],"length":1,"stats":{"Line":2}},{"line":777,"address":[55658024],"length":1,"stats":{"Line":0}},{"line":778,"address":[54834640],"length":1,"stats":{"Line":2}},{"line":779,"address":[53289682],"length":1,"stats":{"Line":0}},{"line":780,"address":[55658120],"length":1,"stats":{"Line":0}},{"line":781,"address":[54834736],"length":1,"stats":{"Line":0}},{"line":782,"address":[54834768],"length":1,"stats":{"Line":0}},{"line":783,"address":[53289807],"length":1,"stats":{"Line":2}},{"line":784,"address":[54834826],"length":1,"stats":{"Line":0}},{"line":785,"address":[54834855],"length":1,"stats":{"Line":5}},{"line":786,"address":[53289894],"length":1,"stats":{"Line":0}},{"line":788,"address":[55658335],"length":1,"stats":{"Line":3}},{"line":789,"address":[54834955],"length":1,"stats":{"Line":6}},{"line":790,"address":[53290199],"length":1,"stats":{"Line":3}},{"line":793,"address":[53285366],"length":1,"stats":{"Line":2}},{"line":797,"address":[53290299],"length":1,"stats":{"Line":2}},{"line":798,"address":[55658735],"length":1,"stats":{"Line":2}},{"line":799,"address":[53290565],"length":1,"stats":{"Line":2}},{"line":802,"address":[53290229],"length":1,"stats":{"Line":2}},{"line":803,"address":[55658665,55658997],"length":1,"stats":{"Line":4}},{"line":804,"address":[55659200],"length":1,"stats":{"Line":2}},{"line":808,"address":[53285407],"length":1,"stats":{"Line":3}},{"line":814,"address":[53285465],"length":1,"stats":{"Line":3}},{"line":815,"address":[55659230,55653938],"length":1,"stats":{"Line":6}},{"line":816,"address":[55659433],"length":1,"stats":{"Line":3}},{"line":817,"address":[53291079],"length":1,"stats":{"Line":2}},{"line":818,"address":[55659448],"length":1,"stats":{"Line":2}},{"line":820,"address":[53291114],"length":1,"stats":{"Line":3}},{"line":821,"address":[55659548],"length":1,"stats":{"Line":3}},{"line":822,"address":[54836364],"length":1,"stats":{"Line":3}},{"line":825,"address":[53285529],"length":1,"stats":{"Line":2}},{"line":829,"address":[54830583,54836394],"length":1,"stats":{"Line":4}},{"line":830,"address":[54626208,54626213],"length":1,"stats":{"Line":6}},{"line":831,"address":[54836622],"length":1,"stats":{"Line":0}},{"line":835,"address":[55660007,55660072],"length":1,"stats":{"Line":4}},{"line":836,"address":[53291882],"length":1,"stats":{"Line":2}},{"line":837,"address":[55660401,55660300],"length":1,"stats":{"Line":4}},{"line":838,"address":[54837085],"length":1,"stats":{"Line":2}},{"line":839,"address":[55660630],"length":1,"stats":{"Line":2}},{"line":841,"address":[55660656,55660555],"length":1,"stats":{"Line":2}},{"line":843,"address":[54837101],"length":1,"stats":{"Line":2}},{"line":846,"address":[55654062],"length":1,"stats":{"Line":2}},{"line":849,"address":[53285652,53292337],"length":1,"stats":{"Line":4}},{"line":850,"address":[55660926],"length":1,"stats":{"Line":2}},{"line":851,"address":[55660951],"length":1,"stats":{"Line":2}},{"line":854,"address":[55654162],"length":1,"stats":{"Line":2}},{"line":860,"address":[53285742],"length":1,"stats":{"Line":3}},{"line":861,"address":[54830775,54837576],"length":1,"stats":{"Line":5}},{"line":862,"address":[53292813],"length":1,"stats":{"Line":2}},{"line":863,"address":[55661220],"length":1,"stats":{"Line":3}},{"line":864,"address":[53292874],"length":1,"stats":{"Line":2}},{"line":865,"address":[55661288],"length":1,"stats":{"Line":2}},{"line":866,"address":[54838104],"length":1,"stats":{"Line":2}},{"line":869,"address":[55654254],"length":1,"stats":{"Line":2}},{"line":870,"address":[55661550,55654292],"length":1,"stats":{"Line":4}},{"line":871,"address":[54838337],"length":1,"stats":{"Line":2}},{"line":872,"address":[55661778],"length":1,"stats":{"Line":2}},{"line":873,"address":[55662010],"length":1,"stats":{"Line":2}},{"line":876,"address":[54830899],"length":1,"stats":{"Line":2}},{"line":882,"address":[55654397],"length":1,"stats":{"Line":2}},{"line":883,"address":[55654422,55662040],"length":1,"stats":{"Line":4}},{"line":884,"address":[54838827],"length":1,"stats":{"Line":2}},{"line":885,"address":[55662268],"length":1,"stats":{"Line":2}},{"line":886,"address":[55662500],"length":1,"stats":{"Line":2}},{"line":887,"address":[55662532],"length":1,"stats":{"Line":2}},{"line":888,"address":[54839348],"length":1,"stats":{"Line":2}},{"line":891,"address":[53286059],"length":1,"stats":{"Line":4}},{"line":899,"address":[54831110],"length":1,"stats":{"Line":4}},{"line":901,"address":[53294455],"length":1,"stats":{"Line":2}},{"line":902,"address":[54839441,54840345],"length":1,"stats":{"Line":4}},{"line":903,"address":[55663964],"length":1,"stats":{"Line":2}},{"line":904,"address":[54840580],"length":1,"stats":{"Line":2}},{"line":905,"address":[54840622,54840684],"length":1,"stats":{"Line":0}},{"line":907,"address":[53295704],"length":1,"stats":{"Line":2}},{"line":909,"address":[53295937],"length":1,"stats":{"Line":2}},{"line":910,"address":[53295969],"length":1,"stats":{"Line":2}},{"line":911,"address":[55664433,55664371],"length":1,"stats":{"Line":0}},{"line":913,"address":[55664399],"length":1,"stats":{"Line":2}},{"line":915,"address":[55664630],"length":1,"stats":{"Line":2}},{"line":916,"address":[54841246],"length":1,"stats":{"Line":2}},{"line":917,"address":[54841343,54841288],"length":1,"stats":{"Line":4}},{"line":919,"address":[55664732],"length":1,"stats":{"Line":2}},{"line":922,"address":[55662895,55662794],"length":1,"stats":{"Line":8}},{"line":923,"address":[53294730],"length":1,"stats":{"Line":4}},{"line":924,"address":[55663130],"length":1,"stats":{"Line":4}},{"line":925,"address":[54839811,54839756],"length":1,"stats":{"Line":8}},{"line":927,"address":[53294832],"length":1,"stats":{"Line":0}},{"line":929,"address":[55663424],"length":1,"stats":{"Line":4}},{"line":930,"address":[53295108],"length":1,"stats":{"Line":2}},{"line":931,"address":[53295195,53295140],"length":1,"stats":{"Line":4}},{"line":933,"address":[53295168],"length":1,"stats":{"Line":2}},{"line":937,"address":[54831144],"length":1,"stats":{"Line":3}},{"line":938,"address":[55654604],"length":1,"stats":{"Line":4}},{"line":939,"address":[55654629,55664951],"length":1,"stats":{"Line":7}},{"line":940,"address":[54841632],"length":1,"stats":{"Line":2}},{"line":941,"address":[53296820],"length":1,"stats":{"Line":2}},{"line":943,"address":[54841683,54841784],"length":1,"stats":{"Line":5}},{"line":945,"address":[54841648],"length":1,"stats":{"Line":5}},{"line":948,"address":[53286308],"length":1,"stats":{"Line":2}},{"line":949,"address":[55654771],"length":1,"stats":{"Line":2}},{"line":950,"address":[54831356,54841843],"length":1,"stats":{"Line":4}},{"line":951,"address":[53297029],"length":1,"stats":{"Line":2}},{"line":952,"address":[53297153],"length":1,"stats":{"Line":2}},{"line":954,"address":[54842114,54842016],"length":1,"stats":{"Line":2}},{"line":955,"address":[53297247],"length":1,"stats":{"Line":2}},{"line":956,"address":[54842218],"length":1,"stats":{"Line":2}},{"line":958,"address":[53297045],"length":1,"stats":{"Line":2}},{"line":961,"address":[55654918],"length":1,"stats":{"Line":2}},{"line":962,"address":[55654953],"length":1,"stats":{"Line":2}},{"line":963,"address":[53286546,53297419],"length":1,"stats":{"Line":4}},{"line":964,"address":[53297624],"length":1,"stats":{"Line":2}},{"line":965,"address":[55666002],"length":1,"stats":{"Line":2}},{"line":966,"address":[53297878],"length":1,"stats":{"Line":2}},{"line":969,"address":[53286593],"length":1,"stats":{"Line":2}},{"line":970,"address":[55655044],"length":1,"stats":{"Line":2}},{"line":971,"address":[55666252,55655069],"length":1,"stats":{"Line":4}},{"line":972,"address":[55666455],"length":1,"stats":{"Line":2}},{"line":975,"address":[53286677],"length":1,"stats":{"Line":2}},{"line":976,"address":[53286720],"length":1,"stats":{"Line":2}},{"line":977,"address":[55666477,55655184],"length":1,"stats":{"Line":2}},{"line":978,"address":[55666581],"length":1,"stats":{"Line":2}},{"line":979,"address":[53298271],"length":1,"stats":{"Line":2}},{"line":983,"address":[54831836],"length":1,"stats":{"Line":2}},{"line":986,"address":[54831881],"length":1,"stats":{"Line":2}},{"line":987,"address":[55655333],"length":1,"stats":{"Line":2}},{"line":988,"address":[53298496,53286926],"length":1,"stats":{"Line":4}},{"line":989,"address":[55667039],"length":1,"stats":{"Line":2}},{"line":992,"address":[54831972],"length":1,"stats":{"Line":2}},{"line":994,"address":[55655432],"length":1,"stats":{"Line":2}},{"line":995,"address":[54832017,54843645],"length":1,"stats":{"Line":4}},{"line":996,"address":[53298797],"length":1,"stats":{"Line":2}},{"line":997,"address":[53298948],"length":1,"stats":{"Line":2}},{"line":999,"address":[54843877,54843921],"length":1,"stats":{"Line":5}},{"line":1000,"address":[54843993],"length":1,"stats":{"Line":4}},{"line":1001,"address":[53299085],"length":1,"stats":{"Line":0}},{"line":1002,"address":[54844036],"length":1,"stats":{"Line":4}},{"line":1003,"address":[53299128],"length":1,"stats":{"Line":2}},{"line":1005,"address":[55667506],"length":1,"stats":{"Line":4}},{"line":1009,"address":[54843795],"length":1,"stats":{"Line":2}},{"line":1010,"address":[55667223],"length":1,"stats":{"Line":2}},{"line":1011,"address":[53298915,53299191],"length":1,"stats":{"Line":4}},{"line":1012,"address":[55667725],"length":1,"stats":{"Line":2}},{"line":1016,"address":[55667176],"length":1,"stats":{"Line":2}},{"line":1019,"address":[55655499],"length":1,"stats":{"Line":2}},{"line":1020,"address":[54832071],"length":1,"stats":{"Line":2}},{"line":1021,"address":[55667755,55655543],"length":1,"stats":{"Line":4}},{"line":1024,"address":[55655582],"length":1,"stats":{"Line":2}},{"line":1026,"address":[53299628,53287182],"length":1,"stats":{"Line":4}},{"line":1027,"address":[55668164],"length":1,"stats":{"Line":2}},{"line":1028,"address":[54844773],"length":1,"stats":{"Line":2}},{"line":1029,"address":[53300080],"length":1,"stats":{"Line":2}},{"line":1032,"address":[55655682],"length":1,"stats":{"Line":2}},{"line":1039,"address":[54832285],"length":1,"stats":{"Line":2}},{"line":1040,"address":[55668439,55655750],"length":1,"stats":{"Line":4}},{"line":1041,"address":[54845226],"length":1,"stats":{"Line":2}},{"line":1042,"address":[55668674],"length":1,"stats":{"Line":2}},{"line":1043,"address":[54845478],"length":1,"stats":{"Line":2}},{"line":1044,"address":[54845510],"length":1,"stats":{"Line":2}},{"line":1045,"address":[53300819],"length":1,"stats":{"Line":2}},{"line":1049,"address":[55656186],"length":1,"stats":{"Line":3}},{"line":1052,"address":[55653024],"length":1,"stats":{"Line":2}},{"line":1053,"address":[55653038,55653062],"length":1,"stats":{"Line":4}},{"line":1054,"address":[54829646],"length":1,"stats":{"Line":2}},{"line":1058,"address":[54873712],"length":1,"stats":{"Line":2}},{"line":1059,"address":[53329026],"length":1,"stats":{"Line":2}},{"line":1060,"address":[54873766],"length":1,"stats":{"Line":2}},{"line":1061,"address":[53329063],"length":1,"stats":{"Line":2}},{"line":1066,"address":[55652624],"length":1,"stats":{"Line":2}},{"line":1067,"address":[53284168],"length":1,"stats":{"Line":2}},{"line":1072,"address":[55652656,55652996,55652990],"length":1,"stats":{"Line":14}},{"line":1073,"address":[53284224],"length":1,"stats":{"Line":16}},{"line":1074,"address":[55652850],"length":1,"stats":{"Line":2}},{"line":1075,"address":[55652908],"length":1,"stats":{"Line":2}}],"covered":621,"coverable":656},{"path":["/","home","md","language","mdhavers","src","error.rs"],"content":"use thiserror::Error;\n\n/// Scots error messages - gie the user a guid tellin' aff!\n#[derive(Error, Debug, Clone, PartialEq)]\n#[allow(dead_code)]\npub enum HaversError {\n    #[error(\"Och! Ah dinnae ken whit '{lexeme}' is at line {line}, column {column}\")]\n    UnkentToken {\n        lexeme: String,\n        line: usize,\n        column: usize,\n    },\n\n    #[error(\"Haud yer wheesht! Unexpected '{found}' at line {line} - ah wis expectin' {expected}\")]\n    UnexpectedToken {\n        expected: String,\n        found: String,\n        line: usize,\n    },\n\n    #[error(\"Awa' an bile yer heid! '{name}' hasnae been defined yet at line {line}\")]\n    UndefinedVariable { name: String, line: usize },\n\n    #[error(\"Ye numpty! Tryin' tae divide by zero at line {line}\")]\n    DivisionByZero { line: usize },\n\n    #[error(\"That's pure mince! Type error at line {line}: {message}\")]\n    TypeError { message: String, line: usize },\n\n    #[error(\"Whit's aw this aboot? '{name}' isnae a function at line {line}\")]\n    NotCallable { name: String, line: usize },\n\n    #[error(\"Yer bum's oot the windae! Function '{name}' expects {expected} arguments but ye gave it {got} at line {line}\")]\n    WrongArity {\n        name: String,\n        expected: usize,\n        got: usize,\n        line: usize,\n    },\n\n    #[error(\"Hoachin'! Index {index} is oot o' bounds (size is {size}) at line {line}\")]\n    IndexOutOfBounds {\n        index: i64,\n        size: usize,\n        line: usize,\n    },\n\n    #[error(\"Dinnae be daft! Cannae read the file '{path}': {reason}\")]\n    FileError { path: String, reason: String },\n\n    #[error(\"Yer code's a richt guddle! Parser gave up at line {line}: {message}\")]\n    ParseError { message: String, line: usize },\n\n    #[error(\"Jings! Something went awfy wrang: {0}\")]\n    InternalError(String),\n\n    #[error(\"Och! Compilation went tits up: {0}\")]\n    CompileError(String),\n\n    #[error(\"Wheesht! Break statement ootside a loop at line {line} - ye can only brak fae inside a whiles or fer loop!\")]\n    BreakOutsideLoop { line: usize },\n\n    #[error(\"Haud on there! Continue statement ootside a loop at line {line} - ye can only haud inside a whiles or fer loop!\")]\n    ContinueOutsideLoop { line: usize },\n\n    #[error(\n        \"Stack's fair puggled! Too many nested calls at line {line} - yer recursion's gone radge!\"\n    )]\n    StackOverflow { line: usize },\n\n    #[error(\"Cannae find module '{name}' - hae ye checked the path is richt?\")]\n    ModuleNotFound { name: String },\n\n    #[error(\"That string's no' finished! Missin' closing quote at line {line}\")]\n    UnterminatedString { line: usize },\n\n    #[error(\"Yer number's aw wrang at line {line}: {value}\")]\n    InvalidNumber { value: String, line: usize },\n\n    #[error(\"Haud yer horses! '{name}' is awready defined at line {line}\")]\n    AlreadyDefined { name: String, line: usize },\n\n    #[error(\"Whit are ye playin' at? '{name}' isnae an object at line {line}\")]\n    NotAnObject { name: String, line: usize },\n\n    #[error(\"Och away! '{property}' doesnae exist on this object at line {line}\")]\n    UndefinedProperty { property: String, line: usize },\n\n    #[error(\"Yer loop's gone doolally! Infinite loop detected at line {line}\")]\n    InfiniteLoop { line: usize },\n\n    #[error(\"That's no' a list, ya bampot! Expected a list at line {line}\")]\n    NotAList { line: usize },\n\n    #[error(\"That's no' a dictionary! Expected a dict at line {line}\")]\n    NotADict { line: usize },\n\n    #[error(\"Key '{key}' doesnae exist in the dictionary at line {line}\")]\n    KeyNotFound { key: String, line: usize },\n\n    #[error(\"Ye cannae dae that! {operation} is no' allowed at line {line}\")]\n    InvalidOperation { operation: String, line: usize },\n\n    #[error(\"The import's gone in a fankle! Circular import detected: {path}\")]\n    CircularImport { path: String },\n\n    #[error(\"Mak siccar failed at line {line}! {message}\")]\n    AssertionFailed { message: String, line: usize },\n\n    #[error(\"Ye've fair scunnered it! Return statement ootside a function at line {line}\")]\n    ReturnOutsideFunction { line: usize },\n\n    #[error(\"Haud on! Cannae iterate over a {type_name} at line {line} - need a list or range\")]\n    NotIterable { type_name: String, line: usize },\n\n    #[error(\"Yer pattern's aw wrang at line {line}: {message}\")]\n    PatternError { message: String, line: usize },\n\n    #[error(\"Wheesht! Yer number's too muckle at line {line} - it's overflowed!\")]\n    IntegerOverflow { line: usize },\n\n    #[error(\"By the bonnie banks! Negative index {index} is oot o' range at line {line}\")]\n    NegativeIndexOutOfBounds { index: i64, line: usize },\n\n    #[error(\"Haud yer wheesht! Empty list at line {line} - ye cannae {operation} on naething!\")]\n    EmptyCollection { operation: String, line: usize },\n\n    #[error(\"Yer regex is mince at line {line}: {message}\")]\n    InvalidRegex { message: String, line: usize },\n\n    #[error(\"That format string's a guddle at line {line}: {message}\")]\n    FormatError { message: String, line: usize },\n\n    #[error(\"The JSON's aw wrang at line {line}: {message}\")]\n    JsonError { message: String, line: usize },\n\n    #[error(\"Ye cannae compare {left_type} wi' {right_type} at line {line} - they're like chalk an' cheese!\")]\n    IncomparableTypes {\n        left_type: String,\n        right_type: String,\n        line: usize,\n    },\n\n    #[error(\"That number's nae use at line {line}: {message}\")]\n    InvalidNumberOperation { message: String, line: usize },\n\n    #[error(\"Yer match hasnae covered aw the cases at line {line}!\")]\n    NonExhaustiveMatch { line: usize },\n\n    #[error(\"Ye've got duplicate keys in yer dict at line {line}: '{key}'\")]\n    DuplicateKey { key: String, line: usize },\n\n    #[error(\"Timeout! Yer code took too lang at line {line} - maybe an infinite loop?\")]\n    ExecutionTimeout { line: usize },\n\n    #[error(\"Memory's fair scunnered! Ran oot o' space at line {line}\")]\n    OutOfMemory { line: usize },\n\n    #[error(\n        \"That's a private member! Ye cannae access '{member}' fae ootside the class at line {line}\"\n    )]\n    PrivateMemberAccess { member: String, line: usize },\n\n    #[error(\"Immutable! Ye cannae change '{name}' at line {line} - it's set in stone!\")]\n    ImmutableVariable { name: String, line: usize },\n\n    #[error(\"Hurled at line {line}: {message}\")]\n    UserError { message: String, line: usize },\n}\n\nimpl HaversError {\n    pub fn line(&self) -> Option<usize> {\n        match self {\n            HaversError::UnkentToken { line, .. } => Some(*line),\n            HaversError::UnexpectedToken { line, .. } => Some(*line),\n            HaversError::UndefinedVariable { line, .. } => Some(*line),\n            HaversError::DivisionByZero { line } => Some(*line),\n            HaversError::TypeError { line, .. } => Some(*line),\n            HaversError::NotCallable { line, .. } => Some(*line),\n            HaversError::WrongArity { line, .. } => Some(*line),\n            HaversError::IndexOutOfBounds { line, .. } => Some(*line),\n            HaversError::ParseError { line, .. } => Some(*line),\n            HaversError::BreakOutsideLoop { line } => Some(*line),\n            HaversError::ContinueOutsideLoop { line } => Some(*line),\n            HaversError::StackOverflow { line } => Some(*line),\n            HaversError::UnterminatedString { line } => Some(*line),\n            HaversError::InvalidNumber { line, .. } => Some(*line),\n            HaversError::AlreadyDefined { line, .. } => Some(*line),\n            HaversError::NotAnObject { line, .. } => Some(*line),\n            HaversError::UndefinedProperty { line, .. } => Some(*line),\n            HaversError::InfiniteLoop { line } => Some(*line),\n            HaversError::NotAList { line } => Some(*line),\n            HaversError::NotADict { line } => Some(*line),\n            HaversError::KeyNotFound { line, .. } => Some(*line),\n            HaversError::InvalidOperation { line, .. } => Some(*line),\n            HaversError::AssertionFailed { line, .. } => Some(*line),\n            HaversError::ReturnOutsideFunction { line } => Some(*line),\n            HaversError::NotIterable { line, .. } => Some(*line),\n            HaversError::PatternError { line, .. } => Some(*line),\n            HaversError::IntegerOverflow { line } => Some(*line),\n            HaversError::NegativeIndexOutOfBounds { line, .. } => Some(*line),\n            HaversError::EmptyCollection { line, .. } => Some(*line),\n            HaversError::InvalidRegex { line, .. } => Some(*line),\n            HaversError::FormatError { line, .. } => Some(*line),\n            HaversError::JsonError { line, .. } => Some(*line),\n            HaversError::IncomparableTypes { line, .. } => Some(*line),\n            HaversError::InvalidNumberOperation { line, .. } => Some(*line),\n            HaversError::NonExhaustiveMatch { line } => Some(*line),\n            HaversError::DuplicateKey { line, .. } => Some(*line),\n            HaversError::ExecutionTimeout { line } => Some(*line),\n            HaversError::OutOfMemory { line } => Some(*line),\n            HaversError::PrivateMemberAccess { line, .. } => Some(*line),\n            HaversError::ImmutableVariable { line, .. } => Some(*line),\n            HaversError::UserError { line, .. } => Some(*line),\n            _ => None,\n        }\n    }\n}\n\n/// Scots phrases fer random error decoration\npub fn random_scots_exclamation() -> &'static str {\n    use std::time::{SystemTime, UNIX_EPOCH};\n    let seed = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as usize;\n\n    const PHRASES: &[&str] = &[\n        \"Och naw!\",\n        \"Jings crivvens!\",\n        \"Haud yer wheesht!\",\n        \"Michty me!\",\n        \"Hoots mon!\",\n        \"Blimey!\",\n        \"Ach, fer cryin' oot loud!\",\n        \"By the wee man!\",\n        \"Guid grief!\",\n        \"Haud the bus!\",\n        \"Help ma boab!\",\n        \"Crivvens!\",\n        \"Whit a scunner!\",\n        \"Aw naw!\",\n        \"Dearie me!\",\n        \"Sakes alive!\",\n        \"Whit in the name o' the wee man!\",\n        \"For ony favour!\",\n        \"Haud yer horses!\",\n        \"Whit's aw this then?\",\n        \"Och, here we go again!\",\n        \"By the bonnie banks!\",\n        \"Fit like? No' guid!\",\n        \"Awa' an' dinnae come back!\",\n        \"Yer aff yer heid!\",\n        \"Pure radge!\",\n        \"Whit a palaver!\",\n        \"Gonnae no' dae that!\",\n        \"Gie's peace!\",\n        \"Yer havin' a laugh!\",\n        \"Stone the crows!\",\n        \"Sakes o' mercy!\",\n        \"Whit a fankle!\",\n        \"Heavens tae Betsy!\",\n        \"Lang may yer lum reek... but no' the day!\",\n        \"By ma grannie's tartan knickers!\",\n        \"Haud me back!\",\n        \"Whit in tarnation!\",\n        \"Yer code's gone doolally!\",\n        \"Bletherin' bogles!\",\n        \"Sufferin' sporrans!\",\n        \"Nessie's nostrils!\",\n        \"Haggis tae Highlands!\",\n        \"Tatties an' neeps!\",\n        \"By the Loch Ness Monster!\",\n        \"Burns wid be birlin' in his grave!\",\n        \"Haud yer weesht an' fix it!\",\n        \"Whit's aw the stooshie?\",\n        \"Yer code's fair glaikit!\",\n        \"By the ghost o' Robert Bruce!\",\n        \"Awa' wi' the fairies!\",\n        \"That's a real howler!\",\n        \"Och, fit a cairry on!\",\n        \"Nae messin' aboot!\",\n        \"Yer code's in a right fankle!\",\n        \"Guid heavens above!\",\n        \"Whit's the malky?\",\n        \"By the beard o' Rob Roy!\",\n        \"Cannae believe ma een!\",\n    ];\n\n    PHRASES[seed % PHRASES.len()]\n}\n\n/// Get a wee bit o' encouragement after an error\n#[allow(dead_code)]\npub fn scots_encouragement() -> &'static str {\n    use std::time::{SystemTime, UNIX_EPOCH};\n    let seed = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as usize;\n\n    const PHRASES: &[&str] = &[\n        \"Dinnae fash yersel - hae anither go!\",\n        \"Keep the heid an' try again!\",\n        \"Ye'll get it next time, nae bother!\",\n        \"Haud on - ye're nearly there!\",\n        \"Gie it anither bash!\",\n        \"Chin up, it's nae the end o' the warld!\",\n        \"Rome wisnae built in a day, an' neither is guid code!\",\n        \"Every maister wis once a disaster!\",\n        \"Yer code's getting' better - keep goin'!\",\n        \"Bugs are just features ye didnae plan fer!\",\n        \"Even the best programmers get scunnered sometimes!\",\n        \"A wee setback isnae a defeat!\",\n        \"Whit doesnae kill yer code makes it stronger!\",\n        \"The best debugging is done efter a cup o' tea!\",\n        \"Ye're daein' braw - dinnae gie up!\",\n        \"Mony a mickle maks a muckle - keep at it!\",\n        \"Practice maks perfect, an' bugs mak ye smarter!\",\n    ];\n\n    PHRASES[(seed / 2) % PHRASES.len()]\n}\n\n/// Get a Scottish programming proverb\npub fn scots_programming_wisdom() -> &'static str {\n    use std::time::{SystemTime, UNIX_EPOCH};\n    let seed = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as usize;\n\n    const PROVERBS: &[&str] = &[\n        \"A guid programmer kens when tae ask fer help.\",\n        \"Mony a guid tune is played on an auld fiddle - an' auld code can still work!\",\n        \"Better a wee error noo than a muckle disaster later.\",\n        \"Test early, test often, or ye'll be greetin'.\",\n        \"Comments are like shortbread - ye can never hae too many.\",\n        \"Readable code is worth its weight in haggis.\",\n        \"Dinnae optimize afore yer time.\",\n        \"A bug in the hand is worth two in production.\",\n        \"When in doubt, blether it oot (print debugging)!\",\n        \"Keep yer functions wee, like a dram o' whisky.\",\n        \"Git commit early an' often - save yer work!\",\n        \"The best code is the code ye dinnae hae tae write.\",\n        \"Variable names should tell a story, no' a riddle.\",\n        \"If it works, dinnae touch it. If it doesnae, fix it!\",\n        \"A rubber duck debugging session is worth a thousand breakpoints.\",\n        \"Fools look tae tomorrow - wise coders push tae main today.\",\n        \"He that winna be ruled by the compiler must be ruled by the debugger.\",\n        \"A stitch in time saves nine - an' a unit test saves ninety!\",\n        \"What's fer ye'll no go past ye - but ye still hae tae write the code.\",\n        \"Be happy while ye're livin', fer ye're a lang time debuggin'.\",\n        \"The proof o' the puddin' is in the eatin' - the proof o' the code is in the testin'.\",\n        \"Ye cannae make a silk purse oot o' a soo's lug - or guid code fae bad requirements.\",\n        \"A nod's as guid as a wink tae a blind horse - but explicit code is better than implicit!\",\n        \"Mony mickles mak a muckle - an' mony wee functions mak guid code.\",\n        \"Gie a man a fish an' ye feed him fer a day; teach a man tae code an' he'll hae bugs forever.\",\n    ];\n\n    PROVERBS[(seed / 3) % PROVERBS.len()]\n}\n\npub type HaversResult<T> = Result<T, HaversError>;\n\n/// Get a helpful suggestion fer common errors\npub fn get_error_suggestion(error: &HaversError) -> Option<&'static str> {\n    match error {\n        HaversError::UndefinedVariable { name, .. } => {\n            // Check for common misspellings of keywords\n            let name_lower = name.to_lowercase();\n            match name_lower.as_str() {\n                \"true\" | \"false\" => Some(\" Did ye mean 'aye' or 'nae'? In mdhavers we use Scots words fer booleans!\"),\n                \"if\" | \"else\" => Some(\" Did ye mean 'gin' (if) or 'ither' (else)? We speak Scots here!\"),\n                \"while\" => Some(\" Did ye mean 'whiles'? That's how we say 'while' in Scots!\"),\n                \"for\" => Some(\" Did ye mean 'fer'? That's the Scots way tae loop!\"),\n                \"let\" | \"var\" | \"const\" => Some(\" Did ye mean 'ken'? Use 'ken x = 42' tae declare variables!\"),\n                \"print\" | \"println\" | \"console\" | \"echo\" => Some(\" Did ye mean 'blether'? That's how we print in mdhavers!\"),\n                \"return\" => Some(\" Did ye mean 'gie'? Use 'gie value' tae return fae a function!\"),\n                \"function\" | \"func\" | \"fn\" | \"def\" => Some(\" Did ye mean 'dae'? Use 'dae name() { }' tae define functions!\"),\n                \"null\" | \"nil\" | \"none\" | \"undefined\" => Some(\" Did ye mean 'naething'? That's oor word fer null!\"),\n                \"class\" => Some(\" Did ye mean 'kin'? Use 'kin ClassName { }' tae define classes!\"),\n                \"self\" | \"this\" => Some(\" Did ye mean 'masel'? Use 'masel.property' inside classes!\"),\n                \"try\" => Some(\" Did ye mean 'hae_a_bash'? That's how we try things in Scots!\"),\n                \"catch\" | \"except\" => Some(\" Did ye mean 'gin_it_gangs_wrang'? That's oor catch block!\"),\n                \"import\" | \"require\" | \"include\" => Some(\" Did ye mean 'fetch'? Use 'fetch \\\"module\\\"' tae import!\"),\n                \"break\" => Some(\" Did ye mean 'brak'? That's how we break oot o' loops!\"),\n                \"continue\" => Some(\" Did ye mean 'haud'? That's how we continue tae the next iteration!\"),\n                \"switch\" | \"case\" => Some(\" Did ye mean 'keek' and 'whan'? Use 'keek value { whan 1 -> ... }'!\"),\n                \"assert\" => Some(\" Did ye mean 'mak_siccar'? Like Robert the Bruce said!\"),\n                \"and\" | \"&&\" => Some(\" Did ye mean 'an'? Use 'x an y' fer logical AND!\"),\n                \"not\" | \"!\" => Some(\" Did ye mean 'nae'? Use 'nae x' fer logical NOT!\"),\n                \"map\" => Some(\" Did ye mean 'gaun'? Use 'gaun(list, |x| x * 2)' tae map!\"),\n                \"filter\" => Some(\" Did ye mean 'sieve'? Use 'sieve(list, |x| x > 0)' tae filter!\"),\n                \"reduce\" | \"fold\" => Some(\" Did ye mean 'tumble'? Use 'tumble(list, init, |acc, x| acc + x)'!\"),\n                \"length\" | \"size\" | \"count\" => Some(\" Did ye mean 'len'? Use 'len(list)' tae get the length!\"),\n                \"type\" | \"typeof\" => Some(\" Did ye mean 'whit_kind'? Use 'whit_kind(x)' tae get the type!\"),\n                \"str\" | \"string\" | \"tostring\" => Some(\" Did ye mean 'tae_string'? Use 'tae_string(x)' tae convert!\"),\n                \"int\" | \"integer\" | \"toint\" => Some(\" Did ye mean 'tae_int'? Use 'tae_int(x)' tae convert!\"),\n                \"push\" | \"append\" | \"add\" => Some(\" Did ye mean 'shove'? Use 'shove(list, item)' tae add tae a list!\"),\n                \"pop\" | \"remove\" => Some(\" Did ye mean 'yank'? Use 'yank(list)' tae remove fae a list!\"),\n                \"input\" | \"read\" | \"readline\" => Some(\" Did ye mean 'speir'? Use 'speir(\\\"prompt\\\")' tae get input!\"),\n                \"struct\" => Some(\" Did ye mean 'thing'? Use 'thing Name { fields }' fer structs!\"),\n                \"trim\" => Some(\" Did ye mean 'wheesht'? Use 'wheesht(str)' tae trim whitespace!\"),\n                \"slice\" | \"substring\" | \"substr\" => Some(\" Did ye mean 'scran'? Use 'scran(str, start, end)' tae slice!\"),\n                \"find\" | \"indexof\" => Some(\" Did ye mean 'index_of'? Use 'index_of(str, substr)' tae find!\"),\n                \"random\" | \"rand\" => Some(\" Did ye mean 'jammy'? Use 'jammy(min, max)' fer random numbers!\"),\n                \"sleep\" | \"wait\" | \"delay\" => Some(\" Did ye mean 'snooze'? Use 'snooze(ms)' tae pause!\"),\n                \"now\" | \"time\" | \"timestamp\" => Some(\" Did ye mean 'noo' or 'the_noo'? That's how we get the time!\"),\n                \"exit\" | \"quit\" => Some(\" Did ye mean 'awa'? Use 'awa(code)' tae exit the program!\"),\n                \"throw\" | \"raise\" => Some(\" Did ye mean 'fling'? Use 'fling \\\"error message\\\"' tae throw errors!\"),\n                \"lambda\" | \"arrow\" => Some(\" Use '|x| x * 2' fer lambdas - nae need fer a keyword!\"),\n                \"extends\" | \"inherit\" => Some(\" Use 'kin Child frae Parent { }' fer inheritance!\"),\n                \"in\" => Some(\" Use 'contains(list, item)' tae check if an item is in a list!\"),\n                \"or\" | \"||\" => Some(\" Use 'or' fer logical OR: 'x or y'\"),\n                \"array\" | \"list\" | \"vec\" => Some(\" Use square brackets: '[1, 2, 3]' tae create a list!\"),\n                \"dict\" | \"hash\" | \"hashmap\" | \"object\" => Some(\" Use curly braces: '{\\\"key\\\": value}' tae create a dict!\"),\n                \"first\" | \"head\" => Some(\" Did ye mean 'heid'? Use 'heid(list)' tae get the first element!\"),\n                \"last\" => Some(\" Did ye mean 'bum'? Use 'bum(list)' tae get the last element!\"),\n                \"rest\" | \"tail\" => Some(\" Did ye mean 'tail'? Use 'tail(list)' tae get all but the first!\"),\n                \"sort\" => Some(\" Use 'sort(list)' tae sort a list!\"),\n                \"reverse\" => Some(\" Use 'reverse(list)' tae reverse a list!\"),\n                \"join\" => Some(\" Use 'join(list, sep)' tae join a list intae a string!\"),\n                \"split\" => Some(\" Use 'split(str, sep)' tae split a string intae a list!\"),\n                \"format\" => Some(\" Use f-strings: f\\\"Hello {name}!\\\" fer string formatting!\"),\n                \"debug\" | \"inspect\" => Some(\" Use 'clype(x)' tae print debug info aboot a value!\"),\n                \"range\" => Some(\" Use 'start..end' fer ranges! E.g., 'fer i in 0..10 { }'\"),\n                \"foreach\" => Some(\" Use 'fer item in list { }' tae iterate over items!\"),\n                \"async\" | \"await\" => Some(\" mdhavers doesnae support async yet - stick tae synchronous code!\"),\n                \"match\" => Some(\" Did ye mean 'keek'? Use 'keek value { whan x -> ... }'!\"),\n                \"enum\" => Some(\" Use dictionaries or constants fer enum-like patterns!\"),\n                \"interface\" | \"trait\" | \"protocol\" => Some(\" Use classes (kin) - mdhavers doesnae have interfaces!\"),\n                \"static\" => Some(\" All functions at module level are like static - nae need fer a keyword!\"),\n                \"public\" | \"private\" | \"protected\" => Some(\" mdhavers doesnae have access modifiers - everything's public!\"),\n                \"new\" => Some(\" Just call the class like a function: 'MyClass()' - nae 'new' needed!\"),\n                \"super\" => Some(\" Did ye mean 'auld'? Use 'auld.method()' tae call parent class methods!\"),\n                \"final\" | \"readonly\" => Some(\" Use 'ken' fer all variables - they're mutable by default!\"),\n                \"void\" => Some(\" Functions wi' nae return value automatically return 'naething'!\"),\n                \"boolean\" | \"bool\" => Some(\" Booleans are 'aye' (true) an' 'nae' (false) in mdhavers!\"),\n                \"String\" => Some(\" Strings are created wi' quotes: \\\"hello\\\" or 'hello'!\"),\n                \"char\" | \"character\" => Some(\" Use 'char_at(str, index)' tae get a character fae a string!\"),\n                \"float\" | \"double\" | \"decimal\" => Some(\" Just use numbers wi' decimal points: '3.14'!\"),\n                \"byte\" | \"bytes\" => Some(\" Strings handle text - fer binary, use lists o' integers!\"),\n                \"set\" => Some(\" Use the Set class fae the structures module, or a dict wi' dummy values!\"),\n                \"tuple\" => Some(\" Use lists fer tuples: '[1, \\\"hello\\\", aye]'!\"),\n                \"global\" => Some(\" Variables at module level are global - nae keyword needed!\"),\n                \"do\" => Some(\" Did ye mean 'dae'? Use 'dae name() { }' fer functions!\"),\n                \"end\" | \"endif\" | \"endfor\" | \"endwhile\" => Some(\" Use curly braces { } tae end blocks - nae 'end' keyword!\"),\n                \"then\" => Some(\" Nae 'then' keyword - use 'gin condition { ... }'!\"),\n                \"begin\" => Some(\" Use { tae start a block - nae 'begin' keyword!\"),\n                \"puts\" | \"write\" | \"output\" => Some(\" Did ye mean 'blether'? Use 'blether \\\"text\\\"' tae print!\"),\n                \"gets\" => Some(\" Did ye mean 'speir'? Use 'speir(\\\"prompt\\\")' tae get input!\"),\n                \"sprintf\" | \"printf\" => Some(\" Use f-strings: f\\\"Value is {x}\\\" fer formatting!\"),\n                \"len\" => Some(\" 'len' is built-in! Use 'len(list)' or 'len(string)'!\"),\n                \"abs\" | \"absolute\" => Some(\" Use 'abs(x)' fer absolute value - it's built-in!\"),\n                \"max\" | \"maximum\" => Some(\" Use 'max(a, b)' or 'max(list)' - it's built-in!\"),\n                \"min\" | \"minimum\" => Some(\" Use 'min(a, b)' or 'min(list)' - it's built-in!\"),\n                \"floor\" | \"ceil\" | \"round\" => Some(\" Use 'floor(x)', 'ceil(x)', or 'round(x)' - they're built-in!\"),\n                \"sqrt\" | \"squareroot\" => Some(\" Use the maths module: 'fetch \\\"lib/maths\\\"' fer sqrt!\"),\n                \"sin\" | \"cos\" | \"tan\" => Some(\" Use the maths module: 'fetch \\\"lib/maths\\\"' fer trig functions!\"),\n                \"log\" | \"exp\" => Some(\" Use the maths module: 'fetch \\\"lib/maths\\\"' fer logarithms!\"),\n                \"open\" | \"fopen\" => Some(\" Use 'read_file(path)' or 'write_file(path, content)' fer files!\"),\n                \"close\" | \"fclose\" => Some(\" File handles close automatically - nae need tae close manually!\"),\n                \"module\" | \"package\" | \"namespace\" => Some(\" Modules are just .braw files! Use 'fetch \\\"lib/name\\\"' tae import!\"),\n                \"from\" => Some(\" Did ye mean 'frae'? Use 'kin Child frae Parent { }' fer inheritance!\"),\n                _ => None,\n            }\n        }\n        HaversError::UnexpectedToken { found, expected, .. } => {\n            if found == \"}\" && expected.contains(\"expression\") {\n                Some(\" Ye might be missin' an expression before the closing brace!\")\n            } else if found == \"=\" && expected.contains(\"expression\") {\n                Some(\" Did ye mean '==' fer comparison? Single '=' is fer assignment!\")\n            } else if found == \")\" {\n                Some(\" Check yer brackets - ye might hae an extra ')' or be missin' something!\")\n            } else {\n                None\n            }\n        }\n        HaversError::TypeError { message, .. } => {\n            if message.contains(\"add\") && message.contains(\"string\") {\n                Some(\" Use 'tae_string(x)' tae convert numbers tae strings before concatenatin'!\")\n            } else if message.contains(\"integer\") && message.contains(\"index\") {\n                Some(\" List indices must be integers. Use 'tae_int(x)' if needed!\")\n            } else {\n                None\n            }\n        }\n        HaversError::WrongArity { expected, got, .. } => {\n            if *expected == 0 && *got > 0 {\n                Some(\" This function takes nae arguments - remove the bits in the brackets!\")\n            } else if *got == 0 && *expected > 0 {\n                Some(\" This function needs arguments - check the function definition!\")\n            } else {\n                None\n            }\n        }\n        HaversError::IndexOutOfBounds { index, size, .. } => {\n            if *index < 0 {\n                Some(\" Negative indices count fae the end. -1 is the last element!\")\n            } else if *size == 0 {\n                Some(\" The list is empty! Check ye've added items before accessin' them.\")\n            } else {\n                Some(\" Remember, indices start at 0! The last valid index is len - 1.\")\n            }\n        }\n        HaversError::DivisionByZero { .. } => {\n            Some(\" Check yer divisor - ye cannae divide by zero! Maybe add a 'gin x != 0' check?\")\n        }\n        HaversError::StackOverflow { .. } => {\n            Some(\" Yer recursion needs a base case! Make sure ye're returnin' somewhere.\")\n        }\n        HaversError::NotCallable { .. } => {\n            Some(\" Ye can only call functions wi' brackets. Check the variable type wi' 'whit_kind(x)'!\")\n        }\n        HaversError::KeyNotFound { .. } => {\n            Some(\" Use 'keys(dict)' tae see whit keys exist, or check wi' 'has_key(dict, key)'!\")\n        }\n        HaversError::UnterminatedString { .. } => {\n            Some(\" Ye forgot tae close yer string! Add a \\\" at the end.\")\n        }\n        HaversError::CircularImport { .. } => {\n            Some(\" Module A imports B which imports A - that's a loop! Reorganise yer imports.\")\n        }\n        HaversError::BreakOutsideLoop { .. } => {\n            Some(\" 'brak' only works inside 'whiles' or 'fer' loops!\")\n        }\n        HaversError::ContinueOutsideLoop { .. } => {\n            Some(\" 'haud' only works inside 'whiles' or 'fer' loops!\")\n        }\n        HaversError::ReturnOutsideFunction { .. } => {\n            Some(\" 'gie' only works inside functions! Define a function wi' 'dae name() { }'\")\n        }\n        _ => None,\n    }\n}\n\n/// A wee helper tae format errors bonnie-like\npub fn format_error_context(source: &str, line: usize) -> String {\n    let lines: Vec<&str> = source.lines().collect();\n    if line == 0 || line > lines.len() {\n        return String::new();\n    }\n\n    let mut result = String::new();\n    let line_idx = line - 1;\n\n    // Show a wee bit o' context\n    if line_idx > 0 {\n        result.push_str(&format!(\"  {} | {}\\n\", line - 1, lines[line_idx - 1]));\n    }\n    result.push_str(&format!(\"> {} | {}\\n\", line, lines[line_idx]));\n    if line_idx + 1 < lines.len() {\n        result.push_str(&format!(\"  {} | {}\\n\", line + 1, lines[line_idx + 1]));\n    }\n\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_error_suggestions() {\n        // Test common keyword misspellings\n        let err = HaversError::UndefinedVariable {\n            name: \"true\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"aye\"));\n\n        let err = HaversError::UndefinedVariable {\n            name: \"print\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"blether\"));\n\n        let err = HaversError::UndefinedVariable {\n            name: \"null\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"naething\"));\n\n        let err = HaversError::UndefinedVariable {\n            name: \"function\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"dae\"));\n    }\n\n    #[test]\n    fn test_error_suggestions_more_keywords() {\n        // Test more keyword misspellings\n        let keywords = vec![\n            (\"false\", \"nae\"),\n            (\"if\", \"gin\"),\n            (\"else\", \"ither\"),\n            (\"while\", \"whiles\"),\n            (\"for\", \"fer\"),\n            (\"let\", \"ken\"),\n            (\"return\", \"gie\"),\n            (\"class\", \"kin\"),\n            (\"self\", \"masel\"),\n            (\"try\", \"hae_a_bash\"),\n            (\"catch\", \"gin_it_gangs_wrang\"),\n            (\"import\", \"fetch\"),\n            (\"break\", \"brak\"),\n            (\"continue\", \"haud\"),\n            (\"switch\", \"keek\"),\n            (\"assert\", \"mak_siccar\"),\n            (\"and\", \"an\"),\n            (\"map\", \"gaun\"),\n            (\"filter\", \"sieve\"),\n            (\"reduce\", \"tumble\"),\n            (\"length\", \"len\"),\n            (\"type\", \"whit_kind\"),\n            (\"str\", \"tae_string\"),\n            (\"int\", \"tae_int\"),\n            (\"push\", \"shove\"),\n            (\"pop\", \"yank\"),\n            (\"input\", \"speir\"),\n            (\"struct\", \"thing\"),\n            (\"trim\", \"wheesht\"),\n            (\"random\", \"jammy\"),\n            (\"sleep\", \"snooze\"),\n            (\"now\", \"noo\"),\n            (\"exit\", \"awa\"),\n            (\"throw\", \"fling\"),\n            (\"extends\", \"frae\"),\n            (\"super\", \"auld\"),\n            (\"first\", \"heid\"),\n            (\"last\", \"bum\"),\n            (\"debug\", \"clype\"),\n        ];\n\n        for (keyword, expected) in keywords {\n            let err = HaversError::UndefinedVariable {\n                name: keyword.to_string(),\n                line: 1,\n            };\n            let suggestion = get_error_suggestion(&err);\n            assert!(suggestion.is_some(), \"Expected suggestion for {}\", keyword);\n            assert!(\n                suggestion.unwrap().to_lowercase().contains(expected),\n                \"Expected '{}' in suggestion for '{}'\",\n                expected,\n                keyword\n            );\n        }\n    }\n\n    #[test]\n    fn test_error_suggestions_other_errors() {\n        // Test division by zero suggestion\n        let err = HaversError::DivisionByZero { line: 1 };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"zero\"));\n\n        // Test stack overflow suggestion\n        let err = HaversError::StackOverflow { line: 1 };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"recursion\"));\n\n        // Test index out of bounds for empty list\n        let err = HaversError::IndexOutOfBounds {\n            index: 0,\n            size: 0,\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"empty\"));\n\n        // Test negative index\n        let err = HaversError::IndexOutOfBounds {\n            index: -1,\n            size: 5,\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"Negative\"));\n\n        // Test positive index out of bounds\n        let err = HaversError::IndexOutOfBounds {\n            index: 10,\n            size: 5,\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"0\"));\n\n        // Test not callable\n        let err = HaversError::NotCallable {\n            name: \"x\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test key not found\n        let err = HaversError::KeyNotFound {\n            key: \"foo\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test unterminated string\n        let err = HaversError::UnterminatedString { line: 1 };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test circular import\n        let err = HaversError::CircularImport {\n            path: \"lib\".to_string(),\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test break outside loop\n        let err = HaversError::BreakOutsideLoop { line: 1 };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test continue outside loop\n        let err = HaversError::ContinueOutsideLoop { line: 1 };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test return outside function\n        let err = HaversError::ReturnOutsideFunction { line: 1 };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test wrong arity - no args expected\n        let err = HaversError::WrongArity {\n            name: \"foo\".to_string(),\n            expected: 0,\n            got: 2,\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test wrong arity - args expected\n        let err = HaversError::WrongArity {\n            name: \"foo\".to_string(),\n            expected: 2,\n            got: 0,\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test type error with string add\n        let err = HaversError::TypeError {\n            message: \"Cannot add string\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test unexpected token - closing brace\n        let err = HaversError::UnexpectedToken {\n            expected: \"expression\".to_string(),\n            found: \"}\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test unexpected token - equals\n        let err = HaversError::UnexpectedToken {\n            expected: \"expression\".to_string(),\n            found: \"=\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n\n        // Test unexpected token - paren\n        let err = HaversError::UnexpectedToken {\n            expected: \"something\".to_string(),\n            found: \")\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_some());\n    }\n\n    #[test]\n    fn test_scots_phrases() {\n        // Test that random phrases return valid strings\n        let phrase = random_scots_exclamation();\n        assert!(!phrase.is_empty());\n\n        let encouragement = scots_encouragement();\n        assert!(!encouragement.is_empty());\n\n        let wisdom = scots_programming_wisdom();\n        assert!(!wisdom.is_empty());\n    }\n\n    #[test]\n    fn test_format_error_context() {\n        let source = \"ken x = 1\\nken y = 2\\nken z = 3\";\n        let context = format_error_context(source, 2);\n        assert!(context.contains(\"ken y = 2\"));\n        assert!(context.contains(\"> 2 |\"));\n    }\n\n    #[test]\n    fn test_format_error_context_edge_cases() {\n        // Test first line\n        let source = \"ken x = 1\\nken y = 2\";\n        let context = format_error_context(source, 1);\n        assert!(context.contains(\"ken x = 1\"));\n        assert!(context.contains(\"> 1 |\"));\n\n        // Test last line\n        let context = format_error_context(source, 2);\n        assert!(context.contains(\"ken y = 2\"));\n\n        // Test invalid line 0\n        let context = format_error_context(source, 0);\n        assert!(context.is_empty());\n\n        // Test line beyond source\n        let context = format_error_context(source, 10);\n        assert!(context.is_empty());\n    }\n\n    #[test]\n    fn test_error_line_method() {\n        // Test all error variants that have line\n        assert_eq!(\n            HaversError::UnkentToken {\n                lexeme: \"x\".to_string(),\n                line: 5,\n                column: 3\n            }\n            .line(),\n            Some(5)\n        );\n\n        assert_eq!(\n            HaversError::UnexpectedToken {\n                expected: \"a\".to_string(),\n                found: \"b\".to_string(),\n                line: 10\n            }\n            .line(),\n            Some(10)\n        );\n\n        assert_eq!(\n            HaversError::UndefinedVariable {\n                name: \"x\".to_string(),\n                line: 3\n            }\n            .line(),\n            Some(3)\n        );\n\n        assert_eq!(HaversError::DivisionByZero { line: 7 }.line(), Some(7));\n\n        assert_eq!(\n            HaversError::TypeError {\n                message: \"msg\".to_string(),\n                line: 2\n            }\n            .line(),\n            Some(2)\n        );\n\n        assert_eq!(\n            HaversError::NotCallable {\n                name: \"x\".to_string(),\n                line: 4\n            }\n            .line(),\n            Some(4)\n        );\n\n        assert_eq!(\n            HaversError::WrongArity {\n                name: \"f\".to_string(),\n                expected: 1,\n                got: 2,\n                line: 6\n            }\n            .line(),\n            Some(6)\n        );\n\n        assert_eq!(\n            HaversError::IndexOutOfBounds {\n                index: 5,\n                size: 3,\n                line: 8\n            }\n            .line(),\n            Some(8)\n        );\n\n        assert_eq!(\n            HaversError::ParseError {\n                message: \"err\".to_string(),\n                line: 9\n            }\n            .line(),\n            Some(9)\n        );\n\n        assert_eq!(HaversError::BreakOutsideLoop { line: 11 }.line(), Some(11));\n        assert_eq!(\n            HaversError::ContinueOutsideLoop { line: 12 }.line(),\n            Some(12)\n        );\n        assert_eq!(HaversError::StackOverflow { line: 13 }.line(), Some(13));\n        assert_eq!(\n            HaversError::UnterminatedString { line: 14 }.line(),\n            Some(14)\n        );\n        assert_eq!(\n            HaversError::InvalidNumber {\n                value: \"x\".to_string(),\n                line: 15\n            }\n            .line(),\n            Some(15)\n        );\n        assert_eq!(\n            HaversError::AlreadyDefined {\n                name: \"x\".to_string(),\n                line: 16\n            }\n            .line(),\n            Some(16)\n        );\n        assert_eq!(\n            HaversError::NotAnObject {\n                name: \"x\".to_string(),\n                line: 17\n            }\n            .line(),\n            Some(17)\n        );\n        assert_eq!(\n            HaversError::UndefinedProperty {\n                property: \"x\".to_string(),\n                line: 18\n            }\n            .line(),\n            Some(18)\n        );\n        assert_eq!(HaversError::InfiniteLoop { line: 19 }.line(), Some(19));\n        assert_eq!(HaversError::NotAList { line: 20 }.line(), Some(20));\n        assert_eq!(HaversError::NotADict { line: 21 }.line(), Some(21));\n        assert_eq!(\n            HaversError::KeyNotFound {\n                key: \"x\".to_string(),\n                line: 22\n            }\n            .line(),\n            Some(22)\n        );\n        assert_eq!(\n            HaversError::InvalidOperation {\n                operation: \"op\".to_string(),\n                line: 23\n            }\n            .line(),\n            Some(23)\n        );\n        assert_eq!(\n            HaversError::AssertionFailed {\n                message: \"msg\".to_string(),\n                line: 24\n            }\n            .line(),\n            Some(24)\n        );\n        assert_eq!(\n            HaversError::ReturnOutsideFunction { line: 25 }.line(),\n            Some(25)\n        );\n        assert_eq!(\n            HaversError::NotIterable {\n                type_name: \"int\".to_string(),\n                line: 26\n            }\n            .line(),\n            Some(26)\n        );\n        assert_eq!(\n            HaversError::PatternError {\n                message: \"msg\".to_string(),\n                line: 27\n            }\n            .line(),\n            Some(27)\n        );\n        assert_eq!(HaversError::IntegerOverflow { line: 28 }.line(), Some(28));\n        assert_eq!(\n            HaversError::NegativeIndexOutOfBounds {\n                index: -1,\n                line: 29\n            }\n            .line(),\n            Some(29)\n        );\n        assert_eq!(\n            HaversError::EmptyCollection {\n                operation: \"op\".to_string(),\n                line: 30\n            }\n            .line(),\n            Some(30)\n        );\n        assert_eq!(\n            HaversError::InvalidRegex {\n                message: \"msg\".to_string(),\n                line: 31\n            }\n            .line(),\n            Some(31)\n        );\n        assert_eq!(\n            HaversError::FormatError {\n                message: \"msg\".to_string(),\n                line: 32\n            }\n            .line(),\n            Some(32)\n        );\n        assert_eq!(\n            HaversError::JsonError {\n                message: \"msg\".to_string(),\n                line: 33\n            }\n            .line(),\n            Some(33)\n        );\n        assert_eq!(\n            HaversError::IncomparableTypes {\n                left_type: \"a\".to_string(),\n                right_type: \"b\".to_string(),\n                line: 34\n            }\n            .line(),\n            Some(34)\n        );\n        assert_eq!(\n            HaversError::InvalidNumberOperation {\n                message: \"msg\".to_string(),\n                line: 35\n            }\n            .line(),\n            Some(35)\n        );\n        assert_eq!(\n            HaversError::NonExhaustiveMatch { line: 36 }.line(),\n            Some(36)\n        );\n        assert_eq!(\n            HaversError::DuplicateKey {\n                key: \"x\".to_string(),\n                line: 37\n            }\n            .line(),\n            Some(37)\n        );\n        assert_eq!(HaversError::ExecutionTimeout { line: 38 }.line(), Some(38));\n        assert_eq!(HaversError::OutOfMemory { line: 39 }.line(), Some(39));\n        assert_eq!(\n            HaversError::PrivateMemberAccess {\n                member: \"x\".to_string(),\n                line: 40\n            }\n            .line(),\n            Some(40)\n        );\n        assert_eq!(\n            HaversError::ImmutableVariable {\n                name: \"x\".to_string(),\n                line: 41\n            }\n            .line(),\n            Some(41)\n        );\n\n        // Errors without line\n        assert_eq!(\n            HaversError::FileError {\n                path: \"x\".to_string(),\n                reason: \"r\".to_string()\n            }\n            .line(),\n            None\n        );\n        assert_eq!(HaversError::InternalError(\"msg\".to_string()).line(), None);\n        assert_eq!(\n            HaversError::ModuleNotFound {\n                name: \"x\".to_string()\n            }\n            .line(),\n            None\n        );\n        assert_eq!(\n            HaversError::CircularImport {\n                path: \"x\".to_string()\n            }\n            .line(),\n            None\n        );\n    }\n\n    #[test]\n    fn test_error_display() {\n        // Test that error messages format correctly\n        let err = HaversError::UndefinedVariable {\n            name: \"x\".to_string(),\n            line: 5,\n        };\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"x\"));\n        assert!(msg.contains(\"5\"));\n\n        let err = HaversError::DivisionByZero { line: 3 };\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"3\"));\n        assert!(msg.contains(\"zero\"));\n\n        let err = HaversError::WrongArity {\n            name: \"foo\".to_string(),\n            expected: 2,\n            got: 3,\n            line: 7,\n        };\n        let msg = format!(\"{}\", err);\n        assert!(msg.contains(\"foo\"));\n        assert!(msg.contains(\"2\"));\n        assert!(msg.contains(\"3\"));\n    }\n\n    #[test]\n    fn test_no_suggestion_for_unknown() {\n        let err = HaversError::UndefinedVariable {\n            name: \"my_custom_variable\".to_string(),\n            line: 1,\n        };\n        let suggestion = get_error_suggestion(&err);\n        assert!(suggestion.is_none());\n    }\n}\n","traces":[{"line":171,"address":[110225834,110226618],"length":1,"stats":{"Line":0}},{"line":172,"address":[107942788,107942004],"length":1,"stats":{"Line":2}},{"line":173,"address":[55613841],"length":1,"stats":{"Line":2}},{"line":174,"address":[108613920,108613983,108613136,108613199],"length":1,"stats":{"Line":2}},{"line":175,"address":[55613935],"length":1,"stats":{"Line":2}},{"line":176,"address":[55613975],"length":1,"stats":{"Line":2}},{"line":177,"address":[56936127],"length":1,"stats":{"Line":2}},{"line":178,"address":[52691703],"length":1,"stats":{"Line":2}},{"line":179,"address":[107942979,107942358,107942195,107943142],"length":1,"stats":{"Line":2}},{"line":180,"address":[54782023],"length":1,"stats":{"Line":2}},{"line":181,"address":[52691823],"length":1,"stats":{"Line":2}},{"line":182,"address":[56936327],"length":1,"stats":{"Line":2}},{"line":183,"address":[53083618],"length":1,"stats":{"Line":2}},{"line":184,"address":[56936407],"length":1,"stats":{"Line":2}},{"line":185,"address":[56936447],"length":1,"stats":{"Line":2}},{"line":186,"address":[55614374],"length":1,"stats":{"Line":2}},{"line":187,"address":[108805083],"length":1,"stats":{"Line":2}},{"line":188,"address":[107943954],"length":1,"stats":{"Line":2}},{"line":189,"address":[52692142],"length":1,"stats":{"Line":2}},{"line":190,"address":[52692182],"length":1,"stats":{"Line":2}},{"line":191,"address":[107943803],"length":1,"stats":{"Line":2}},{"line":192,"address":[54782502],"length":1,"stats":{"Line":2}},{"line":193,"address":[108805060],"length":1,"stats":{"Line":2}},{"line":194,"address":[52692342],"length":1,"stats":{"Line":2}},{"line":195,"address":[52692382],"length":1,"stats":{"Line":2}},{"line":196,"address":[55614774],"length":1,"stats":{"Line":2}},{"line":197,"address":[55614814],"length":1,"stats":{"Line":2}},{"line":198,"address":[108805251],"length":1,"stats":{"Line":2}},{"line":199,"address":[107944061,107944125],"length":1,"stats":{"Line":2}},{"line":200,"address":[56937046],"length":1,"stats":{"Line":2}},{"line":201,"address":[108615374,108615445],"length":1,"stats":{"Line":2}},{"line":202,"address":[54782905],"length":1,"stats":{"Line":2}},{"line":203,"address":[55615060],"length":1,"stats":{"Line":2}},{"line":204,"address":[54782991],"length":1,"stats":{"Line":2}},{"line":205,"address":[52692794],"length":1,"stats":{"Line":2}},{"line":206,"address":[56937301],"length":1,"stats":{"Line":2}},{"line":207,"address":[54783120],"length":1,"stats":{"Line":2}},{"line":208,"address":[110228611],"length":1,"stats":{"Line":2}},{"line":209,"address":[53084181],"length":1,"stats":{"Line":2}},{"line":210,"address":[108615843],"length":1,"stats":{"Line":2}},{"line":211,"address":[108806107,108806011],"length":1,"stats":{"Line":2}},{"line":212,"address":[52693092],"length":1,"stats":{"Line":2}},{"line":213,"address":[55615484],"length":1,"stats":{"Line":2}},{"line":214,"address":[107944084,107944370],"length":1,"stats":{"Line":0}},{"line":215,"address":[54781764],"length":1,"stats":{"Line":2}},{"line":221,"address":[108801725],"length":1,"stats":{"Line":2}},{"line":223,"address":[52708774,52708692],"length":1,"stats":{"Line":4}},{"line":224,"address":[52708710],"length":1,"stats":{"Line":2}},{"line":225,"address":[108611535],"length":1,"stats":{"Line":2}},{"line":226,"address":[55631157],"length":1,"stats":{"Line":2}},{"line":290,"address":[56953259,56953315],"length":1,"stats":{"Line":2}},{"line":295,"address":[52693232],"length":1,"stats":{"Line":2}},{"line":297,"address":[55615674,55615588],"length":1,"stats":{"Line":4}},{"line":298,"address":[54783494],"length":1,"stats":{"Line":2}},{"line":299,"address":[54783527],"length":1,"stats":{"Line":2}},{"line":300,"address":[56937777],"length":1,"stats":{"Line":2}},{"line":322,"address":[52693382,52693323],"length":1,"stats":{"Line":2}},{"line":326,"address":[54799136],"length":1,"stats":{"Line":2}},{"line":328,"address":[52708868,52708950],"length":1,"stats":{"Line":4}},{"line":329,"address":[55631270],"length":1,"stats":{"Line":2}},{"line":330,"address":[55631303],"length":1,"stats":{"Line":2}},{"line":331,"address":[55631333],"length":1,"stats":{"Line":2}},{"line":361,"address":[55631343,55631409],"length":1,"stats":{"Line":2}},{"line":364,"address":[4777731],"length":1,"stats":{"Line":0}},{"line":367,"address":[54785424,54798483,54798489],"length":1,"stats":{"Line":5}},{"line":368,"address":[56939655],"length":1,"stats":{"Line":5}},{"line":369,"address":[4777867],"length":1,"stats":{"Line":4}},{"line":371,"address":[52695332],"length":1,"stats":{"Line":5}},{"line":372,"address":[56939854,56940696],"length":1,"stats":{"Line":10}},{"line":373,"address":[4777935],"length":1,"stats":{"Line":5}},{"line":374,"address":[55618764],"length":1,"stats":{"Line":5}},{"line":375,"address":[55618906,55618987],"length":1,"stats":{"Line":7}},{"line":376,"address":[55618961,55619074,55619026],"length":1,"stats":{"Line":9}},{"line":377,"address":[54786936,54787001],"length":1,"stats":{"Line":7}},{"line":378,"address":[52696890],"length":1,"stats":{"Line":5}},{"line":379,"address":[4778003],"length":1,"stats":{"Line":4}},{"line":380,"address":[55619588,55619653],"length":1,"stats":{"Line":5}},{"line":381,"address":[4778034],"length":1,"stats":{"Line":5}},{"line":382,"address":[55620213,55620132],"length":1,"stats":{"Line":5}},{"line":383,"address":[56942348,56942283],"length":1,"stats":{"Line":5}},{"line":384,"address":[54788330,54788249],"length":1,"stats":{"Line":5}},{"line":385,"address":[55620481,55620416],"length":1,"stats":{"Line":5}},{"line":386,"address":[54788478],"length":1,"stats":{"Line":3}},{"line":387,"address":[56942964,56942883],"length":1,"stats":{"Line":5}},{"line":388,"address":[56943003,56943051,56942938],"length":1,"stats":{"Line":7}},{"line":389,"address":[56943090,56943025],"length":1,"stats":{"Line":5}},{"line":390,"address":[54789072,54788991],"length":1,"stats":{"Line":5}},{"line":391,"address":[52698836,52698771],"length":1,"stats":{"Line":5}},{"line":392,"address":[54789220],"length":1,"stats":{"Line":3}},{"line":393,"address":[54789443,54789362],"length":1,"stats":{"Line":5}},{"line":394,"address":[55621594,55621529,55621642],"length":1,"stats":{"Line":7}},{"line":395,"address":[52699294,52699229],"length":1,"stats":{"Line":5}},{"line":396,"address":[4776358],"length":1,"stats":{"Line":3}},{"line":397,"address":[56944083],"length":1,"stats":{"Line":3}},{"line":398,"address":[54790017],"length":1,"stats":{"Line":3}},{"line":399,"address":[54790196],"length":1,"stats":{"Line":3}},{"line":400,"address":[4776384],"length":1,"stats":{"Line":3}},{"line":401,"address":[4776403,4776489],"length":1,"stats":{"Line":3}},{"line":402,"address":[56944892],"length":1,"stats":{"Line":3}},{"line":403,"address":[55623047,55622975],"length":1,"stats":{"Line":5}},{"line":404,"address":[54791016,54790971,54790912],"length":1,"stats":{"Line":6}},{"line":405,"address":[55623164,55623105],"length":1,"stats":{"Line":6}},{"line":406,"address":[55623316],"length":1,"stats":{"Line":4}},{"line":407,"address":[55623446],"length":1,"stats":{"Line":4}},{"line":408,"address":[4778226],"length":1,"stats":{"Line":4}},{"line":409,"address":[52701368],"length":1,"stats":{"Line":4}},{"line":410,"address":[56946030],"length":1,"stats":{"Line":4}},{"line":411,"address":[56946160],"length":1,"stats":{"Line":4}},{"line":412,"address":[56946290],"length":1,"stats":{"Line":4}},{"line":413,"address":[54792212],"length":1,"stats":{"Line":4}},{"line":414,"address":[56946550,56946622],"length":1,"stats":{"Line":4}},{"line":415,"address":[52702116,52702175],"length":1,"stats":{"Line":8}},{"line":416,"address":[52702278],"length":1,"stats":{"Line":4}},{"line":417,"address":[55624844],"length":1,"stats":{"Line":4}},{"line":418,"address":[52702689],"length":1,"stats":{"Line":3}},{"line":419,"address":[56947374,56947302],"length":1,"stats":{"Line":6}},{"line":420,"address":[55625255,55625314],"length":1,"stats":{"Line":8}},{"line":421,"address":[52703102,52703030],"length":1,"stats":{"Line":4}},{"line":422,"address":[4776131,4776137,4775536],"length":1,"stats":{"Line":8}},{"line":423,"address":[4775694,4775952,4775656],"length":1,"stats":{"Line":8}},{"line":424,"address":[55625628,55625732,55625687],"length":1,"stats":{"Line":8}},{"line":425,"address":[52703381,52703322,52703426],"length":1,"stats":{"Line":8}},{"line":426,"address":[52703403,52703462],"length":1,"stats":{"Line":8}},{"line":427,"address":[55626024,55625952],"length":1,"stats":{"Line":4}},{"line":428,"address":[56948156,56948201,56948097],"length":1,"stats":{"Line":8}},{"line":429,"address":[55626141,55626082],"length":1,"stats":{"Line":8}},{"line":430,"address":[54794132,54794204],"length":1,"stats":{"Line":4}},{"line":431,"address":[55626352,55626293,55626397],"length":1,"stats":{"Line":8}},{"line":432,"address":[54794262,54794321],"length":1,"stats":{"Line":8}},{"line":433,"address":[55626585,55626657],"length":1,"stats":{"Line":4}},{"line":434,"address":[55626634,55626693],"length":1,"stats":{"Line":8}},{"line":435,"address":[56948941,56949013],"length":1,"stats":{"Line":4}},{"line":436,"address":[54794886,54794782,54794841],"length":1,"stats":{"Line":10}},{"line":437,"address":[4777163],"length":1,"stats":{"Line":4}},{"line":438,"address":[54795097,54795025],"length":1,"stats":{"Line":2}},{"line":439,"address":[52704799,52704858],"length":1,"stats":{"Line":4}},{"line":440,"address":[4776704],"length":1,"stats":{"Line":2}},{"line":441,"address":[56949493,56949552],"length":1,"stats":{"Line":4}},{"line":442,"address":[56949655],"length":1,"stats":{"Line":2}},{"line":443,"address":[54795626],"length":1,"stats":{"Line":2}},{"line":444,"address":[54795828,54795756],"length":1,"stats":{"Line":2}},{"line":445,"address":[56950072,56950117,56950013],"length":1,"stats":{"Line":4}},{"line":446,"address":[4776886],"length":1,"stats":{"Line":4}},{"line":447,"address":[52705751,52705692,52705796],"length":1,"stats":{"Line":4}},{"line":448,"address":[54796048,54796107],"length":1,"stats":{"Line":4}},{"line":449,"address":[54796312,54796384],"length":1,"stats":{"Line":2}},{"line":450,"address":[52706145,52706086,52706190],"length":1,"stats":{"Line":4}},{"line":451,"address":[52706167,52706226],"length":1,"stats":{"Line":4}},{"line":452,"address":[56950861,56950933],"length":1,"stats":{"Line":2}},{"line":453,"address":[55628814,55628873],"length":1,"stats":{"Line":4}},{"line":454,"address":[52706661,52706589],"length":1,"stats":{"Line":2}},{"line":455,"address":[55629084,55629025],"length":1,"stats":{"Line":4}},{"line":456,"address":[52706800],"length":1,"stats":{"Line":2}},{"line":457,"address":[56951413],"length":1,"stats":{"Line":2}},{"line":458,"address":[52707060],"length":1,"stats":{"Line":2}},{"line":459,"address":[54797514],"length":1,"stats":{"Line":2}},{"line":460,"address":[54797644],"length":1,"stats":{"Line":2}},{"line":461,"address":[54797823],"length":1,"stats":{"Line":2}},{"line":462,"address":[54797953],"length":1,"stats":{"Line":2}},{"line":463,"address":[52707808],"length":1,"stats":{"Line":2}},{"line":464,"address":[56952421],"length":1,"stats":{"Line":2}},{"line":465,"address":[54798392,54798437],"length":1,"stats":{"Line":2}},{"line":466,"address":[55630535],"length":1,"stats":{"Line":2}},{"line":469,"address":[54785516],"length":1,"stats":{"Line":2}},{"line":470,"address":[56940467,56939759,56940405],"length":1,"stats":{"Line":6}},{"line":471,"address":[55618344],"length":1,"stats":{"Line":2}},{"line":472,"address":[56940370,56940569,56940507],"length":1,"stats":{"Line":6}},{"line":473,"address":[55618446],"length":1,"stats":{"Line":2}},{"line":474,"address":[56940583,56940472],"length":1,"stats":{"Line":2}},{"line":475,"address":[56940585],"length":1,"stats":{"Line":2}},{"line":477,"address":[54786363],"length":1,"stats":{"Line":0}},{"line":480,"address":[56939920],"length":1,"stats":{"Line":2}},{"line":481,"address":[54798553,54798615,54785732],"length":1,"stats":{"Line":6}},{"line":482,"address":[56952796],"length":1,"stats":{"Line":2}},{"line":483,"address":[56952840,56952718,56952915],"length":1,"stats":{"Line":0}},{"line":484,"address":[4756548,4756479],"length":1,"stats":{"Line":0}},{"line":486,"address":[52708345],"length":1,"stats":{"Line":0}},{"line":489,"address":[56940022],"length":1,"stats":{"Line":2}},{"line":490,"address":[55630881,55617972,55630832],"length":1,"stats":{"Line":6}},{"line":491,"address":[56952950],"length":1,"stats":{"Line":2}},{"line":492,"address":[54798832,54798782,54798734,54798800],"length":1,"stats":{"Line":6}},{"line":493,"address":[56953013],"length":1,"stats":{"Line":2}},{"line":495,"address":[52708513],"length":1,"stats":{"Line":0}},{"line":498,"address":[54785884],"length":1,"stats":{"Line":2}},{"line":499,"address":[56940130,56953088],"length":1,"stats":{"Line":4}},{"line":500,"address":[56953061],"length":1,"stats":{"Line":2}},{"line":501,"address":[4757042,4756954,4757027],"length":1,"stats":{"Line":6}},{"line":502,"address":[4757035],"length":1,"stats":{"Line":2}},{"line":504,"address":[54798917],"length":1,"stats":{"Line":2}},{"line":507,"address":[4757098],"length":1,"stats":{"Line":0}},{"line":508,"address":[54785672],"length":1,"stats":{"Line":2}},{"line":511,"address":[56940210],"length":1,"stats":{"Line":2}},{"line":513,"address":[4757258],"length":1,"stats":{"Line":0}},{"line":514,"address":[54785774],"length":1,"stats":{"Line":2}},{"line":517,"address":[56940274],"length":1,"stats":{"Line":2}},{"line":519,"address":[4757465],"length":1,"stats":{"Line":0}},{"line":520,"address":[54786034],"length":1,"stats":{"Line":2}},{"line":523,"address":[52695825],"length":1,"stats":{"Line":2}},{"line":525,"address":[4757482],"length":1,"stats":{"Line":0}},{"line":526,"address":[54785938],"length":1,"stats":{"Line":2}},{"line":528,"address":[4757609],"length":1,"stats":{"Line":0}},{"line":529,"address":[54785970],"length":1,"stats":{"Line":2}},{"line":532,"address":[55618242],"length":1,"stats":{"Line":2}},{"line":534,"address":[56939699],"length":1,"stats":{"Line":0}},{"line":539,"address":[55617514,55615760,55617492],"length":1,"stats":{"Line":3}},{"line":540,"address":[56937919],"length":1,"stats":{"Line":3}},{"line":541,"address":[54783838,54783759,54783730],"length":1,"stats":{"Line":12}},{"line":542,"address":[54783749],"length":1,"stats":{"Line":2}},{"line":545,"address":[55615968],"length":1,"stats":{"Line":4}},{"line":546,"address":[55615975,55616022],"length":1,"stats":{"Line":4}},{"line":549,"address":[54783902],"length":1,"stats":{"Line":4}},{"line":550,"address":[54784013],"length":1,"stats":{"Line":2}},{"line":552,"address":[54783979,54784476],"length":1,"stats":{"Line":6}},{"line":553,"address":[54784776],"length":1,"stats":{"Line":4}},{"line":554,"address":[52694653],"length":1,"stats":{"Line":4}},{"line":557,"address":[52694600],"length":1,"stats":{"Line":4}}],"covered":202,"coverable":216},{"path":["/","home","md","language","mdhavers","src","formatter.rs"],"content":"//! Pretty printer fer mdhavers code\n//! Makes yer code look braw and proper!\n\nuse crate::ast::*;\n\n/// Configuration fer the formatter\n#[allow(dead_code)]\npub struct FormatterConfig {\n    /// Number o' spaces fer indentation\n    pub indent_size: usize,\n    /// Maximum line width before we wrap\n    pub max_line_width: usize,\n}\n\nimpl Default for FormatterConfig {\n    fn default() -> Self {\n        FormatterConfig {\n            indent_size: 4,\n            max_line_width: 100,\n        }\n    }\n}\n\n/// The formatter itself\npub struct Formatter {\n    config: FormatterConfig,\n    output: String,\n    indent_level: usize,\n}\n\nimpl Default for Formatter {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Formatter {\n    pub fn new() -> Self {\n        Formatter::with_config(FormatterConfig::default())\n    }\n\n    pub fn with_config(config: FormatterConfig) -> Self {\n        Formatter {\n            config,\n            output: String::new(),\n            indent_level: 0,\n        }\n    }\n\n    /// Format a whole program\n    pub fn format(&mut self, program: &Program) -> String {\n        self.output.clear();\n        self.indent_level = 0;\n\n        for (i, stmt) in program.statements.iter().enumerate() {\n            self.format_stmt(stmt);\n\n            // Add blank line between top-level declarations\n            if i < program.statements.len() - 1 {\n                // Add extra newline after functions and classes\n                match stmt {\n                    Stmt::Function { .. } | Stmt::Class { .. } => {\n                        self.output.push('\\n');\n                    }\n                    _ => {}\n                }\n            }\n        }\n\n        // Ensure file ends with newline\n        if !self.output.ends_with('\\n') {\n            self.output.push('\\n');\n        }\n\n        self.output.clone()\n    }\n\n    fn indent(&self) -> String {\n        \" \".repeat(self.config.indent_size * self.indent_level)\n    }\n\n    fn write(&mut self, s: &str) {\n        self.output.push_str(s);\n    }\n\n    fn writeln(&mut self, s: &str) {\n        self.output.push_str(&self.indent());\n        self.output.push_str(s);\n        self.output.push('\\n');\n    }\n\n    fn format_stmt(&mut self, stmt: &Stmt) {\n        match stmt {\n            Stmt::VarDecl {\n                name, initializer, ..\n            } => {\n                let init = if let Some(expr) = initializer {\n                    format!(\" = {}\", self.format_expr(expr))\n                } else {\n                    String::new()\n                };\n                self.writeln(&format!(\"ken {}{}\", name, init));\n            }\n\n            Stmt::Expression { expr, .. } => {\n                self.writeln(&self.format_expr(expr));\n            }\n\n            Stmt::Block { statements, .. } => {\n                self.writeln(\"{\");\n                self.indent_level += 1;\n                for s in statements {\n                    self.format_stmt(s);\n                }\n                self.indent_level -= 1;\n                self.writeln(\"}\");\n            }\n\n            Stmt::If {\n                condition,\n                then_branch,\n                else_branch,\n                ..\n            } => {\n                let cond = self.format_expr(condition);\n                self.write(&self.indent());\n                self.write(&format!(\"gin {} \", cond));\n                self.format_stmt_inline(then_branch);\n\n                if let Some(else_stmt) = else_branch {\n                    self.write(\" ither \");\n                    self.format_stmt_inline(else_stmt);\n                }\n                self.output.push('\\n');\n            }\n\n            Stmt::While {\n                condition, body, ..\n            } => {\n                let cond = self.format_expr(condition);\n                self.write(&self.indent());\n                self.write(&format!(\"whiles {} \", cond));\n                self.format_stmt_inline(body);\n                self.output.push('\\n');\n            }\n\n            Stmt::For {\n                variable,\n                iterable,\n                body,\n                ..\n            } => {\n                let iter = self.format_expr(iterable);\n                self.write(&self.indent());\n                self.write(&format!(\"fer {} in {} \", variable, iter));\n                self.format_stmt_inline(body);\n                self.output.push('\\n');\n            }\n\n            Stmt::Function {\n                name, params, body, ..\n            } => {\n                let params_str = self.format_params(params);\n                self.writeln(&format!(\"dae {}({}) {{\", name, params_str));\n                self.indent_level += 1;\n                for s in body {\n                    self.format_stmt(s);\n                }\n                self.indent_level -= 1;\n                self.writeln(\"}\");\n            }\n\n            Stmt::Return { value, .. } => {\n                if let Some(expr) = value {\n                    self.writeln(&format!(\"gie {}\", self.format_expr(expr)));\n                } else {\n                    self.writeln(\"gie\");\n                }\n            }\n\n            Stmt::Print { value, .. } => {\n                self.writeln(&format!(\"blether {}\", self.format_expr(value)));\n            }\n\n            Stmt::Break { .. } => {\n                self.writeln(\"brak\");\n            }\n\n            Stmt::Continue { .. } => {\n                self.writeln(\"haud\");\n            }\n\n            Stmt::Class {\n                name,\n                superclass,\n                methods,\n                ..\n            } => {\n                let inheritance = if let Some(parent) = superclass {\n                    format!(\" fae {}\", parent)\n                } else {\n                    String::new()\n                };\n                self.writeln(&format!(\"kin {}{} {{\", name, inheritance));\n                self.indent_level += 1;\n                for (i, method) in methods.iter().enumerate() {\n                    self.format_stmt(method);\n                    // Add blank line between methods\n                    if i < methods.len() - 1 {\n                        self.output.push('\\n');\n                    }\n                }\n                self.indent_level -= 1;\n                self.writeln(\"}\");\n            }\n\n            Stmt::Struct { name, fields, .. } => {\n                let fields_str = fields.join(\", \");\n                self.writeln(&format!(\"thing {} {{ {} }}\", name, fields_str));\n            }\n\n            Stmt::Import { path, alias, .. } => {\n                if let Some(a) = alias {\n                    self.writeln(&format!(\"fetch \\\"{}\\\" as {}\", path, a));\n                } else {\n                    self.writeln(&format!(\"fetch \\\"{}\\\"\", path));\n                }\n            }\n\n            Stmt::TryCatch {\n                try_block,\n                error_name,\n                catch_block,\n                ..\n            } => {\n                self.write(&self.indent());\n                self.write(\"hae_a_bash \");\n                self.format_stmt_inline(try_block);\n                self.write(&format!(\" gin_it_gangs_wrang {} \", error_name));\n                self.format_stmt_inline(catch_block);\n                self.output.push('\\n');\n            }\n\n            Stmt::Match { value, arms, .. } => {\n                let val = self.format_expr(value);\n                self.writeln(&format!(\"keek {} {{\", val));\n                self.indent_level += 1;\n                for arm in arms {\n                    self.format_match_arm(arm);\n                }\n                self.indent_level -= 1;\n                self.writeln(\"}\");\n            }\n\n            Stmt::Assert {\n                condition, message, ..\n            } => {\n                let cond = self.format_expr(condition);\n                if let Some(msg) = message {\n                    let msg_str = self.format_expr(msg);\n                    self.writeln(&format!(\"mak_siccar {}, {}\", cond, msg_str));\n                } else {\n                    self.writeln(&format!(\"mak_siccar {}\", cond));\n                }\n            }\n\n            Stmt::Destructure {\n                patterns, value, ..\n            } => {\n                let patterns_str = self.format_destruct_patterns(patterns);\n                let val_str = self.format_expr(value);\n                self.writeln(&format!(\"ken [{}] = {}\", patterns_str, val_str));\n            }\n\n            Stmt::Log { level, message, .. } => {\n                let keyword = match level {\n                    crate::ast::LogLevel::Wheesht => \"log_wheesht\",\n                    crate::ast::LogLevel::Roar => \"log_roar\",\n                    crate::ast::LogLevel::Holler => \"log_holler\",\n                    crate::ast::LogLevel::Blether => \"log_blether\",\n                    crate::ast::LogLevel::Mutter => \"log_mutter\",\n                    crate::ast::LogLevel::Whisper => \"log_whisper\",\n                };\n                let msg = self.format_expr(message);\n                self.writeln(&format!(\"{} {}\", keyword, msg));\n            }\n\n            Stmt::Hurl { message, .. } => {\n                let msg = self.format_expr(message);\n                self.writeln(&format!(\"hurl {}\", msg));\n            }\n        }\n    }\n\n    /// Format destructuring patterns\n    fn format_destruct_patterns(&self, patterns: &[DestructPattern]) -> String {\n        patterns\n            .iter()\n            .map(|p| match p {\n                DestructPattern::Variable(name) => name.clone(),\n                DestructPattern::Rest(name) => format!(\"...{}\", name),\n                DestructPattern::Ignore => \"_\".to_string(),\n            })\n            .collect::<Vec<_>>()\n            .join(\", \")\n    }\n\n    /// Format a statement inline (without adding its own newline)\n    fn format_stmt_inline(&mut self, stmt: &Stmt) {\n        match stmt {\n            Stmt::Block { statements, .. } => {\n                self.write(\"{\\n\");\n                self.indent_level += 1;\n                for s in statements {\n                    self.format_stmt(s);\n                }\n                self.indent_level -= 1;\n                self.write(&self.indent());\n                self.write(\"}\");\n            }\n            _ => {\n                // For single statements, wrap in block\n                self.write(\"{ \");\n                let formatted = self.format_stmt_single(stmt);\n                self.write(&formatted);\n                self.write(\" }\");\n            }\n        }\n    }\n\n    /// Format a single statement without newlines\n    fn format_stmt_single(&self, stmt: &Stmt) -> String {\n        match stmt {\n            Stmt::VarDecl {\n                name, initializer, ..\n            } => {\n                if let Some(expr) = initializer {\n                    format!(\"ken {} = {}\", name, self.format_expr(expr))\n                } else {\n                    format!(\"ken {}\", name)\n                }\n            }\n            Stmt::Expression { expr, .. } => self.format_expr(expr),\n            Stmt::Return { value, .. } => {\n                if let Some(expr) = value {\n                    format!(\"gie {}\", self.format_expr(expr))\n                } else {\n                    \"gie\".to_string()\n                }\n            }\n            Stmt::Print { value, .. } => format!(\"blether {}\", self.format_expr(value)),\n            Stmt::Break { .. } => \"brak\".to_string(),\n            Stmt::Continue { .. } => \"haud\".to_string(),\n            _ => \"...\".to_string(), // Complex statements should use blocks\n        }\n    }\n\n    fn format_match_arm(&mut self, arm: &MatchArm) {\n        let pattern = self.format_pattern(&arm.pattern);\n        self.write(&self.indent());\n        self.write(&format!(\"whan {} -> \", pattern));\n        self.format_stmt_inline(&arm.body);\n        self.output.push('\\n');\n    }\n\n    fn format_pattern(&self, pattern: &Pattern) -> String {\n        match pattern {\n            Pattern::Literal(lit) => format!(\"{}\", lit),\n            Pattern::Identifier(name) => name.clone(),\n            Pattern::Wildcard => \"_\".to_string(),\n            Pattern::Range { start, end } => {\n                format!(\"{}..{}\", self.format_expr(start), self.format_expr(end))\n            }\n        }\n    }\n\n    /// Format function parameters, handling default values\n    fn format_params(&self, params: &[Param]) -> String {\n        params\n            .iter()\n            .map(|p| {\n                if let Some(default) = &p.default {\n                    format!(\"{} = {}\", p.name, self.format_expr(default))\n                } else {\n                    p.name.clone()\n                }\n            })\n            .collect::<Vec<_>>()\n            .join(\", \")\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    fn format_expr(&self, expr: &Expr) -> String {\n        match expr {\n            Expr::Literal { value, .. } => format!(\"{}\", value),\n\n            Expr::Variable { name, .. } => name.clone(),\n\n            Expr::Assign { name, value, .. } => {\n                format!(\"{} = {}\", name, self.format_expr(value))\n            }\n\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                format!(\n                    \"{} {} {}\",\n                    self.format_expr(left),\n                    operator,\n                    self.format_expr(right)\n                )\n            }\n\n            Expr::Unary {\n                operator, operand, ..\n            } => match operator {\n                UnaryOp::Not => format!(\"nae {}\", self.format_expr(operand)),\n                UnaryOp::Negate => format!(\"-{}\", self.format_expr(operand)),\n            },\n\n            Expr::Logical {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                format!(\n                    \"{} {} {}\",\n                    self.format_expr(left),\n                    operator,\n                    self.format_expr(right)\n                )\n            }\n\n            Expr::Call {\n                callee, arguments, ..\n            } => {\n                let args: Vec<String> = arguments.iter().map(|a| self.format_expr(a)).collect();\n                format!(\"{}({})\", self.format_expr(callee), args.join(\", \"))\n            }\n\n            Expr::Get {\n                object, property, ..\n            } => {\n                format!(\"{}.{}\", self.format_expr(object), property)\n            }\n\n            Expr::Set {\n                object,\n                property,\n                value,\n                ..\n            } => {\n                format!(\n                    \"{}.{} = {}\",\n                    self.format_expr(object),\n                    property,\n                    self.format_expr(value)\n                )\n            }\n\n            Expr::Index { object, index, .. } => {\n                format!(\"{}[{}]\", self.format_expr(object), self.format_expr(index))\n            }\n\n            Expr::IndexSet {\n                object,\n                index,\n                value,\n                ..\n            } => {\n                format!(\n                    \"{}[{}] = {}\",\n                    self.format_expr(object),\n                    self.format_expr(index),\n                    self.format_expr(value)\n                )\n            }\n\n            Expr::Slice {\n                object,\n                start,\n                end,\n                step,\n                ..\n            } => {\n                let start_str = start\n                    .as_ref()\n                    .map(|s| self.format_expr(s))\n                    .unwrap_or_default();\n                let end_str = end\n                    .as_ref()\n                    .map(|e| self.format_expr(e))\n                    .unwrap_or_default();\n                if let Some(st) = step {\n                    format!(\n                        \"{}[{}:{}:{}]\",\n                        self.format_expr(object),\n                        start_str,\n                        end_str,\n                        self.format_expr(st)\n                    )\n                } else {\n                    format!(\"{}[{}:{}]\", self.format_expr(object), start_str, end_str)\n                }\n            }\n\n            Expr::List { elements, .. } => {\n                let elems: Vec<String> = elements.iter().map(|e| self.format_expr(e)).collect();\n                format!(\"[{}]\", elems.join(\", \"))\n            }\n\n            Expr::Dict { pairs, .. } => {\n                let kvs: Vec<String> = pairs\n                    .iter()\n                    .map(|(k, v)| format!(\"{}: {}\", self.format_expr(k), self.format_expr(v)))\n                    .collect();\n                format!(\"{{{}}}\", kvs.join(\", \"))\n            }\n\n            Expr::Range {\n                start,\n                end,\n                inclusive,\n                ..\n            } => {\n                let op = if *inclusive { \"..=\" } else { \"..\" };\n                format!(\"{}{}{}\", self.format_expr(start), op, self.format_expr(end))\n            }\n\n            Expr::Grouping { expr, .. } => {\n                format!(\"({})\", self.format_expr(expr))\n            }\n\n            Expr::Lambda { params, body, .. } => {\n                let params_str = params.join(\", \");\n                format!(\"|{}| {}\", params_str, self.format_expr(body))\n            }\n\n            Expr::Masel { .. } => \"masel\".to_string(),\n\n            Expr::Input { prompt, .. } => {\n                format!(\"speir {}\", self.format_expr(prompt))\n            }\n\n            Expr::FString { parts, .. } => {\n                let mut result = String::from(\"f\\\"\");\n                for part in parts {\n                    match part {\n                        FStringPart::Text(s) => result.push_str(s),\n                        FStringPart::Expr(e) => {\n                            result.push('{');\n                            result.push_str(&self.format_expr(e));\n                            result.push('}');\n                        }\n                    }\n                }\n                result.push('\"');\n                result\n            }\n\n            Expr::Spread { expr, .. } => {\n                format!(\"...{}\", self.format_expr(expr))\n            }\n\n            Expr::Pipe { left, right, .. } => {\n                format!(\"{} |> {}\", self.format_expr(left), self.format_expr(right))\n            }\n\n            Expr::Ternary {\n                condition,\n                then_expr,\n                else_expr,\n                ..\n            } => {\n                format!(\n                    \"gin {} than {} ither {}\",\n                    self.format_expr(condition),\n                    self.format_expr(then_expr),\n                    self.format_expr(else_expr)\n                )\n            }\n        }\n    }\n}\n\n/// Format source code (convenience function)\npub fn format_source(source: &str) -> Result<String, crate::error::HaversError> {\n    let program = crate::parser::parse(source)?;\n    let mut formatter = Formatter::new();\n    Ok(formatter.format(&program))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::parser::parse;\n\n    // ==================== FormatterConfig Tests ====================\n\n    #[test]\n    fn test_formatter_config_default() {\n        let config = FormatterConfig::default();\n        assert_eq!(config.indent_size, 4);\n        assert_eq!(config.max_line_width, 100);\n    }\n\n    #[test]\n    fn test_formatter_with_config() {\n        let config = FormatterConfig {\n            indent_size: 2,\n            max_line_width: 80,\n        };\n        let formatter = Formatter::with_config(config);\n        assert_eq!(formatter.config.indent_size, 2);\n    }\n\n    // ==================== Variable Declaration Tests ====================\n\n    #[test]\n    fn test_format_variable() {\n        let source = \"ken   x   =    42\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert_eq!(result.trim(), \"ken x = 42\");\n    }\n\n    #[test]\n    fn test_format_variable_no_initializer() {\n        let source = \"ken x\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert_eq!(result.trim(), \"ken x\");\n    }\n\n    // ==================== Function Tests ====================\n\n    #[test]\n    fn test_format_function() {\n        let source = \"dae greet(name){blether name}\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"dae greet(name) {\"));\n        assert!(result.contains(\"    blether name\"));\n        assert!(result.contains(\"}\"));\n    }\n\n    #[test]\n    fn test_format_function_with_defaults() {\n        let source = \"dae foo(a, b = 10, c = \\\"test\\\") { gie a + b }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"dae foo(a, b = 10, c = \\\"test\\\") {\"));\n    }\n\n    #[test]\n    fn test_format_multiple_functions_extra_newline() {\n        let source = r#\"dae foo() { gie 1 }\ndae bar() { gie 2 }\"#;\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        // Should have extra blank line between functions\n        assert!(result.contains(\"}\\n\\ndae bar\"));\n    }\n\n    // ==================== Control Flow Tests ====================\n\n    #[test]\n    fn test_format_if_else() {\n        let source = \"gin x > 5 {blether \\\"big\\\"} ither {blether \\\"wee\\\"}\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"gin x > 5 {\"));\n        assert!(result.contains(\"} ither {\"));\n    }\n\n    #[test]\n    fn test_format_if_no_else() {\n        let source = \"gin x > 5 { blether \\\"big\\\" }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"gin x > 5 {\"));\n        assert!(!result.contains(\"ither\"));\n    }\n\n    #[test]\n    fn test_format_while() {\n        let source = \"whiles x < 10 { ken x = x + 1 }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"whiles x < 10 {\"));\n    }\n\n    #[test]\n    fn test_format_for() {\n        let source = \"fer i in 0..10 { blether i }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"fer i in 0..10 {\"));\n    }\n\n    #[test]\n    fn test_format_break() {\n        let source = \"whiles aye { brak }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"brak\"));\n    }\n\n    #[test]\n    fn test_format_continue() {\n        let source = \"whiles aye { haud }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"haud\"));\n    }\n\n    // ==================== Return Statement Tests ====================\n\n    #[test]\n    fn test_format_return_with_value() {\n        let source = \"dae foo() { gie 42 }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"gie 42\"));\n    }\n\n    #[test]\n    fn test_format_return_no_value() {\n        // Return without value needs newline before closing brace\n        let source = \"dae foo() {\\n    gie\\n}\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"    gie\\n\"));\n    }\n\n    // ==================== Class Tests ====================\n\n    #[test]\n    fn test_format_class() {\n        let source = \"kin Animal {dae init(name){masel.name = name}}\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"kin Animal {\"));\n        assert!(result.contains(\"dae init(name) {\"));\n    }\n\n    #[test]\n    fn test_format_class_with_inheritance() {\n        let source = \"kin Dog fae Animal { dae bark() { blether \\\"woof\\\" } }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"kin Dog fae Animal {\"));\n    }\n\n    #[test]\n    fn test_format_class_multiple_methods() {\n        let source = \"kin Calc { dae add(a,b) { gie a+b } dae sub(a,b) { gie a-b } }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"dae add(a, b)\"));\n        assert!(result.contains(\"dae sub(a, b)\"));\n        // Blank line between methods\n        assert!(result.contains(\"}\\n\\n    dae sub\"));\n    }\n\n    #[test]\n    fn test_format_multiple_classes_extra_newline() {\n        let source = r#\"kin A { dae foo() { gie 1 } }\nkin B { dae bar() { gie 2 } }\"#;\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        // Extra blank line between classes\n        assert!(result.contains(\"}\\n\\nkin B\"));\n    }\n\n    // ==================== Struct Tests ====================\n\n    #[test]\n    fn test_format_struct() {\n        let source = \"thing Point { x, y }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"thing Point { x, y }\"));\n    }\n\n    // ==================== Import Tests ====================\n\n    #[test]\n    fn test_format_import() {\n        let source = \"fetch \\\"math\\\"\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"fetch \\\"math\\\"\"));\n    }\n\n    #[test]\n    fn test_format_import_with_alias() {\n        // Parser uses \"tae\" for aliases, but formatter outputs \"as\"\n        // This test verifies the formatter handles the alias case\n        let source = \"fetch \\\"math\\\" tae m\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        // Note: formatter outputs \"as\" for Scots readability\n        assert!(result.contains(\"fetch \\\"math\\\" as m\"));\n    }\n\n    // ==================== Try-Catch Tests ====================\n\n    #[test]\n    fn test_format_try_catch() {\n        let source = \"hae_a_bash { ken x = 1 / 0 } gin_it_gangs_wrang e { blether e }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"hae_a_bash {\"));\n        assert!(result.contains(\"gin_it_gangs_wrang e {\"));\n    }\n\n    // ==================== Match Statement Tests ====================\n\n    #[test]\n    fn test_format_match() {\n        let source = r#\"keek x {\n            whan 1 -> blether \"one\"\n            whan 2 -> blether \"two\"\n            whan _ -> blether \"other\"\n        }\"#;\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"keek x {\"));\n        assert!(result.contains(\"whan 1 ->\"));\n        assert!(result.contains(\"whan 2 ->\"));\n        assert!(result.contains(\"whan _ ->\"));\n    }\n\n    #[test]\n    fn test_format_match_range_pattern() {\n        let source = r#\"keek x {\n            whan 1..10 -> blether \"range\"\n            whan _ -> blether \"other\"\n        }\"#;\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"whan 1..10 ->\"));\n    }\n\n    // ==================== Assert Tests ====================\n\n    #[test]\n    fn test_format_assert() {\n        let source = \"mak_siccar x > 0\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"mak_siccar x > 0\"));\n    }\n\n    #[test]\n    fn test_format_assert_with_message() {\n        let source = \"mak_siccar x > 0, \\\"x must be positive\\\"\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"mak_siccar x > 0, \\\"x must be positive\\\"\"));\n    }\n\n    // ==================== Destructuring Tests ====================\n\n    #[test]\n    fn test_format_destructure_simple() {\n        let source = \"ken [a, b] = [1, 2]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"ken [a, b] = [1, 2]\"));\n    }\n\n    #[test]\n    fn test_format_destructure_with_rest() {\n        let source = \"ken [first, ...rest] = [1, 2, 3, 4]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"ken [first, ...rest] = [1, 2, 3, 4]\"));\n    }\n\n    #[test]\n    fn test_format_destructure_with_ignore() {\n        let source = \"ken [_, second, _] = [1, 2, 3]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"ken [_, second, _] = [1, 2, 3]\"));\n    }\n\n    // ==================== Expression Tests ====================\n\n    #[test]\n    fn test_format_assignment() {\n        let source = \"ken x = 1\\nx = 42\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"x = 42\"));\n    }\n\n    #[test]\n    fn test_format_unary_not() {\n        let source = \"nae aye\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"nae aye\"));\n    }\n\n    #[test]\n    fn test_format_unary_negate() {\n        let source = \"-42\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"-42\"));\n    }\n\n    #[test]\n    fn test_format_logical_and() {\n        let source = \"aye an nae\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"aye an nae\"));\n    }\n\n    #[test]\n    fn test_format_logical_or() {\n        let source = \"aye or nae\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"aye or nae\"));\n    }\n\n    #[test]\n    fn test_format_call() {\n        let source = \"foo(1, 2, 3)\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"foo(1, 2, 3)\"));\n    }\n\n    #[test]\n    fn test_format_get_property() {\n        let source = \"obj.prop\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"obj.prop\"));\n    }\n\n    #[test]\n    fn test_format_set_property() {\n        let source = \"ken obj = {}\\nobj.prop = 42\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"obj.prop = 42\"));\n    }\n\n    #[test]\n    fn test_format_index() {\n        let source = \"list[0]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"list[0]\"));\n    }\n\n    #[test]\n    fn test_format_index_set() {\n        let source = \"ken list = [1,2,3]\\nlist[0] = 99\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"list[0] = 99\"));\n    }\n\n    #[test]\n    fn test_format_slice() {\n        let source = \"list[1:3]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"list[1:3]\"));\n    }\n\n    #[test]\n    fn test_format_slice_with_step() {\n        let source = \"list[::2]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"list[::2]\"));\n    }\n\n    #[test]\n    fn test_format_list() {\n        let source = \"[1, 2, 3]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"[1, 2, 3]\"));\n    }\n\n    #[test]\n    fn test_format_dict() {\n        // Dict must be assigned to variable\n        let source = r#\"ken d = {\"a\": 1, \"b\": 2}\"#;\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        // Dict order may vary\n        assert!(result.contains(\"{\"));\n        assert!(result.contains(\"}\"));\n    }\n\n    #[test]\n    fn test_format_range_exclusive() {\n        let source = \"0..10\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"0..10\"));\n    }\n\n    #[test]\n    fn test_format_range_inclusive() {\n        // Parser currently doesn't support ..= syntax (always creates exclusive ranges)\n        // This test verifies the formatter can output inclusive range syntax\n        // by constructing the AST manually - but since we need parse() for this,\n        // we'll test the output branch indirectly through for loop formatting\n        let source = \"fer i in 0..10 { blether i }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"0..10\"));\n    }\n\n    #[test]\n    fn test_format_grouping() {\n        let source = \"(1 + 2) * 3\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"(1 + 2)\"));\n    }\n\n    #[test]\n    fn test_format_lambda() {\n        let source = \"|x, y| x + y\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"|x, y| x + y\"));\n    }\n\n    #[test]\n    fn test_format_masel() {\n        let source = \"kin Foo { dae test() { gie masel } }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"masel\"));\n    }\n\n    #[test]\n    fn test_format_input() {\n        let source = \"speir \\\"What is your name? \\\"\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"speir \\\"What is your name? \\\"\"));\n    }\n\n    #[test]\n    fn test_format_fstring() {\n        let source = \"ken name = \\\"world\\\"\\nf\\\"Hello {name}!\\\"\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"f\\\"Hello {name}!\\\"\"));\n    }\n\n    #[test]\n    fn test_format_spread() {\n        let source = \"[1, 2, ...[3, 4]]\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"...[3, 4]\"));\n    }\n\n    #[test]\n    fn test_format_pipe() {\n        let source = \"5 |> double |> triple\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"|>\"));\n    }\n\n    #[test]\n    fn test_format_ternary() {\n        // Ternary expressions must be assigned to a variable\n        let source = \"ken result = gin x > 0 than \\\"positive\\\" ither \\\"non-positive\\\"\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"gin x > 0 than \\\"positive\\\" ither \\\"non-positive\\\"\"));\n    }\n\n    // ==================== Block Statement Tests ====================\n\n    #[test]\n    fn test_format_block() {\n        let source = \"{ ken x = 1\\n ken y = 2 }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"{\\n\"));\n        assert!(result.contains(\"    ken x = 1\"));\n        assert!(result.contains(\"    ken y = 2\"));\n    }\n\n    // ==================== Inline Statement Tests ====================\n    // Note: The parser requires blocks after control flow statements,\n    // so single inline statements are not testable via parsing.\n    // These tests verify the formatter handles block statements correctly\n    // when they contain single statements.\n\n    #[test]\n    fn test_format_single_stmt_in_if() {\n        // Parser requires blocks, but formatter handles them gracefully\n        let source = \"gin aye { ken x = 1 }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"gin aye {\"));\n        assert!(result.contains(\"ken x = 1\"));\n    }\n\n    #[test]\n    fn test_format_single_stmt_return_in_if() {\n        let source = \"gin aye { gie 42 }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"gie 42\"));\n    }\n\n    #[test]\n    fn test_format_single_stmt_print_in_if() {\n        let source = \"gin aye { blether \\\"hi\\\" }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"blether \\\"hi\\\"\"));\n    }\n\n    #[test]\n    fn test_format_single_stmt_break_in_while() {\n        let source = \"whiles aye { brak }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"brak\"));\n    }\n\n    #[test]\n    fn test_format_single_stmt_continue_in_while() {\n        let source = \"whiles aye { haud }\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.contains(\"haud\"));\n    }\n\n    // ==================== File Ending Tests ====================\n\n    #[test]\n    fn test_format_adds_trailing_newline() {\n        let source = \"ken x = 1\";\n        let program = parse(source).unwrap();\n        let mut formatter = Formatter::new();\n        let result = formatter.format(&program);\n        assert!(result.ends_with('\\n'));\n    }\n\n    // ==================== Convenience Function Tests ====================\n\n    #[test]\n    fn test_format_source_function() {\n        let result = format_source(\"ken x=42\").unwrap();\n        assert!(result.contains(\"ken x = 42\"));\n    }\n\n    #[test]\n    fn test_format_source_error() {\n        let result = format_source(\"ken =\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":16,"address":[55716576],"length":1,"stats":{"Line":5}},{"line":32,"address":[55716544],"length":1,"stats":{"Line":0}},{"line":33,"address":[54884440],"length":1,"stats":{"Line":0}},{"line":38,"address":[56209056],"length":1,"stats":{"Line":3}},{"line":39,"address":[56209070],"length":1,"stats":{"Line":4}},{"line":42,"address":[55576048],"length":1,"stats":{"Line":5}},{"line":45,"address":[54909921],"length":1,"stats":{"Line":4}},{"line":51,"address":[54913936],"length":1,"stats":{"Line":5}},{"line":52,"address":[55746099],"length":1,"stats":{"Line":4}},{"line":53,"address":[54914002],"length":1,"stats":{"Line":5}},{"line":55,"address":[55580138,55580215],"length":1,"stats":{"Line":9}},{"line":56,"address":[56209407],"length":1,"stats":{"Line":4}},{"line":59,"address":[55746318,55746443],"length":1,"stats":{"Line":8}},{"line":61,"address":[55746471],"length":1,"stats":{"Line":2}},{"line":63,"address":[54914433],"length":1,"stats":{"Line":3}},{"line":71,"address":[55746349],"length":1,"stats":{"Line":3}},{"line":72,"address":[54914268],"length":1,"stats":{"Line":0}},{"line":75,"address":[55746407],"length":1,"stats":{"Line":3}},{"line":78,"address":[55746576],"length":1,"stats":{"Line":2}},{"line":79,"address":[55746595,55746650],"length":1,"stats":{"Line":3}},{"line":82,"address":[55746000],"length":1,"stats":{"Line":3}},{"line":83,"address":[55746018],"length":1,"stats":{"Line":3}},{"line":86,"address":[54914769,54914560,54914763],"length":1,"stats":{"Line":2}},{"line":87,"address":[55746722],"length":1,"stats":{"Line":2}},{"line":88,"address":[55746836],"length":1,"stats":{"Line":4}},{"line":89,"address":[55580869],"length":1,"stats":{"Line":6}},{"line":92,"address":[54900461,54898112,54900455],"length":1,"stats":{"Line":6}},{"line":93,"address":[56193462],"length":1,"stats":{"Line":4}},{"line":94,"address":[55730361],"length":1,"stats":{"Line":4}},{"line":97,"address":[55732289,55730399],"length":1,"stats":{"Line":8}},{"line":98,"address":[55732313,55732363],"length":1,"stats":{"Line":4}},{"line":100,"address":[55732345],"length":1,"stats":{"Line":2}},{"line":102,"address":[56195700,56195803],"length":1,"stats":{"Line":8}},{"line":105,"address":[55730457],"length":1,"stats":{"Line":2}},{"line":106,"address":[55567005,55564581],"length":1,"stats":{"Line":2}},{"line":109,"address":[55730540],"length":1,"stats":{"Line":2}},{"line":110,"address":[55564656],"length":1,"stats":{"Line":2}},{"line":111,"address":[55567147,55564681,55567120],"length":1,"stats":{"Line":4}},{"line":112,"address":[55733073,55733036],"length":1,"stats":{"Line":4}},{"line":113,"address":[55567236],"length":1,"stats":{"Line":2}},{"line":115,"address":[55567318,55567251],"length":1,"stats":{"Line":2}},{"line":116,"address":[54901098],"length":1,"stats":{"Line":2}},{"line":119,"address":[55564768],"length":1,"stats":{"Line":2}},{"line":125,"address":[54898588],"length":1,"stats":{"Line":2}},{"line":126,"address":[55564817,55567383],"length":1,"stats":{"Line":6}},{"line":127,"address":[55567497],"length":1,"stats":{"Line":4}},{"line":128,"address":[56196845],"length":1,"stats":{"Line":4}},{"line":130,"address":[55567873],"length":1,"stats":{"Line":4}},{"line":131,"address":[54901725],"length":1,"stats":{"Line":2}},{"line":132,"address":[56197065],"length":1,"stats":{"Line":2}},{"line":134,"address":[55567950],"length":1,"stats":{"Line":2}},{"line":137,"address":[55730747],"length":1,"stats":{"Line":2}},{"line":140,"address":[55564886],"length":1,"stats":{"Line":2}},{"line":141,"address":[56193995,56197249],"length":1,"stats":{"Line":5}},{"line":142,"address":[55568275],"length":1,"stats":{"Line":4}},{"line":143,"address":[56197623],"length":1,"stats":{"Line":4}},{"line":144,"address":[55568651],"length":1,"stats":{"Line":4}},{"line":147,"address":[55564948],"length":1,"stats":{"Line":2}},{"line":153,"address":[56194079],"length":1,"stats":{"Line":2}},{"line":154,"address":[55734655,55730916],"length":1,"stats":{"Line":4}},{"line":155,"address":[55568863],"length":1,"stats":{"Line":2}},{"line":156,"address":[55569182],"length":1,"stats":{"Line":2}},{"line":157,"address":[54903100],"length":1,"stats":{"Line":2}},{"line":160,"address":[55565030],"length":1,"stats":{"Line":6}},{"line":163,"address":[56194168],"length":1,"stats":{"Line":6}},{"line":164,"address":[54898945,54903182],"length":1,"stats":{"Line":4}},{"line":165,"address":[55735649,55735570],"length":1,"stats":{"Line":5}},{"line":166,"address":[54903510,54903573],"length":1,"stats":{"Line":15}},{"line":167,"address":[55569877,55569996],"length":1,"stats":{"Line":10}},{"line":169,"address":[55735878,55735814],"length":1,"stats":{"Line":3}},{"line":170,"address":[56199025],"length":1,"stats":{"Line":3}},{"line":173,"address":[56194283],"length":1,"stats":{"Line":3}},{"line":174,"address":[56199105,56194306],"length":1,"stats":{"Line":6}},{"line":175,"address":[54903851,54903913],"length":1,"stats":{"Line":4}},{"line":177,"address":[55570081],"length":1,"stats":{"Line":2}},{"line":181,"address":[55565276],"length":1,"stats":{"Line":3}},{"line":182,"address":[54899100,54904205],"length":1,"stats":{"Line":5}},{"line":186,"address":[55731255],"length":1,"stats":{"Line":2}},{"line":190,"address":[54899173],"length":1,"stats":{"Line":2}},{"line":193,"address":[55731353],"length":1,"stats":{"Line":3}},{"line":199,"address":[56194556,56199783],"length":1,"stats":{"Line":5}},{"line":200,"address":[55736625],"length":1,"stats":{"Line":2}},{"line":202,"address":[56199919],"length":1,"stats":{"Line":3}},{"line":204,"address":[54904662,54904749],"length":1,"stats":{"Line":10}},{"line":205,"address":[55737216,55737137],"length":1,"stats":{"Line":6}},{"line":206,"address":[56200415,56200355],"length":1,"stats":{"Line":12}},{"line":207,"address":[56200682],"length":1,"stats":{"Line":6}},{"line":209,"address":[56200809],"length":1,"stats":{"Line":6}},{"line":210,"address":[54905654],"length":1,"stats":{"Line":2}},{"line":213,"address":[55737615,55737551],"length":1,"stats":{"Line":3}},{"line":214,"address":[54905484],"length":1,"stats":{"Line":5}},{"line":217,"address":[54899314],"length":1,"stats":{"Line":2}},{"line":218,"address":[54899341],"length":1,"stats":{"Line":2}},{"line":219,"address":[54905722,54899407],"length":1,"stats":{"Line":4}},{"line":222,"address":[56194745],"length":1,"stats":{"Line":3}},{"line":223,"address":[54899491,54906017],"length":1,"stats":{"Line":5}},{"line":224,"address":[56201287,56201715],"length":1,"stats":{"Line":2}},{"line":226,"address":[55738396,55738667],"length":1,"stats":{"Line":2}},{"line":230,"address":[56194841],"length":1,"stats":{"Line":2}},{"line":236,"address":[54906649,54899623],"length":1,"stats":{"Line":2}},{"line":237,"address":[55572912],"length":1,"stats":{"Line":2}},{"line":238,"address":[54907041,54906771],"length":1,"stats":{"Line":2}},{"line":239,"address":[56202308,56202121],"length":1,"stats":{"Line":2}},{"line":240,"address":[55739263,55739386],"length":1,"stats":{"Line":2}},{"line":241,"address":[55739364],"length":1,"stats":{"Line":2}},{"line":244,"address":[55731790],"length":1,"stats":{"Line":4}},{"line":245,"address":[56195021],"length":1,"stats":{"Line":4}},{"line":246,"address":[54907331,54899742],"length":1,"stats":{"Line":8}},{"line":247,"address":[56202818,56202881],"length":1,"stats":{"Line":4}},{"line":248,"address":[54907662,54907610],"length":1,"stats":{"Line":8}},{"line":249,"address":[54907770,54907883],"length":1,"stats":{"Line":7}},{"line":251,"address":[55574001,55573943],"length":1,"stats":{"Line":3}},{"line":252,"address":[56203070],"length":1,"stats":{"Line":3}},{"line":255,"address":[55731892],"length":1,"stats":{"Line":3}},{"line":258,"address":[55731923],"length":1,"stats":{"Line":3}},{"line":259,"address":[56195124,56203150],"length":1,"stats":{"Line":5}},{"line":260,"address":[55740032],"length":1,"stats":{"Line":2}},{"line":261,"address":[55574167,55574251],"length":1,"stats":{"Line":4}},{"line":263,"address":[55740499,55740039],"length":1,"stats":{"Line":4}},{"line":267,"address":[55731994],"length":1,"stats":{"Line":2}},{"line":270,"address":[54899917],"length":1,"stats":{"Line":4}},{"line":271,"address":[56195278],"length":1,"stats":{"Line":6}},{"line":272,"address":[56203901,56203985],"length":1,"stats":{"Line":12}},{"line":275,"address":[55732120],"length":1,"stats":{"Line":0}},{"line":276,"address":[55566246],"length":1,"stats":{"Line":0}},{"line":277,"address":[55575191],"length":1,"stats":{"Line":0}},{"line":278,"address":[55575223],"length":1,"stats":{"Line":0}},{"line":279,"address":[55741206],"length":1,"stats":{"Line":0}},{"line":280,"address":[56204369],"length":1,"stats":{"Line":0}},{"line":281,"address":[55575310],"length":1,"stats":{"Line":0}},{"line":282,"address":[56204427],"length":1,"stats":{"Line":0}},{"line":284,"address":[56204483],"length":1,"stats":{"Line":0}},{"line":285,"address":[56204580,56204501],"length":1,"stats":{"Line":0}},{"line":288,"address":[54900098],"length":1,"stats":{"Line":0}},{"line":289,"address":[55566326],"length":1,"stats":{"Line":0}},{"line":290,"address":[55566339,55575811],"length":1,"stats":{"Line":0}},{"line":296,"address":[55579949,55579744,55579955],"length":1,"stats":{"Line":4}},{"line":297,"address":[55579836],"length":1,"stats":{"Line":4}},{"line":299,"address":[53885840,53885877],"length":1,"stats":{"Line":16}},{"line":300,"address":[53885921],"length":1,"stats":{"Line":4}},{"line":301,"address":[54405171],"length":1,"stats":{"Line":2}},{"line":302,"address":[53886070],"length":1,"stats":{"Line":2}},{"line":309,"address":[55744320,55743776,55744314],"length":1,"stats":{"Line":4}},{"line":310,"address":[55743809],"length":1,"stats":{"Line":4}},{"line":311,"address":[55743866],"length":1,"stats":{"Line":2}},{"line":312,"address":[54911771],"length":1,"stats":{"Line":4}},{"line":313,"address":[55743905,55744018,55744040],"length":1,"stats":{"Line":8}},{"line":314,"address":[56207142,56207172],"length":1,"stats":{"Line":8}},{"line":315,"address":[55578145],"length":1,"stats":{"Line":4}},{"line":317,"address":[55744200,55744127],"length":1,"stats":{"Line":4}},{"line":318,"address":[55744213,55744173],"length":1,"stats":{"Line":4}},{"line":319,"address":[55578319],"length":1,"stats":{"Line":4}},{"line":323,"address":[54911821],"length":1,"stats":{"Line":3}},{"line":324,"address":[55743973],"length":1,"stats":{"Line":3}},{"line":325,"address":[54912277,54911871],"length":1,"stats":{"Line":6}},{"line":326,"address":[56207519],"length":1,"stats":{"Line":3}},{"line":332,"address":[55579333,55579339,55578480],"length":1,"stats":{"Line":3}},{"line":333,"address":[56207611],"length":1,"stats":{"Line":3}},{"line":334,"address":[56207717],"length":1,"stats":{"Line":0}},{"line":337,"address":[55744629,55744908],"length":1,"stats":{"Line":0}},{"line":338,"address":[54912995,54912817],"length":1,"stats":{"Line":0}},{"line":340,"address":[55579014],"length":1,"stats":{"Line":0}},{"line":343,"address":[55744686],"length":1,"stats":{"Line":0}},{"line":344,"address":[55744713],"length":1,"stats":{"Line":0}},{"line":345,"address":[54912621,54913218],"length":1,"stats":{"Line":0}},{"line":346,"address":[55579383,55579437],"length":1,"stats":{"Line":0}},{"line":348,"address":[56208505],"length":1,"stats":{"Line":0}},{"line":351,"address":[55579589,55578817],"length":1,"stats":{"Line":3}},{"line":352,"address":[55578879],"length":1,"stats":{"Line":0}},{"line":353,"address":[54912763],"length":1,"stats":{"Line":0}},{"line":354,"address":[55578601],"length":1,"stats":{"Line":0}},{"line":358,"address":[54911641,54911635,54911152],"length":1,"stats":{"Line":4}},{"line":359,"address":[56206428],"length":1,"stats":{"Line":4}},{"line":360,"address":[55743323,55743376],"length":1,"stats":{"Line":4}},{"line":361,"address":[55743469],"length":1,"stats":{"Line":4}},{"line":362,"address":[55577725],"length":1,"stats":{"Line":3}},{"line":363,"address":[54911597],"length":1,"stats":{"Line":3}},{"line":366,"address":[55577263,55576432,55577269],"length":1,"stats":{"Line":4}},{"line":367,"address":[55576475],"length":1,"stats":{"Line":4}},{"line":368,"address":[55576511],"length":1,"stats":{"Line":2}},{"line":369,"address":[56205727],"length":1,"stats":{"Line":0}},{"line":370,"address":[56205759],"length":1,"stats":{"Line":3}},{"line":371,"address":[56205784],"length":1,"stats":{"Line":2}},{"line":372,"address":[56205819,56205858],"length":1,"stats":{"Line":4}},{"line":378,"address":[54910265,54910000,54910259],"length":1,"stats":{"Line":7}},{"line":379,"address":[54910137],"length":1,"stats":{"Line":2}},{"line":381,"address":[54910089],"length":1,"stats":{"Line":12}},{"line":382,"address":[53885483],"length":1,"stats":{"Line":5}},{"line":383,"address":[53885635,53885546],"length":1,"stats":{"Line":2}},{"line":385,"address":[56127169],"length":1,"stats":{"Line":5}},{"line":393,"address":[54887568,54887562,54884912],"length":1,"stats":{"Line":5}},{"line":394,"address":[55551270],"length":1,"stats":{"Line":5}},{"line":395,"address":[55551343],"length":1,"stats":{"Line":6}},{"line":397,"address":[55717326],"length":1,"stats":{"Line":3}},{"line":399,"address":[54885252],"length":1,"stats":{"Line":2}},{"line":400,"address":[55717394,55719329],"length":1,"stats":{"Line":4}},{"line":403,"address":[54885351],"length":1,"stats":{"Line":3}},{"line":409,"address":[54887852,54887800],"length":1,"stats":{"Line":3}},{"line":411,"address":[54885374,54887692,54887589],"length":1,"stats":{"Line":6}},{"line":413,"address":[56183023,56182979],"length":1,"stats":{"Line":6}},{"line":417,"address":[55551738],"length":1,"stats":{"Line":3}},{"line":420,"address":[55554761,55554408],"length":1,"stats":{"Line":4}},{"line":421,"address":[55554446],"length":1,"stats":{"Line":2}},{"line":424,"address":[55717611],"length":1,"stats":{"Line":4}},{"line":430,"address":[56184398,56184346],"length":1,"stats":{"Line":4}},{"line":432,"address":[55720941,55717649,55721044],"length":1,"stats":{"Line":8}},{"line":434,"address":[54888953,54888909],"length":1,"stats":{"Line":8}},{"line":438,"address":[56180951],"length":1,"stats":{"Line":2}},{"line":441,"address":[56126176,56126197],"length":1,"stats":{"Line":6}},{"line":442,"address":[54889430,54889561,54885676],"length":1,"stats":{"Line":6}},{"line":445,"address":[56181086],"length":1,"stats":{"Line":2}},{"line":448,"address":[56185290,56181116],"length":1,"stats":{"Line":4}},{"line":451,"address":[55552067],"length":1,"stats":{"Line":2}},{"line":457,"address":[56185906,56185854],"length":1,"stats":{"Line":2}},{"line":459,"address":[55556555,55556658,55552113],"length":1,"stats":{"Line":4}},{"line":461,"address":[54890465,54890421],"length":1,"stats":{"Line":4}},{"line":465,"address":[55552152],"length":1,"stats":{"Line":2}},{"line":466,"address":[54885907,54890942],"length":1,"stats":{"Line":4}},{"line":469,"address":[55552244],"length":1,"stats":{"Line":2}},{"line":475,"address":[54891852,54891684,54891904],"length":1,"stats":{"Line":2}},{"line":477,"address":[55557687,55557790,55552290],"length":1,"stats":{"Line":4}},{"line":478,"address":[55557811,55557767],"length":1,"stats":{"Line":4}},{"line":479,"address":[56187038],"length":1,"stats":{"Line":2}},{"line":483,"address":[55552367],"length":1,"stats":{"Line":3}},{"line":492,"address":[53885277,53885248],"length":1,"stats":{"Line":7}},{"line":496,"address":[55558535],"length":1,"stats":{"Line":6}},{"line":498,"address":[56187661],"length":1,"stats":{"Line":2}},{"line":499,"address":[54892741,54892793],"length":1,"stats":{"Line":2}},{"line":501,"address":[55724529,55724598],"length":1,"stats":{"Line":4}},{"line":504,"address":[55724737],"length":1,"stats":{"Line":2}},{"line":507,"address":[54892448,54893219],"length":1,"stats":{"Line":4}},{"line":511,"address":[55552502],"length":1,"stats":{"Line":6}},{"line":512,"address":[55718368],"length":1,"stats":{"Line":18}},{"line":513,"address":[55552599,55559920],"length":1,"stats":{"Line":12}},{"line":516,"address":[55552637],"length":1,"stats":{"Line":2}},{"line":517,"address":[55552649],"length":1,"stats":{"Line":2}},{"line":519,"address":[54886442],"length":1,"stats":{"Line":6}},{"line":521,"address":[56181822,56189309],"length":1,"stats":{"Line":4}},{"line":524,"address":[56181883],"length":1,"stats":{"Line":2}},{"line":530,"address":[54894256,54886607],"length":1,"stats":{"Line":4}},{"line":531,"address":[55560526],"length":1,"stats":{"Line":2}},{"line":534,"address":[54886630],"length":1,"stats":{"Line":2}},{"line":535,"address":[55552871,55561144],"length":1,"stats":{"Line":4}},{"line":538,"address":[56181998],"length":1,"stats":{"Line":2}},{"line":539,"address":[54886711],"length":1,"stats":{"Line":2}},{"line":540,"address":[55718867,55727318,55727457],"length":1,"stats":{"Line":6}},{"line":543,"address":[55553020],"length":1,"stats":{"Line":2}},{"line":545,"address":[54886825],"length":1,"stats":{"Line":2}},{"line":546,"address":[54895618,54886840],"length":1,"stats":{"Line":4}},{"line":549,"address":[56182193],"length":1,"stats":{"Line":2}},{"line":550,"address":[55719011],"length":1,"stats":{"Line":2}},{"line":551,"address":[55553158,55562168],"length":1,"stats":{"Line":4}},{"line":552,"address":[55562269],"length":1,"stats":{"Line":2}},{"line":553,"address":[55562432],"length":1,"stats":{"Line":2}},{"line":554,"address":[56191471],"length":1,"stats":{"Line":2}},{"line":555,"address":[54896186],"length":1,"stats":{"Line":2}},{"line":556,"address":[54896285],"length":1,"stats":{"Line":2}},{"line":557,"address":[56191811],"length":1,"stats":{"Line":2}},{"line":561,"address":[55728201],"length":1,"stats":{"Line":2}},{"line":562,"address":[54896124],"length":1,"stats":{"Line":2}},{"line":565,"address":[55553192],"length":1,"stats":{"Line":2}},{"line":566,"address":[56191851,56182295],"length":1,"stats":{"Line":4}},{"line":569,"address":[54887024],"length":1,"stats":{"Line":2}},{"line":570,"address":[55553284,55563043],"length":1,"stats":{"Line":4}},{"line":573,"address":[54887139],"length":1,"stats":{"Line":2}},{"line":579,"address":[55729811,55729659,55729863],"length":1,"stats":{"Line":2}},{"line":581,"address":[55719274,55729460,55729560],"length":1,"stats":{"Line":4}},{"line":582,"address":[54897428,54897466],"length":1,"stats":{"Line":4}},{"line":583,"address":[56192901],"length":1,"stats":{"Line":2}},{"line":591,"address":[55551182,55550800,55551176],"length":1,"stats":{"Line":3}},{"line":592,"address":[56179920],"length":1,"stats":{"Line":4}},{"line":593,"address":[55550994],"length":1,"stats":{"Line":2}},{"line":594,"address":[55551107,55551059],"length":1,"stats":{"Line":4}}],"covered":244,"coverable":273},{"path":["/","home","md","language","mdhavers","src","graphics.rs"],"content":"//! Graphics module for mdhavers using raylib\n//!\n//! Provides immediate-mode graphics with Scots-themed API names.\n//! All graphics functions are prefixed with \"draw_\" for drawing\n//! and \"screen_\" for window/screen operations.\n\n#[cfg(feature = \"graphics\")]\nuse raylib::prelude::*;\n\n#[cfg(feature = \"graphics\")]\nuse std::cell::RefCell;\n\n#[cfg(feature = \"graphics\")]\nuse std::rc::Rc;\n\n#[cfg(feature = \"graphics\")]\nuse crate::value::{NativeFunction, Value};\n\n#[cfg(feature = \"graphics\")]\nthread_local! {\n    static RAYLIB_HANDLE: RefCell<Option<RaylibHandle>> = RefCell::new(None);\n    static RAYLIB_THREAD: RefCell<Option<RaylibThread>> = RefCell::new(None);\n}\n\n/// Register all graphics functions in the interpreter globals\n#[cfg(feature = \"graphics\")]\npub fn register_graphics_functions(globals: &Rc<RefCell<crate::value::Environment>>) {\n    // Window/Screen functions\n    register_screen_functions(globals);\n\n    // Drawing functions\n    register_draw_functions(globals);\n\n    // Input functions\n    register_input_functions(globals);\n\n    // Color helpers\n    register_color_functions(globals);\n\n    // Audio functions\n    register_audio_functions(globals);\n}\n\n#[cfg(feature = \"graphics\")]\nfn register_screen_functions(globals: &Rc<RefCell<crate::value::Environment>>) {\n    use std::cell::RefCell;\n    use std::rc::Rc;\n\n    // screen_open - Open a graphics window\n    globals.borrow_mut().define(\n        \"screen_open\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_open\", 3, |args| {\n            let width = args[0].as_integer().ok_or(\"width must be an integer\")? as i32;\n            let height = args[1].as_integer().ok_or(\"height must be an integer\")? as i32;\n            let title = match &args[2] {\n                Value::String(s) => s.clone(),\n                _ => return Err(\"title must be a string\".to_string()),\n            };\n\n            RAYLIB_HANDLE.with(|h| {\n                if h.borrow().is_some() {\n                    return Err(\"Window already open\".to_string());\n                }\n\n                let (rl, thread) = raylib::init().size(width, height).title(&title).build();\n\n                *h.borrow_mut() = Some(rl);\n                RAYLIB_THREAD.with(|t| *t.borrow_mut() = Some(thread));\n                Ok(Value::Nil)\n            })\n        }))),\n    );\n\n    // screen_close - Close the graphics window\n    globals.borrow_mut().define(\n        \"screen_close\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_close\", 0, |_args| {\n            RAYLIB_HANDLE.with(|h| {\n                *h.borrow_mut() = None;\n            });\n            RAYLIB_THREAD.with(|t| {\n                *t.borrow_mut() = None;\n            });\n            Ok(Value::Nil)\n        }))),\n    );\n\n    // screen_should_close - Check if window should close (X button, ESC)\n    globals.borrow_mut().define(\n        \"screen_should_close\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\n            \"screen_should_close\",\n            0,\n            |_args| {\n                RAYLIB_HANDLE.with(|h| {\n                    let borrowed = h.borrow();\n                    if let Some(rl) = borrowed.as_ref() {\n                        Ok(Value::Bool(rl.window_should_close()))\n                    } else {\n                        Err(\"Window not open\".to_string())\n                    }\n                })\n            },\n        ))),\n    );\n\n    // screen_begin - Begin drawing frame\n    globals.borrow_mut().define(\n        \"screen_begin\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_begin\", 0, |_args| {\n            // Drawing is handled in screen_clear and screen_end\n            Ok(Value::Nil)\n        }))),\n    );\n\n    // screen_end - End drawing frame (swap buffers)\n    globals.borrow_mut().define(\n        \"screen_end\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_end\", 0, |_args| {\n            // Raylib handles this automatically in the draw closure\n            Ok(Value::Nil)\n        }))),\n    );\n\n    // screen_clear - Clear the screen with a color\n    globals.borrow_mut().define(\n        \"screen_clear\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_clear\", 1, |args| {\n            let color = value_to_color(&args[0])?;\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    RAYLIB_THREAD.with(|t| {\n                        let t_borrowed = t.borrow();\n                        if let Some(thread) = t_borrowed.as_ref() {\n                            let mut d = rl.begin_drawing(thread);\n                            d.clear_background(color);\n                        }\n                    });\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // screen_width - Get screen width\n    globals.borrow_mut().define(\n        \"screen_width\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_width\", 0, |_args| {\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Integer(rl.get_screen_width() as i64))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // screen_height - Get screen height\n    globals.borrow_mut().define(\n        \"screen_height\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_height\", 0, |_args| {\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Integer(rl.get_screen_height() as i64))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // screen_fps - Set target FPS\n    globals.borrow_mut().define(\n        \"screen_fps\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"screen_fps\", 1, |args| {\n            let fps = args[0].as_integer().ok_or(\"fps must be an integer\")? as u32;\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    rl.set_target_fps(fps);\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n}\n\n#[cfg(feature = \"graphics\")]\nfn register_draw_functions(globals: &Rc<RefCell<crate::value::Environment>>) {\n    use std::rc::Rc;\n\n    // draw_rect - Draw a filled rectangle\n    globals.borrow_mut().define(\n        \"draw_rect\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"draw_rect\", 5, |args| {\n            let x = args[0].as_integer().ok_or(\"x must be an integer\")? as i32;\n            let y = args[1].as_integer().ok_or(\"y must be an integer\")? as i32;\n            let width = args[2].as_integer().ok_or(\"width must be an integer\")? as i32;\n            let height = args[3].as_integer().ok_or(\"height must be an integer\")? as i32;\n            let color = value_to_color(&args[4])?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    RAYLIB_THREAD.with(|t| {\n                        let t_borrowed = t.borrow();\n                        if let Some(thread) = t_borrowed.as_ref() {\n                            let mut d = rl.begin_drawing(thread);\n                            d.draw_rectangle(x, y, width, height, color);\n                        }\n                    });\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // draw_circle - Draw a filled circle\n    globals.borrow_mut().define(\n        \"draw_circle\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"draw_circle\", 4, |args| {\n            let x = args[0].as_integer().ok_or(\"x must be an integer\")? as i32;\n            let y = args[1].as_integer().ok_or(\"y must be an integer\")? as i32;\n            let radius = args[2].as_integer().ok_or(\"radius must be an integer\")? as f32;\n            let color = value_to_color(&args[3])?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    RAYLIB_THREAD.with(|t| {\n                        let t_borrowed = t.borrow();\n                        if let Some(thread) = t_borrowed.as_ref() {\n                            let mut d = rl.begin_drawing(thread);\n                            d.draw_circle(x, y, radius, color);\n                        }\n                    });\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // draw_line - Draw a line\n    globals.borrow_mut().define(\n        \"draw_line\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"draw_line\", 5, |args| {\n            let x1 = args[0].as_integer().ok_or(\"x1 must be an integer\")? as i32;\n            let y1 = args[1].as_integer().ok_or(\"y1 must be an integer\")? as i32;\n            let x2 = args[2].as_integer().ok_or(\"x2 must be an integer\")? as i32;\n            let y2 = args[3].as_integer().ok_or(\"y2 must be an integer\")? as i32;\n            let color = value_to_color(&args[4])?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    RAYLIB_THREAD.with(|t| {\n                        let t_borrowed = t.borrow();\n                        if let Some(thread) = t_borrowed.as_ref() {\n                            let mut d = rl.begin_drawing(thread);\n                            d.draw_line(x1, y1, x2, y2, color);\n                        }\n                    });\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // draw_text - Draw text at position\n    globals.borrow_mut().define(\n        \"draw_text\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"draw_text\", 5, |args| {\n            let text = match &args[0] {\n                Value::String(s) => s.clone(),\n                _ => return Err(\"text must be a string\".to_string()),\n            };\n            let x = args[1].as_integer().ok_or(\"x must be an integer\")? as i32;\n            let y = args[2].as_integer().ok_or(\"y must be an integer\")? as i32;\n            let size = args[3].as_integer().ok_or(\"size must be an integer\")? as i32;\n            let color = value_to_color(&args[4])?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    RAYLIB_THREAD.with(|t| {\n                        let t_borrowed = t.borrow();\n                        if let Some(thread) = t_borrowed.as_ref() {\n                            let mut d = rl.begin_drawing(thread);\n                            d.draw_text(&text, x, y, size, color);\n                        }\n                    });\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // draw_pixel - Draw a single pixel\n    globals.borrow_mut().define(\n        \"draw_pixel\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"draw_pixel\", 3, |args| {\n            let x = args[0].as_integer().ok_or(\"x must be an integer\")? as i32;\n            let y = args[1].as_integer().ok_or(\"y must be an integer\")? as i32;\n            let color = value_to_color(&args[2])?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let mut borrowed = h.borrow_mut();\n                if let Some(rl) = borrowed.as_mut() {\n                    RAYLIB_THREAD.with(|t| {\n                        let t_borrowed = t.borrow();\n                        if let Some(thread) = t_borrowed.as_ref() {\n                            let mut d = rl.begin_drawing(thread);\n                            d.draw_pixel(x, y, color);\n                        }\n                    });\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n}\n\n#[cfg(feature = \"graphics\")]\nfn register_input_functions(globals: &Rc<RefCell<crate::value::Environment>>) {\n    use std::rc::Rc;\n\n    // key_pressed - Check if a key was pressed this frame\n    globals.borrow_mut().define(\n        \"key_pressed\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"key_pressed\", 1, |args| {\n            let key_name = match &args[0] {\n                Value::String(s) => s.clone(),\n                _ => return Err(\"key name must be a string\".to_string()),\n            };\n\n            let key = string_to_key(&key_name)?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Bool(rl.is_key_pressed(key)))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // key_down - Check if a key is currently held down\n    globals.borrow_mut().define(\n        \"key_down\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"key_down\", 1, |args| {\n            let key_name = match &args[0] {\n                Value::String(s) => s.clone(),\n                _ => return Err(\"key name must be a string\".to_string()),\n            };\n\n            let key = string_to_key(&key_name)?;\n\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Bool(rl.is_key_down(key)))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // mouse_x - Get mouse X position\n    globals.borrow_mut().define(\n        \"mouse_x\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"mouse_x\", 0, |_args| {\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Integer(rl.get_mouse_x() as i64))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // mouse_y - Get mouse Y position\n    globals.borrow_mut().define(\n        \"mouse_y\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"mouse_y\", 0, |_args| {\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Integer(rl.get_mouse_y() as i64))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n\n    // mouse_pressed - Check if mouse button was pressed\n    globals.borrow_mut().define(\n        \"mouse_pressed\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"mouse_pressed\", 1, |args| {\n            let button = args[0].as_integer().ok_or(\"button must be an integer\")? as i32;\n            let mouse_button = match button {\n                0 => MouseButton::MOUSE_BUTTON_LEFT,\n                1 => MouseButton::MOUSE_BUTTON_RIGHT,\n                2 => MouseButton::MOUSE_BUTTON_MIDDLE,\n                _ => return Err(\"Invalid mouse button (use 0=left, 1=right, 2=middle)\".to_string()),\n            };\n\n            RAYLIB_HANDLE.with(|h| {\n                let borrowed = h.borrow();\n                if let Some(rl) = borrowed.as_ref() {\n                    Ok(Value::Bool(rl.is_mouse_button_pressed(mouse_button)))\n                } else {\n                    Err(\"Window not open\".to_string())\n                }\n            })\n        }))),\n    );\n}\n\n#[cfg(feature = \"graphics\")]\nfn register_color_functions(globals: &Rc<RefCell<crate::value::Environment>>) {\n    use std::rc::Rc;\n\n    // rgb - Create a color from RGB values\n    globals.borrow_mut().define(\n        \"rgb\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"rgb\", 3, |args| {\n            let r = args[0].as_integer().ok_or(\"r must be an integer\")?;\n            let g = args[1].as_integer().ok_or(\"g must be an integer\")?;\n            let b = args[2].as_integer().ok_or(\"b must be an integer\")?;\n            Ok(Value::List(std::rc::Rc::new(std::cell::RefCell::new(\n                vec![\n                    Value::Integer(r.clamp(0, 255)),\n                    Value::Integer(g.clamp(0, 255)),\n                    Value::Integer(b.clamp(0, 255)),\n                    Value::Integer(255), // Alpha\n                ],\n            ))))\n        }))),\n    );\n\n    // rgba - Create a color from RGBA values\n    globals.borrow_mut().define(\n        \"rgba\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"rgba\", 4, |args| {\n            let r = args[0].as_integer().ok_or(\"r must be an integer\")?;\n            let g = args[1].as_integer().ok_or(\"g must be an integer\")?;\n            let b = args[2].as_integer().ok_or(\"b must be an integer\")?;\n            let a = args[3].as_integer().ok_or(\"a must be an integer\")?;\n            Ok(Value::List(std::rc::Rc::new(std::cell::RefCell::new(\n                vec![\n                    Value::Integer(r.clamp(0, 255)),\n                    Value::Integer(g.clamp(0, 255)),\n                    Value::Integer(b.clamp(0, 255)),\n                    Value::Integer(a.clamp(0, 255)),\n                ],\n            ))))\n        }))),\n    );\n}\n\n/// Convert a mdhavers Value to a raylib Color\n#[cfg(feature = \"graphics\")]\nfn value_to_color(value: &Value) -> Result<Color, String> {\n    match value {\n        // Named color strings\n        Value::String(name) => string_to_color(name),\n        // [r, g, b] or [r, g, b, a] list\n        Value::List(list) => {\n            let list = list.borrow();\n            if list.len() < 3 {\n                return Err(\"Color list must have at least 3 elements (r, g, b)\".to_string());\n            }\n            let r = list[0].as_integer().ok_or(\"r must be an integer\")? as u8;\n            let g = list[1].as_integer().ok_or(\"g must be an integer\")? as u8;\n            let b = list[2].as_integer().ok_or(\"b must be an integer\")? as u8;\n            let a = if list.len() >= 4 {\n                list[3].as_integer().ok_or(\"a must be an integer\")? as u8\n            } else {\n                255\n            };\n            Ok(Color::new(r, g, b, a))\n        }\n        _ => Err(\"Color must be a string name or [r, g, b] list\".to_string()),\n    }\n}\n\n/// Convert a color name string to a raylib Color\n#[cfg(feature = \"graphics\")]\nfn string_to_color(name: &str) -> Result<Color, String> {\n    match name.to_lowercase().as_str() {\n        \"reid\" | \"red\" => Ok(Color::RED),\n        \"green\" | \"gress\" => Ok(Color::GREEN),\n        \"blue\" | \"blae\" => Ok(Color::BLUE),\n        \"white\" | \"whit\" => Ok(Color::WHITE),\n        \"black\" | \"bleck\" => Ok(Color::BLACK),\n        \"yellow\" | \"yella\" => Ok(Color::YELLOW),\n        \"orange\" | \"orange\" => Ok(Color::ORANGE),\n        \"pink\" | \"pink\" => Ok(Color::PINK),\n        \"purple\" | \"purpie\" => Ok(Color::PURPLE),\n        \"gray\" | \"grey\" => Ok(Color::GRAY),\n        \"darkgray\" | \"derkgrey\" => Ok(Color::DARKGRAY),\n        \"lightgray\" | \"lichtgrey\" => Ok(Color::LIGHTGRAY),\n        \"brown\" | \"broon\" => Ok(Color::BROWN),\n        \"gold\" | \"gowd\" => Ok(Color::GOLD),\n        \"skyblue\" | \"skyblae\" => Ok(Color::SKYBLUE),\n        _ => Err(format!(\"Unknown color: {}\", name)),\n    }\n}\n\n/// Convert a key name string to a raylib KeyboardKey\n#[cfg(feature = \"graphics\")]\nfn string_to_key(name: &str) -> Result<KeyboardKey, String> {\n    match name.to_lowercase().as_str() {\n        \"up\" => Ok(KeyboardKey::KEY_UP),\n        \"down\" => Ok(KeyboardKey::KEY_DOWN),\n        \"left\" => Ok(KeyboardKey::KEY_LEFT),\n        \"right\" => Ok(KeyboardKey::KEY_RIGHT),\n        \"space\" => Ok(KeyboardKey::KEY_SPACE),\n        \"enter\" => Ok(KeyboardKey::KEY_ENTER),\n        \"escape\" | \"esc\" => Ok(KeyboardKey::KEY_ESCAPE),\n        \"a\" => Ok(KeyboardKey::KEY_A),\n        \"b\" => Ok(KeyboardKey::KEY_B),\n        \"c\" => Ok(KeyboardKey::KEY_C),\n        \"d\" => Ok(KeyboardKey::KEY_D),\n        \"e\" => Ok(KeyboardKey::KEY_E),\n        \"f\" => Ok(KeyboardKey::KEY_F),\n        \"g\" => Ok(KeyboardKey::KEY_G),\n        \"h\" => Ok(KeyboardKey::KEY_H),\n        \"i\" => Ok(KeyboardKey::KEY_I),\n        \"j\" => Ok(KeyboardKey::KEY_J),\n        \"k\" => Ok(KeyboardKey::KEY_K),\n        \"l\" => Ok(KeyboardKey::KEY_L),\n        \"m\" => Ok(KeyboardKey::KEY_M),\n        \"n\" => Ok(KeyboardKey::KEY_N),\n        \"o\" => Ok(KeyboardKey::KEY_O),\n        \"p\" => Ok(KeyboardKey::KEY_P),\n        \"q\" => Ok(KeyboardKey::KEY_Q),\n        \"r\" => Ok(KeyboardKey::KEY_R),\n        \"s\" => Ok(KeyboardKey::KEY_S),\n        \"t\" => Ok(KeyboardKey::KEY_T),\n        \"u\" => Ok(KeyboardKey::KEY_U),\n        \"v\" => Ok(KeyboardKey::KEY_V),\n        \"w\" => Ok(KeyboardKey::KEY_W),\n        \"x\" => Ok(KeyboardKey::KEY_X),\n        \"y\" => Ok(KeyboardKey::KEY_Y),\n        \"z\" => Ok(KeyboardKey::KEY_Z),\n        \"0\" => Ok(KeyboardKey::KEY_ZERO),\n        \"1\" => Ok(KeyboardKey::KEY_ONE),\n        \"2\" => Ok(KeyboardKey::KEY_TWO),\n        \"3\" => Ok(KeyboardKey::KEY_THREE),\n        \"4\" => Ok(KeyboardKey::KEY_FOUR),\n        \"5\" => Ok(KeyboardKey::KEY_FIVE),\n        \"6\" => Ok(KeyboardKey::KEY_SIX),\n        \"7\" => Ok(KeyboardKey::KEY_SEVEN),\n        \"8\" => Ok(KeyboardKey::KEY_EIGHT),\n        \"9\" => Ok(KeyboardKey::KEY_NINE),\n        _ => Err(format!(\"Unknown key: {}\", name)),\n    }\n}\n\n// ============================================\n// Audio Functions\n// ============================================\n\n#[cfg(feature = \"graphics\")]\nthread_local! {\n    static AUDIO_INITIALIZED: RefCell<bool> = RefCell::new(false);\n}\n\n#[cfg(feature = \"graphics\")]\nfn register_audio_functions(globals: &Rc<RefCell<crate::value::Environment>>) {\n    use std::rc::Rc;\n\n    // audio_init - Initialize audio device (must be called before playing sounds)\n    globals.borrow_mut().define(\n        \"audio_init\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"audio_init\", 0, |_args| {\n            AUDIO_INITIALIZED.with(|init| {\n                if !*init.borrow() {\n                    // Note: raylib's InitAudioDevice is usually called automatically\n                    // with InitWindow, but we make it explicit for the user\n                    *init.borrow_mut() = true;\n                }\n            });\n            Ok(Value::Nil)\n        }))),\n    );\n\n    // audio_close - Close audio device\n    globals.borrow_mut().define(\n        \"audio_close\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"audio_close\", 0, |_args| {\n            AUDIO_INITIALIZED.with(|init| {\n                *init.borrow_mut() = false;\n            });\n            Ok(Value::Nil)\n        }))),\n    );\n\n    // Note: Full audio implementation would require managing Sound and Music handles\n    // which need proper resource management. For simplicity, we provide the basic API\n    // but actual sound loading/playing would require additional infrastructure.\n\n    // sound_load - Load a sound file (returns a sound handle ID)\n    globals.borrow_mut().define(\n        \"sound_load\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"sound_load\", 1, |args| {\n            let _path = match &args[0] {\n                Value::String(s) => s.clone(),\n                _ => return Err(\"path must be a string\".to_string()),\n            };\n            // Note: Actual implementation would load the sound and return a handle\n            // For now, we return a placeholder\n            Err(\"Sound loading requires full graphics feature implementation\".to_string())\n        }))),\n    );\n\n    // sound_play - Play a loaded sound\n    globals.borrow_mut().define(\n        \"sound_play\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"sound_play\", 1, |_args| {\n            Err(\"Sound playing requires full graphics feature implementation\".to_string())\n        }))),\n    );\n\n    // music_load - Load a music file (returns a music handle ID)\n    globals.borrow_mut().define(\n        \"music_load\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"music_load\", 1, |args| {\n            let _path = match &args[0] {\n                Value::String(s) => s.clone(),\n                _ => return Err(\"path must be a string\".to_string()),\n            };\n            Err(\"Music loading requires full graphics feature implementation\".to_string())\n        }))),\n    );\n\n    // music_play - Play loaded music\n    globals.borrow_mut().define(\n        \"music_play\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"music_play\", 1, |_args| {\n            Err(\"Music playing requires full graphics feature implementation\".to_string())\n        }))),\n    );\n\n    // music_stop - Stop playing music\n    globals.borrow_mut().define(\n        \"music_stop\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"music_stop\", 1, |_args| {\n            Err(\"Music stopping requires full graphics feature implementation\".to_string())\n        }))),\n    );\n\n    // set_volume - Set master volume (0.0 to 1.0)\n    globals.borrow_mut().define(\n        \"set_volume\".to_string(),\n        Value::NativeFunction(Rc::new(NativeFunction::new(\"set_volume\", 1, |args| {\n            let _volume = match &args[0] {\n                Value::Float(f) => *f,\n                Value::Integer(i) => *i as f64,\n                _ => return Err(\"volume must be a number\".to_string()),\n            };\n            // Note: Would call SetMasterVolume(volume as f32)\n            Ok(Value::Nil)\n        }))),\n    );\n}\n\n/// Stub for when graphics feature is not enabled\n#[cfg(not(feature = \"graphics\"))]\npub fn register_graphics_functions(\n    _globals: &std::rc::Rc<std::cell::RefCell<crate::value::Environment>>,\n) {\n    // Graphics not available - do nothing\n}\n","traces":[{"line":695,"address":[55374688],"length":1,"stats":{"Line":23}}],"covered":1,"coverable":1},{"path":["/","home","md","language","mdhavers","src","interpreter.rs"],"content":"use std::cell::RefCell;\nuse std::collections::{HashMap, HashSet};\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\nuse std::rc::Rc;\n\n#[cfg(feature = \"cli\")]\nuse crossterm::{\n    event::{read, Event, KeyCode, KeyEvent},\n    terminal::{disable_raw_mode, enable_raw_mode},\n};\n\nuse crate::ast::{LogLevel, *};\nuse crate::error::{HaversError, HaversResult};\nuse crate::value::*;\nuse chrono::Local;\nuse std::sync::atomic::{AtomicBool, AtomicU8, Ordering};\nuse std::sync::Mutex;\n\n/// Global log level that can be modified by native functions\n/// Default is Blether (3 = INFO)\nstatic GLOBAL_LOG_LEVEL: AtomicU8 = AtomicU8::new(3);\n\n/// Whether crash handling is enabled (default: true)\nstatic CRASH_HANDLING_ENABLED: AtomicBool = AtomicBool::new(true);\n\n/// A stack frame for the shadow call stack\n#[derive(Debug, Clone)]\npub struct StackFrame {\n    /// Function name or \"<main>\"\n    pub name: String,\n    /// Source file name\n    pub file: String,\n    /// Line number\n    pub line: usize,\n}\n\nimpl std::fmt::Display for StackFrame {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"  at {} ({}:{})\", self.name, self.file, self.line)\n    }\n}\n\n/// Global shadow call stack for crash reporting\nstatic SHADOW_STACK: Mutex<Vec<StackFrame>> = Mutex::new(Vec::new());\nstatic CURRENT_STACK_FILE: Mutex<String> = Mutex::new(String::new());\n\n/// Push a frame onto the shadow stack\npub fn push_stack_frame(name: &str, line: usize) {\n    if let Ok(mut stack) = SHADOW_STACK.lock() {\n        let file = CURRENT_STACK_FILE\n            .lock()\n            .map(|f| f.clone())\n            .unwrap_or_default();\n        stack.push(StackFrame {\n            name: name.to_string(),\n            file,\n            line,\n        });\n    }\n}\n\n/// Pop a frame from the shadow stack\npub fn pop_stack_frame() {\n    if let Ok(mut stack) = SHADOW_STACK.lock() {\n        stack.pop();\n    }\n}\n\n/// Get a copy of the current stack trace\npub fn get_stack_trace() -> Vec<StackFrame> {\n    SHADOW_STACK.lock().map(|s| s.clone()).unwrap_or_default()\n}\n\n/// Clear the stack trace (for REPL reset)\n#[allow(dead_code)]\npub fn clear_stack_trace() {\n    if let Ok(mut stack) = SHADOW_STACK.lock() {\n        stack.clear();\n    }\n}\n\n/// Set the current file name for stack frames\npub fn set_stack_file(file: &str) {\n    if let Ok(mut f) = CURRENT_STACK_FILE.lock() {\n        *f = file.to_string();\n    }\n}\n\n/// Print the current stack trace to stderr\npub fn print_stack_trace() {\n    let stack = get_stack_trace();\n    if stack.is_empty() {\n        eprintln!(\"  (no stack trace available)\");\n        return;\n    }\n    eprintln!(\"\\n Stack trace (most recent call last):\");\n    for frame in stack.iter().rev() {\n        eprintln!(\"{}\", frame);\n    }\n}\n\n/// Enable or disable crash handling\npub fn set_crash_handling(enabled: bool) {\n    CRASH_HANDLING_ENABLED.store(enabled, Ordering::Relaxed);\n}\n\n/// Check if crash handling is enabled\npub fn is_crash_handling_enabled() -> bool {\n    CRASH_HANDLING_ENABLED.load(Ordering::Relaxed)\n}\n\n/// Get the global log level\npub fn get_global_log_level() -> LogLevel {\n    match GLOBAL_LOG_LEVEL.load(Ordering::Relaxed) {\n        0 => LogLevel::Wheesht,\n        1 => LogLevel::Roar,\n        2 => LogLevel::Holler,\n        3 => LogLevel::Blether,\n        4 => LogLevel::Mutter,\n        5 => LogLevel::Whisper,\n        _ => LogLevel::Blether,\n    }\n}\n\n/// Set the global log level\npub fn set_global_log_level(level: LogLevel) {\n    GLOBAL_LOG_LEVEL.store(level as u8, Ordering::Relaxed);\n}\n\n/// Control flow signals\n#[derive(Debug)]\nenum ControlFlow {\n    Return(Value),\n    Break,\n    Continue,\n}\n\n/// Trace mode fer debugging - shows step-by-step execution\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub enum TraceMode {\n    /// Nae tracing at aw\n    #[default]\n    Off,\n    /// Show statement execution only\n    Statements,\n    /// Show everything (statements, expressions, values)\n    Verbose,\n}\n\n/// The interpreter - runs mdhavers programs\npub struct Interpreter {\n    pub globals: Rc<RefCell<Environment>>,\n    environment: Rc<RefCell<Environment>>,\n    output: Vec<String>,\n    /// Track loaded modules tae prevent circular imports\n    loaded_modules: HashSet<PathBuf>,\n    /// Current working directory fer resolving relative imports\n    current_dir: PathBuf,\n    /// Whether the prelude has been loaded\n    prelude_loaded: bool,\n    /// Trace mode fer debugging\n    trace_mode: TraceMode,\n    /// Current trace indentation level\n    trace_depth: usize,\n    /// Current log level (default: Blether/INFO)\n    #[allow(dead_code)]\n    log_level: LogLevel,\n    /// Current source file name for log messages\n    current_file: String,\n}\n\nimpl Interpreter {\n    pub fn new() -> Self {\n        let globals = Rc::new(RefCell::new(Environment::new()));\n\n        // Define native functions\n        Self::define_natives(&globals);\n\n        // Register graphics functions (if feature enabled)\n        crate::graphics::register_graphics_functions(&globals);\n\n        // Check fer MDH_LOG_LEVEL environment variable\n        let log_level = std::env::var(\"MDH_LOG_LEVEL\")\n            .ok()\n            .and_then(|s| LogLevel::parse_level(&s))\n            .unwrap_or(LogLevel::Blether);\n\n        // Set the global log level too\n        set_global_log_level(log_level);\n\n        Interpreter {\n            globals: globals.clone(),\n            environment: globals,\n            output: Vec::new(),\n            loaded_modules: HashSet::new(),\n            current_dir: std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\")),\n            prelude_loaded: false,\n            trace_mode: TraceMode::Off,\n            trace_depth: 0,\n            log_level,\n            current_file: \"<repl>\".to_string(),\n        }\n    }\n\n    /// Set the current source file name (fer log messages)\n    pub fn set_current_file(&mut self, file: &str) {\n        self.current_file = file.to_string();\n        // Also update the global stack file for crash reporting\n        set_stack_file(file);\n    }\n\n    /// Set the log level\n    #[allow(dead_code)]\n    pub fn set_log_level(&mut self, level: LogLevel) {\n        self.log_level = level;\n    }\n\n    /// Get current log level\n    #[allow(dead_code)]\n    pub fn get_log_level(&self) -> LogLevel {\n        self.log_level\n    }\n\n    /// Check if a log level should be output\n    fn should_log(&self, level: LogLevel) -> bool {\n        // Use the global log level (can be changed at runtime)\n        let current_level = get_global_log_level();\n        (level as u8) <= (current_level as u8)\n    }\n\n    /// Format and output a log message\n    fn log_message(&self, level: LogLevel, message: &str, line: usize) {\n        if !self.should_log(level) {\n            return;\n        }\n\n        let timestamp = Local::now().format(\"%Y-%m-%d %H:%M:%S%.3f\");\n        let thread_id = std::thread::current().id();\n        // Extract numeric part from thread ID (format is ThreadId(N))\n        let thread_num: u64 = format!(\"{:?}\", thread_id)\n            .chars()\n            .filter(|c| c.is_ascii_digit())\n            .collect::<String>()\n            .parse()\n            .unwrap_or(0)\n            % 10000;\n\n        eprintln!(\n            \"[{:7}] {} [thread:{:04}] {}:{} | {}\",\n            level.name(),\n            timestamp,\n            thread_num,\n            self.current_file,\n            line,\n            message\n        );\n    }\n\n    /// Enable trace mode fer debugging\n    pub fn set_trace_mode(&mut self, mode: TraceMode) {\n        self.trace_mode = mode;\n    }\n\n    /// Get current trace mode\n    #[allow(dead_code)]\n    pub fn trace_mode(&self) -> TraceMode {\n        self.trace_mode\n    }\n\n    /// Print a trace message with proper indentation and Scottish flair\n    fn trace(&self, msg: &str) {\n        if self.trace_mode != TraceMode::Off {\n            let indent = \"  \".repeat(self.trace_depth);\n            eprintln!(\"\\x1b[33m {}{}\\x1b[0m\", indent, msg);\n        }\n    }\n\n    /// Print a verbose trace message (only in verbose mode)\n    fn trace_verbose(&self, msg: &str) {\n        if self.trace_mode == TraceMode::Verbose {\n            let indent = \"  \".repeat(self.trace_depth);\n            eprintln!(\"\\x1b[36m   {}{}\\x1b[0m\", indent, msg);\n        }\n    }\n\n    /// Create an interpreter with a specific working directory\n    #[allow(dead_code)]\n    pub fn with_dir<P: AsRef<Path>>(dir: P) -> Self {\n        let mut interp = Self::new();\n        interp.current_dir = dir.as_ref().to_path_buf();\n        interp\n    }\n\n    /// Set the current directory fer module resolution\n    pub fn set_current_dir<P: AsRef<Path>>(&mut self, dir: P) {\n        self.current_dir = dir.as_ref().to_path_buf();\n    }\n\n    /// Get all user-defined variables (fer REPL environment inspection)\n    pub fn get_user_variables(&self) -> Vec<(String, String, String)> {\n        let env = self.environment.borrow();\n        let exports = env.get_exports();\n        let mut vars = Vec::new();\n\n        // Get all variables that aren't native functions\n        for (name, value) in exports.iter() {\n            // Skip native functions\n            if matches!(value, Value::NativeFunction(_)) {\n                continue;\n            }\n            // Skip prelude functions (they have specific patterns)\n            if matches!(value, Value::Function(_)) {\n                // Include user-defined functions but mark them\n                vars.push((name.clone(), \"function\".to_string(), format!(\"{}\", value)));\n            } else {\n                vars.push((\n                    name.clone(),\n                    value.type_name().to_string(),\n                    format!(\"{}\", value),\n                ));\n            }\n        }\n\n        // Sort by name for consistent display\n        vars.sort_by(|a, b| a.0.cmp(&b.0));\n        vars\n    }\n\n    /// Load the standard prelude (automatically loaded unless disabled)\n    /// The prelude provides common utility functions written in mdhavers\n    pub fn load_prelude(&mut self) -> HaversResult<()> {\n        if self.prelude_loaded {\n            return Ok(());\n        }\n\n        // Try tae find the prelude in these locations:\n        // 1. stdlib/prelude.braw relative tae the executable\n        // 2. stdlib/prelude.braw relative tae current directory\n        // 3. Embedded prelude as fallback\n\n        let prelude_locations = [\n            // Next tae the executable\n            std::env::current_exe()\n                .ok()\n                .and_then(|p| p.parent().map(|d| d.join(\"stdlib/prelude.braw\"))),\n            // In the current directory\n            Some(PathBuf::from(\"stdlib/prelude.braw\")),\n            // In the project root (fer development)\n            Some(PathBuf::from(\"../stdlib/prelude.braw\")),\n        ];\n\n        for maybe_path in prelude_locations.iter().flatten() {\n            if let Ok(source) = std::fs::read_to_string(maybe_path) {\n                match crate::parser::parse(&source) {\n                    Ok(program) => {\n                        // Execute prelude in globals\n                        for stmt in &program.statements {\n                            self.execute_stmt(stmt)?;\n                        }\n                        self.prelude_loaded = true;\n                        return Ok(());\n                    }\n                    Err(e) => {\n                        // Prelude has syntax error - this is a bug\n                        return Err(HaversError::ParseError {\n                            message: format!(\"Prelude has errors (this shouldnae happen!): {}\", e),\n                            line: 1,\n                        });\n                    }\n                }\n            }\n        }\n\n        // If nae prelude file found, that's okay - just continue without it\n        // The language still works, just without the convenience functions\n        self.prelude_loaded = true;\n        Ok(())\n    }\n\n    /// Check if prelude is loaded\n    #[allow(dead_code)]\n    pub fn has_prelude(&self) -> bool {\n        self.prelude_loaded\n    }\n\n    fn define_natives(globals: &Rc<RefCell<Environment>>) {\n        // get_key - read a single key press (raw input)\n        #[cfg(feature = \"cli\")]\n        globals.borrow_mut().define(\n            \"get_key\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"get_key\", 0, |_args| {\n                enable_raw_mode().map_err(|e| format!(\"Cannae enable raw mode: {}\", e))?;\n\n                let result = match read() {\n                    Ok(Event::Key(KeyEvent { code, .. })) => match code {\n                        KeyCode::Char(c) => Ok(Value::String(c.to_string())),\n                        KeyCode::Enter => Ok(Value::String(\"\\n\".to_string())),\n                        KeyCode::Esc => Ok(Value::String(\"\\x1b\".to_string())),\n                        KeyCode::Backspace => Ok(Value::String(\"\\x08\".to_string())),\n                        KeyCode::Left => Ok(Value::String(\"Left\".to_string())),\n                        KeyCode::Right => Ok(Value::String(\"Right\".to_string())),\n                        KeyCode::Up => Ok(Value::String(\"Up\".to_string())),\n                        KeyCode::Down => Ok(Value::String(\"Down\".to_string())),\n                        _ => Ok(Value::String(\"\".to_string())),\n                    },\n                    Ok(_) => Ok(Value::String(\"\".to_string())),\n                    Err(e) => Err(format!(\"Cannae read key: {}\", e)),\n                };\n\n                disable_raw_mode().map_err(|e| format!(\"Cannae disable raw mode: {}\", e))?;\n\n                result\n            }))),\n        );\n        // len - get length of list, string, dict, or set\n        globals.borrow_mut().define(\n            \"len\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"len\", 1, |args| {\n                match &args[0] {\n                    Value::String(s) => Ok(Value::Integer(s.len() as i64)),\n                    Value::List(l) => Ok(Value::Integer(l.borrow().len() as i64)),\n                    Value::Dict(d) => Ok(Value::Integer(d.borrow().len() as i64)),\n                    Value::Set(s) => Ok(Value::Integer(s.borrow().len() as i64)),\n                    _ => Err(\"len() expects a string, list, dict, or creel\".to_string()),\n                }\n            }))),\n        );\n\n        // type - get type of value (whit_kind in Scots!)\n        globals.borrow_mut().define(\n            \"whit_kind\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"whit_kind\", 1, |args| {\n                Ok(Value::String(args[0].type_name().to_string()))\n            }))),\n        );\n\n        // str - convert to string (tae_string in Scots!)\n        globals.borrow_mut().define(\n            \"tae_string\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tae_string\", 1, |args| {\n                Ok(Value::String(format!(\"{}\", args[0])))\n            }))),\n        );\n\n        // int - convert to integer (tae_int in Scots!)\n        globals.borrow_mut().define(\n            \"tae_int\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"tae_int\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Integer(*n)),\n                    Value::Float(f) => Ok(Value::Integer(*f as i64)),\n                    Value::String(s) => s\n                        .parse::<i64>()\n                        .map(Value::Integer)\n                        .map_err(|_| format!(\"Cannae turn '{}' intae an integer\", s)),\n                    Value::Bool(b) => Ok(Value::Integer(if *b { 1 } else { 0 })),\n                    _ => Err(format!(\n                        \"Cannae turn {} intae an integer\",\n                        args[0].type_name()\n                    )),\n                },\n            ))),\n        );\n\n        // float - convert to float (tae_float in Scots!)\n        globals.borrow_mut().define(\n            \"tae_float\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"tae_float\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Float(*n as f64)),\n                    Value::Float(f) => Ok(Value::Float(*f)),\n                    Value::String(s) => s\n                        .parse::<f64>()\n                        .map(Value::Float)\n                        .map_err(|_| format!(\"Cannae turn '{}' intae a float\", s)),\n                    _ => Err(format!(\"Cannae turn {} intae a float\", args[0].type_name())),\n                },\n            ))),\n        );\n\n        // push - add to list (shove in Scots!)\n        globals.borrow_mut().define(\n            \"shove\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"shove\", 2, |args| {\n                if let Value::List(list) = &args[0] {\n                    list.borrow_mut().push(args[1].clone());\n                    Ok(Value::Nil)\n                } else {\n                    Err(\"shove() expects a list as first argument\".to_string())\n                }\n            }))),\n        );\n\n        // pop - remove from list (yank in Scots!)\n        globals.borrow_mut().define(\n            \"yank\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"yank\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    list.borrow_mut()\n                        .pop()\n                        .ok_or_else(|| \"Cannae yank fae an empty list!\".to_string())\n                } else {\n                    Err(\"yank() expects a list\".to_string())\n                }\n            }))),\n        );\n\n        // keys - get dictionary keys\n        globals.borrow_mut().define(\n            \"keys\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"keys\", 1, |args| {\n                if let Value::Dict(dict) = &args[0] {\n                    let keys: Vec<Value> = dict\n                        .borrow()\n                        .keys()\n                        .map(|k| Value::String(k.clone()))\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(keys))))\n                } else {\n                    Err(\"keys() expects a dict\".to_string())\n                }\n            }))),\n        );\n\n        // values - get dictionary values\n        globals.borrow_mut().define(\n            \"values\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"values\", 1, |args| {\n                if let Value::Dict(dict) = &args[0] {\n                    let vals: Vec<Value> = dict.borrow().values().cloned().collect();\n                    Ok(Value::List(Rc::new(RefCell::new(vals))))\n                } else {\n                    Err(\"values() expects a dict\".to_string())\n                }\n            }))),\n        );\n\n        // range - create a range\n        globals.borrow_mut().define(\n            \"range\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"range\", 2, |args| {\n                let start = args[0].as_integer().ok_or(\"range() expects integers\")?;\n                let end = args[1].as_integer().ok_or(\"range() expects integers\")?;\n                Ok(Value::Range(RangeValue::new(start, end, false)))\n            }))),\n        );\n\n        // abs - absolute value\n        globals.borrow_mut().define(\n            \"abs\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"abs\", 1, |args| {\n                match &args[0] {\n                    Value::Integer(n) => Ok(Value::Integer(n.abs())),\n                    Value::Float(f) => Ok(Value::Float(f.abs())),\n                    _ => Err(\"abs() expects a number\".to_string()),\n                }\n            }))),\n        );\n\n        // min - minimum value\n        globals.borrow_mut().define(\n            \"min\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"min\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => {\n                        Ok(Value::Integer(std::cmp::min(*a, *b)))\n                    }\n                    (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.min(*b))),\n                    _ => Err(\"min() expects two numbers of the same type\".to_string()),\n                }\n            }))),\n        );\n\n        // max - maximum value\n        globals.borrow_mut().define(\n            \"max\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"max\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => {\n                        Ok(Value::Integer(std::cmp::max(*a, *b)))\n                    }\n                    (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.max(*b))),\n                    _ => Err(\"max() expects two numbers of the same type\".to_string()),\n                }\n            }))),\n        );\n\n        // floor\n        globals.borrow_mut().define(\n            \"floor\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"floor\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Integer(f.floor() as i64)),\n                    Value::Integer(n) => Ok(Value::Integer(*n)),\n                    _ => Err(\"floor() expects a number\".to_string()),\n                },\n            ))),\n        );\n\n        // ceil\n        globals.borrow_mut().define(\n            \"ceil\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"ceil\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Integer(f.ceil() as i64)),\n                    Value::Integer(n) => Ok(Value::Integer(*n)),\n                    _ => Err(\"ceil() expects a number\".to_string()),\n                },\n            ))),\n        );\n\n        // round\n        globals.borrow_mut().define(\n            \"round\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"round\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Integer(f.round() as i64)),\n                    Value::Integer(n) => Ok(Value::Integer(*n)),\n                    _ => Err(\"round() expects a number\".to_string()),\n                },\n            ))),\n        );\n\n        // sqrt\n        globals.borrow_mut().define(\n            \"sqrt\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"sqrt\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.sqrt())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).sqrt())),\n                    _ => Err(\"sqrt() expects a number\".to_string()),\n                },\n            ))),\n        );\n\n        // set_log_level - set the logging level at runtime\n        globals.borrow_mut().define(\n            \"set_log_level\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"set_log_level\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => {\n                        if let Some(level) = LogLevel::parse_level(s) {\n                            set_global_log_level(level);\n                            Ok(Value::Nil)\n                        } else {\n                            Err(format!(\n                                \"Invalid log level '{}'. Use: wheesht, roar, holler, blether, mutter, or whisper\",\n                                s\n                            ))\n                        }\n                    }\n                    Value::Integer(n) => {\n                        let level = match n {\n                            0 => LogLevel::Wheesht,\n                            1 => LogLevel::Roar,\n                            2 => LogLevel::Holler,\n                            3 => LogLevel::Blether,\n                            4 => LogLevel::Mutter,\n                            5 => LogLevel::Whisper,\n                            _ => return Err(format!(\"Invalid log level {}. Use 0-5\", n)),\n                        };\n                        set_global_log_level(level);\n                        Ok(Value::Nil)\n                    }\n                    _ => Err(\"set_log_level() expects a string or integer\".to_string()),\n                },\n            ))),\n        );\n\n        // get_log_level - get the current logging level\n        globals.borrow_mut().define(\n            \"get_log_level\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"get_log_level\", 0, |_args| {\n                let level = get_global_log_level();\n                Ok(Value::String(level.name().to_lowercase()))\n            }))),\n        );\n\n        // stacktrace - get the current stack trace as a string\n        globals.borrow_mut().define(\n            \"stacktrace\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"stacktrace\", 0, |_args| {\n                let stack = get_stack_trace();\n                let trace = stack\n                    .iter()\n                    .rev()\n                    .map(|f| format!(\"  at {} ({}:{})\", f.name, f.file, f.line))\n                    .collect::<Vec<_>>()\n                    .join(\"\\n\");\n                Ok(Value::String(if trace.is_empty() {\n                    \"(no stack trace)\".to_string()\n                } else {\n                    trace\n                }))\n            }))),\n        );\n\n        // set_crash_handling - enable or disable crash handling\n        globals.borrow_mut().define(\n            \"set_crash_handling\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"set_crash_handling\",\n                1,\n                |args| match &args[0] {\n                    Value::Bool(enabled) => {\n                        set_crash_handling(*enabled);\n                        Ok(Value::Nil)\n                    }\n                    _ => Err(\"set_crash_handling() expects a boolean\".to_string()),\n                },\n            ))),\n        );\n\n        // split - split string\n        globals.borrow_mut().define(\n            \"split\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"split\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(delim)) => {\n                        let parts: Vec<Value> = s\n                            .split(delim.as_str())\n                            .map(|p| Value::String(p.to_string()))\n                            .collect();\n                        Ok(Value::List(Rc::new(RefCell::new(parts))))\n                    }\n                    _ => Err(\"split() expects two strings\".to_string()),\n                }\n            }))),\n        );\n\n        // join - join list into string\n        globals.borrow_mut().define(\n            \"join\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"join\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(list), Value::String(delim)) => {\n                        let parts: Vec<String> =\n                            list.borrow().iter().map(|v| format!(\"{}\", v)).collect();\n                        Ok(Value::String(parts.join(delim)))\n                    }\n                    _ => Err(\"join() expects a list and a string\".to_string()),\n                }\n            }))),\n        );\n\n        // contains - check if list/string contains value\n        globals.borrow_mut().define(\n            \"contains\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"contains\",\n                2,\n                |args| match &args[0] {\n                    Value::List(list) => {\n                        let found = list.borrow().iter().any(|v| v == &args[1]);\n                        Ok(Value::Bool(found))\n                    }\n                    Value::String(s) => {\n                        if let Value::String(needle) = &args[1] {\n                            Ok(Value::Bool(s.contains(needle.as_str())))\n                        } else {\n                            Err(\"contains() on string expects a string needle\".to_string())\n                        }\n                    }\n                    Value::Dict(dict) => {\n                        if let Value::String(key) = &args[1] {\n                            Ok(Value::Bool(dict.borrow().contains_key(key)))\n                        } else {\n                            Err(\"contains() on dict expects a string key\".to_string())\n                        }\n                    }\n                    _ => Err(\"contains() expects a list, string, or dict\".to_string()),\n                },\n            ))),\n        );\n\n        // reverse - reverse a list or string\n        globals.borrow_mut().define(\n            \"reverse\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"reverse\",\n                1,\n                |args| match &args[0] {\n                    Value::List(list) => {\n                        let mut reversed = list.borrow().clone();\n                        reversed.reverse();\n                        Ok(Value::List(Rc::new(RefCell::new(reversed))))\n                    }\n                    Value::String(s) => Ok(Value::String(s.chars().rev().collect())),\n                    _ => Err(\"reverse() expects a list or string\".to_string()),\n                },\n            ))),\n        );\n\n        // slap - append lists together (like a friendly slap on the back!)\n        globals.borrow_mut().define(\n            \"slap\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"slap\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(a), Value::List(b)) => {\n                        let mut result = a.borrow().clone();\n                        result.extend(b.borrow().clone());\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    (Value::String(a), Value::String(b)) => {\n                        Ok(Value::String(format!(\"{}{}\", a, b)))\n                    }\n                    _ => Err(\"slap() expects two lists or two strings\".to_string()),\n                }\n            }))),\n        );\n\n        // heid - get the first element (head)\n        globals.borrow_mut().define(\n            \"heid\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"heid\",\n                1,\n                |args| match &args[0] {\n                    Value::List(list) => list\n                        .borrow()\n                        .first()\n                        .cloned()\n                        .ok_or(\"Cannae get heid o' empty list!\".to_string()),\n                    Value::String(s) => s\n                        .chars()\n                        .next()\n                        .map(|c| Value::String(c.to_string()))\n                        .ok_or(\"Cannae get heid o' empty string!\".to_string()),\n                    _ => Err(\"heid() expects a list or string\".to_string()),\n                },\n            ))),\n        );\n\n        // tail - get everything except the first (like a tail!)\n        globals.borrow_mut().define(\n            \"tail\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"tail\",\n                1,\n                |args| match &args[0] {\n                    Value::List(list) => {\n                        let list = list.borrow();\n                        if list.is_empty() {\n                            Ok(Value::List(Rc::new(RefCell::new(Vec::new()))))\n                        } else {\n                            Ok(Value::List(Rc::new(RefCell::new(list[1..].to_vec()))))\n                        }\n                    }\n                    Value::String(s) => Ok(Value::String(s.chars().skip(1).collect())),\n                    _ => Err(\"tail() expects a list or string\".to_string()),\n                },\n            ))),\n        );\n\n        // bum - get the last element (backside!)\n        globals.borrow_mut().define(\n            \"bum\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bum\", 1, |args| {\n                match &args[0] {\n                    Value::List(list) => list\n                        .borrow()\n                        .last()\n                        .cloned()\n                        .ok_or(\"Cannae get bum o' empty list!\".to_string()),\n                    Value::String(s) => s\n                        .chars()\n                        .last()\n                        .map(|c| Value::String(c.to_string()))\n                        .ok_or(\"Cannae get bum o' empty string!\".to_string()),\n                    _ => Err(\"bum() expects a list or string\".to_string()),\n                }\n            }))),\n        );\n\n        // scran - slice a list or string (grab a portion, like grabbing scran/food)\n        globals.borrow_mut().define(\n            \"scran\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"scran\", 3, |args| {\n                let start = args[1]\n                    .as_integer()\n                    .ok_or(\"scran() needs integer indices\")?;\n                let end = args[2]\n                    .as_integer()\n                    .ok_or(\"scran() needs integer indices\")?;\n                match &args[0] {\n                    Value::List(list) => {\n                        let list = list.borrow();\n                        let start = start.max(0) as usize;\n                        let end = end.min(list.len() as i64) as usize;\n                        Ok(Value::List(Rc::new(RefCell::new(\n                            list[start..end].to_vec(),\n                        ))))\n                    }\n                    Value::String(s) => {\n                        let start = start.max(0) as usize;\n                        let end = end.min(s.len() as i64) as usize;\n                        Ok(Value::String(\n                            s.chars().skip(start).take(end - start).collect(),\n                        ))\n                    }\n                    _ => Err(\"scran() expects a list or string\".to_string()),\n                }\n            }))),\n        );\n\n        // sumaw - sum all numbers in a list (sum aw = sum all)\n        globals.borrow_mut().define(\n            \"sumaw\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"sumaw\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let mut sum: f64 = 0.0;\n                    let mut is_float = false;\n                    for item in list.borrow().iter() {\n                        match item {\n                            Value::Integer(n) => sum += *n as f64,\n                            Value::Float(f) => {\n                                sum += f;\n                                is_float = true;\n                            }\n                            _ => return Err(\"sumaw() expects a list of numbers\".to_string()),\n                        }\n                    }\n                    if is_float {\n                        Ok(Value::Float(sum))\n                    } else {\n                        Ok(Value::Integer(sum as i64))\n                    }\n                } else {\n                    Err(\"sumaw() expects a list\".to_string())\n                }\n            }))),\n        );\n\n        // coont - count occurrences in list or string\n        globals.borrow_mut().define(\n            \"coont\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"coont\",\n                2,\n                |args| match &args[0] {\n                    Value::List(list) => {\n                        let count = list.borrow().iter().filter(|&x| x == &args[1]).count();\n                        Ok(Value::Integer(count as i64))\n                    }\n                    Value::String(s) => {\n                        if let Value::String(needle) = &args[1] {\n                            let count = s.matches(needle.as_str()).count();\n                            Ok(Value::Integer(count as i64))\n                        } else {\n                            Err(\"coont() on string needs a string tae count\".to_string())\n                        }\n                    }\n                    _ => Err(\"coont() expects a list or string\".to_string()),\n                },\n            ))),\n        );\n\n        // wheesht - remove whitespace (be quiet/silent!)\n        globals.borrow_mut().define(\n            \"wheesht\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"wheesht\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(s.trim().to_string()))\n                } else {\n                    Err(\"wheesht() expects a string\".to_string())\n                }\n            }))),\n        );\n\n        // upper - to uppercase (shout it oot!)\n        globals.borrow_mut().define(\n            \"upper\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"upper\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(s.to_uppercase()))\n                } else {\n                    Err(\"upper() expects a string\".to_string())\n                }\n            }))),\n        );\n\n        // lower - to lowercase (calm doon!)\n        globals.borrow_mut().define(\n            \"lower\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"lower\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(s.to_lowercase()))\n                } else {\n                    Err(\"lower() expects a string\".to_string())\n                }\n            }))),\n        );\n\n        // shuffle - randomly shuffle a list (like a ceilidh!)\n        globals.borrow_mut().define(\n            \"shuffle\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"shuffle\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    use std::time::{SystemTime, UNIX_EPOCH};\n                    let seed = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_nanos() as u64;\n                    let mut shuffled = list.borrow().clone();\n                    // Simple Fisher-Yates shuffle with basic RNG\n                    let mut rng = seed;\n                    for i in (1..shuffled.len()).rev() {\n                        rng = rng.wrapping_mul(1103515245).wrapping_add(12345);\n                        let j = (rng as usize) % (i + 1);\n                        shuffled.swap(i, j);\n                    }\n                    Ok(Value::List(Rc::new(RefCell::new(shuffled))))\n                } else {\n                    Err(\"shuffle() expects a list\".to_string())\n                }\n            }))),\n        );\n\n        // sort - sort a list\n        globals.borrow_mut().define(\n            \"sort\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"sort\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let mut sorted = list.borrow().clone();\n                    sorted.sort_by(|a, b| match (a, b) {\n                        (Value::Integer(x), Value::Integer(y)) => x.cmp(y),\n                        (Value::Float(x), Value::Float(y)) => {\n                            x.partial_cmp(y).unwrap_or(std::cmp::Ordering::Equal)\n                        }\n                        (Value::String(x), Value::String(y)) => x.cmp(y),\n                        _ => std::cmp::Ordering::Equal,\n                    });\n                    Ok(Value::List(Rc::new(RefCell::new(sorted))))\n                } else {\n                    Err(\"sort() expects a list\".to_string())\n                }\n            }))),\n        );\n\n        // jammy - random number (Scots: lucky!)\n        globals.borrow_mut().define(\n            \"jammy\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"jammy\", 2, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let min = args[0].as_integer().ok_or(\"jammy() needs integer bounds\")?;\n                let max = args[1].as_integer().ok_or(\"jammy() needs integer bounds\")?;\n                if min >= max {\n                    return Err(\"jammy() needs min < max, ya numpty!\".to_string());\n                }\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as u64;\n                let rng = seed.wrapping_mul(1103515245).wrapping_add(12345);\n                let range = (max - min) as u64;\n                let result = min + ((rng % range) as i64);\n                Ok(Value::Integer(result))\n            }))),\n        );\n\n        // the_noo - current timestamp in seconds (Scots: \"the now\")\n        globals.borrow_mut().define(\n            \"the_noo\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"the_noo\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let secs = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs();\n                Ok(Value::Integer(secs as i64))\n            }))),\n        );\n\n        // clype - debug print with type info (Scots: tell/inform/snitch)\n        globals.borrow_mut().define(\n            \"clype\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"clype\", 1, |args| {\n                let val = &args[0];\n                Ok(Value::String(format!(\"[{}] {}\", val.type_name(), val)))\n            }))),\n        );\n\n        // is_a - type checking (returns aye/nae)\n        globals.borrow_mut().define(\n            \"is_a\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_a\", 2, |args| {\n                let type_name = match &args[1] {\n                    Value::String(s) => s.as_str(),\n                    _ => return Err(\"is_a() needs a type name string\".to_string()),\n                };\n                let matches = match type_name {\n                    \"integer\" | \"int\" => matches!(args[0], Value::Integer(_)),\n                    \"float\" => matches!(args[0], Value::Float(_)),\n                    \"string\" | \"str\" => matches!(args[0], Value::String(_)),\n                    \"bool\" => matches!(args[0], Value::Bool(_)),\n                    \"list\" => matches!(args[0], Value::List(_)),\n                    \"dict\" => matches!(args[0], Value::Dict(_)),\n                    \"function\" | \"dae\" => {\n                        matches!(args[0], Value::Function(_) | Value::NativeFunction(_))\n                    }\n                    \"naething\" | \"nil\" => matches!(args[0], Value::Nil),\n                    \"range\" => matches!(args[0], Value::Range(_)),\n                    _ => false,\n                };\n                Ok(Value::Bool(matches))\n            }))),\n        );\n\n        // tae_bool - convert to boolean\n        globals.borrow_mut().define(\n            \"tae_bool\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tae_bool\", 1, |args| {\n                Ok(Value::Bool(args[0].is_truthy()))\n            }))),\n        );\n\n        // char_at - get character at index (returns string of length 1)\n        globals.borrow_mut().define(\n            \"char_at\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"char_at\", 2, |args| {\n                let s = match &args[0] {\n                    Value::String(s) => s,\n                    _ => return Err(\"char_at() needs a string\".to_string()),\n                };\n                let idx = args[1]\n                    .as_integer()\n                    .ok_or(\"char_at() needs an integer index\")?;\n                let idx = if idx < 0 { s.len() as i64 + idx } else { idx } as usize;\n                s.chars()\n                    .nth(idx)\n                    .map(|c| Value::String(c.to_string()))\n                    .ok_or_else(|| {\n                        format!(\n                            \"Index {} oot o' bounds fer string o' length {}\",\n                            idx,\n                            s.len()\n                        )\n                    })\n            }))),\n        );\n\n        // replace - replace occurrences in string\n        globals.borrow_mut().define(\n            \"replace\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"replace\", 3, |args| {\n                match (&args[0], &args[1], &args[2]) {\n                    (Value::String(s), Value::String(from), Value::String(to)) => {\n                        Ok(Value::String(s.replace(from.as_str(), to.as_str())))\n                    }\n                    _ => Err(\"replace() needs three strings\".to_string()),\n                }\n            }))),\n        );\n\n        // starts_wi - check if string starts with prefix (Scots: starts with)\n        globals.borrow_mut().define(\n            \"starts_wi\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"starts_wi\", 2, |args| match (\n                &args[0], &args[1],\n            ) {\n                (Value::String(s), Value::String(prefix)) => {\n                    Ok(Value::Bool(s.starts_with(prefix.as_str())))\n                }\n                _ => Err(\"starts_wi() needs two strings\".to_string()),\n            }))),\n        );\n\n        // ends_wi - check if string ends with suffix\n        globals.borrow_mut().define(\n            \"ends_wi\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"ends_wi\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(suffix)) => {\n                        Ok(Value::Bool(s.ends_with(suffix.as_str())))\n                    }\n                    _ => Err(\"ends_wi() needs two strings\".to_string()),\n                }\n            }))),\n        );\n\n        // repeat - repeat a string n times\n        globals.borrow_mut().define(\n            \"repeat\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"repeat\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::String(s), Value::Integer(n)) => {\n                        if *n < 0 {\n                            Err(\"Cannae repeat a negative number o' times!\".to_string())\n                        } else {\n                            Ok(Value::String(s.repeat(*n as usize)))\n                        }\n                    }\n                    _ => Err(\"repeat() needs a string and an integer\".to_string()),\n                }\n            }))),\n        );\n\n        // index_of - find index of substring (returns -1 if not found)\n        globals.borrow_mut().define(\n            \"index_of\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"index_of\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(needle)) => Ok(Value::Integer(\n                        s.find(needle.as_str()).map(|i| i as i64).unwrap_or(-1),\n                    )),\n                    (Value::List(list), val) => {\n                        let list = list.borrow();\n                        for (i, item) in list.iter().enumerate() {\n                            if item == val {\n                                return Ok(Value::Integer(i as i64));\n                            }\n                        }\n                        Ok(Value::Integer(-1))\n                    }\n                    _ => Err(\"index_of() needs a string/list and a value\".to_string()),\n                }\n            }))),\n        );\n\n        // === More String Functions ===\n\n        // pad_left - pad string on the left to reach target length\n        globals.borrow_mut().define(\n            \"pad_left\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pad_left\", 3, |args| {\n                match (&args[0], &args[1], &args[2]) {\n                    (Value::String(s), Value::Integer(width), Value::String(pad_char)) => {\n                        let width = *width as usize;\n                        if s.len() >= width {\n                            Ok(Value::String(s.clone()))\n                        } else {\n                            let pad = pad_char.chars().next().unwrap_or(' ');\n                            let padding: String =\n                                std::iter::repeat_n(pad, width - s.len()).collect();\n                            Ok(Value::String(format!(\"{}{}\", padding, s)))\n                        }\n                    }\n                    _ => Err(\n                        \"pad_left() needs a string, integer width, and pad character\".to_string(),\n                    ),\n                }\n            }))),\n        );\n\n        // pad_right - pad string on the right to reach target length\n        globals.borrow_mut().define(\n            \"pad_right\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pad_right\", 3, |args| match (\n                &args[0], &args[1], &args[2],\n            ) {\n                (Value::String(s), Value::Integer(width), Value::String(pad_char)) => {\n                    let width = *width as usize;\n                    if s.len() >= width {\n                        Ok(Value::String(s.clone()))\n                    } else {\n                        let pad = pad_char.chars().next().unwrap_or(' ');\n                        let padding: String = std::iter::repeat_n(pad, width - s.len()).collect();\n                        Ok(Value::String(format!(\"{}{}\", s, padding)))\n                    }\n                }\n                _ => {\n                    Err(\"pad_right() needs a string, integer width, and pad character\".to_string())\n                }\n            }))),\n        );\n\n        // lines - split string into lines (on newlines)\n        globals.borrow_mut().define(\n            \"lines\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"lines\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    let line_list: Vec<Value> = s\n                        .lines()\n                        .map(|line| Value::String(line.to_string()))\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(line_list))))\n                } else {\n                    Err(\"lines() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // words - split string into words (on whitespace)\n        globals.borrow_mut().define(\n            \"words\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"words\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    let word_list: Vec<Value> = s\n                        .split_whitespace()\n                        .map(|word| Value::String(word.to_string()))\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(word_list))))\n                } else {\n                    Err(\"words() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // is_digit - check if string contains only digits\n        globals.borrow_mut().define(\n            \"is_digit\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_digit\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::Bool(\n                        !s.is_empty() && s.chars().all(|c| c.is_ascii_digit()),\n                    ))\n                } else {\n                    Err(\"is_digit() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // is_alpha - check if string contains only letters\n        globals.borrow_mut().define(\n            \"is_alpha\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_alpha\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::Bool(\n                        !s.is_empty() && s.chars().all(|c| c.is_alphabetic()),\n                    ))\n                } else {\n                    Err(\"is_alpha() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // is_space - check if string contains only whitespace\n        globals.borrow_mut().define(\n            \"is_space\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_space\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::Bool(\n                        !s.is_empty() && s.chars().all(|c| c.is_whitespace()),\n                    ))\n                } else {\n                    Err(\"is_space() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // capitalize - capitalize first letter\n        globals.borrow_mut().define(\n            \"capitalize\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"capitalize\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    let mut chars = s.chars();\n                    let result = match chars.next() {\n                        Some(first) => {\n                            format!(\"{}{}\", first.to_uppercase(), chars.collect::<String>())\n                        }\n                        None => String::new(),\n                    };\n                    Ok(Value::String(result))\n                } else {\n                    Err(\"capitalize() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // title - capitalize each word\n        globals.borrow_mut().define(\n            \"title\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"title\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    let result = s\n                        .split_whitespace()\n                        .map(|word| {\n                            let mut chars = word.chars();\n                            match chars.next() {\n                                Some(first) => format!(\n                                    \"{}{}\",\n                                    first.to_uppercase(),\n                                    chars.collect::<String>().to_lowercase()\n                                ),\n                                None => String::new(),\n                            }\n                        })\n                        .collect::<Vec<String>>()\n                        .join(\" \");\n                    Ok(Value::String(result))\n                } else {\n                    Err(\"title() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // chars - split string into list of characters\n        globals.borrow_mut().define(\n            \"chars\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"chars\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    let char_list: Vec<Value> =\n                        s.chars().map(|c| Value::String(c.to_string())).collect();\n                    Ok(Value::List(Rc::new(RefCell::new(char_list))))\n                } else {\n                    Err(\"chars() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // ord - get ASCII/Unicode code of first character\n        globals.borrow_mut().define(\n            \"ord\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"ord\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    s.chars()\n                        .next()\n                        .map(|c| Value::Integer(c as i64))\n                        .ok_or_else(|| \"Cannae get ord o' empty string!\".to_string())\n                } else {\n                    Err(\"ord() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // chr - get character from ASCII/Unicode code\n        globals.borrow_mut().define(\n            \"chr\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"chr\", 1, |args| {\n                if let Value::Integer(n) = &args[0] {\n                    if *n >= 0 && *n <= 0x10FFFF {\n                        char::from_u32(*n as u32)\n                            .map(|c| Value::String(c.to_string()))\n                            .ok_or_else(|| format!(\"Invalid Unicode codepoint: {}\", n))\n                    } else {\n                        Err(format!(\n                            \"chr() needs a valid Unicode codepoint (0 to 1114111), got {}\",\n                            n\n                        ))\n                    }\n                } else {\n                    Err(\"chr() needs an integer\".to_string())\n                }\n            }))),\n        );\n\n        // flatten - flatten nested lists one level\n        globals.borrow_mut().define(\n            \"flatten\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"flatten\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let mut result = Vec::new();\n                    for item in list.borrow().iter() {\n                        if let Value::List(inner) = item {\n                            result.extend(inner.borrow().clone());\n                        } else {\n                            result.push(item.clone());\n                        }\n                    }\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"flatten() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // zip - combine two lists into list of pairs\n        globals.borrow_mut().define(\n            \"zip\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"zip\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(a), Value::List(b)) => {\n                        let a = a.borrow();\n                        let b = b.borrow();\n                        let result: Vec<Value> = a\n                            .iter()\n                            .zip(b.iter())\n                            .map(|(x, y)| {\n                                Value::List(Rc::new(RefCell::new(vec![x.clone(), y.clone()])))\n                            })\n                            .collect();\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"zip() needs two lists\".to_string()),\n                }\n            }))),\n        );\n\n        // enumerate - return list of [index, value] pairs\n        globals.borrow_mut().define(\n            \"enumerate\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"enumerate\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let result: Vec<Value> = list\n                        .borrow()\n                        .iter()\n                        .enumerate()\n                        .map(|(i, v)| {\n                            Value::List(Rc::new(RefCell::new(vec![\n                                Value::Integer(i as i64),\n                                v.clone(),\n                            ])))\n                        })\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"enumerate() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // === More List Manipulation Functions ===\n\n        // uniq - remove duplicates from a list (keeping first occurrence)\n        globals.borrow_mut().define(\n            \"uniq\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"uniq\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let mut seen = Vec::new();\n                    let mut result = Vec::new();\n                    for item in list.borrow().iter() {\n                        let item_str = format!(\"{:?}\", item);\n                        if !seen.contains(&item_str) {\n                            seen.push(item_str);\n                            result.push(item.clone());\n                        }\n                    }\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"uniq() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // chynge - insert at index (Scots: change)\n        globals.borrow_mut().define(\n            \"chynge\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"chynge\", 3, |args| {\n                if let Value::List(list) = &args[0] {\n                    let idx = args[1]\n                        .as_integer()\n                        .ok_or(\"chynge() needs an integer index\")?;\n                    let mut new_list = list.borrow().clone();\n                    let idx = if idx < 0 {\n                        (new_list.len() as i64 + idx) as usize\n                    } else {\n                        idx as usize\n                    };\n                    if idx > new_list.len() {\n                        return Err(format!(\n                            \"Index {} oot o' bounds fer list o' length {}\",\n                            idx,\n                            new_list.len()\n                        ));\n                    }\n                    new_list.insert(idx, args[2].clone());\n                    Ok(Value::List(Rc::new(RefCell::new(new_list))))\n                } else {\n                    Err(\"chynge() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // dicht - remove at index (Scots: wipe/clean)\n        globals.borrow_mut().define(\n            \"dicht\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"dicht\", 2, |args| {\n                if let Value::List(list) = &args[0] {\n                    let idx = args[1]\n                        .as_integer()\n                        .ok_or(\"dicht() needs an integer index\")?;\n                    let mut new_list = list.borrow().clone();\n                    let idx = if idx < 0 {\n                        (new_list.len() as i64 + idx) as usize\n                    } else {\n                        idx as usize\n                    };\n                    if idx >= new_list.len() {\n                        return Err(format!(\n                            \"Index {} oot o' bounds fer list o' length {}\",\n                            idx,\n                            new_list.len()\n                        ));\n                    }\n                    new_list.remove(idx);\n                    Ok(Value::List(Rc::new(RefCell::new(new_list))))\n                } else {\n                    Err(\"dicht() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // tak - take first n elements (Scots: take)\n        globals.borrow_mut().define(\n            \"tak\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tak\", 2, |args| {\n                let n = args[1].as_integer().ok_or(\"tak() needs an integer count\")?;\n                let n = n.max(0) as usize;\n                match &args[0] {\n                    Value::List(list) => {\n                        let list = list.borrow();\n                        let result: Vec<Value> = list.iter().take(n).cloned().collect();\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    Value::String(s) => {\n                        let taken: String = s.chars().take(n).collect();\n                        Ok(Value::String(taken))\n                    }\n                    _ => Err(\"tak() needs a list or string\".to_string()),\n                }\n            }))),\n        );\n\n        // drap - drop first n elements (Scots: drop)\n        globals.borrow_mut().define(\n            \"drap\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"drap\", 2, |args| {\n                let n = args[1]\n                    .as_integer()\n                    .ok_or(\"drap() needs an integer count\")?;\n                let n = n.max(0) as usize;\n                match &args[0] {\n                    Value::List(list) => {\n                        let list = list.borrow();\n                        let result: Vec<Value> = list.iter().skip(n).cloned().collect();\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    Value::String(s) => {\n                        let dropped: String = s.chars().skip(n).collect();\n                        Ok(Value::String(dropped))\n                    }\n                    _ => Err(\"drap() needs a list or string\".to_string()),\n                }\n            }))),\n        );\n\n        // redd_up - remove nil values from list (Scots: tidy up)\n        globals.borrow_mut().define(\n            \"redd_up\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"redd_up\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let result: Vec<Value> = list\n                        .borrow()\n                        .iter()\n                        .filter(|v| !matches!(v, Value::Nil))\n                        .cloned()\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"redd_up() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // pairty - partition list based on predicate result (returns [truthy, falsy])\n        // Note: This is a simpler version - returns [evens, odds] for integers\n        globals.borrow_mut().define(\n            \"split_by\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"split_by\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(list), Value::String(pred)) => {\n                        let mut truthy = Vec::new();\n                        let mut falsy = Vec::new();\n                        for item in list.borrow().iter() {\n                            let is_match = match pred.as_str() {\n                                \"even\" => matches!(item, Value::Integer(n) if n % 2 == 0),\n                                \"odd\" => matches!(item, Value::Integer(n) if n % 2 != 0),\n                                \"positive\" => matches!(item, Value::Integer(n) if *n > 0) || matches!(item, Value::Float(f) if *f > 0.0),\n                                \"negative\" => matches!(item, Value::Integer(n) if *n < 0) || matches!(item, Value::Float(f) if *f < 0.0),\n                                \"truthy\" => item.is_truthy(),\n                                \"nil\" => matches!(item, Value::Nil),\n                                \"string\" => matches!(item, Value::String(_)),\n                                \"number\" => matches!(item, Value::Integer(_) | Value::Float(_)),\n                                _ => return Err(format!(\"Unknown predicate '{}'. Try: even, odd, positive, negative, truthy, nil, string, number\", pred)),\n                            };\n                            if is_match {\n                                truthy.push(item.clone());\n                            } else {\n                                falsy.push(item.clone());\n                            }\n                        }\n                        Ok(Value::List(Rc::new(RefCell::new(vec![\n                            Value::List(Rc::new(RefCell::new(truthy))),\n                            Value::List(Rc::new(RefCell::new(falsy))),\n                        ]))))\n                    }\n                    _ => Err(\"split_by() needs a list and a predicate string\".to_string()),\n                }\n            }))),\n        );\n\n        // grup_runs - group consecutive equal elements (like run-length encoding)\n        globals.borrow_mut().define(\n            \"grup_runs\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"grup_runs\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let list = list.borrow();\n                    let mut result: Vec<Value> = Vec::new();\n                    let mut current_group: Vec<Value> = Vec::new();\n\n                    for item in list.iter() {\n                        if current_group.is_empty() || &current_group[0] == item {\n                            current_group.push(item.clone());\n                        } else {\n                            result.push(Value::List(Rc::new(RefCell::new(current_group))));\n                            current_group = vec![item.clone()];\n                        }\n                    }\n                    if !current_group.is_empty() {\n                        result.push(Value::List(Rc::new(RefCell::new(current_group))));\n                    }\n\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"grup_runs() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // chunks - split list into chunks of size n\n        globals.borrow_mut().define(\n            \"chunks\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"chunks\", 2, |args| {\n                if let Value::List(list) = &args[0] {\n                    let n = args[1]\n                        .as_integer()\n                        .ok_or(\"chunks() needs an integer size\")?;\n                    if n <= 0 {\n                        return Err(\"chunks() size must be positive\".to_string());\n                    }\n                    let n = n as usize;\n                    let list = list.borrow();\n                    let result: Vec<Value> = list\n                        .chunks(n)\n                        .map(|chunk| Value::List(Rc::new(RefCell::new(chunk.to_vec()))))\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"chunks() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // interleave - alternate elements from two lists\n        globals.borrow_mut().define(\n            \"interleave\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"interleave\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::List(a), Value::List(b)) => {\n                        let a = a.borrow();\n                        let b = b.borrow();\n                        let mut result = Vec::new();\n                        let max_len = a.len().max(b.len());\n                        for i in 0..max_len {\n                            if i < a.len() {\n                                result.push(a[i].clone());\n                            }\n                            if i < b.len() {\n                                result.push(b[i].clone());\n                            }\n                        }\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"interleave() needs two lists\".to_string()),\n                },\n            ))),\n        );\n\n        // === More Mathematical Functions ===\n\n        // pooer - power/exponent (Scots: power)\n        globals.borrow_mut().define(\n            \"pooer\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pooer\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::Integer(base), Value::Integer(exp)) => {\n                        if *exp < 0 {\n                            Ok(Value::Float((*base as f64).powi(*exp as i32)))\n                        } else {\n                            Ok(Value::Integer(base.pow(*exp as u32)))\n                        }\n                    }\n                    (Value::Float(base), Value::Integer(exp)) => {\n                        Ok(Value::Float(base.powi(*exp as i32)))\n                    }\n                    (Value::Float(base), Value::Float(exp)) => Ok(Value::Float(base.powf(*exp))),\n                    (Value::Integer(base), Value::Float(exp)) => {\n                        Ok(Value::Float((*base as f64).powf(*exp)))\n                    }\n                    _ => Err(\"pooer() needs twa numbers\".to_string()),\n                }\n            }))),\n        );\n\n        // sin - sine (trigonometry)\n        globals.borrow_mut().define(\n            \"sin\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"sin\", 1, |args| {\n                match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.sin())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).sin())),\n                    _ => Err(\"sin() needs a number\".to_string()),\n                }\n            }))),\n        );\n\n        // cos - cosine\n        globals.borrow_mut().define(\n            \"cos\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"cos\", 1, |args| {\n                match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.cos())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).cos())),\n                    _ => Err(\"cos() needs a number\".to_string()),\n                }\n            }))),\n        );\n\n        // tan - tangent\n        globals.borrow_mut().define(\n            \"tan\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tan\", 1, |args| {\n                match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.tan())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).tan())),\n                    _ => Err(\"tan() needs a number\".to_string()),\n                }\n            }))),\n        );\n\n        // log - natural logarithm\n        globals.borrow_mut().define(\n            \"log\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"log\", 1, |args| {\n                match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.ln())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).ln())),\n                    _ => Err(\"log() needs a number\".to_string()),\n                }\n            }))),\n        );\n\n        // log10 - base 10 logarithm\n        globals.borrow_mut().define(\n            \"log10\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"log10\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.log10())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).log10())),\n                    _ => Err(\"log10() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // PI constant\n        globals\n            .borrow_mut()\n            .define(\"PI\".to_string(), Value::Float(std::f64::consts::PI));\n\n        // E constant (Euler's number)\n        globals\n            .borrow_mut()\n            .define(\"E\".to_string(), Value::Float(std::f64::consts::E));\n\n        // TAU constant (2*PI)\n        globals\n            .borrow_mut()\n            .define(\"TAU\".to_string(), Value::Float(std::f64::consts::TAU));\n\n        // exp - e raised to the power\n        globals.borrow_mut().define(\n            \"exp\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"exp\", 1, |args| {\n                match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.exp())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).exp())),\n                    _ => Err(\"exp() needs a number\".to_string()),\n                }\n            }))),\n        );\n\n        // pow - raise to a power (Scottish: mak it muckle!)\n        globals.borrow_mut().define(\n            \"pow\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pow\", 2, |args| {\n                let base = match &args[0] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"pow() needs numbers\".to_string()),\n                };\n                let exponent = match &args[1] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"pow() needs numbers\".to_string()),\n                };\n                Ok(Value::Float(base.powf(exponent)))\n            }))),\n        );\n\n        // asin - arc sine\n        globals.borrow_mut().define(\n            \"asin\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"asin\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.asin())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).asin())),\n                    _ => Err(\"asin() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // acos - arc cosine\n        globals.borrow_mut().define(\n            \"acos\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"acos\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.acos())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).acos())),\n                    _ => Err(\"acos() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // atan - arc tangent\n        globals.borrow_mut().define(\n            \"atan\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"atan\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.atan())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).atan())),\n                    _ => Err(\"atan() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // atan2 - two-argument arc tangent\n        globals.borrow_mut().define(\n            \"atan2\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"atan2\", 2, |args| {\n                let y = match &args[0] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"atan2() needs numbers\".to_string()),\n                };\n                let x = match &args[1] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"atan2() needs numbers\".to_string()),\n                };\n                Ok(Value::Float(y.atan2(x)))\n            }))),\n        );\n\n        // hypot - hypotenuse (sqrt(x + y))\n        globals.borrow_mut().define(\n            \"hypot\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"hypot\", 2, |args| {\n                let x = match &args[0] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"hypot() needs numbers\".to_string()),\n                };\n                let y = match &args[1] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"hypot() needs numbers\".to_string()),\n                };\n                Ok(Value::Float(x.hypot(y)))\n            }))),\n        );\n\n        // degrees - convert radians to degrees\n        globals.borrow_mut().define(\n            \"degrees\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"degrees\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.to_degrees())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).to_degrees())),\n                    _ => Err(\"degrees() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // radians - convert degrees to radians\n        globals.borrow_mut().define(\n            \"radians\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"radians\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.to_radians())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).to_radians())),\n                    _ => Err(\"radians() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // === Time Functions ===\n\n        // snooze - sleep for milliseconds (Scots: have a wee rest)\n        globals.borrow_mut().define(\n            \"snooze\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"snooze\", 1, |args| {\n                let ms = args[0]\n                    .as_integer()\n                    .ok_or(\"snooze() needs an integer (milliseconds)\")?;\n                if ms < 0 {\n                    return Err(\"Cannae snooze fer negative time, ya daftie!\".to_string());\n                }\n                std::thread::sleep(std::time::Duration::from_millis(ms as u64));\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // === String Functions ===\n\n        // roar - convert to uppercase (shout it oot even louder than upper!)\n        globals.borrow_mut().define(\n            \"roar\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"roar\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    // Add exclamation for extra emphasis!\n                    Ok(Value::String(format!(\"{}!\", s.to_uppercase())))\n                } else {\n                    Err(\"roar() expects a string\".to_string())\n                }\n            }))),\n        );\n\n        // mutter - whisper text (lowercase with dots)\n        globals.borrow_mut().define(\n            \"mutter\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"mutter\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(format!(\"...{}...\", s.to_lowercase())))\n                } else {\n                    Err(\"mutter() expects a string\".to_string())\n                }\n            }))),\n        );\n\n        // blooter - scramble a string randomly (Scots: hit/strike messily)\n        globals.borrow_mut().define(\n            \"blooter\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"blooter\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    use std::time::{SystemTime, UNIX_EPOCH};\n                    let seed = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_nanos() as u64;\n                    let mut chars: Vec<char> = s.chars().collect();\n                    // Fisher-Yates shuffle\n                    let mut rng = seed;\n                    for i in (1..chars.len()).rev() {\n                        rng = rng.wrapping_mul(1103515245).wrapping_add(12345);\n                        let j = (rng as usize) % (i + 1);\n                        chars.swap(i, j);\n                    }\n                    Ok(Value::String(chars.into_iter().collect()))\n                } else {\n                    Err(\"blooter() expects a string\".to_string())\n                }\n            }))),\n        );\n\n        // pad_left - pad string on left\n        globals.borrow_mut().define(\n            \"pad_left\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pad_left\", 3, |args| {\n                match (&args[0], &args[1], &args[2]) {\n                    (Value::String(s), Value::Integer(width), Value::String(pad)) => {\n                        let pad_char = pad.chars().next().unwrap_or(' ');\n                        let w = *width as usize;\n                        if s.len() >= w {\n                            Ok(Value::String(s.clone()))\n                        } else {\n                            Ok(Value::String(format!(\n                                \"{}{}\",\n                                pad_char.to_string().repeat(w - s.len()),\n                                s\n                            )))\n                        }\n                    }\n                    _ => Err(\"pad_left() needs (string, width, pad_char)\".to_string()),\n                }\n            }))),\n        );\n\n        // pad_right - pad string on right\n        globals.borrow_mut().define(\n            \"pad_right\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pad_right\", 3, |args| match (\n                &args[0], &args[1], &args[2],\n            ) {\n                (Value::String(s), Value::Integer(width), Value::String(pad)) => {\n                    let pad_char = pad.chars().next().unwrap_or(' ');\n                    let w = *width as usize;\n                    if s.len() >= w {\n                        Ok(Value::String(s.clone()))\n                    } else {\n                        Ok(Value::String(format!(\n                            \"{}{}\",\n                            s,\n                            pad_char.to_string().repeat(w - s.len())\n                        )))\n                    }\n                }\n                _ => Err(\"pad_right() needs (string, width, pad_char)\".to_string()),\n            }))),\n        );\n\n        // === List Functions ===\n\n        // drap - drop first n elements from list (Scots: drop)\n        globals.borrow_mut().define(\n            \"drap\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"drap\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(list), Value::Integer(n)) => {\n                        let n = *n as usize;\n                        let items = list.borrow();\n                        let result: Vec<Value> = items.iter().skip(n).cloned().collect();\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"drap() needs a list and an integer\".to_string()),\n                }\n            }))),\n        );\n\n        // tak - take first n elements from list (Scots: take)\n        globals.borrow_mut().define(\n            \"tak\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tak\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(list), Value::Integer(n)) => {\n                        let n = *n as usize;\n                        let items = list.borrow();\n                        let result: Vec<Value> = items.iter().take(n).cloned().collect();\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"tak() needs a list and an integer\".to_string()),\n                }\n            }))),\n        );\n\n        // grup - group elements into chunks (Scots: grip/group)\n        globals.borrow_mut().define(\n            \"grup\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"grup\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(list), Value::Integer(size)) => {\n                        if *size <= 0 {\n                            return Err(\"grup() needs a positive chunk size\".to_string());\n                        }\n                        let size = *size as usize;\n                        let items = list.borrow();\n                        let result: Vec<Value> = items\n                            .chunks(size)\n                            .map(|chunk| Value::List(Rc::new(RefCell::new(chunk.to_vec()))))\n                            .collect();\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"grup() needs a list and an integer\".to_string()),\n                }\n            }))),\n        );\n\n        // pair_up - create pairs from a list [a,b,c,d] -> [[a,b], [c,d]]\n        globals.borrow_mut().define(\n            \"pair_up\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pair_up\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    let result: Vec<Value> = items\n                        .chunks(2)\n                        .map(|chunk| Value::List(Rc::new(RefCell::new(chunk.to_vec()))))\n                        .collect();\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"pair_up() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // fankle - interleave two lists (Scots: tangle)\n        globals.borrow_mut().define(\n            \"fankle\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"fankle\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::List(a), Value::List(b)) => {\n                        let a = a.borrow();\n                        let b = b.borrow();\n                        let mut result = Vec::new();\n                        let mut ai = a.iter();\n                        let mut bi = b.iter();\n                        loop {\n                            match (ai.next(), bi.next()) {\n                                (Some(x), Some(y)) => {\n                                    result.push(x.clone());\n                                    result.push(y.clone());\n                                }\n                                (Some(x), None) => result.push(x.clone()),\n                                (None, Some(y)) => result.push(y.clone()),\n                                (None, None) => break,\n                            }\n                        }\n                        Ok(Value::List(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"fankle() needs two lists\".to_string()),\n                }\n            }))),\n        );\n\n        // === Fun Scottish Functions ===\n\n        // och - express disappointment or frustration\n        globals.borrow_mut().define(\n            \"och\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"och\", 1, |args| {\n                Ok(Value::String(format!(\"Och! {}\", args[0])))\n            }))),\n        );\n\n        // jings - express surprise (like \"gosh!\" or \"goodness!\")\n        globals.borrow_mut().define(\n            \"jings\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"jings\", 1, |args| {\n                Ok(Value::String(format!(\"Jings! {}\", args[0])))\n            }))),\n        );\n\n        // crivvens - express astonishment (from Oor Wullie)\n        globals.borrow_mut().define(\n            \"crivvens\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"crivvens\", 1, |args| {\n                Ok(Value::String(format!(\"Crivvens! {}\", args[0])))\n            }))),\n        );\n\n        // help_ma_boab - express extreme surprise (Scottish exclamation)\n        globals.borrow_mut().define(\n            \"help_ma_boab\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"help_ma_boab\", 1, |args| {\n                Ok(Value::String(format!(\"Help ma boab! {}\", args[0])))\n            }))),\n        );\n\n        // haud_yer_wheesht - tell someone to be quiet (returns empty string)\n        globals.borrow_mut().define(\n            \"haud_yer_wheesht\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"haud_yer_wheesht\",\n                0,\n                |_args| Ok(Value::String(\"\".to_string())),\n            ))),\n        );\n\n        // braw - check if something is good/excellent\n        globals.borrow_mut().define(\n            \"braw\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"braw\", 1, |args| {\n                // Everything is braw in Scotland!\n                let val = &args[0];\n                let is_braw = match val {\n                    Value::Nil => false,\n                    Value::Bool(b) => *b,\n                    Value::Integer(n) => *n > 0,\n                    Value::Float(f) => *f > 0.0,\n                    Value::String(s) => !s.is_empty(),\n                    Value::List(l) => !l.borrow().is_empty(),\n                    Value::Dict(d) => !d.borrow().is_empty(),\n                    _ => true,\n                };\n                Ok(Value::Bool(is_braw))\n            }))),\n        );\n\n        // clarty - check if something is messy/dirty (has duplicates in list)\n        globals.borrow_mut().define(\n            \"clarty\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"clarty\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    let mut seen = Vec::new();\n                    for item in items.iter() {\n                        if seen.contains(item) {\n                            return Ok(Value::Bool(true)); // Has duplicates = clarty\n                        }\n                        seen.push(item.clone());\n                    }\n                    Ok(Value::Bool(false))\n                } else if let Value::String(s) = &args[0] {\n                    // String is clarty if it has repeated characters\n                    let chars: Vec<char> = s.chars().collect();\n                    let unique: std::collections::HashSet<char> = chars.iter().cloned().collect();\n                    Ok(Value::Bool(chars.len() != unique.len()))\n                } else {\n                    Err(\"clarty() needs a list or string\".to_string())\n                }\n            }))),\n        );\n\n        // dreich - check if a string is boring/dull (all same character or empty)\n        globals.borrow_mut().define(\n            \"dreich\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"dreich\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    if s.is_empty() {\n                        return Ok(Value::Bool(true)); // Empty is dreich\n                    }\n                    let first = s.chars().next().unwrap();\n                    let is_dreich = s.chars().all(|c| c == first);\n                    Ok(Value::Bool(is_dreich))\n                } else {\n                    Err(\"dreich() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // stoater - get a particularly good/outstanding element (max for numbers)\n        globals.borrow_mut().define(\n            \"stoater\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"stoater\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Err(\"Cannae find a stoater in an empty list!\".to_string());\n                    }\n                    // Find the \"best\" element (max for numbers, longest for strings)\n                    let mut best = items[0].clone();\n                    for item in items.iter().skip(1) {\n                        match (&best, item) {\n                            (Value::Integer(a), Value::Integer(b)) => {\n                                if *b > *a {\n                                    best = item.clone();\n                                }\n                            }\n                            (Value::Float(a), Value::Float(b)) => {\n                                if *b > *a {\n                                    best = item.clone();\n                                }\n                            }\n                            (Value::String(a), Value::String(b)) => {\n                                if b.len() > a.len() {\n                                    best = item.clone();\n                                }\n                            }\n                            _ => {}\n                        }\n                    }\n                    Ok(best)\n                } else {\n                    Err(\"stoater() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // numpty_check - validate input isn't empty/nil\n        globals.borrow_mut().define(\n            \"numpty_check\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"numpty_check\",\n                1,\n                |args| match &args[0] {\n                    Value::Nil => Ok(Value::String(\"That's naething, ya numpty!\".to_string())),\n                    Value::String(s) if s.is_empty() => {\n                        Ok(Value::String(\"Empty string, ya numpty!\".to_string()))\n                    }\n                    Value::List(l) if l.borrow().is_empty() => {\n                        Ok(Value::String(\"Empty list, ya numpty!\".to_string()))\n                    }\n                    _ => Ok(Value::String(\"That's braw!\".to_string())),\n                },\n            ))),\n        );\n\n        // scottify - add Scottish flair to text\n        globals.borrow_mut().define(\n            \"scottify\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"scottify\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    let scottified = s\n                        .replace(\"yes\", \"aye\")\n                        .replace(\"Yes\", \"Aye\")\n                        .replace(\"no\", \"nae\")\n                        .replace(\"No\", \"Nae\")\n                        .replace(\"know\", \"ken\")\n                        .replace(\"Know\", \"Ken\")\n                        .replace(\"not\", \"nae\")\n                        .replace(\"from\", \"fae\")\n                        .replace(\"to\", \"tae\")\n                        .replace(\"do\", \"dae\")\n                        .replace(\"myself\", \"masel\")\n                        .replace(\"yourself\", \"yersel\")\n                        .replace(\"small\", \"wee\")\n                        .replace(\"little\", \"wee\")\n                        .replace(\"child\", \"bairn\")\n                        .replace(\"children\", \"bairns\")\n                        .replace(\"church\", \"kirk\")\n                        .replace(\"beautiful\", \"bonnie\")\n                        .replace(\"Beautiful\", \"Bonnie\")\n                        .replace(\"going\", \"gaun\")\n                        .replace(\"have\", \"hae\")\n                        .replace(\"nothing\", \"naething\")\n                        .replace(\"something\", \"somethin\")\n                        .replace(\"everything\", \"awthing\")\n                        .replace(\"everyone\", \"awbody\")\n                        .replace(\"about\", \"aboot\")\n                        .replace(\"out\", \"oot\")\n                        .replace(\"house\", \"hoose\");\n                    Ok(Value::String(scottified))\n                } else {\n                    Err(\"scottify() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // unique - remove duplicates from list (keeps first occurrence)\n        globals.borrow_mut().define(\n            \"unique\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"unique\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let mut seen = Vec::new();\n                    let mut result = Vec::new();\n                    for item in list.borrow().iter() {\n                        if !seen.contains(item) {\n                            seen.push(item.clone());\n                            result.push(item.clone());\n                        }\n                    }\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                } else {\n                    Err(\"unique() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // === File I/O Functions ===\n\n        // scrieve - write to file (Scots: \"write\")\n        globals.borrow_mut().define(\n            \"scrieve\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"scrieve\", 2, |args| {\n                use std::fs::File;\n                use std::io::Write as IoWrite;\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"scrieve() needs a file path string\".to_string()),\n                };\n                let content = args[1].to_string();\n                let mut file = File::create(&path)\n                    .map_err(|e| format!(\"Couldnae open '{}' fer writin': {}\", path, e))?;\n                file.write_all(content.as_bytes())\n                    .map_err(|e| format!(\"Couldnae write tae '{}': {}\", path, e))?;\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // read_file - read entire file (Scots: readie would be good but let's be clear)\n        globals.borrow_mut().define(\n            \"read_file\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"read_file\", 1, |args| {\n                use std::fs;\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"read_file() needs a file path string\".to_string()),\n                };\n                let content = fs::read_to_string(&path)\n                    .map_err(|e| format!(\"Couldnae read '{}': {}\", path, e))?;\n                Ok(Value::String(content))\n            }))),\n        );\n\n        // read_lines - read file as list of lines\n        globals.borrow_mut().define(\n            \"read_lines\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"read_lines\", 1, |args| {\n                use std::fs;\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"read_lines() needs a file path string\".to_string()),\n                };\n                let content = fs::read_to_string(&path)\n                    .map_err(|e| format!(\"Couldnae read '{}': {}\", path, e))?;\n                let lines: Vec<Value> = content\n                    .lines()\n                    .map(|l| Value::String(l.to_string()))\n                    .collect();\n                Ok(Value::List(Rc::new(RefCell::new(lines))))\n            }))),\n        );\n\n        // file_exists - check if file exists\n        globals.borrow_mut().define(\n            \"file_exists\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"file_exists\", 1, |args| {\n                use std::path::Path;\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"file_exists() needs a file path string\".to_string()),\n                };\n                Ok(Value::Bool(Path::new(&path).exists()))\n            }))),\n        );\n\n        // append_file - append to file\n        globals.borrow_mut().define(\n            \"append_file\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"append_file\", 2, |args| {\n                use std::fs::OpenOptions;\n                use std::io::Write as IoWrite;\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"append_file() needs a file path string\".to_string()),\n                };\n                let content = args[1].to_string();\n                let mut file = OpenOptions::new()\n                    .create(true)\n                    .append(true)\n                    .open(&path)\n                    .map_err(|e| format!(\"Couldnae open '{}' fer appendin': {}\", path, e))?;\n                file.write_all(content.as_bytes())\n                    .map_err(|e| format!(\"Couldnae append tae '{}': {}\", path, e))?;\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // === More Scots-Themed Functions ===\n\n        // haver - generate random nonsense (Scots: talk rubbish)\n        globals.borrow_mut().define(\n            \"haver\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"haver\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let havers = [\n                    \"Och, yer bum's oot the windae!\",\n                    \"Awa' an bile yer heid!\",\n                    \"Haud yer wheesht, ya numpty!\",\n                    \"Dinnae fash yersel!\",\n                    \"Whit's fer ye'll no go by ye!\",\n                    \"Lang may yer lum reek!\",\n                    \"Yer a wee scunner, so ye are!\",\n                    \"Haste ye back!\",\n                    \"It's a dreich day the day!\",\n                    \"Pure dead brilliant!\",\n                    \"Ah'm fair puckled!\",\n                    \"Gie it laldy!\",\n                    \"Whit a stoater!\",\n                    \"That's pure mince!\",\n                    \"Jings, crivvens, help ma boab!\",\n                ];\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as u64;\n                let rng = seed.wrapping_mul(1103515245).wrapping_add(12345);\n                let idx = (rng as usize) % havers.len();\n                Ok(Value::String(havers[idx].to_string()))\n            }))),\n        );\n\n        // slainte - return a Scottish toast (Scots: health/cheers)\n        globals.borrow_mut().define(\n            \"slainte\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"slainte\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let toasts = [\n                    \"Slinte mhath! (Good health!)\",\n                    \"Here's tae us, wha's like us? Gey few, and they're a' deid!\",\n                    \"May the best ye've ever seen be the worst ye'll ever see!\",\n                    \"Lang may yer lum reek wi' ither fowk's coal!\",\n                    \"May ye aye be happy, an' never drink frae a toom glass!\",\n                    \"Here's tae the heath, the hill and the heather!\",\n                ];\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as u64;\n                let rng = seed.wrapping_mul(1103515245).wrapping_add(12345);\n                let idx = (rng as usize) % toasts.len();\n                Ok(Value::String(toasts[idx].to_string()))\n            }))),\n        );\n\n        // braw_time - format current time in a nice Scottish way\n        globals.borrow_mut().define(\n            \"braw_time\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"braw_time\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let secs = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs();\n                // Simple hour/minute calculation (UTC)\n                let hours = (secs / 3600) % 24;\n                let minutes = (secs / 60) % 60;\n                let time_str = match hours {\n                    0..=5 => format!(\"It's the wee small hours ({:02}:{:02})\", hours, minutes),\n                    6..=11 => format!(\"It's the mornin' ({:02}:{:02})\", hours, minutes),\n                    12 => format!(\"It's high noon ({:02}:{:02})\", hours, minutes),\n                    13..=17 => format!(\"It's the efternoon ({:02}:{:02})\", hours, minutes),\n                    18..=21 => format!(\"It's the evenin' ({:02}:{:02})\", hours, minutes),\n                    _ => format!(\"It's gettin' late ({:02}:{:02})\", hours, minutes),\n                };\n                Ok(Value::String(time_str))\n            }))),\n        );\n\n        // wheesht_aw - trim and clean up a string (more thorough than wheesht)\n        globals.borrow_mut().define(\n            \"wheesht_aw\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"wheesht_aw\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    // Collapse multiple spaces and trim\n                    let cleaned: String = s.split_whitespace().collect::<Vec<_>>().join(\" \");\n                    Ok(Value::String(cleaned))\n                } else {\n                    Err(\"wheesht_aw() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // scunner_check - validate that a value meets expectations (returns descriptive error)\n        globals.borrow_mut().define(\n            \"scunner_check\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"scunner_check\", 2, |args| {\n                let val = &args[0];\n                let expected_type = match &args[1] {\n                    Value::String(s) => s.as_str(),\n                    _ => return Err(\"scunner_check() needs type name as second arg\".to_string()),\n                };\n                let actual_type = val.type_name();\n                if actual_type == expected_type {\n                    Ok(Value::Bool(true))\n                } else {\n                    Ok(Value::String(format!(\n                        \"Och, ya scunner! Expected {} but got {}\",\n                        expected_type, actual_type\n                    )))\n                }\n            }))),\n        );\n\n        // bampot_mode - deliberately cause chaos (scramble list order)\n        globals.borrow_mut().define(\n            \"bampot_mode\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bampot_mode\", 1, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                if let Value::List(list) = &args[0] {\n                    let mut items: Vec<Value> = list.borrow().clone();\n                    let seed = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_nanos() as u64;\n                    let mut rng = seed;\n                    // Double shuffle for extra chaos!\n                    for _ in 0..2 {\n                        for i in (1..items.len()).rev() {\n                            rng = rng.wrapping_mul(1103515245).wrapping_add(12345);\n                            let j = (rng as usize) % (i + 1);\n                            items.swap(i, j);\n                        }\n                    }\n                    items.reverse(); // And reverse for good measure!\n                    Ok(Value::List(Rc::new(RefCell::new(items))))\n                } else {\n                    Err(\"bampot_mode() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // crabbit - check if a number is negative (Scots: grumpy/bad-tempered)\n        globals.borrow_mut().define(\n            \"crabbit\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"crabbit\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Bool(*n < 0)),\n                    Value::Float(f) => Ok(Value::Bool(*f < 0.0)),\n                    _ => Err(\"crabbit() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // gallus - check if a value is bold/impressive (non-empty/non-zero)\n        globals.borrow_mut().define(\n            \"gallus\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"gallus\", 1, |args| {\n                let is_gallus = match &args[0] {\n                    Value::Integer(n) => *n != 0 && (*n > 100 || *n < -100),\n                    Value::Float(f) => *f != 0.0 && (*f > 100.0 || *f < -100.0),\n                    Value::String(s) => s.len() > 20,\n                    Value::List(l) => l.borrow().len() > 10,\n                    _ => false,\n                };\n                Ok(Value::Bool(is_gallus))\n            }))),\n        );\n\n        // drookit - check if list has duplicates (Scots: soaking wet/full)\n        globals.borrow_mut().define(\n            \"drookit\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"drookit\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    let mut seen = Vec::new();\n                    for item in items.iter() {\n                        if seen.contains(item) {\n                            return Ok(Value::Bool(true));\n                        }\n                        seen.push(item.clone());\n                    }\n                    Ok(Value::Bool(false))\n                } else {\n                    Err(\"drookit() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // glaikit - check if something looks \"stupid\" (empty, zero, or invalid)\n        globals.borrow_mut().define(\n            \"glaikit\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"glaikit\", 1, |args| {\n                let is_glaikit = match &args[0] {\n                    Value::Nil => true,\n                    Value::Integer(0) => true,\n                    Value::Float(f) if *f == 0.0 => true,\n                    Value::String(s) if s.is_empty() || s.trim().is_empty() => true,\n                    Value::List(l) if l.borrow().is_empty() => true,\n                    Value::Dict(d) if d.borrow().is_empty() => true,\n                    _ => false,\n                };\n                Ok(Value::Bool(is_glaikit))\n            }))),\n        );\n\n        // cannie - check if a value is \"careful\"/safe (within reasonable bounds)\n        globals.borrow_mut().define(\n            \"cannie\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"cannie\", 1, |args| {\n                let is_cannie = match &args[0] {\n                    Value::Integer(n) => *n >= -1000 && *n <= 1000,\n                    Value::Float(f) => *f >= -1000.0 && *f <= 1000.0 && f.is_finite(),\n                    Value::String(s) => s.len() <= 1000 && !s.contains(|c: char| c.is_control()),\n                    Value::List(l) => l.borrow().len() <= 1000,\n                    Value::Dict(d) => d.borrow().len() <= 100,\n                    _ => true,\n                };\n                Ok(Value::Bool(is_cannie))\n            }))),\n        );\n\n        // geggie - get the \"mouth\" (first and last chars) of a string\n        globals.borrow_mut().define(\n            \"geggie\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"geggie\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    if s.is_empty() {\n                        return Ok(Value::String(\"\".to_string()));\n                    }\n                    let first = s.chars().next().unwrap();\n                    let last = s.chars().last().unwrap();\n                    Ok(Value::String(format!(\"{}{}\", first, last)))\n                } else {\n                    Err(\"geggie() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // banter - interleave two strings\n        globals.borrow_mut().define(\n            \"banter\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"banter\", 2, |args| {\n                let s1 = match &args[0] {\n                    Value::String(s) => s,\n                    _ => return Err(\"banter() needs two strings\".to_string()),\n                };\n                let s2 = match &args[1] {\n                    Value::String(s) => s,\n                    _ => return Err(\"banter() needs two strings\".to_string()),\n                };\n                let mut result = String::new();\n                let mut chars1 = s1.chars();\n                let mut chars2 = s2.chars();\n                loop {\n                    match (chars1.next(), chars2.next()) {\n                        (Some(c1), Some(c2)) => {\n                            result.push(c1);\n                            result.push(c2);\n                        }\n                        (Some(c1), None) => result.push(c1),\n                        (None, Some(c2)) => result.push(c2),\n                        (None, None) => break,\n                    }\n                }\n                Ok(Value::String(result))\n            }))),\n        );\n\n        // skelp - split a string into chunks of n chars (Scots: slap/hit)\n        globals.borrow_mut().define(\n            \"skelp\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"skelp\", 2, |args| {\n                let s = match &args[0] {\n                    Value::String(s) => s,\n                    _ => return Err(\"skelp() needs a string and size\".to_string()),\n                };\n                let size = args[1].as_integer().ok_or(\"skelp() needs integer size\")?;\n                if size <= 0 {\n                    return Err(\"skelp() size must be positive\".to_string());\n                }\n                let chunks: Vec<Value> = s\n                    .chars()\n                    .collect::<Vec<_>>()\n                    .chunks(size as usize)\n                    .map(|chunk| Value::String(chunk.iter().collect()))\n                    .collect();\n                Ok(Value::List(Rc::new(RefCell::new(chunks))))\n            }))),\n        );\n\n        // indices_o - find all indices of a value (Scots: indices of)\n        globals.borrow_mut().define(\n            \"indices_o\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"indices_o\",\n                2,\n                |args| match &args[0] {\n                    Value::List(list) => {\n                        let items = list.borrow();\n                        let needle = &args[1];\n                        let indices: Vec<Value> = items\n                            .iter()\n                            .enumerate()\n                            .filter(|(_, item)| *item == needle)\n                            .map(|(i, _)| Value::Integer(i as i64))\n                            .collect();\n                        Ok(Value::List(Rc::new(RefCell::new(indices))))\n                    }\n                    Value::String(s) => {\n                        let needle = match &args[1] {\n                            Value::String(n) => n,\n                            _ => {\n                                return Err(\n                                    \"indices_o() on string needs a string needle\".to_string()\n                                )\n                            }\n                        };\n                        if needle.is_empty() {\n                            return Err(\"Cannae search fer an empty string, ya numpty!\".to_string());\n                        }\n                        let indices: Vec<Value> = s\n                            .match_indices(needle.as_str())\n                            .map(|(i, _)| Value::Integer(i as i64))\n                            .collect();\n                        Ok(Value::List(Rc::new(RefCell::new(indices))))\n                    }\n                    _ => Err(\"indices_o() needs a list or string\".to_string()),\n                },\n            ))),\n        );\n\n        // braw_date - format a timestamp or current time in Scottish style\n        globals.borrow_mut().define(\n            \"braw_date\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"braw_date\", 1, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let secs = match &args[0] {\n                    Value::Integer(n) => *n as u64,\n                    Value::Nil => SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs(),\n                    _ => return Err(\"braw_date() needs a timestamp or naething\".to_string()),\n                };\n                // Calculate date components (simplified, doesn't handle leap years perfectly)\n                let days_since_epoch = secs / 86400;\n                let day_of_week = ((days_since_epoch + 4) % 7) as usize; // Jan 1, 1970 was Thursday\n\n                let scots_day_names = [\n                    \"the Sabbath\",\n                    \"Monday\",\n                    \"Tuesday\",\n                    \"Wednesday\",\n                    \"Thursday\",\n                    \"Friday\",\n                    \"Setterday\",\n                ];\n\n                // Simple month/day calculation\n                let mut remaining_days = days_since_epoch as i64;\n                let mut year = 1970i64;\n                loop {\n                    let days_in_year = if (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 {\n                        366\n                    } else {\n                        365\n                    };\n                    if remaining_days < days_in_year {\n                        break;\n                    }\n                    remaining_days -= days_in_year;\n                    year += 1;\n                }\n\n                let scots_months = [\n                    \"Januar\",\n                    \"Februar\",\n                    \"Mairch\",\n                    \"Aprile\",\n                    \"Mey\",\n                    \"Juin\",\n                    \"Julie\",\n                    \"August\",\n                    \"September\",\n                    \"October\",\n                    \"November\",\n                    \"December\",\n                ];\n                let days_in_months: [i64; 12] =\n                    if (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 {\n                        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n                    } else {\n                        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n                    };\n\n                let mut month = 0usize;\n                for (i, &days) in days_in_months.iter().enumerate() {\n                    if remaining_days < days {\n                        month = i;\n                        break;\n                    }\n                    remaining_days -= days;\n                }\n                let day = remaining_days + 1;\n\n                let ordinal = match day {\n                    1 | 21 | 31 => \"st\",\n                    2 | 22 => \"nd\",\n                    3 | 23 => \"rd\",\n                    _ => \"th\",\n                };\n\n                Ok(Value::String(format!(\n                    \"{}, the {}{} o' {}, {}\",\n                    scots_day_names[day_of_week], day, ordinal, scots_months[month], year\n                )))\n            }))),\n        );\n\n        // Higher-order functions are defined as marker values\n        // They get special handling in call_value\n\n        // gaun - map function over list (Scots: \"going\")\n        globals.borrow_mut().define(\n            \"gaun\".to_string(),\n            Value::String(\"__builtin_gaun__\".to_string()),\n        );\n\n        // sieve - filter list (keep elements that pass)\n        globals.borrow_mut().define(\n            \"sieve\".to_string(),\n            Value::String(\"__builtin_sieve__\".to_string()),\n        );\n\n        // tumble - reduce/fold list (Scots: tumble together)\n        globals.borrow_mut().define(\n            \"tumble\".to_string(),\n            Value::String(\"__builtin_tumble__\".to_string()),\n        );\n\n        // ilk - for each (Scots: each/every)\n        globals.borrow_mut().define(\n            \"ilk\".to_string(),\n            Value::String(\"__builtin_ilk__\".to_string()),\n        );\n\n        // hunt - find first matching element\n        globals.borrow_mut().define(\n            \"hunt\".to_string(),\n            Value::String(\"__builtin_hunt__\".to_string()),\n        );\n\n        // ony - check if any element matches (Scots: any)\n        globals.borrow_mut().define(\n            \"ony\".to_string(),\n            Value::String(\"__builtin_ony__\".to_string()),\n        );\n\n        // aw - check if all elements match (Scots: all)\n        globals.borrow_mut().define(\n            \"aw\".to_string(),\n            Value::String(\"__builtin_aw__\".to_string()),\n        );\n\n        // grup_up - group list elements by function result (Scots: group up)\n        globals.borrow_mut().define(\n            \"grup_up\".to_string(),\n            Value::String(\"__builtin_grup_up__\".to_string()),\n        );\n\n        // pairt_by - partition list by predicate into [true, false] lists\n        globals.borrow_mut().define(\n            \"pairt_by\".to_string(),\n            Value::String(\"__builtin_pairt_by__\".to_string()),\n        );\n\n        // === More Scots-Flavoured Functions ===\n\n        // haverin - check if a string is empty/nonsense (talking havers!)\n        globals.borrow_mut().define(\n            \"haverin\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"haverin\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => {\n                        let trimmed = s.trim();\n                        Ok(Value::Bool(trimmed.is_empty() || trimmed.len() < 2))\n                    }\n                    Value::Nil => Ok(Value::Bool(true)),\n                    Value::List(l) => Ok(Value::Bool(l.borrow().is_empty())),\n                    _ => Ok(Value::Bool(false)),\n                },\n            ))),\n        );\n\n        // scunner - check if value is \"disgusting\" (negative or empty)\n        globals.borrow_mut().define(\n            \"scunner\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"scunner\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Bool(*n < 0)),\n                    Value::Float(f) => Ok(Value::Bool(*f < 0.0)),\n                    Value::String(s) => Ok(Value::Bool(s.is_empty())),\n                    Value::List(l) => Ok(Value::Bool(l.borrow().is_empty())),\n                    Value::Bool(b) => Ok(Value::Bool(!*b)),\n                    Value::Nil => Ok(Value::Bool(true)),\n                    _ => Ok(Value::Bool(false)),\n                },\n            ))),\n        );\n\n        // bonnie - pretty print a value with decoration\n        globals.borrow_mut().define(\n            \"bonnie\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bonnie\", 1, |args| {\n                let val_str = format!(\"{}\", args[0]);\n                Ok(Value::String(format!(\"~~~ {} ~~~\", val_str)))\n            }))),\n        );\n\n        // is_wee - check if value is small (< 10 for numbers, < 5 chars for strings)\n        globals.borrow_mut().define(\n            \"is_wee\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_wee\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Bool(n.abs() < 10)),\n                    Value::Float(f) => Ok(Value::Bool(f.abs() < 10.0)),\n                    Value::String(s) => Ok(Value::Bool(s.len() < 5)),\n                    Value::List(l) => Ok(Value::Bool(l.borrow().len() < 5)),\n                    _ => Ok(Value::Bool(true)),\n                },\n            ))),\n        );\n\n        // is_muckle - check if value is big (opposite of is_wee)\n        globals.borrow_mut().define(\n            \"is_muckle\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_muckle\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Bool(n.abs() >= 100)),\n                    Value::Float(f) => Ok(Value::Bool(f.abs() >= 100.0)),\n                    Value::String(s) => Ok(Value::Bool(s.len() >= 50)),\n                    Value::List(l) => Ok(Value::Bool(l.borrow().len() >= 50)),\n                    _ => Ok(Value::Bool(false)),\n                },\n            ))),\n        );\n\n        // cannie - check if value is safe/valid (not nil, not empty, not negative)\n        globals.borrow_mut().define(\n            \"cannie\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"cannie\",\n                1,\n                |args| match &args[0] {\n                    Value::Nil => Ok(Value::Bool(false)),\n                    Value::Integer(n) => Ok(Value::Bool(*n >= 0)),\n                    Value::Float(f) => Ok(Value::Bool(*f >= 0.0 && !f.is_nan())),\n                    Value::String(s) => Ok(Value::Bool(!s.is_empty())),\n                    Value::List(l) => Ok(Value::Bool(!l.borrow().is_empty())),\n                    Value::Bool(b) => Ok(Value::Bool(*b)),\n                    _ => Ok(Value::Bool(true)),\n                },\n            ))),\n        );\n\n        // wrang_sort - check if value is the wrong type (sort = kind/type in Scots)\n        globals.borrow_mut().define(\n            \"wrang_sort\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"wrang_sort\", 2, |args| {\n                let expected_type = match &args[1] {\n                    Value::String(s) => s.as_str(),\n                    _ => return Err(\"Second arg must be a type name string\".to_string()),\n                };\n                let actual_type = args[0].type_name();\n                Ok(Value::Bool(actual_type != expected_type))\n            }))),\n        );\n\n        // tattie_scone - repeat string n times with | separator (like stacking scones!)\n        globals.borrow_mut().define(\n            \"tattie_scone\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tattie_scone\", 2, |args| {\n                let s = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"tattie_scone needs a string\".to_string()),\n                };\n                let n = match &args[1] {\n                    Value::Integer(n) => *n as usize,\n                    _ => return Err(\"tattie_scone needs a number\".to_string()),\n                };\n                let result = vec![s; n].join(\" | \");\n                Ok(Value::String(result))\n            }))),\n        );\n\n        // haggis_hunt - find all occurrences of substring in string\n        globals.borrow_mut().define(\n            \"haggis_hunt\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"haggis_hunt\", 2, |args| {\n                let haystack = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"haggis_hunt needs a string tae search\".to_string()),\n                };\n                let needle = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"haggis_hunt needs a string tae find\".to_string()),\n                };\n                let positions: Vec<Value> = haystack\n                    .match_indices(&needle)\n                    .map(|(i, _)| Value::Integer(i as i64))\n                    .collect();\n                Ok(Value::List(Rc::new(RefCell::new(positions))))\n            }))),\n        );\n\n        // sporran_fill - pad both sides of string (like a sporran!)\n        globals.borrow_mut().define(\n            \"sporran_fill\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"sporran_fill\", 3, |args| {\n                let s = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"sporran_fill needs a string\".to_string()),\n                };\n                let width = match &args[1] {\n                    Value::Integer(n) => *n as usize,\n                    _ => return Err(\"sporran_fill needs a width\".to_string()),\n                };\n                let fill = match &args[2] {\n                    Value::String(c) => c.chars().next().unwrap_or(' '),\n                    _ => return Err(\"sporran_fill needs a fill character\".to_string()),\n                };\n                if s.len() >= width {\n                    return Ok(Value::String(s));\n                }\n                let padding = width - s.len();\n                let left_pad = padding / 2;\n                let right_pad = padding - left_pad;\n                let result = format!(\n                    \"{}{}{}\",\n                    fill.to_string().repeat(left_pad),\n                    s,\n                    fill.to_string().repeat(right_pad)\n                );\n                Ok(Value::String(result))\n            }))),\n        );\n\n        // ============================================================\n        // MORE SCOTS FUN FUNCTIONS\n        // ============================================================\n\n        // blether_format - format a string with named placeholders\n        // blether_format(\"Hullo {name}, ye are {age} years auld\", {\"name\": \"Hamish\", \"age\": 42})\n        globals.borrow_mut().define(\n            \"blether_format\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"blether_format\", 2, |args| {\n                let template = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"blether_format needs a template string\".to_string()),\n                };\n                let dict = match &args[1] {\n                    Value::Dict(d) => d.borrow().clone(),\n                    _ => return Err(\"blether_format needs a dictionary o' values\".to_string()),\n                };\n                let mut result = template;\n                for (key, value) in dict {\n                    let placeholder = format!(\"{{{}}}\", key);\n                    result = result.replace(&placeholder, &format!(\"{}\", value));\n                }\n                Ok(Value::String(result))\n            }))),\n        );\n\n        // ceilidh - shuffle and interleave two lists like dancers at a ceilidh!\n        globals.borrow_mut().define(\n            \"ceilidh\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"ceilidh\", 2, |args| {\n                let list1 = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => return Err(\"ceilidh needs two lists\".to_string()),\n                };\n                let list2 = match &args[1] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => return Err(\"ceilidh needs two lists\".to_string()),\n                };\n                let mut result = Vec::new();\n                let max_len = list1.len().max(list2.len());\n                for i in 0..max_len {\n                    if i < list1.len() {\n                        result.push(list1[i].clone());\n                    }\n                    if i < list2.len() {\n                        result.push(list2[i].clone());\n                    }\n                }\n                Ok(Value::List(Rc::new(RefCell::new(result))))\n            }))),\n        );\n\n        // dram - get a random element from a list (like pouring a wee dram!)\n        globals.borrow_mut().define(\n            \"dram\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"dram\", 1, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => return Err(\"dram needs a list tae pick fae\".to_string()),\n                };\n                if list.is_empty() {\n                    return Ok(Value::Nil);\n                }\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as usize;\n                let idx = seed % list.len();\n                Ok(list[idx].clone())\n            }))),\n        );\n\n        // birl - rotate a list (birl = spin/rotate in Scots)\n        globals.borrow_mut().define(\n            \"birl\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"birl\", 2, |args| {\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => return Err(\"birl needs a list\".to_string()),\n                };\n                let n = match &args[1] {\n                    Value::Integer(n) => *n,\n                    _ => return Err(\"birl needs a rotation count\".to_string()),\n                };\n                if list.is_empty() {\n                    return Ok(Value::List(Rc::new(RefCell::new(list))));\n                }\n                let len = list.len() as i64;\n                let n = ((n % len) + len) % len; // Handle negative rotation\n                let n = n as usize;\n                let mut result = list.clone();\n                result.rotate_left(n);\n                Ok(Value::List(Rc::new(RefCell::new(result))))\n            }))),\n        );\n\n        // stooshie - create chaos/noise (shuffle a string's characters)\n        globals.borrow_mut().define(\n            \"stooshie\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"stooshie\", 1, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let s = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"stooshie needs a string\".to_string()),\n                };\n                let mut chars: Vec<char> = s.chars().collect();\n                // Simple Fisher-Yates shuffle\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as u64;\n                let mut rng = seed;\n                for i in (1..chars.len()).rev() {\n                    rng = rng.wrapping_mul(1103515245).wrapping_add(12345);\n                    let j = (rng as usize) % (i + 1);\n                    chars.swap(i, j);\n                }\n                Ok(Value::String(chars.into_iter().collect()))\n            }))),\n        );\n\n        // clype - report on a value (like telling tales!) - returns debug info\n        globals.borrow_mut().define(\n            \"clype\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"clype\", 1, |args| {\n                let val = &args[0];\n                let type_name = val.type_name();\n                let info = match val {\n                    Value::List(l) => format!(\"list wi' {} items\", l.borrow().len()),\n                    Value::Dict(d) => format!(\"dict wi' {} entries\", d.borrow().len()),\n                    Value::Set(s) => format!(\"creel wi' {} items\", s.borrow().len()),\n                    Value::String(s) => format!(\"string o' {} characters\", s.len()),\n                    Value::Integer(n) => format!(\"integer: {}\", n),\n                    Value::Float(f) => format!(\"float: {}\", f),\n                    Value::Bool(b) => format!(\"boolean: {}\", if *b { \"aye\" } else { \"nae\" }),\n                    Value::Nil => \"naething\".to_string(),\n                    Value::Function(f) => format!(\"function '{}'\", f.name),\n                    Value::NativeFunction(f) => format!(\"native function '{}'\", f.name),\n                    Value::Class(c) => format!(\"class '{}'\", c.name),\n                    Value::Instance(inst) => format!(\"instance o' '{}'\", inst.borrow().class.name),\n                    _ => type_name.to_string(),\n                };\n                Ok(Value::String(format!(\"[{}] {}\", type_name, info)))\n            }))),\n        );\n\n        // sclaff - flatten nested lists (sclaff = hit flat in golf)\n        globals.borrow_mut().define(\n            \"sclaff\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"sclaff\", 1, |args| {\n                fn flatten_recursive(val: &Value, result: &mut Vec<Value>) {\n                    match val {\n                        Value::List(l) => {\n                            for item in l.borrow().iter() {\n                                flatten_recursive(item, result);\n                            }\n                        }\n                        other => result.push(other.clone()),\n                    }\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.clone(),\n                    _ => return Err(\"sclaff needs a list\".to_string()),\n                };\n                let mut result = Vec::new();\n                for item in list.borrow().iter() {\n                    flatten_recursive(item, &mut result);\n                }\n                Ok(Value::List(Rc::new(RefCell::new(result))))\n            }))),\n        );\n\n        // ============================================================\n        // TIMING/BENCHMARKING FUNCTIONS - Measure yer code's speed!\n        // ============================================================\n\n        // noo - get current timestamp in milliseconds (like \"now\")\n        globals.borrow_mut().define(\n            \"noo\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"noo\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n                Ok(Value::Integer(duration.as_millis() as i64))\n            }))),\n        );\n\n        // tick - high precision nanoseconds timestamp\n        globals.borrow_mut().define(\n            \"tick\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tick\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n                Ok(Value::Integer(duration.as_nanos() as i64))\n            }))),\n        );\n\n        // bide - sleep for milliseconds (bide = wait in Scots)\n        globals.borrow_mut().define(\n            \"bide\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bide\", 1, |args| {\n                let ms = match &args[0] {\n                    Value::Integer(n) => *n as u64,\n                    Value::Float(f) => *f as u64,\n                    _ => return Err(\"bide() needs a number o' milliseconds\".to_string()),\n                };\n                std::thread::sleep(std::time::Duration::from_millis(ms));\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // stopwatch - time a function call and return [result, time_ms]\n        globals.borrow_mut().define(\n            \"stopwatch\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"stopwatch\", 1, |args| {\n                // This is a placeholder - actual timing requires interpreter access\n                // For now, just return the function info\n                match &args[0] {\n                    Value::Function(f) => Ok(Value::String(format!(\n                        \"Use 'noo()' before and after callin' '{}' tae time it!\",\n                        f.name\n                    ))),\n                    _ => Err(\"stopwatch() needs a function\".to_string()),\n                }\n            }))),\n        );\n\n        // ============================================================\n        // SET (CREEL) FUNCTIONS - A creel is a basket in Scots!\n        // ============================================================\n\n        // creel - create a new set from a list\n        globals.borrow_mut().define(\n            \"creel\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"creel\", 1, |args| {\n                match &args[0] {\n                    Value::List(list) => {\n                        let items: HashSet<String> =\n                            list.borrow().iter().map(|v| format!(\"{}\", v)).collect();\n                        Ok(Value::Set(Rc::new(RefCell::new(items))))\n                    }\n                    Value::Set(s) => Ok(Value::Set(s.clone())), // Already a set\n                    _ => Err(\"creel() needs a list tae make a set fae\".to_string()),\n                }\n            }))),\n        );\n\n        // toss_in - add item to set (toss it intae the creel!)\n        globals.borrow_mut().define(\n            \"toss_in\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"toss_in\", 2, |args| {\n                if let Value::Set(set) = &args[0] {\n                    let item = format!(\"{}\", args[1]);\n                    set.borrow_mut().insert(item);\n                    Ok(Value::Set(set.clone()))\n                } else {\n                    Err(\"toss_in() needs a creel (set)\".to_string())\n                }\n            }))),\n        );\n\n        // heave_oot - remove item from set (heave it oot the creel!)\n        globals.borrow_mut().define(\n            \"heave_oot\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"heave_oot\", 2, |args| {\n                if let Value::Set(set) = &args[0] {\n                    let item = format!(\"{}\", args[1]);\n                    set.borrow_mut().remove(&item);\n                    Ok(Value::Set(set.clone()))\n                } else {\n                    Err(\"heave_oot() needs a creel (set)\".to_string())\n                }\n            }))),\n        );\n\n        // is_in_creel - check if item is in set\n        globals.borrow_mut().define(\n            \"is_in_creel\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_in_creel\", 2, |args| {\n                if let Value::Set(set) = &args[0] {\n                    let item = format!(\"{}\", args[1]);\n                    Ok(Value::Bool(set.borrow().contains(&item)))\n                } else {\n                    Err(\"is_in_creel() needs a creel (set)\".to_string())\n                }\n            }))),\n        );\n\n        // creels_thegither - union of two sets (put them thegither!)\n        globals.borrow_mut().define(\n            \"creels_thegither\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"creels_thegither\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Set(a), Value::Set(b)) => {\n                        let union: HashSet<String> =\n                            a.borrow().union(&*b.borrow()).cloned().collect();\n                        Ok(Value::Set(Rc::new(RefCell::new(union))))\n                    }\n                    _ => Err(\"creels_thegither() needs two creels\".to_string()),\n                },\n            ))),\n        );\n\n        // creels_baith - intersection of two sets (what's in baith!)\n        globals.borrow_mut().define(\n            \"creels_baith\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"creels_baith\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Set(a), Value::Set(b)) => {\n                        let intersection: HashSet<String> =\n                            a.borrow().intersection(&*b.borrow()).cloned().collect();\n                        Ok(Value::Set(Rc::new(RefCell::new(intersection))))\n                    }\n                    _ => Err(\"creels_baith() needs two creels\".to_string()),\n                },\n            ))),\n        );\n\n        // creels_differ - difference of two sets (what's in a but no in b)\n        globals.borrow_mut().define(\n            \"creels_differ\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"creels_differ\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Set(a), Value::Set(b)) => {\n                        let difference: HashSet<String> =\n                            a.borrow().difference(&*b.borrow()).cloned().collect();\n                        Ok(Value::Set(Rc::new(RefCell::new(difference))))\n                    }\n                    _ => Err(\"creels_differ() needs two creels\".to_string()),\n                },\n            ))),\n        );\n\n        // creel_tae_list - convert set to sorted list\n        globals.borrow_mut().define(\n            \"creel_tae_list\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"creel_tae_list\", 1, |args| {\n                if let Value::Set(set) = &args[0] {\n                    let mut items: Vec<String> = set.borrow().iter().cloned().collect();\n                    items.sort();\n                    let values: Vec<Value> = items.into_iter().map(Value::String).collect();\n                    Ok(Value::List(Rc::new(RefCell::new(values))))\n                } else {\n                    Err(\"creel_tae_list() needs a creel\".to_string())\n                }\n            }))),\n        );\n\n        // is_subset - check if one set is a subset of another (is a inside b?)\n        globals.borrow_mut().define(\n            \"is_subset\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_subset\", 2, |args| match (\n                &args[0], &args[1],\n            ) {\n                (Value::Set(a), Value::Set(b)) => {\n                    Ok(Value::Bool(a.borrow().is_subset(&*b.borrow())))\n                }\n                _ => Err(\"is_subset() needs two creels\".to_string()),\n            }))),\n        );\n\n        // is_superset - check if one set is a superset of another (does a contain aw o b?)\n        globals.borrow_mut().define(\n            \"is_superset\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_superset\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Set(a), Value::Set(b)) => {\n                        Ok(Value::Bool(a.borrow().is_superset(&*b.borrow())))\n                    }\n                    _ => Err(\"is_superset() needs two creels\".to_string()),\n                },\n            ))),\n        );\n\n        // is_disjoint - check if two sets have nae overlap\n        globals.borrow_mut().define(\n            \"is_disjoint\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_disjoint\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Set(a), Value::Set(b)) => {\n                        Ok(Value::Bool(a.borrow().is_disjoint(&*b.borrow())))\n                    }\n                    _ => Err(\"is_disjoint() needs two creels\".to_string()),\n                },\n            ))),\n        );\n\n        // empty_creel - create an empty set\n        globals.borrow_mut().define(\n            \"empty_creel\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"empty_creel\", 0, |_args| {\n                Ok(Value::Set(Rc::new(RefCell::new(HashSet::new()))))\n            }))),\n        );\n\n        // json_parse - parse a JSON string intae a value\n        globals.borrow_mut().define(\n            \"json_parse\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"json_parse\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    parse_json_value(s)\n                } else {\n                    Err(\"json_parse() expects a string, ya numpty!\".to_string())\n                }\n            }))),\n        );\n\n        // json_stringify - convert a value tae JSON string\n        globals.borrow_mut().define(\n            \"json_stringify\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"json_stringify\", 1, |args| {\n                Ok(Value::String(value_to_json(&args[0])))\n            }))),\n        );\n\n        // json_pretty - convert a value tae pretty-printed JSON string\n        globals.borrow_mut().define(\n            \"json_pretty\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"json_pretty\", 1, |args| {\n                Ok(Value::String(value_to_json_pretty(&args[0], 0)))\n            }))),\n        );\n\n        // ============================================================\n        // BITWISE OPERATIONS - Fer aw yer binary fiddlin' needs!\n        // ============================================================\n\n        // bit_an - bitwise AND (Scots: \"an\" = and)\n        globals.borrow_mut().define(\n            \"bit_an\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bit_an\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(*a & *b)),\n                    _ => Err(\"bit_an() needs two integers\".to_string()),\n                }\n            }))),\n        );\n\n        // bit_or - bitwise OR\n        globals.borrow_mut().define(\n            \"bit_or\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bit_or\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(*a | *b)),\n                    _ => Err(\"bit_or() needs two integers\".to_string()),\n                }\n            }))),\n        );\n\n        // bit_xor - bitwise XOR\n        globals.borrow_mut().define(\n            \"bit_xor\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"bit_xor\", 2, |args| {\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(*a ^ *b)),\n                    _ => Err(\"bit_xor() needs two integers\".to_string()),\n                }\n            }))),\n        );\n\n        // bit_nae - bitwise NOT (Scots: nae = not)\n        globals.borrow_mut().define(\n            \"bit_nae\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"bit_nae\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Integer(!*n)),\n                    _ => Err(\"bit_nae() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // bit_shove_left - left shift (shove left!)\n        globals.borrow_mut().define(\n            \"bit_shove_left\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"bit_shove_left\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => {\n                        if *b < 0 || *b > 63 {\n                            return Err(\"Shift amount must be 0-63, ya numpty!\".to_string());\n                        }\n                        Ok(Value::Integer(*a << *b))\n                    }\n                    _ => Err(\"bit_shove_left() needs two integers\".to_string()),\n                },\n            ))),\n        );\n\n        // bit_shove_right - right shift (shove right!)\n        globals.borrow_mut().define(\n            \"bit_shove_right\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"bit_shove_right\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => {\n                        if *b < 0 || *b > 63 {\n                            return Err(\"Shift amount must be 0-63, ya numpty!\".to_string());\n                        }\n                        Ok(Value::Integer(*a >> *b))\n                    }\n                    _ => Err(\"bit_shove_right() needs two integers\".to_string()),\n                },\n            ))),\n        );\n\n        // bit_coont - count number of set bits (popcount)\n        globals.borrow_mut().define(\n            \"bit_coont\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"bit_coont\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Integer(n.count_ones() as i64)),\n                    _ => Err(\"bit_coont() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // tae_binary - convert to binary string\n        globals.borrow_mut().define(\n            \"tae_binary\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"tae_binary\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::String(format!(\"{:b}\", n))),\n                    _ => Err(\"tae_binary() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // tae_hex - convert to hexadecimal string\n        globals.borrow_mut().define(\n            \"tae_hex\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"tae_hex\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::String(format!(\"{:x}\", n))),\n                    _ => Err(\"tae_hex() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // tae_octal - convert to octal string\n        globals.borrow_mut().define(\n            \"tae_octal\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"tae_octal\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::String(format!(\"{:o}\", n))),\n                    _ => Err(\"tae_octal() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // fae_binary - parse binary string to integer\n        globals.borrow_mut().define(\n            \"fae_binary\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"fae_binary\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => i64::from_str_radix(s.trim_start_matches(\"0b\"), 2)\n                        .map(Value::Integer)\n                        .map_err(|_| format!(\"Cannae parse '{}' as binary\", s)),\n                    _ => Err(\"fae_binary() needs a string\".to_string()),\n                },\n            ))),\n        );\n\n        // fae_hex - parse hexadecimal string to integer\n        globals.borrow_mut().define(\n            \"fae_hex\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"fae_hex\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => i64::from_str_radix(s.trim_start_matches(\"0x\"), 16)\n                        .map(Value::Integer)\n                        .map_err(|_| format!(\"Cannae parse '{}' as hex\", s)),\n                    _ => Err(\"fae_hex() needs a string\".to_string()),\n                },\n            ))),\n        );\n\n        // ============================================================\n        // MORE DICTIONARY FUNCTIONS - Fer managin' yer dicts!\n        // ============================================================\n\n        // dict_merge - merge two dictionaries (second overrides first)\n        globals.borrow_mut().define(\n            \"dict_merge\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"dict_merge\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::Dict(a), Value::Dict(b)) => {\n                        let mut result = a.borrow().clone();\n                        for (k, v) in b.borrow().iter() {\n                            result.insert(k.clone(), v.clone());\n                        }\n                        Ok(Value::Dict(Rc::new(RefCell::new(result))))\n                    }\n                    _ => Err(\"dict_merge() needs two dictionaries\".to_string()),\n                },\n            ))),\n        );\n\n        // dict_get - get value with default (avoids crashes!)\n        globals.borrow_mut().define(\n            \"dict_get\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"dict_get\",\n                3,\n                |args| match &args[0] {\n                    Value::Dict(d) => {\n                        let key = match &args[1] {\n                            Value::String(s) => s.clone(),\n                            _ => return Err(\"dict_get() key must be a string\".to_string()),\n                        };\n                        Ok(d.borrow()\n                            .get(&key)\n                            .cloned()\n                            .unwrap_or_else(|| args[2].clone()))\n                    }\n                    _ => Err(\"dict_get() needs a dictionary\".to_string()),\n                },\n            ))),\n        );\n\n        // dict_has - check if dictionary has a key\n        globals.borrow_mut().define(\n            \"dict_has\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"dict_has\",\n                2,\n                |args| match &args[0] {\n                    Value::Dict(d) => {\n                        let key = match &args[1] {\n                            Value::String(s) => s.clone(),\n                            _ => return Err(\"dict_has() key must be a string\".to_string()),\n                        };\n                        Ok(Value::Bool(d.borrow().contains_key(&key)))\n                    }\n                    _ => Err(\"dict_has() needs a dictionary\".to_string()),\n                },\n            ))),\n        );\n\n        // dict_remove - remove a key from dictionary (returns new dict)\n        globals.borrow_mut().define(\n            \"dict_remove\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"dict_remove\",\n                2,\n                |args| match &args[0] {\n                    Value::Dict(d) => {\n                        let key = match &args[1] {\n                            Value::String(s) => s.clone(),\n                            _ => return Err(\"dict_remove() key must be a string\".to_string()),\n                        };\n                        let mut new_dict = d.borrow().clone();\n                        new_dict.remove(&key);\n                        Ok(Value::Dict(Rc::new(RefCell::new(new_dict))))\n                    }\n                    _ => Err(\"dict_remove() needs a dictionary\".to_string()),\n                },\n            ))),\n        );\n\n        // dict_invert - swap keys and values\n        globals.borrow_mut().define(\n            \"dict_invert\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"dict_invert\",\n                1,\n                |args| match &args[0] {\n                    Value::Dict(d) => {\n                        let mut inverted = HashMap::new();\n                        for (k, v) in d.borrow().iter() {\n                            let new_key = format!(\"{}\", v);\n                            inverted.insert(new_key, Value::String(k.clone()));\n                        }\n                        Ok(Value::Dict(Rc::new(RefCell::new(inverted))))\n                    }\n                    _ => Err(\"dict_invert() needs a dictionary\".to_string()),\n                },\n            ))),\n        );\n\n        // items - get dictionary as list of [key, value] pairs\n        globals.borrow_mut().define(\n            \"items\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"items\",\n                1,\n                |args| match &args[0] {\n                    Value::Dict(d) => {\n                        let pairs: Vec<Value> = d\n                            .borrow()\n                            .iter()\n                            .map(|(k, v)| {\n                                Value::List(Rc::new(RefCell::new(vec![\n                                    Value::String(k.clone()),\n                                    v.clone(),\n                                ])))\n                            })\n                            .collect();\n                        Ok(Value::List(Rc::new(RefCell::new(pairs))))\n                    }\n                    _ => Err(\"items() needs a dictionary\".to_string()),\n                },\n            ))),\n        );\n\n        // fae_pairs - create dictionary from list of [key, value] pairs\n        globals.borrow_mut().define(\n            \"fae_pairs\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"fae_pairs\",\n                1,\n                |args| match &args[0] {\n                    Value::List(list) => {\n                        let mut dict = HashMap::new();\n                        for item in list.borrow().iter() {\n                            if let Value::List(pair) = item {\n                                let pair = pair.borrow();\n                                if pair.len() >= 2 {\n                                    let key = format!(\"{}\", pair[0]);\n                                    dict.insert(key, pair[1].clone());\n                                }\n                            }\n                        }\n                        Ok(Value::Dict(Rc::new(RefCell::new(dict))))\n                    }\n                    _ => Err(\"fae_pairs() needs a list o' pairs\".to_string()),\n                },\n            ))),\n        );\n\n        // ============================================================\n        // STRING UTILITIES - More ways tae wrangle yer strings!\n        // ============================================================\n\n        // center - center a string in a field of given width\n        globals.borrow_mut().define(\n            \"center\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"center\", 3, |args| {\n                let s = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"center() needs a string\".to_string()),\n                };\n                let width = match &args[1] {\n                    Value::Integer(n) => *n as usize,\n                    _ => return Err(\"center() needs a width\".to_string()),\n                };\n                let fill = match &args[2] {\n                    Value::String(c) => c.chars().next().unwrap_or(' '),\n                    _ => return Err(\"center() needs a fill character\".to_string()),\n                };\n                if s.len() >= width {\n                    return Ok(Value::String(s));\n                }\n                let padding = width - s.len();\n                let left_pad = padding / 2;\n                let right_pad = padding - left_pad;\n                Ok(Value::String(format!(\n                    \"{}{}{}\",\n                    fill.to_string().repeat(left_pad),\n                    s,\n                    fill.to_string().repeat(right_pad)\n                )))\n            }))),\n        );\n\n        // is_upper - check if string is all uppercase\n        globals.borrow_mut().define(\n            \"is_upper\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_upper\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => {\n                        let has_letters = s.chars().any(|c| c.is_alphabetic());\n                        Ok(Value::Bool(\n                            has_letters\n                                && s.chars().all(|c| !c.is_alphabetic() || c.is_uppercase()),\n                        ))\n                    }\n                    _ => Err(\"is_upper() needs a string\".to_string()),\n                },\n            ))),\n        );\n\n        // is_lower - check if string is all lowercase\n        globals.borrow_mut().define(\n            \"is_lower\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_lower\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => {\n                        let has_letters = s.chars().any(|c| c.is_alphabetic());\n                        Ok(Value::Bool(\n                            has_letters\n                                && s.chars().all(|c| !c.is_alphabetic() || c.is_lowercase()),\n                        ))\n                    }\n                    _ => Err(\"is_lower() needs a string\".to_string()),\n                },\n            ))),\n        );\n\n        // swapcase - swap case of all letters\n        globals.borrow_mut().define(\n            \"swapcase\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"swapcase\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => {\n                        let swapped: String = s\n                            .chars()\n                            .map(|c| {\n                                if c.is_uppercase() {\n                                    c.to_lowercase().next().unwrap_or(c)\n                                } else if c.is_lowercase() {\n                                    c.to_uppercase().next().unwrap_or(c)\n                                } else {\n                                    c\n                                }\n                            })\n                            .collect();\n                        Ok(Value::String(swapped))\n                    }\n                    _ => Err(\"swapcase() needs a string\".to_string()),\n                },\n            ))),\n        );\n\n        // strip_left - remove leading characters\n        globals.borrow_mut().define(\n            \"strip_left\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"strip_left\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(chars)) => {\n                        let char_set: Vec<char> = chars.chars().collect();\n                        Ok(Value::String(\n                            s.trim_start_matches(|c| char_set.contains(&c)).to_string(),\n                        ))\n                    }\n                    _ => Err(\"strip_left() needs two strings\".to_string()),\n                },\n            ))),\n        );\n\n        // strip_right - remove trailing characters\n        globals.borrow_mut().define(\n            \"strip_right\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"strip_right\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(chars)) => {\n                        let char_set: Vec<char> = chars.chars().collect();\n                        Ok(Value::String(\n                            s.trim_end_matches(|c| char_set.contains(&c)).to_string(),\n                        ))\n                    }\n                    _ => Err(\"strip_right() needs two strings\".to_string()),\n                },\n            ))),\n        );\n\n        // replace_first - replace only first occurrence\n        globals.borrow_mut().define(\n            \"replace_first\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"replace_first\",\n                3,\n                |args| match (&args[0], &args[1], &args[2]) {\n                    (Value::String(s), Value::String(from), Value::String(to)) => {\n                        Ok(Value::String(s.replacen(from.as_str(), to.as_str(), 1)))\n                    }\n                    _ => Err(\"replace_first() needs three strings\".to_string()),\n                },\n            ))),\n        );\n\n        // substr_between - get substring between two markers\n        globals.borrow_mut().define(\n            \"substr_between\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"substr_between\",\n                3,\n                |args| match (&args[0], &args[1], &args[2]) {\n                    (Value::String(s), Value::String(start), Value::String(end)) => {\n                        if let Some(start_idx) = s.find(start.as_str()) {\n                            let after_start = start_idx + start.len();\n                            if let Some(end_idx) = s[after_start..].find(end.as_str()) {\n                                return Ok(Value::String(\n                                    s[after_start..after_start + end_idx].to_string(),\n                                ));\n                            }\n                        }\n                        Ok(Value::Nil)\n                    }\n                    _ => Err(\"substr_between() needs three strings\".to_string()),\n                },\n            ))),\n        );\n\n        // ============================================================\n        // MORE MATHEMATICAL FUNCTIONS\n        // ============================================================\n\n        // sign - get sign of number (-1, 0, or 1)\n        globals.borrow_mut().define(\n            \"sign\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"sign\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Integer(if *n > 0 {\n                        1\n                    } else if *n < 0 {\n                        -1\n                    } else {\n                        0\n                    })),\n                    Value::Float(f) => Ok(Value::Integer(if *f > 0.0 {\n                        1\n                    } else if *f < 0.0 {\n                        -1\n                    } else {\n                        0\n                    })),\n                    _ => Err(\"sign() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // clamp - constrain a value between min and max\n        globals.borrow_mut().define(\n            \"clamp\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"clamp\", 3, |args| {\n                match (&args[0], &args[1], &args[2]) {\n                    (Value::Integer(n), Value::Integer(min), Value::Integer(max)) => {\n                        Ok(Value::Integer((*n).max(*min).min(*max)))\n                    }\n                    (Value::Float(n), Value::Float(min), Value::Float(max)) => {\n                        Ok(Value::Float(n.max(*min).min(*max)))\n                    }\n                    _ => Err(\"clamp() needs three numbers o' the same type\".to_string()),\n                }\n            }))),\n        );\n\n        // lerp - linear interpolation between two values\n        globals.borrow_mut().define(\n            \"lerp\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"lerp\", 3, |args| {\n                let a = match &args[0] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"lerp() needs numbers\".to_string()),\n                };\n                let b = match &args[1] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"lerp() needs numbers\".to_string()),\n                };\n                let t = match &args[2] {\n                    Value::Float(f) => *f,\n                    Value::Integer(n) => *n as f64,\n                    _ => return Err(\"lerp() needs numbers\".to_string()),\n                };\n                Ok(Value::Float(a + (b - a) * t))\n            }))),\n        );\n\n        // gcd - greatest common divisor\n        globals.borrow_mut().define(\n            \"gcd\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"gcd\", 2, |args| {\n                fn gcd_calc(a: i64, b: i64) -> i64 {\n                    if b == 0 {\n                        a.abs()\n                    } else {\n                        gcd_calc(b, a % b)\n                    }\n                }\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(gcd_calc(*a, *b))),\n                    _ => Err(\"gcd() needs two integers\".to_string()),\n                }\n            }))),\n        );\n\n        // lcm - least common multiple\n        globals.borrow_mut().define(\n            \"lcm\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"lcm\", 2, |args| {\n                fn gcd_calc(a: i64, b: i64) -> i64 {\n                    if b == 0 {\n                        a.abs()\n                    } else {\n                        gcd_calc(b, a % b)\n                    }\n                }\n                match (&args[0], &args[1]) {\n                    (Value::Integer(a), Value::Integer(b)) => {\n                        if *a == 0 || *b == 0 {\n                            Ok(Value::Integer(0))\n                        } else {\n                            Ok(Value::Integer((*a * *b).abs() / gcd_calc(*a, *b)))\n                        }\n                    }\n                    _ => Err(\"lcm() needs two integers\".to_string()),\n                }\n            }))),\n        );\n\n        // factorial - calculate factorial\n        globals.borrow_mut().define(\n            \"factorial\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"factorial\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => {\n                        if *n < 0 {\n                            return Err(\n                                \"Cannae calculate factorial o' negative number!\".to_string()\n                            );\n                        }\n                        if *n > 20 {\n                            return Err(\"Factorial too big! Max is 20\".to_string());\n                        }\n                        let mut result: i64 = 1;\n                        for i in 2..=*n {\n                            result *= i;\n                        }\n                        Ok(Value::Integer(result))\n                    }\n                    _ => Err(\"factorial() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // is_even - check if number is even\n        globals.borrow_mut().define(\n            \"is_even\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_even\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Bool(*n % 2 == 0)),\n                    _ => Err(\"is_even() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // is_odd - check if number is odd\n        globals.borrow_mut().define(\n            \"is_odd\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_odd\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => Ok(Value::Bool(*n % 2 != 0)),\n                    _ => Err(\"is_odd() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // is_prime - check if number is prime\n        globals.borrow_mut().define(\n            \"is_prime\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_prime\",\n                1,\n                |args| match &args[0] {\n                    Value::Integer(n) => {\n                        if *n < 2 {\n                            return Ok(Value::Bool(false));\n                        }\n                        if *n == 2 {\n                            return Ok(Value::Bool(true));\n                        }\n                        if *n % 2 == 0 {\n                            return Ok(Value::Bool(false));\n                        }\n                        let sqrt_n = (*n as f64).sqrt() as i64;\n                        for i in (3..=sqrt_n).step_by(2) {\n                            if *n % i == 0 {\n                                return Ok(Value::Bool(false));\n                            }\n                        }\n                        Ok(Value::Bool(true))\n                    }\n                    _ => Err(\"is_prime() needs an integer\".to_string()),\n                },\n            ))),\n        );\n\n        // ============================================================\n        // ASSERTION FUNCTIONS - Test yer code, ya numpty!\n        // ============================================================\n\n        // assert - throw error if condition is false\n        globals.borrow_mut().define(\n            \"assert\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"assert\", 2, |args| {\n                let condition = args[0].is_truthy();\n                if !condition {\n                    let msg = match &args[1] {\n                        Value::String(s) => s.clone(),\n                        _ => format!(\"{}\", args[1]),\n                    };\n                    Err(format!(\"Assertion failed: {}\", msg))\n                } else {\n                    Ok(Value::Bool(true))\n                }\n            }))),\n        );\n\n        // assert_equal - throw error if values are not equal\n        globals.borrow_mut().define(\n            \"assert_equal\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"assert_equal\", 2, |args| {\n                if args[0] == args[1] {\n                    Ok(Value::Bool(true))\n                } else {\n                    Err(format!(\n                        \"Assertion failed: expected {} but got {}\",\n                        args[0], args[1]\n                    ))\n                }\n            }))),\n        );\n\n        // assert_nae_equal - throw error if values are equal\n        globals.borrow_mut().define(\n            \"assert_nae_equal\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"assert_nae_equal\",\n                2,\n                |args| {\n                    if args[0] != args[1] {\n                        Ok(Value::Bool(true))\n                    } else {\n                        Err(format!(\n                            \"Assertion failed: {} should not equal {}\",\n                            args[0], args[1]\n                        ))\n                    }\n                },\n            ))),\n        );\n\n        // ============================================================\n        // LIST STATISTICS - Fer number-crunchin'!\n        // ============================================================\n\n        // average - calculate average of a list of numbers (Scots: mean)\n        globals.borrow_mut().define(\n            \"average\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"average\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Err(\"Cannae calculate average o' empty list!\".to_string());\n                    }\n                    let mut sum: f64 = 0.0;\n                    for item in items.iter() {\n                        match item {\n                            Value::Integer(n) => sum += *n as f64,\n                            Value::Float(f) => sum += *f,\n                            _ => return Err(\"average() needs a list o' numbers\".to_string()),\n                        }\n                    }\n                    Ok(Value::Float(sum / items.len() as f64))\n                } else {\n                    Err(\"average() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // median - calculate median of a list of numbers\n        globals.borrow_mut().define(\n            \"median\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"median\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Err(\"Cannae calculate median o' empty list!\".to_string());\n                    }\n                    let mut nums: Vec<f64> = Vec::new();\n                    for item in items.iter() {\n                        match item {\n                            Value::Integer(n) => nums.push(*n as f64),\n                            Value::Float(f) => nums.push(*f),\n                            _ => return Err(\"median() needs a list o' numbers\".to_string()),\n                        }\n                    }\n                    nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n                    let mid = nums.len() / 2;\n                    if nums.len().is_multiple_of(2) {\n                        Ok(Value::Float((nums[mid - 1] + nums[mid]) / 2.0))\n                    } else {\n                        Ok(Value::Float(nums[mid]))\n                    }\n                } else {\n                    Err(\"median() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // product - multiply all numbers in a list\n        globals.borrow_mut().define(\n            \"product\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"product\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Ok(Value::Integer(1));\n                    }\n                    let mut prod: f64 = 1.0;\n                    let mut is_float = false;\n                    for item in items.iter() {\n                        match item {\n                            Value::Integer(n) => prod *= *n as f64,\n                            Value::Float(f) => {\n                                prod *= *f;\n                                is_float = true;\n                            }\n                            _ => return Err(\"product() needs a list o' numbers\".to_string()),\n                        }\n                    }\n                    if is_float {\n                        Ok(Value::Float(prod))\n                    } else {\n                        Ok(Value::Integer(prod as i64))\n                    }\n                } else {\n                    Err(\"product() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // minaw - find minimum in a list (min all)\n        globals.borrow_mut().define(\n            \"minaw\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"minaw\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Err(\"Cannae find minimum o' empty list!\".to_string());\n                    }\n                    let mut min_val = items[0].clone();\n                    for item in items.iter().skip(1) {\n                        match (&min_val, item) {\n                            (Value::Integer(a), Value::Integer(b)) => {\n                                if *b < *a {\n                                    min_val = item.clone();\n                                }\n                            }\n                            (Value::Float(a), Value::Float(b)) => {\n                                if *b < *a {\n                                    min_val = item.clone();\n                                }\n                            }\n                            _ => {\n                                return Err(\"minaw() needs a list o' comparable numbers\".to_string())\n                            }\n                        }\n                    }\n                    Ok(min_val)\n                } else {\n                    Err(\"minaw() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // maxaw - find maximum in a list (max all)\n        globals.borrow_mut().define(\n            \"maxaw\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"maxaw\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Err(\"Cannae find maximum o' empty list!\".to_string());\n                    }\n                    let mut max_val = items[0].clone();\n                    for item in items.iter().skip(1) {\n                        match (&max_val, item) {\n                            (Value::Integer(a), Value::Integer(b)) => {\n                                if *b > *a {\n                                    max_val = item.clone();\n                                }\n                            }\n                            (Value::Float(a), Value::Float(b)) => {\n                                if *b > *a {\n                                    max_val = item.clone();\n                                }\n                            }\n                            _ => {\n                                return Err(\"maxaw() needs a list o' comparable numbers\".to_string())\n                            }\n                        }\n                    }\n                    Ok(max_val)\n                } else {\n                    Err(\"maxaw() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // range_o - get the range (max - min) of a list\n        globals.borrow_mut().define(\n            \"range_o\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"range_o\", 1, |args| {\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Err(\"Cannae get range o' empty list!\".to_string());\n                    }\n                    let mut min_val: f64 = f64::MAX;\n                    let mut max_val: f64 = f64::MIN;\n                    for item in items.iter() {\n                        match item {\n                            Value::Integer(n) => {\n                                let v = *n as f64;\n                                if v < min_val {\n                                    min_val = v;\n                                }\n                                if v > max_val {\n                                    max_val = v;\n                                }\n                            }\n                            Value::Float(f) => {\n                                if *f < min_val {\n                                    min_val = *f;\n                                }\n                                if *f > max_val {\n                                    max_val = *f;\n                                }\n                            }\n                            _ => return Err(\"range_o() needs a list o' numbers\".to_string()),\n                        }\n                    }\n                    Ok(Value::Float(max_val - min_val))\n                } else {\n                    Err(\"range_o() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // ============================================================\n        // STDLIB EXPANSION - File I/O\n        // ============================================================\n\n        // scrieve_append - append to file (Scots: write-append)\n        globals.borrow_mut().define(\n            \"scrieve_append\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"scrieve_append\", 2, |args| {\n                use std::fs::OpenOptions;\n                use std::io::Write as IoWrite;\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"scrieve_append() needs a file path string\".to_string()),\n                };\n                let content = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    v => format!(\"{}\", v),\n                };\n                let mut file = OpenOptions::new()\n                    .create(true)\n                    .append(true)\n                    .open(&path)\n                    .map_err(|e| format!(\"Couldnae open '{}' fer appendin': {}\", path, e))?;\n                file.write_all(content.as_bytes())\n                    .map_err(|e| format!(\"Couldnae append tae '{}': {}\", path, e))?;\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // file_delete - delete a file\n        globals.borrow_mut().define(\n            \"file_delete\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"file_delete\", 1, |args| {\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"file_delete() needs a file path string\".to_string()),\n                };\n                std::fs::remove_file(&path)\n                    .map_err(|e| format!(\"Couldnae delete '{}': {}\", path, e))?;\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // list_dir - list directory contents\n        globals.borrow_mut().define(\n            \"list_dir\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"list_dir\", 1, |args| {\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"list_dir() needs a directory path string\".to_string()),\n                };\n                let entries = std::fs::read_dir(&path)\n                    .map_err(|e| format!(\"Couldnae read directory '{}': {}\", path, e))?;\n                let files: Vec<Value> = entries\n                    .filter_map(|e| e.ok())\n                    .map(|e| Value::String(e.file_name().to_string_lossy().to_string()))\n                    .collect();\n                Ok(Value::List(Rc::new(RefCell::new(files))))\n            }))),\n        );\n\n        // make_dir - create directory (and parents)\n        globals.borrow_mut().define(\n            \"make_dir\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"make_dir\", 1, |args| {\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"make_dir() needs a directory path string\".to_string()),\n                };\n                std::fs::create_dir_all(&path)\n                    .map_err(|e| format!(\"Couldnae create directory '{}': {}\", path, e))?;\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // is_dir - check if path is a directory\n        globals.borrow_mut().define(\n            \"is_dir\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_dir\", 1, |args| {\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"is_dir() needs a path string\".to_string()),\n                };\n                Ok(Value::Bool(std::path::Path::new(&path).is_dir()))\n            }))),\n        );\n\n        // file_size - get file size in bytes\n        globals.borrow_mut().define(\n            \"file_size\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"file_size\", 1, |args| {\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"file_size() needs a file path string\".to_string()),\n                };\n                let metadata = std::fs::metadata(&path)\n                    .map_err(|e| format!(\"Couldnae get file info fer '{}': {}\", path, e))?;\n                Ok(Value::Integer(metadata.len() as i64))\n            }))),\n        );\n\n        // path_join - join path components\n        globals.borrow_mut().define(\n            \"path_join\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"path_join\", 2, |args| {\n                let path1 = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"path_join() needs strings\".to_string()),\n                };\n                let path2 = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"path_join() needs strings\".to_string()),\n                };\n                let joined = std::path::Path::new(&path1).join(&path2);\n                Ok(Value::String(joined.to_string_lossy().to_string()))\n            }))),\n        );\n\n        // ============================================================\n        // STDLIB EXPANSION - String Functions\n        // ============================================================\n\n        // trim - remove leading/trailing whitespace\n        globals.borrow_mut().define(\n            \"trim\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"trim\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(s.trim().to_string()))\n                } else {\n                    Err(\"trim() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // trim_start - remove leading whitespace\n        globals.borrow_mut().define(\n            \"trim_start\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"trim_start\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(s.trim_start().to_string()))\n                } else {\n                    Err(\"trim_start() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // trim_end - remove trailing whitespace\n        globals.borrow_mut().define(\n            \"trim_end\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"trim_end\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::String(s.trim_end().to_string()))\n                } else {\n                    Err(\"trim_end() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // starts_with - check if string starts with prefix\n        globals.borrow_mut().define(\n            \"starts_with\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"starts_with\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(prefix)) => {\n                        Ok(Value::Bool(s.starts_with(prefix.as_str())))\n                    }\n                    _ => Err(\"starts_with() needs two strings\".to_string()),\n                },\n            ))),\n        );\n\n        // ends_with - check if string ends with suffix\n        globals.borrow_mut().define(\n            \"ends_with\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"ends_with\", 2, |args| match (\n                &args[0], &args[1],\n            ) {\n                (Value::String(s), Value::String(suffix)) => {\n                    Ok(Value::Bool(s.ends_with(suffix.as_str())))\n                }\n                _ => Err(\"ends_with() needs two strings\".to_string()),\n            }))),\n        );\n\n        // last_index_of - find last index of substring\n        globals.borrow_mut().define(\n            \"last_index_of\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"last_index_of\",\n                2,\n                |args| match (&args[0], &args[1]) {\n                    (Value::String(s), Value::String(needle)) => Ok(Value::Integer(\n                        s.rfind(needle.as_str()).map(|i| i as i64).unwrap_or(-1),\n                    )),\n                    _ => Err(\"last_index_of() needs two strings\".to_string()),\n                },\n            ))),\n        );\n\n        // substring - extract substring (start, end exclusive)\n        globals.borrow_mut().define(\n            \"substring\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"substring\", 3, |args| {\n                let s = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"substring() needs a string\".to_string()),\n                };\n                let start = args[1]\n                    .as_integer()\n                    .ok_or(\"substring() needs integer indices\")?\n                    as usize;\n                let end = args[2]\n                    .as_integer()\n                    .ok_or(\"substring() needs integer indices\")? as usize;\n                let chars: Vec<char> = s.chars().collect();\n                let start = start.min(chars.len());\n                let end = end.min(chars.len());\n                Ok(Value::String(chars[start..end].iter().collect()))\n            }))),\n        );\n\n        // is_empty - check if string is empty\n        globals.borrow_mut().define(\n            \"is_empty\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"is_empty\",\n                1,\n                |args| match &args[0] {\n                    Value::String(s) => Ok(Value::Bool(s.is_empty())),\n                    Value::List(l) => Ok(Value::Bool(l.borrow().is_empty())),\n                    Value::Dict(d) => Ok(Value::Bool(d.borrow().is_empty())),\n                    _ => Err(\"is_empty() needs a string, list, or dict\".to_string()),\n                },\n            ))),\n        );\n\n        // is_blank - check if string is empty or only whitespace\n        globals.borrow_mut().define(\n            \"is_blank\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"is_blank\", 1, |args| {\n                if let Value::String(s) = &args[0] {\n                    Ok(Value::Bool(s.trim().is_empty()))\n                } else {\n                    Err(\"is_blank() needs a string\".to_string())\n                }\n            }))),\n        );\n\n        // ============================================================\n        // STDLIB EXPANSION - Math Functions\n        // ============================================================\n\n        // random - random float between 0.0 and 1.0\n        globals.borrow_mut().define(\n            \"random\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"random\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as u64;\n                let rng = seed.wrapping_mul(1103515245).wrapping_add(12345);\n                let random_float = (rng as f64) / (u64::MAX as f64);\n                Ok(Value::Float(random_float))\n            }))),\n        );\n\n        // random_int - random integer in range (inclusive)\n        globals.borrow_mut().define(\n            \"random_int\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"random_int\", 2, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let min = args[0]\n                    .as_integer()\n                    .ok_or(\"random_int() needs integer bounds\")?;\n                let max = args[1]\n                    .as_integer()\n                    .ok_or(\"random_int() needs integer bounds\")?;\n                if min > max {\n                    return Err(\"random_int() min must be <= max\".to_string());\n                }\n                let seed = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_nanos() as u64;\n                let rng = seed.wrapping_mul(1103515245).wrapping_add(12345);\n                let range = (max - min + 1) as u64;\n                let result = min + ((rng % range) as i64);\n                Ok(Value::Integer(result))\n            }))),\n        );\n\n        // random_choice - random element from list\n        globals.borrow_mut().define(\n            \"random_choice\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"random_choice\", 1, |args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                if let Value::List(list) = &args[0] {\n                    let items = list.borrow();\n                    if items.is_empty() {\n                        return Ok(Value::Nil);\n                    }\n                    let seed = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_nanos() as u64;\n                    let rng = seed.wrapping_mul(1103515245).wrapping_add(12345);\n                    let idx = (rng as usize) % items.len();\n                    Ok(items[idx].clone())\n                } else {\n                    Err(\"random_choice() needs a list\".to_string())\n                }\n            }))),\n        );\n\n        // pi - return PI constant\n        globals.borrow_mut().define(\n            \"pi\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"pi\", 0, |_args| {\n                Ok(Value::Float(std::f64::consts::PI))\n            }))),\n        );\n\n        // e - return Euler's number\n        globals.borrow_mut().define(\n            \"e\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"e\", 0, |_args| {\n                Ok(Value::Float(std::f64::consts::E))\n            }))),\n        );\n\n        // tau - return TAU (2*PI)\n        globals.borrow_mut().define(\n            \"tau\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"tau\", 0, |_args| {\n                Ok(Value::Float(std::f64::consts::TAU))\n            }))),\n        );\n\n        // trunc - truncate toward zero\n        globals.borrow_mut().define(\n            \"trunc\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"trunc\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Integer(f.trunc() as i64)),\n                    Value::Integer(n) => Ok(Value::Integer(*n)),\n                    _ => Err(\"trunc() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // log2 - base 2 logarithm\n        globals.borrow_mut().define(\n            \"log2\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"log2\",\n                1,\n                |args| match &args[0] {\n                    Value::Float(f) => Ok(Value::Float(f.log2())),\n                    Value::Integer(n) => Ok(Value::Float((*n as f64).log2())),\n                    _ => Err(\"log2() needs a number\".to_string()),\n                },\n            ))),\n        );\n\n        // ============================================================\n        // STDLIB EXPANSION - Date/Time Functions\n        // ============================================================\n\n        // date_now - current date as dict\n        globals.borrow_mut().define(\n            \"date_now\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"date_now\", 0, |_args| {\n                use chrono::{Datelike, Local, Timelike};\n                let now = Local::now();\n                let mut dict = HashMap::new();\n                dict.insert(\"year\".to_string(), Value::Integer(now.year() as i64));\n                dict.insert(\"month\".to_string(), Value::Integer(now.month() as i64));\n                dict.insert(\"day\".to_string(), Value::Integer(now.day() as i64));\n                dict.insert(\"hour\".to_string(), Value::Integer(now.hour() as i64));\n                dict.insert(\"minute\".to_string(), Value::Integer(now.minute() as i64));\n                dict.insert(\"second\".to_string(), Value::Integer(now.second() as i64));\n                dict.insert(\n                    \"weekday\".to_string(),\n                    Value::Integer(now.weekday().num_days_from_monday() as i64),\n                );\n                Ok(Value::Dict(Rc::new(RefCell::new(dict))))\n            }))),\n        );\n\n        // date_format - format timestamp\n        globals.borrow_mut().define(\n            \"date_format\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"date_format\", 2, |args| {\n                use chrono::{Local, TimeZone};\n                let timestamp_ms = args[0]\n                    .as_integer()\n                    .ok_or(\"date_format() needs a timestamp\")?;\n                let format = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"date_format() needs a format string\".to_string()),\n                };\n                let dt = Local\n                    .timestamp_millis_opt(timestamp_ms)\n                    .single()\n                    .ok_or(\"Invalid timestamp\")?;\n                Ok(Value::String(dt.format(&format).to_string()))\n            }))),\n        );\n\n        // date_parse - parse string to timestamp\n        globals.borrow_mut().define(\n            \"date_parse\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"date_parse\", 2, |args| {\n                use chrono::NaiveDateTime;\n                let date_str = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"date_parse() needs a date string\".to_string()),\n                };\n                let format = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"date_parse() needs a format string\".to_string()),\n                };\n                let dt = NaiveDateTime::parse_from_str(&date_str, &format)\n                    .map_err(|e| format!(\"Couldnae parse date '{}': {}\", date_str, e))?;\n                Ok(Value::Integer(dt.and_utc().timestamp_millis()))\n            }))),\n        );\n\n        // date_add - add time to timestamp\n        globals.borrow_mut().define(\n            \"date_add\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"date_add\", 3, |args| {\n                use chrono::{Duration, Local, TimeZone};\n                let timestamp_ms = args[0].as_integer().ok_or(\"date_add() needs a timestamp\")?;\n                let amount = args[1].as_integer().ok_or(\"date_add() needs an amount\")?;\n                let unit = match &args[2] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"date_add() needs a unit string\".to_string()),\n                };\n                let dt = Local\n                    .timestamp_millis_opt(timestamp_ms)\n                    .single()\n                    .ok_or(\"Invalid timestamp\")?;\n                let new_dt = match unit.as_str() {\n                    \"seconds\" => dt + Duration::seconds(amount),\n                    \"minutes\" => dt + Duration::minutes(amount),\n                    \"hours\" => dt + Duration::hours(amount),\n                    \"days\" => dt + Duration::days(amount),\n                    \"weeks\" => dt + Duration::weeks(amount),\n                    _ => return Err(format!(\"Unknown time unit: {}\", unit)),\n                };\n                Ok(Value::Integer(new_dt.timestamp_millis()))\n            }))),\n        );\n\n        // date_diff - difference between timestamps\n        globals.borrow_mut().define(\n            \"date_diff\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"date_diff\", 3, |args| {\n                let ts1 = args[0].as_integer().ok_or(\"date_diff() needs timestamps\")?;\n                let ts2 = args[1].as_integer().ok_or(\"date_diff() needs timestamps\")?;\n                let unit = match &args[2] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"date_diff() needs a unit string\".to_string()),\n                };\n                let diff_ms = ts2 - ts1;\n                let result = match unit.as_str() {\n                    \"milliseconds\" => diff_ms,\n                    \"seconds\" => diff_ms / 1000,\n                    \"minutes\" => diff_ms / 60000,\n                    \"hours\" => diff_ms / 3600000,\n                    \"days\" => diff_ms / 86400000,\n                    \"weeks\" => diff_ms / 604800000,\n                    _ => return Err(format!(\"Unknown time unit: {}\", unit)),\n                };\n                Ok(Value::Integer(result))\n            }))),\n        );\n\n        // timestamp - Unix timestamp in seconds\n        globals.borrow_mut().define(\n            \"timestamp\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"timestamp\", 0, |_args| {\n                use std::time::{SystemTime, UNIX_EPOCH};\n                let secs = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs();\n                Ok(Value::Integer(secs as i64))\n            }))),\n        );\n\n        // timestamp_millis - Unix timestamp in milliseconds\n        globals.borrow_mut().define(\n            \"timestamp_millis\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"timestamp_millis\",\n                0,\n                |_args| {\n                    use std::time::{SystemTime, UNIX_EPOCH};\n                    let millis = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_millis();\n                    Ok(Value::Integer(millis as i64))\n                },\n            ))),\n        );\n\n        // ============================================================\n        // STDLIB EXPANSION - Regular Expressions\n        // ============================================================\n\n        // regex_test - test if pattern matches\n        globals.borrow_mut().define(\n            \"regex_test\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"regex_test\", 2, |args| {\n                use regex::Regex;\n                let text = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_test() needs a string\".to_string()),\n                };\n                let pattern = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_test() needs a pattern string\".to_string()),\n                };\n                let re = Regex::new(&pattern)\n                    .map_err(|e| format!(\"Invalid regex '{}': {}\", pattern, e))?;\n                Ok(Value::Bool(re.is_match(&text)))\n            }))),\n        );\n\n        // regex_match - find first match\n        globals.borrow_mut().define(\n            \"regex_match\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"regex_match\", 2, |args| {\n                use regex::Regex;\n                let text = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_match() needs a string\".to_string()),\n                };\n                let pattern = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_match() needs a pattern string\".to_string()),\n                };\n                let re = Regex::new(&pattern)\n                    .map_err(|e| format!(\"Invalid regex '{}': {}\", pattern, e))?;\n                if let Some(m) = re.find(&text) {\n                    let mut dict = HashMap::new();\n                    dict.insert(\"match\".to_string(), Value::String(m.as_str().to_string()));\n                    dict.insert(\"start\".to_string(), Value::Integer(m.start() as i64));\n                    dict.insert(\"end\".to_string(), Value::Integer(m.end() as i64));\n                    Ok(Value::Dict(Rc::new(RefCell::new(dict))))\n                } else {\n                    Ok(Value::Nil)\n                }\n            }))),\n        );\n\n        // regex_match_all - find all matches\n        globals.borrow_mut().define(\n            \"regex_match_all\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"regex_match_all\", 2, |args| {\n                use regex::Regex;\n                let text = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_match_all() needs a string\".to_string()),\n                };\n                let pattern = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_match_all() needs a pattern string\".to_string()),\n                };\n                let re = Regex::new(&pattern)\n                    .map_err(|e| format!(\"Invalid regex '{}': {}\", pattern, e))?;\n                let matches: Vec<Value> = re\n                    .find_iter(&text)\n                    .map(|m| {\n                        let mut dict = HashMap::new();\n                        dict.insert(\"match\".to_string(), Value::String(m.as_str().to_string()));\n                        dict.insert(\"start\".to_string(), Value::Integer(m.start() as i64));\n                        dict.insert(\"end\".to_string(), Value::Integer(m.end() as i64));\n                        Value::Dict(Rc::new(RefCell::new(dict)))\n                    })\n                    .collect();\n                Ok(Value::List(Rc::new(RefCell::new(matches))))\n            }))),\n        );\n\n        // regex_replace - replace all matches\n        globals.borrow_mut().define(\n            \"regex_replace\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"regex_replace\", 3, |args| {\n                use regex::Regex;\n                let text = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_replace() needs a string\".to_string()),\n                };\n                let pattern = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_replace() needs a pattern string\".to_string()),\n                };\n                let replacement = match &args[2] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_replace() needs a replacement string\".to_string()),\n                };\n                let re = Regex::new(&pattern)\n                    .map_err(|e| format!(\"Invalid regex '{}': {}\", pattern, e))?;\n                Ok(Value::String(\n                    re.replace_all(&text, replacement.as_str()).to_string(),\n                ))\n            }))),\n        );\n\n        // regex_replace_first - replace first match only\n        globals.borrow_mut().define(\n            \"regex_replace_first\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"regex_replace_first\",\n                3,\n                |args| {\n                    use regex::Regex;\n                    let text = match &args[0] {\n                        Value::String(s) => s.clone(),\n                        _ => return Err(\"regex_replace_first() needs a string\".to_string()),\n                    };\n                    let pattern = match &args[1] {\n                        Value::String(s) => s.clone(),\n                        _ => return Err(\"regex_replace_first() needs a pattern string\".to_string()),\n                    };\n                    let replacement = match &args[2] {\n                        Value::String(s) => s.clone(),\n                        _ => {\n                            return Err(\n                                \"regex_replace_first() needs a replacement string\".to_string()\n                            )\n                        }\n                    };\n                    let re = Regex::new(&pattern)\n                        .map_err(|e| format!(\"Invalid regex '{}': {}\", pattern, e))?;\n                    Ok(Value::String(\n                        re.replacen(&text, 1, replacement.as_str()).to_string(),\n                    ))\n                },\n            ))),\n        );\n\n        // regex_split - split by regex pattern\n        globals.borrow_mut().define(\n            \"regex_split\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"regex_split\", 2, |args| {\n                use regex::Regex;\n                let text = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_split() needs a string\".to_string()),\n                };\n                let pattern = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"regex_split() needs a pattern string\".to_string()),\n                };\n                let re = Regex::new(&pattern)\n                    .map_err(|e| format!(\"Invalid regex '{}': {}\", pattern, e))?;\n                let parts: Vec<Value> = re\n                    .split(&text)\n                    .map(|s| Value::String(s.to_string()))\n                    .collect();\n                Ok(Value::List(Rc::new(RefCell::new(parts))))\n            }))),\n        );\n\n        // ============================================================\n        // STDLIB EXPANSION - Environment & System\n        // ============================================================\n\n        // env_get - get environment variable\n        globals.borrow_mut().define(\n            \"env_get\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"env_get\", 1, |args| {\n                let name = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"env_get() needs a variable name string\".to_string()),\n                };\n                match std::env::var(&name) {\n                    Ok(val) => Ok(Value::String(val)),\n                    Err(_) => Ok(Value::Nil),\n                }\n            }))),\n        );\n\n        // env_set - set environment variable\n        globals.borrow_mut().define(\n            \"env_set\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"env_set\", 2, |args| {\n                let name = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"env_set() needs a variable name string\".to_string()),\n                };\n                let value = match &args[1] {\n                    Value::String(s) => s.clone(),\n                    v => format!(\"{}\", v),\n                };\n                std::env::set_var(&name, &value);\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // env_all - get all environment variables as dict\n        globals.borrow_mut().define(\n            \"env_all\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"env_all\", 0, |_args| {\n                let vars: HashMap<String, Value> = std::env::vars()\n                    .map(|(k, v)| (k, Value::String(v)))\n                    .collect();\n                Ok(Value::Dict(Rc::new(RefCell::new(vars))))\n            }))),\n        );\n\n        // shell - execute shell command and return output\n        globals.borrow_mut().define(\n            \"shell\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"shell\", 1, |args| {\n                use std::process::Command;\n                let cmd = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"shell() needs a command string\".to_string()),\n                };\n                let output = if cfg!(target_os = \"windows\") {\n                    Command::new(\"cmd\").args([\"/C\", &cmd]).output()\n                } else {\n                    Command::new(\"sh\").args([\"-c\", &cmd]).output()\n                };\n                match output {\n                    Ok(out) => {\n                        let stdout = String::from_utf8_lossy(&out.stdout).to_string();\n                        let stderr = String::from_utf8_lossy(&out.stderr).to_string();\n                        Ok(Value::String(if stdout.is_empty() {\n                            stderr\n                        } else {\n                            stdout\n                        }))\n                    }\n                    Err(e) => Err(format!(\"Shell command failed: {}\", e)),\n                }\n            }))),\n        );\n\n        // shell_status - execute shell command and return exit code\n        globals.borrow_mut().define(\n            \"shell_status\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"shell_status\", 1, |args| {\n                use std::process::Command;\n                let cmd = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"shell_status() needs a command string\".to_string()),\n                };\n                let status = if cfg!(target_os = \"windows\") {\n                    Command::new(\"cmd\").args([\"/C\", &cmd]).status()\n                } else {\n                    Command::new(\"sh\").args([\"-c\", &cmd]).status()\n                };\n                match status {\n                    Ok(s) => Ok(Value::Integer(s.code().unwrap_or(-1) as i64)),\n                    Err(e) => Err(format!(\"Shell command failed: {}\", e)),\n                }\n            }))),\n        );\n\n        // exit - exit program with code\n        globals.borrow_mut().define(\n            \"exit\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"exit\", 1, |args| {\n                let code = args[0].as_integer().unwrap_or(0) as i32;\n                std::process::exit(code);\n            }))),\n        );\n\n        // args - get command line arguments\n        globals.borrow_mut().define(\n            \"args\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"args\", 0, |_args| {\n                let arguments: Vec<Value> = std::env::args().map(Value::String).collect();\n                Ok(Value::List(Rc::new(RefCell::new(arguments))))\n            }))),\n        );\n\n        // cwd - get current working directory\n        globals.borrow_mut().define(\n            \"cwd\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"cwd\", 0, |_args| {\n                match std::env::current_dir() {\n                    Ok(path) => Ok(Value::String(path.to_string_lossy().to_string())),\n                    Err(e) => Err(format!(\"Couldnae get current directory: {}\", e)),\n                }\n            }))),\n        );\n\n        // chdir - change current directory\n        globals.borrow_mut().define(\n            \"chdir\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\"chdir\", 1, |args| {\n                let path = match &args[0] {\n                    Value::String(s) => s.clone(),\n                    _ => return Err(\"chdir() needs a path string\".to_string()),\n                };\n                std::env::set_current_dir(&path)\n                    .map_err(|e| format!(\"Couldnae change tae directory '{}': {}\", path, e))?;\n                Ok(Value::Nil)\n            }))),\n        );\n\n        // json_stringify_pretty - pretty-printed JSON (alias for json_pretty)\n        globals.borrow_mut().define(\n            \"json_stringify_pretty\".to_string(),\n            Value::NativeFunction(Rc::new(NativeFunction::new(\n                \"json_stringify_pretty\",\n                1,\n                |args| Ok(Value::String(value_to_json_pretty(&args[0], 0))),\n            ))),\n        );\n    }\n\n    /// Run a program\n    pub fn interpret(&mut self, program: &Program) -> HaversResult<Value> {\n        let mut result = Value::Nil;\n        for stmt in &program.statements {\n            result = self.execute_stmt(stmt)?;\n        }\n        Ok(result)\n    }\n\n    /// Get captured output (for testing)\n    #[allow(dead_code)]\n    pub fn get_output(&self) -> &[String] {\n        &self.output\n    }\n\n    /// Clear captured output\n    #[allow(dead_code)]\n    pub fn clear_output(&mut self) {\n        self.output.clear();\n    }\n\n    /// Load a module fae a file\n    fn load_module(\n        &mut self,\n        path: &str,\n        alias: Option<&str>,\n        span: Span,\n    ) -> Result<Result<Value, ControlFlow>, HaversError> {\n        // Resolve the module path\n        let module_path = self.resolve_module_path(path)?;\n\n        // Check fer circular imports\n        if self.loaded_modules.contains(&module_path) {\n            // Already loaded, that's fine - skip\n            return Ok(Ok(Value::Nil));\n        }\n\n        // Read the module file\n        let source =\n            std::fs::read_to_string(&module_path).map_err(|_| HaversError::ModuleNotFound {\n                name: path.to_string(),\n            })?;\n\n        // Parse the module\n        let program = crate::parser::parse(&source).map_err(|e| HaversError::ParseError {\n            message: format!(\"Error in module '{}': {}\", path, e),\n            line: span.line,\n        })?;\n\n        // Mark as loaded tae prevent circular imports\n        self.loaded_modules.insert(module_path.clone());\n\n        // Save the current directory and switch tae the module's directory\n        let old_dir = self.current_dir.clone();\n        if let Some(parent) = module_path.parent() {\n            self.current_dir = parent.to_path_buf();\n        }\n\n        // Execute the module in a new environment that inherits fae globals\n        let module_env = Rc::new(RefCell::new(Environment::with_enclosing(\n            self.globals.clone(),\n        )));\n        let old_env = self.environment.clone();\n        self.environment = module_env.clone();\n\n        // Execute the module\n        for stmt in &program.statements {\n            self.execute_stmt(stmt)?;\n        }\n\n        // Restore environment and directory\n        self.environment = old_env;\n        self.current_dir = old_dir;\n\n        // If there's an alias, create a namespace object\n        // Otherwise, export all defined names tae the current environment\n        if let Some(alias_name) = alias {\n            // Create a dictionary wi' the module's exports\n            let exports = module_env.borrow().get_exports();\n            let module_dict = Value::Dict(Rc::new(RefCell::new(exports)));\n            self.environment\n                .borrow_mut()\n                .define(alias_name.to_string(), module_dict);\n        } else {\n            // Import all names directly\n            let exports = module_env.borrow().get_exports();\n            for (name, value) in exports {\n                self.environment.borrow_mut().define(name, value);\n            }\n        }\n\n        Ok(Ok(Value::Nil))\n    }\n\n    /// Resolve a module path relative tae the current directory\n    fn resolve_module_path(&self, path: &str) -> HaversResult<PathBuf> {\n        let mut module_path = PathBuf::from(path);\n\n        // Add .braw extension if not present\n        if module_path.extension().is_none() {\n            module_path.set_extension(\"braw\");\n        }\n\n        // If it's a relative path, resolve it fae the current directory\n        if module_path.is_relative() {\n            module_path = self.current_dir.join(module_path);\n        }\n\n        // Canonicalize the path\n        module_path\n            .canonicalize()\n            .map_err(|_| HaversError::ModuleNotFound {\n                name: path.to_string(),\n            })\n    }\n\n    fn execute_stmt(&mut self, stmt: &Stmt) -> HaversResult<Value> {\n        match self.execute_stmt_with_control(stmt)? {\n            Ok(value) => Ok(value),\n            Err(ControlFlow::Return(value)) => Ok(value),\n            Err(ControlFlow::Break) => Err(HaversError::BreakOutsideLoop {\n                line: stmt.span().line,\n            }),\n            Err(ControlFlow::Continue) => Err(HaversError::ContinueOutsideLoop {\n                line: stmt.span().line,\n            }),\n        }\n    }\n\n    fn execute_stmt_with_control(\n        &mut self,\n        stmt: &Stmt,\n    ) -> HaversResult<Result<Value, ControlFlow>> {\n        match stmt {\n            Stmt::VarDecl {\n                name,\n                initializer,\n                span,\n            } => {\n                self.trace(&format!(\"[line {}] ken {} = ...\", span.line, name));\n                let value = if let Some(init) = initializer {\n                    let v = self.evaluate(init)?;\n                    self.trace_verbose(&format!(\" {} is noo {}\", name, v));\n                    v\n                } else {\n                    self.trace_verbose(&format!(\" {} is noo naething\", name));\n                    Value::Nil\n                };\n                self.environment.borrow_mut().define(name.clone(), value);\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Expression { expr, span } => {\n                self.trace(&format!(\"[line {}] evaluatin' expression\", span.line));\n                let value = self.evaluate(expr)?;\n                self.trace_verbose(&format!(\" result: {}\", value));\n                Ok(Ok(value))\n            }\n\n            Stmt::Block { statements, span } => {\n                self.trace(&format!(\"[line {}] enterin' block\", span.line));\n                self.trace_depth += 1;\n                let result = self.execute_block(statements, None);\n                self.trace_depth = self.trace_depth.saturating_sub(1);\n                self.trace(&format!(\"[line {}] leavin' block\", span.line));\n                result\n            }\n\n            Stmt::If {\n                condition,\n                then_branch,\n                else_branch,\n                span,\n            } => {\n                self.trace(&format!(\"[line {}] gin (if) statement\", span.line));\n                let cond_value = self.evaluate(condition)?;\n                self.trace_verbose(&format!(\" condition is {}\", cond_value));\n                if cond_value.is_truthy() {\n                    self.trace(&format!(\n                        \"[line {}] condition is aye - takin' then branch\",\n                        span.line\n                    ));\n                    self.execute_stmt_with_control(then_branch)\n                } else if let Some(else_br) = else_branch {\n                    self.trace(&format!(\n                        \"[line {}] condition is nae - takin' ither branch\",\n                        span.line\n                    ));\n                    self.execute_stmt_with_control(else_br)\n                } else {\n                    self.trace_verbose(\" condition is nae, nae ither branch\");\n                    Ok(Ok(Value::Nil))\n                }\n            }\n\n            Stmt::While {\n                condition,\n                body,\n                span,\n            } => {\n                self.trace(&format!(\n                    \"[line {}] whiles (while) loop startin'\",\n                    span.line\n                ));\n                let mut iteration = 0;\n                while self.evaluate(condition)?.is_truthy() {\n                    iteration += 1;\n                    self.trace_verbose(&format!(\" loop iteration {}\", iteration));\n                    match self.execute_stmt_with_control(body)? {\n                        Ok(_) => {}\n                        Err(ControlFlow::Break) => {\n                            self.trace(&format!(\n                                \"[line {}] brak! (break) - leavin' loop\",\n                                span.line\n                            ));\n                            break;\n                        }\n                        Err(ControlFlow::Continue) => {\n                            self.trace_verbose(\" haud! (continue)\");\n                            continue;\n                        }\n                        Err(ControlFlow::Return(v)) => return Ok(Err(ControlFlow::Return(v))),\n                    }\n                }\n                self.trace(&format!(\n                    \"[line {}] whiles loop done after {} iterations\",\n                    span.line, iteration\n                ));\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::For {\n                variable,\n                iterable,\n                body,\n                span,\n            } => {\n                self.trace(&format!(\n                    \"[line {}] fer (for) loop: {} in ...\",\n                    span.line, variable\n                ));\n                let iter_value = self.evaluate(iterable)?;\n\n                let items: Vec<Value> = match iter_value {\n                    Value::Range(range) => range.iter().map(Value::Integer).collect(),\n                    Value::List(list) => list.borrow().clone(),\n                    Value::String(s) => s.chars().map(|c| Value::String(c.to_string())).collect(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: format!(\"Cannae iterate ower a {}\", iter_value.type_name()),\n                            line: span.line,\n                        });\n                    }\n                };\n\n                self.trace_verbose(&format!(\" iteratin' ower {} items\", items.len()));\n                let mut iteration = 0;\n                for item in items {\n                    iteration += 1;\n                    self.trace_verbose(&format!(\n                        \" iteration {}: {} = {}\",\n                        iteration, variable, item\n                    ));\n                    self.environment.borrow_mut().define(variable.clone(), item);\n                    match self.execute_stmt_with_control(body)? {\n                        Ok(_) => {}\n                        Err(ControlFlow::Break) => {\n                            self.trace(&format!(\n                                \"[line {}] brak! (break) - leavin' fer loop\",\n                                span.line\n                            ));\n                            break;\n                        }\n                        Err(ControlFlow::Continue) => {\n                            self.trace_verbose(\" haud! (continue)\");\n                            continue;\n                        }\n                        Err(ControlFlow::Return(v)) => return Ok(Err(ControlFlow::Return(v))),\n                    }\n                }\n                self.trace(&format!(\n                    \"[line {}] fer loop done after {} iterations\",\n                    span.line, iteration\n                ));\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Function {\n                name,\n                params,\n                body,\n                span,\n            } => {\n                self.trace(&format!(\n                    \"[line {}] dae (function) {} wi' {} params\",\n                    span.line,\n                    name,\n                    params.len()\n                ));\n                // Convert AST Param tae runtime FunctionParam\n                let runtime_params: Vec<FunctionParam> = params\n                    .iter()\n                    .map(|p| FunctionParam {\n                        name: p.name.clone(),\n                        default: p.default.clone(),\n                    })\n                    .collect();\n\n                let func = HaversFunction::new(\n                    name.clone(),\n                    runtime_params,\n                    body.clone(),\n                    Some(self.environment.clone()),\n                );\n                self.environment\n                    .borrow_mut()\n                    .define(name.clone(), Value::Function(Rc::new(func)));\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Return { value, span } => {\n                let ret_val = if let Some(expr) = value {\n                    let v = self.evaluate(expr)?;\n                    self.trace(&format!(\"[line {}] gie (return) {}\", span.line, v));\n                    v\n                } else {\n                    self.trace(&format!(\"[line {}] gie (return) naething\", span.line));\n                    Value::Nil\n                };\n                Ok(Err(ControlFlow::Return(ret_val)))\n            }\n\n            Stmt::Print { value, span } => {\n                let val = self.evaluate(value)?;\n                self.trace(&format!(\"[line {}] blether (print): {}\", span.line, val));\n                let output = format!(\"{}\", val);\n                println!(\"{}\", output);\n                self.output.push(output);\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Break { span } => {\n                self.trace(&format!(\"[line {}] brak! (break)\", span.line));\n                Ok(Err(ControlFlow::Break))\n            }\n\n            Stmt::Continue { span } => {\n                self.trace(&format!(\"[line {}] haud! (continue)\", span.line));\n                Ok(Err(ControlFlow::Continue))\n            }\n\n            Stmt::Class {\n                name,\n                superclass,\n                methods,\n                span,\n            } => {\n                self.trace(&format!(\n                    \"[line {}] kin (class) {} defined\",\n                    span.line, name\n                ));\n                let super_class = if let Some(super_name) = superclass {\n                    let super_val = self.environment.borrow().get(super_name).ok_or_else(|| {\n                        HaversError::UndefinedVariable {\n                            name: super_name.clone(),\n                            line: span.line,\n                        }\n                    })?;\n                    match super_val {\n                        Value::Class(c) => Some(c),\n                        _ => {\n                            return Err(HaversError::TypeError {\n                                message: format!(\"{} isnae a class\", super_name),\n                                line: span.line,\n                            });\n                        }\n                    }\n                } else {\n                    None\n                };\n\n                let mut class = HaversClass::new(name.clone(), super_class);\n\n                for method in methods {\n                    if let Stmt::Function {\n                        name: method_name,\n                        params,\n                        body,\n                        ..\n                    } = method\n                    {\n                        // Convert AST Param tae runtime FunctionParam\n                        let runtime_params: Vec<FunctionParam> = params\n                            .iter()\n                            .map(|p| FunctionParam {\n                                name: p.name.clone(),\n                                default: p.default.clone(),\n                            })\n                            .collect();\n\n                        let func = HaversFunction::new(\n                            method_name.clone(),\n                            runtime_params,\n                            body.clone(),\n                            Some(self.environment.clone()),\n                        );\n                        class.methods.insert(method_name.clone(), Rc::new(func));\n                    }\n                }\n\n                self.environment\n                    .borrow_mut()\n                    .define(name.clone(), Value::Class(Rc::new(class)));\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Struct { name, fields, span } => {\n                self.trace(&format!(\n                    \"[line {}] thing (struct) {} defined wi' {} fields\",\n                    span.line,\n                    name,\n                    fields.len()\n                ));\n                let structure = HaversStruct::new(name.clone(), fields.clone());\n                self.environment\n                    .borrow_mut()\n                    .define(name.clone(), Value::Struct(Rc::new(structure)));\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Import { path, alias, span } => {\n                let alias_str = alias\n                    .as_ref()\n                    .map(|a| format!(\" as {}\", a))\n                    .unwrap_or_default();\n                self.trace(&format!(\n                    \"[line {}] fetch (import) \\\"{}\\\"{}\",\n                    span.line, path, alias_str\n                ));\n                self.load_module(path, alias.as_deref(), *span)\n            }\n\n            Stmt::TryCatch {\n                try_block,\n                error_name,\n                catch_block,\n                span,\n            } => {\n                self.trace(&format!(\"[line {}] hae_a_bash (try) startin'\", span.line));\n                match self.execute_stmt_with_control(try_block) {\n                    Ok(result) => {\n                        self.trace(&format!(\n                            \"[line {}] try block succeeded - nae bother!\",\n                            span.line\n                        ));\n                        Ok(result)\n                    }\n                    Err(e) => {\n                        self.trace(&format!(\n                            \"[line {}] gin_it_gangs_wrang (catch) - caught: {}\",\n                            span.line, e\n                        ));\n                        // Bind the error to the catch variable\n                        self.environment\n                            .borrow_mut()\n                            .define(error_name.clone(), Value::String(e.to_string()));\n                        self.execute_stmt_with_control(catch_block)\n                    }\n                }\n            }\n\n            Stmt::Match { value, arms, span } => {\n                self.trace(&format!(\"[line {}] keek (match) statement\", span.line));\n                let val = self.evaluate(value)?;\n                self.trace_verbose(&format!(\" matchin' against: {}\", val));\n\n                for (i, arm) in arms.iter().enumerate() {\n                    if self.pattern_matches(&arm.pattern, &val)? {\n                        self.trace(&format!(\"[line {}] matched arm {}\", span.line, i + 1));\n                        // Bind pattern variables if needed\n                        if let Pattern::Identifier(name) = &arm.pattern {\n                            self.environment\n                                .borrow_mut()\n                                .define(name.clone(), val.clone());\n                        }\n                        return self.execute_stmt_with_control(&arm.body);\n                    }\n                }\n\n                // No match found\n                self.trace(&format!(\"[line {}] nae match found!\", span.line));\n                Err(HaversError::TypeError {\n                    message: format!(\"Nae match found fer {}\", val),\n                    line: span.line,\n                })\n            }\n\n            Stmt::Assert {\n                condition,\n                message,\n                span,\n            } => {\n                self.trace(&format!(\"[line {}] mak_siccar (assert)\", span.line));\n                let cond_value = self.evaluate(condition)?;\n                self.trace_verbose(&format!(\" condition is {}\", cond_value));\n                if !cond_value.is_truthy() {\n                    let msg = if let Some(msg_expr) = message {\n                        let msg_val = self.evaluate(msg_expr)?;\n                        msg_val.to_string()\n                    } else {\n                        \"Assertion failed\".to_string()\n                    };\n                    self.trace(&format!(\"[line {}] assertion FAILED: {}\", span.line, msg));\n                    return Err(HaversError::AssertionFailed {\n                        message: msg,\n                        line: span.line,\n                    });\n                }\n                self.trace_verbose(\" assertion passed - braw!\");\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Destructure {\n                patterns,\n                value,\n                span,\n            } => {\n                self.trace(&format!(\n                    \"[line {}] destructurin' intae {} variables\",\n                    span.line,\n                    patterns.len()\n                ));\n                let val = self.evaluate(value)?;\n                self.trace_verbose(&format!(\" unpackin': {}\", val));\n\n                // The value must be a list\n                let items = match &val {\n                    Value::List(list) => list.borrow().clone(),\n                    Value::String(s) => {\n                        // Strings can be destructured intae characters\n                        s.chars().map(|c| Value::String(c.to_string())).collect()\n                    }\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: format!(\n                                \"Ye can only destructure lists and strings, no' {}\",\n                                val.type_name()\n                            ),\n                            line: span.line,\n                        });\n                    }\n                };\n\n                // Find the rest pattern position if any\n                let rest_pos = patterns\n                    .iter()\n                    .position(|p| matches!(p, DestructPattern::Rest(_)));\n\n                // Calculate positions\n                let before_rest = rest_pos.unwrap_or(patterns.len());\n                let after_rest = if let Some(pos) = rest_pos {\n                    patterns.len() - pos - 1\n                } else {\n                    0\n                };\n\n                // Check we have enough elements\n                let min_required = before_rest + after_rest;\n                if items.len() < min_required {\n                    return Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae destructure: need at least {} elements but got {}\",\n                            min_required,\n                            items.len()\n                        ),\n                        line: span.line,\n                    });\n                }\n\n                // Bind the variables\n                let mut item_idx = 0;\n                for (pat_idx, pattern) in patterns.iter().enumerate() {\n                    match pattern {\n                        DestructPattern::Variable(name) => {\n                            if pat_idx < before_rest {\n                                // Before rest: take from start\n                                self.environment\n                                    .borrow_mut()\n                                    .define(name.clone(), items[item_idx].clone());\n                                item_idx += 1;\n                            } else {\n                                // After rest: take from end\n                                let from_end = patterns.len() - pat_idx - 1;\n                                let end_idx = items.len() - from_end - 1;\n                                self.environment\n                                    .borrow_mut()\n                                    .define(name.clone(), items[end_idx].clone());\n                            }\n                        }\n                        DestructPattern::Rest(name) => {\n                            // Capture all elements in the middle\n                            let rest_end = items.len() - after_rest;\n                            let rest_items: Vec<Value> = items[item_idx..rest_end].to_vec();\n                            self.environment.borrow_mut().define(\n                                name.clone(),\n                                Value::List(Rc::new(RefCell::new(rest_items))),\n                            );\n                            item_idx = rest_end;\n                        }\n                        DestructPattern::Ignore => {\n                            if pat_idx < before_rest {\n                                item_idx += 1;\n                            }\n                            // Just skip this element\n                        }\n                    }\n                }\n\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Log {\n                level,\n                message,\n                span,\n            } => {\n                let msg = self.evaluate(message)?;\n                self.log_message(*level, &format!(\"{}\", msg), span.line);\n                Ok(Ok(Value::Nil))\n            }\n\n            Stmt::Hurl { message, span } => {\n                let msg = self.evaluate(message)?;\n                let error_msg = match msg {\n                    Value::String(s) => s,\n                    v => format!(\"{}\", v),\n                };\n                Err(HaversError::UserError {\n                    message: error_msg,\n                    line: span.line,\n                })\n            }\n        }\n    }\n\n    fn execute_block(\n        &mut self,\n        statements: &[Stmt],\n        env: Option<Rc<RefCell<Environment>>>,\n    ) -> HaversResult<Result<Value, ControlFlow>> {\n        let previous = self.environment.clone();\n        let new_env = env.unwrap_or_else(|| {\n            Rc::new(RefCell::new(Environment::with_enclosing(previous.clone())))\n        });\n        self.environment = new_env;\n\n        let mut result = Ok(Value::Nil);\n        for stmt in statements {\n            match self.execute_stmt_with_control(stmt)? {\n                Ok(v) => result = Ok(v),\n                Err(cf) => {\n                    self.environment = previous;\n                    return Ok(Err(cf));\n                }\n            }\n        }\n\n        self.environment = previous;\n        Ok(result)\n    }\n\n    fn pattern_matches(&mut self, pattern: &Pattern, value: &Value) -> HaversResult<bool> {\n        match pattern {\n            Pattern::Literal(lit) => {\n                let lit_val = match lit {\n                    Literal::Integer(n) => Value::Integer(*n),\n                    Literal::Float(f) => Value::Float(*f),\n                    Literal::String(s) => Value::String(s.clone()),\n                    Literal::Bool(b) => Value::Bool(*b),\n                    Literal::Nil => Value::Nil,\n                };\n                Ok(lit_val == *value)\n            }\n            Pattern::Identifier(_) => Ok(true), // Always matches, binds value\n            Pattern::Wildcard => Ok(true),\n            Pattern::Range { start, end } => {\n                if let Value::Integer(n) = value {\n                    let start_val = self.evaluate(start)?;\n                    let end_val = self.evaluate(end)?;\n                    if let (Some(s), Some(e)) = (start_val.as_integer(), end_val.as_integer()) {\n                        Ok(*n >= s && *n < e)\n                    } else {\n                        Ok(false)\n                    }\n                } else {\n                    Ok(false)\n                }\n            }\n        }\n    }\n\n    fn evaluate(&mut self, expr: &Expr) -> HaversResult<Value> {\n        match expr {\n            Expr::Literal { value, .. } => Ok(match value {\n                Literal::Integer(n) => Value::Integer(*n),\n                Literal::Float(f) => Value::Float(*f),\n                Literal::String(s) => Value::String(s.clone()),\n                Literal::Bool(b) => Value::Bool(*b),\n                Literal::Nil => Value::Nil,\n            }),\n\n            Expr::Variable { name, span } => self\n                .environment\n                .borrow()\n                .get(name)\n                .ok_or_else(|| HaversError::UndefinedVariable {\n                    name: name.clone(),\n                    line: span.line,\n                }),\n\n            Expr::Assign { name, value, span } => {\n                let val = self.evaluate(value)?;\n                if !self.environment.borrow_mut().assign(name, val.clone()) {\n                    return Err(HaversError::UndefinedVariable {\n                        name: name.clone(),\n                        line: span.line,\n                    });\n                }\n                Ok(val)\n            }\n\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                span,\n            } => {\n                let left_val = self.evaluate(left)?;\n                let right_val = self.evaluate(right)?;\n\n                // Check for operator overloading on instances\n                if let Value::Instance(ref inst) = left_val {\n                    let method_name = self.operator_method_name(operator);\n                    if let Some(method) = inst.borrow().class.find_method(&method_name) {\n                        // Call the overloaded operator method\n                        return self.call_method_on_instance(\n                            inst.clone(),\n                            method,\n                            vec![right_val],\n                            span.line,\n                        );\n                    }\n                }\n\n                self.binary_op(&left_val, operator, &right_val, span.line)\n            }\n\n            Expr::Unary {\n                operator,\n                operand,\n                span,\n            } => {\n                let val = self.evaluate(operand)?;\n                match operator {\n                    UnaryOp::Negate => match val {\n                        Value::Integer(n) => Ok(Value::Integer(-n)),\n                        Value::Float(f) => Ok(Value::Float(-f)),\n                        _ => Err(HaversError::TypeError {\n                            message: format!(\"Cannae negate a {}\", val.type_name()),\n                            line: span.line,\n                        }),\n                    },\n                    UnaryOp::Not => Ok(Value::Bool(!val.is_truthy())),\n                }\n            }\n\n            Expr::Logical {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                let left_val = self.evaluate(left)?;\n                match operator {\n                    LogicalOp::And => {\n                        if !left_val.is_truthy() {\n                            Ok(left_val)\n                        } else {\n                            self.evaluate(right)\n                        }\n                    }\n                    LogicalOp::Or => {\n                        if left_val.is_truthy() {\n                            Ok(left_val)\n                        } else {\n                            self.evaluate(right)\n                        }\n                    }\n                }\n            }\n\n            Expr::Call {\n                callee,\n                arguments,\n                span,\n            } => {\n                // Check if this is a method call (callee is a Get expression)\n                if let Expr::Get { object, property, .. } = callee.as_ref() {\n                    let obj = self.evaluate(object)?;\n                    if let Value::Instance(inst) = &obj {\n                        // It's a method call - get the method and bind 'masel'\n                        // Clone what we need to avoid holding the borrow\n                        let method_opt = {\n                            let borrowed = inst.borrow();\n                            borrowed.class.find_method(property)\n                        };\n                        if let Some(method) = method_opt {\n                            let args = self.evaluate_call_args(arguments, span.line)?;\n                            let env = Rc::new(RefCell::new(Environment::with_enclosing(\n                                method.closure.clone().unwrap_or(self.globals.clone()),\n                            )));\n                            env.borrow_mut()\n                                .define(\"masel\".to_string(), Value::Instance(inst.clone()));\n                            return self.call_function_with_env(&method, args, env, span.line);\n                        }\n                        // Check instance fields for callable values\n                        let field_val_opt = {\n                            let borrowed = inst.borrow();\n                            borrowed.fields.get(property).cloned()\n                        };\n                        if let Some(field_val) = field_val_opt {\n                            let args = self.evaluate_call_args(arguments, span.line)?;\n                            return self.call_value(field_val, args, span.line);\n                        }\n                        return Err(HaversError::UndefinedVariable {\n                            name: property.clone(),\n                            line: span.line,\n                        });\n                    }\n                }\n\n                let callee_val = self.evaluate(callee)?;\n                let args = self.evaluate_call_args(arguments, span.line)?;\n                self.call_value(callee_val, args, span.line)\n            }\n\n            Expr::Get {\n                object,\n                property,\n                span,\n            } => {\n                let obj = self.evaluate(object)?;\n                match obj {\n                    Value::Instance(inst) => inst\n                        .borrow()\n                        .get(property)\n                        .ok_or_else(|| HaversError::UndefinedVariable {\n                            name: property.clone(),\n                            line: span.line,\n                        }),\n                    Value::Dict(dict) => dict\n                        .borrow()\n                        .get(property)\n                        .cloned()\n                        .ok_or_else(|| HaversError::UndefinedVariable {\n                            name: property.clone(),\n                            line: span.line,\n                        }),\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae access property '{}' on a {}\",\n                            property,\n                            obj.type_name()\n                        ),\n                        line: span.line,\n                    }),\n                }\n            }\n\n            Expr::Set {\n                object,\n                property,\n                value,\n                span,\n            } => {\n                let obj = self.evaluate(object)?;\n                let val = self.evaluate(value)?;\n                match obj {\n                    Value::Instance(inst) => {\n                        inst.borrow_mut().set(property.clone(), val.clone());\n                        Ok(val)\n                    }\n                    Value::Dict(dict) => {\n                        dict.borrow_mut().insert(property.clone(), val.clone());\n                        Ok(val)\n                    }\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae set property '{}' on a {}\",\n                            property,\n                            obj.type_name()\n                        ),\n                        line: span.line,\n                    }),\n                }\n            }\n\n            Expr::Index {\n                object,\n                index,\n                span,\n            } => {\n                let obj = self.evaluate(object)?;\n                let idx = self.evaluate(index)?;\n                match (&obj, &idx) {\n                    (Value::List(list), Value::Integer(i)) => {\n                        let list = list.borrow();\n                        let idx = if *i < 0 {\n                            list.len() as i64 + *i\n                        } else {\n                            *i\n                        };\n                        list.get(idx as usize)\n                            .cloned()\n                            .ok_or_else(|| HaversError::IndexOutOfBounds {\n                                index: *i,\n                                size: list.len(),\n                                line: span.line,\n                            })\n                    }\n                    (Value::String(s), Value::Integer(i)) => {\n                        let idx = if *i < 0 {\n                            s.len() as i64 + *i\n                        } else {\n                            *i\n                        };\n                        s.chars()\n                            .nth(idx as usize)\n                            .map(|c| Value::String(c.to_string()))\n                            .ok_or(HaversError::IndexOutOfBounds {\n                                index: *i,\n                                size: s.len(),\n                                line: span.line,\n                            })\n                    }\n                    (Value::Dict(dict), Value::String(key)) => dict\n                        .borrow()\n                        .get(key)\n                        .cloned()\n                        .ok_or_else(|| HaversError::UndefinedVariable {\n                            name: key.clone(),\n                            line: span.line,\n                        }),\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae index a {} wi' a {}\",\n                            obj.type_name(),\n                            idx.type_name()\n                        ),\n                        line: span.line,\n                    }),\n                }\n            }\n\n            Expr::IndexSet {\n                object,\n                index,\n                value,\n                span,\n            } => {\n                let obj = self.evaluate(object)?;\n                let idx = self.evaluate(index)?;\n                let val = self.evaluate(value)?;\n\n                match (&obj, &idx) {\n                    (Value::List(list), Value::Integer(i)) => {\n                        let mut list_mut = list.borrow_mut();\n                        let idx = if *i < 0 {\n                            list_mut.len() as i64 + *i\n                        } else {\n                            *i\n                        };\n                        if idx < 0 || idx as usize >= list_mut.len() {\n                            return Err(HaversError::IndexOutOfBounds {\n                                index: *i,\n                                size: list_mut.len(),\n                                line: span.line,\n                            });\n                        }\n                        list_mut[idx as usize] = val.clone();\n                        Ok(val)\n                    }\n                    (Value::Dict(dict), Value::String(key)) => {\n                        dict.borrow_mut().insert(key.clone(), val.clone());\n                        Ok(val)\n                    }\n                    (Value::Dict(dict), key) => {\n                        // Convert non-string key to string\n                        let key_str = format!(\"{}\", key);\n                        dict.borrow_mut().insert(key_str, val.clone());\n                        Ok(val)\n                    }\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae set index on a {} wi' a {}\",\n                            obj.type_name(),\n                            idx.type_name()\n                        ),\n                        line: span.line,\n                    }),\n                }\n            }\n\n            Expr::Slice {\n                object,\n                start,\n                end,\n                step,\n                span,\n            } => {\n                let obj = self.evaluate(object)?;\n\n                // Get start index, handling None as default\n                let start_idx = if let Some(s) = start {\n                    let val = self.evaluate(s)?;\n                    match val {\n                        Value::Integer(i) => Some(i),\n                        _ => {\n                            return Err(HaversError::TypeError {\n                                message: \"Slice start must be an integer\".to_string(),\n                                line: span.line,\n                            })\n                        }\n                    }\n                } else {\n                    None\n                };\n\n                // Get end index\n                let end_idx = if let Some(e) = end {\n                    let val = self.evaluate(e)?;\n                    match val {\n                        Value::Integer(i) => Some(i),\n                        _ => {\n                            return Err(HaversError::TypeError {\n                                message: \"Slice end must be an integer\".to_string(),\n                                line: span.line,\n                            })\n                        }\n                    }\n                } else {\n                    None\n                };\n\n                // Get step value (default is 1)\n                let step_val = if let Some(st) = step {\n                    let val = self.evaluate(st)?;\n                    match val {\n                        Value::Integer(i) => {\n                            if i == 0 {\n                                return Err(HaversError::TypeError {\n                                    message: \"Slice step cannae be zero, ya dafty!\".to_string(),\n                                    line: span.line,\n                                });\n                            }\n                            i\n                        }\n                        _ => {\n                            return Err(HaversError::TypeError {\n                                message: \"Slice step must be an integer\".to_string(),\n                                line: span.line,\n                            })\n                        }\n                    }\n                } else {\n                    1\n                };\n\n                match obj {\n                    Value::List(list) => {\n                        let list = list.borrow();\n                        let len = list.len() as i64;\n\n                        // Handle defaults based on step direction\n                        let (start, end) = if step_val > 0 {\n                            let s = start_idx.unwrap_or(0);\n                            let e = end_idx.unwrap_or(len);\n                            (s, e)\n                        } else {\n                            // Negative step: default start is -1 (end), default end is before start\n                            let s = start_idx.unwrap_or(-1);\n                            let e = end_idx.unwrap_or(-(len + 1));\n                            (s, e)\n                        };\n\n                        // Normalize negative indices\n                        let start = if start < 0 {\n                            (len + start).max(0) as usize\n                        } else {\n                            (start as usize).min(list.len())\n                        };\n\n                        let end = if end < 0 {\n                            (len + end).max(-1)\n                        } else {\n                            (end as usize).min(list.len()) as i64\n                        };\n\n                        let mut sliced: Vec<Value> = Vec::new();\n                        if step_val > 0 {\n                            let mut i = start as i64;\n                            while i < end && i < len {\n                                if i >= 0 {\n                                    sliced.push(list[i as usize].clone());\n                                }\n                                i += step_val;\n                            }\n                        } else {\n                            // Negative step: go backwards\n                            let mut i = start as i64;\n                            while i > end && i >= 0 {\n                                if (i as usize) < list.len() {\n                                    sliced.push(list[i as usize].clone());\n                                }\n                                i += step_val; // step_val is negative\n                            }\n                        }\n                        Ok(Value::List(Rc::new(RefCell::new(sliced))))\n                    }\n                    Value::String(s) => {\n                        let chars: Vec<char> = s.chars().collect();\n                        let len = chars.len() as i64;\n\n                        // Handle defaults based on step direction\n                        let (start, end) = if step_val > 0 {\n                            let st = start_idx.unwrap_or(0);\n                            let en = end_idx.unwrap_or(len);\n                            (st, en)\n                        } else {\n                            // Negative step: default start is -1 (end), default end is before start\n                            let st = start_idx.unwrap_or(-1);\n                            let en = end_idx.unwrap_or(-(len + 1));\n                            (st, en)\n                        };\n\n                        // Normalize negative indices\n                        let start = if start < 0 {\n                            (len + start).max(0) as usize\n                        } else {\n                            (start as usize).min(chars.len())\n                        };\n\n                        let end = if end < 0 {\n                            (len + end).max(-1)\n                        } else {\n                            (end as usize).min(chars.len()) as i64\n                        };\n\n                        let mut sliced = String::new();\n                        if step_val > 0 {\n                            let mut i = start as i64;\n                            while i < end && i < len {\n                                if i >= 0 {\n                                    sliced.push(chars[i as usize]);\n                                }\n                                i += step_val;\n                            }\n                        } else {\n                            // Negative step: go backwards\n                            let mut i = start as i64;\n                            while i > end && i >= 0 {\n                                if (i as usize) < chars.len() {\n                                    sliced.push(chars[i as usize]);\n                                }\n                                i += step_val; // step_val is negative\n                            }\n                        }\n                        Ok(Value::String(sliced))\n                    }\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\"Cannae slice a {}, ya numpty!\", obj.type_name()),\n                        line: span.line,\n                    }),\n                }\n            }\n\n            Expr::List { elements, .. } => {\n                let mut items = Vec::new();\n                for elem in elements {\n                    // Handle spread operator (...) - skail the elements intae the list\n                    if let Expr::Spread { expr, span } = elem {\n                        let spread_value = self.evaluate(expr)?;\n                        match spread_value {\n                            Value::List(list) => {\n                                items.extend(list.borrow().clone());\n                            }\n                            Value::String(s) => {\n                                // Spread string into characters\n                                for c in s.chars() {\n                                    items.push(Value::String(c.to_string()));\n                                }\n                            }\n                            _ => {\n                                return Err(HaversError::TypeError {\n                                    message: \"Cannae skail (spread) somethin' that isnae a list or string!\".to_string(),\n                                    line: span.line,\n                                });\n                            }\n                        }\n                    } else {\n                        items.push(self.evaluate(elem)?);\n                    }\n                }\n                Ok(Value::List(Rc::new(RefCell::new(items))))\n            }\n\n            Expr::Dict { pairs, .. } => {\n                let mut map = HashMap::new();\n                for (key, value) in pairs {\n                    let k = self.evaluate(key)?;\n                    let v = self.evaluate(value)?;\n                    let key_str = match k {\n                        Value::String(s) => s,\n                        _ => format!(\"{}\", k),\n                    };\n                    map.insert(key_str, v);\n                }\n                Ok(Value::Dict(Rc::new(RefCell::new(map))))\n            }\n\n            Expr::Range {\n                start,\n                end,\n                inclusive,\n                ..\n            } => {\n                let start_val = self.evaluate(start)?;\n                let end_val = self.evaluate(end)?;\n                match (start_val.as_integer(), end_val.as_integer()) {\n                    (Some(s), Some(e)) => Ok(Value::Range(RangeValue::new(s, e, *inclusive))),\n                    _ => Err(HaversError::TypeError {\n                        message: \"Range bounds must be integers\".to_string(),\n                        line: expr.span().line,\n                    }),\n                }\n            }\n\n            Expr::Grouping { expr, .. } => self.evaluate(expr),\n\n            Expr::Lambda {\n                params,\n                body,\n                span,\n            } => {\n                // Convert lambda params tae FunctionParams (lambdas dinnae hae defaults)\n                let runtime_params: Vec<FunctionParam> = params\n                    .iter()\n                    .map(|name| FunctionParam {\n                        name: name.clone(),\n                        default: None,\n                    })\n                    .collect();\n\n                // Create a function from the lambda\n                let func = HaversFunction::new(\n                    \"<lambda>\".to_string(),\n                    runtime_params,\n                    vec![Stmt::Return {\n                        value: Some((**body).clone()),\n                        span: *span,\n                    }],\n                    Some(self.environment.clone()),\n                );\n                Ok(Value::Function(Rc::new(func)))\n            }\n\n            Expr::Masel { span } => {\n                self.environment\n                    .borrow()\n                    .get(\"masel\")\n                    .ok_or_else(|| HaversError::UndefinedVariable {\n                        name: \"masel\".to_string(),\n                        line: span.line,\n                    })\n            }\n\n            Expr::Input { prompt, span: _ } => {\n                let prompt_val = self.evaluate(prompt)?;\n                print!(\"{}\", prompt_val);\n                io::stdout().flush().unwrap();\n\n                let mut input = String::new();\n                io::stdin()\n                    .read_line(&mut input)\n                    .map_err(|e| HaversError::InternalError(e.to_string()))?;\n\n                Ok(Value::String(input.trim().to_string()))\n            }\n\n            Expr::FString { parts, .. } => {\n                let mut result = String::new();\n                for part in parts {\n                    match part {\n                        FStringPart::Text(text) => result.push_str(text),\n                        FStringPart::Expr(expr) => {\n                            let val = self.evaluate(expr)?;\n                            result.push_str(&val.to_string());\n                        }\n                    }\n                }\n                Ok(Value::String(result))\n            }\n\n            // Spread is only valid in specific contexts (lists, function calls)\n            // If we get here, it's an error\n            Expr::Spread { span, .. } => Err(HaversError::TypeError {\n                message: \"The spread operator (...) can only be used in lists or function calls, ya numpty!\".to_string(),\n                line: span.line,\n            }),\n\n            // Pipe forward: left |> right means call right(left)\n            Expr::Pipe { left, right, span } => {\n                let left_val = self.evaluate(left)?;\n                let right_val = self.evaluate(right)?;\n                // Call the right side as a function with left as the argument\n                self.call_value(right_val, vec![left_val], span.line)\n            }\n\n            Expr::Ternary {\n                condition,\n                then_expr,\n                else_expr,\n                ..\n            } => {\n                // Evaluate condition and pick the appropriate branch\n                let cond_val = self.evaluate(condition)?;\n                if cond_val.is_truthy() {\n                    self.evaluate(then_expr)\n                } else {\n                    self.evaluate(else_expr)\n                }\n            }\n        }\n    }\n\n    fn binary_op(\n        &self,\n        left: &Value,\n        op: &BinaryOp,\n        right: &Value,\n        line: usize,\n    ) -> HaversResult<Value> {\n        match op {\n            BinaryOp::Add => match (left, right) {\n                (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(a + b)),\n                (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a + b)),\n                (Value::Integer(a), Value::Float(b)) => Ok(Value::Float(*a as f64 + b)),\n                (Value::Float(a), Value::Integer(b)) => Ok(Value::Float(a + *b as f64)),\n                (Value::String(a), Value::String(b)) => Ok(Value::String(format!(\"{}{}\", a, b))),\n                (Value::String(a), b) => Ok(Value::String(format!(\"{}{}\", a, b))),\n                (a, Value::String(b)) => Ok(Value::String(format!(\"{}{}\", a, b))),\n                (Value::List(a), Value::List(b)) => {\n                    let mut result = a.borrow().clone();\n                    result.extend(b.borrow().clone());\n                    Ok(Value::List(Rc::new(RefCell::new(result))))\n                }\n                _ => Err(HaversError::TypeError {\n                    message: format!(\"Cannae add {} an' {}\", left.type_name(), right.type_name()),\n                    line,\n                }),\n            },\n\n            BinaryOp::Subtract => match (left, right) {\n                (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(a - b)),\n                (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a - b)),\n                (Value::Integer(a), Value::Float(b)) => Ok(Value::Float(*a as f64 - b)),\n                (Value::Float(a), Value::Integer(b)) => Ok(Value::Float(a - *b as f64)),\n                _ => Err(HaversError::TypeError {\n                    message: format!(\n                        \"Cannae subtract {} fae {}\",\n                        right.type_name(),\n                        left.type_name()\n                    ),\n                    line,\n                }),\n            },\n\n            BinaryOp::Multiply => match (left, right) {\n                (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(a * b)),\n                (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a * b)),\n                (Value::Integer(a), Value::Float(b)) => Ok(Value::Float(*a as f64 * b)),\n                (Value::Float(a), Value::Integer(b)) => Ok(Value::Float(a * *b as f64)),\n                (Value::String(s), Value::Integer(n)) | (Value::Integer(n), Value::String(s)) => {\n                    Ok(Value::String(s.repeat(*n as usize)))\n                }\n                _ => Err(HaversError::TypeError {\n                    message: format!(\n                        \"Cannae multiply {} by {}\",\n                        left.type_name(),\n                        right.type_name()\n                    ),\n                    line,\n                }),\n            },\n\n            BinaryOp::Divide => {\n                // Check for division by zero\n                match right {\n                    Value::Integer(0) => return Err(HaversError::DivisionByZero { line }),\n                    Value::Float(f) if *f == 0.0 => {\n                        return Err(HaversError::DivisionByZero { line })\n                    }\n                    _ => {}\n                }\n                match (left, right) {\n                    (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(a / b)),\n                    (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a / b)),\n                    (Value::Integer(a), Value::Float(b)) => Ok(Value::Float(*a as f64 / b)),\n                    (Value::Float(a), Value::Integer(b)) => Ok(Value::Float(a / *b as f64)),\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae divide {} by {}\",\n                            left.type_name(),\n                            right.type_name()\n                        ),\n                        line,\n                    }),\n                }\n            }\n\n            BinaryOp::Modulo => {\n                if let Value::Integer(0) = right {\n                    return Err(HaversError::DivisionByZero { line });\n                }\n                match (left, right) {\n                    (Value::Integer(a), Value::Integer(b)) => Ok(Value::Integer(a % b)),\n                    (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a % b)),\n                    _ => Err(HaversError::TypeError {\n                        message: format!(\n                            \"Cannae get remainder o' {} by {}\",\n                            left.type_name(),\n                            right.type_name()\n                        ),\n                        line,\n                    }),\n                }\n            }\n\n            BinaryOp::Equal => Ok(Value::Bool(left == right)),\n            BinaryOp::NotEqual => Ok(Value::Bool(left != right)),\n\n            BinaryOp::Less => self.compare(left, right, |a, b| a < b, |a, b| a < b, line),\n            BinaryOp::LessEqual => self.compare(left, right, |a, b| a <= b, |a, b| a <= b, line),\n            BinaryOp::Greater => self.compare(left, right, |a, b| a > b, |a, b| a > b, line),\n            BinaryOp::GreaterEqual => self.compare(left, right, |a, b| a >= b, |a, b| a >= b, line),\n        }\n    }\n\n    fn compare<F, S>(\n        &self,\n        left: &Value,\n        right: &Value,\n        cmp: F,\n        str_cmp: S,\n        line: usize,\n    ) -> HaversResult<Value>\n    where\n        F: Fn(f64, f64) -> bool,\n        S: Fn(&str, &str) -> bool,\n    {\n        match (left, right) {\n            (Value::Integer(a), Value::Integer(b)) => Ok(Value::Bool(cmp(*a as f64, *b as f64))),\n            (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(cmp(*a, *b))),\n            (Value::Integer(a), Value::Float(b)) => Ok(Value::Bool(cmp(*a as f64, *b))),\n            (Value::Float(a), Value::Integer(b)) => Ok(Value::Bool(cmp(*a, *b as f64))),\n            (Value::String(a), Value::String(b)) => Ok(Value::Bool(str_cmp(a, b))),\n            _ => Err(HaversError::TypeError {\n                message: format!(\n                    \"Cannae compare {} wi' {}\",\n                    left.type_name(),\n                    right.type_name()\n                ),\n                line,\n            }),\n        }\n    }\n\n    /// Get the method name for operator overloading\n    /// Uses Scots-flavored names:\n    /// - __pit_thegither__ = add (put together)\n    /// - __tak_awa__ = subtract (take away)\n    /// - __times__ = multiply\n    /// - __pairt__ = divide (part/divide)\n    /// - __lave__ = modulo (what's left)\n    /// - __same_as__ = equal\n    /// - __differs_fae__ = not equal\n    /// - __wee_er__ = less than (smaller)\n    /// - __wee_er_or_same__ = less or equal\n    /// - __muckle_er__ = greater than (bigger)\n    /// - __muckle_er_or_same__ = greater or equal\n    fn operator_method_name(&self, op: &BinaryOp) -> String {\n        match op {\n            BinaryOp::Add => \"__pit_thegither__\".to_string(),\n            BinaryOp::Subtract => \"__tak_awa__\".to_string(),\n            BinaryOp::Multiply => \"__times__\".to_string(),\n            BinaryOp::Divide => \"__pairt__\".to_string(),\n            BinaryOp::Modulo => \"__lave__\".to_string(),\n            BinaryOp::Equal => \"__same_as__\".to_string(),\n            BinaryOp::NotEqual => \"__differs_fae__\".to_string(),\n            BinaryOp::Less => \"__wee_er__\".to_string(),\n            BinaryOp::LessEqual => \"__wee_er_or_same__\".to_string(),\n            BinaryOp::Greater => \"__muckle_er__\".to_string(),\n            BinaryOp::GreaterEqual => \"__muckle_er_or_same__\".to_string(),\n        }\n    }\n\n    /// Call a method on an instance with the given arguments\n    fn call_method_on_instance(\n        &mut self,\n        instance: Rc<RefCell<HaversInstance>>,\n        method: Rc<HaversFunction>,\n        args: Vec<Value>,\n        line: usize,\n    ) -> HaversResult<Value> {\n        // Check arity\n        if method.params.len() != args.len() {\n            return Err(HaversError::WrongArity {\n                name: method.name.clone(),\n                expected: method.params.len(),\n                got: args.len(),\n                line,\n            });\n        }\n\n        // Create a new environment for the method\n        let method_env = if let Some(closure) = &method.closure {\n            Environment::with_enclosing(closure.clone())\n        } else {\n            Environment::with_enclosing(self.globals.clone())\n        };\n        let method_env = Rc::new(RefCell::new(method_env));\n\n        // Bind 'masel' to the instance\n        method_env\n            .borrow_mut()\n            .define(\"masel\".to_string(), Value::Instance(instance));\n\n        // Bind the parameters\n        for (param, arg) in method.params.iter().zip(args) {\n            method_env.borrow_mut().define(param.name.clone(), arg);\n        }\n\n        // Execute the method body with our custom environment\n        let result = self.execute_block(&method.body, Some(method_env));\n\n        match result {\n            Ok(Ok(val)) => Ok(val),\n            Ok(Err(ControlFlow::Return(val))) => Ok(val),\n            Ok(Err(ControlFlow::Break)) => Ok(Value::Nil),\n            Ok(Err(ControlFlow::Continue)) => Ok(Value::Nil),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Evaluate function arguments, handling spread operator (...args)\n    fn evaluate_call_args(&mut self, arguments: &[Expr], _line: usize) -> HaversResult<Vec<Value>> {\n        let mut args = Vec::new();\n        for arg in arguments {\n            if let Expr::Spread { expr, span } = arg {\n                let spread_value = self.evaluate(expr)?;\n                match spread_value {\n                    Value::List(list) => {\n                        args.extend(list.borrow().clone());\n                    }\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"Cannae skail (spread) somethin' that isnae a list in function call!\".to_string(),\n                            line: span.line,\n                        });\n                    }\n                }\n            } else {\n                args.push(self.evaluate(arg)?);\n            }\n        }\n        Ok(args)\n    }\n\n    fn call_value(&mut self, callee: Value, args: Vec<Value>, line: usize) -> HaversResult<Value> {\n        match callee {\n            Value::Function(func) => self.call_function(&func, args, line),\n            Value::NativeFunction(native) => {\n                if args.len() != native.arity {\n                    return Err(HaversError::WrongArity {\n                        name: native.name.clone(),\n                        expected: native.arity,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                (native.func)(args).map_err(HaversError::InternalError)\n            }\n            // Higher-order function builtins\n            Value::String(ref s) if s.starts_with(\"__builtin_\") => {\n                self.call_builtin_hof(s, args, line)\n            }\n            Value::Class(class) => {\n                // Create new instance\n                let instance = Rc::new(RefCell::new(HaversInstance::new(class.clone())));\n\n                // Call init if it exists\n                if let Some(init) = class.find_method(\"init\") {\n                    let env = Rc::new(RefCell::new(Environment::with_enclosing(\n                        init.closure.clone().unwrap_or(self.globals.clone()),\n                    )));\n                    env.borrow_mut()\n                        .define(\"masel\".to_string(), Value::Instance(instance.clone()));\n                    self.call_function_with_env(&init, args, env, line)?;\n                }\n\n                Ok(Value::Instance(instance))\n            }\n            Value::Struct(structure) => {\n                // Create instance with fields\n                if args.len() != structure.fields.len() {\n                    return Err(HaversError::WrongArity {\n                        name: structure.name.clone(),\n                        expected: structure.fields.len(),\n                        got: args.len(),\n                        line,\n                    });\n                }\n\n                let mut fields = HashMap::new();\n                for (field, value) in structure.fields.iter().zip(args) {\n                    fields.insert(field.clone(), value);\n                }\n\n                // Return as a dict for now\n                Ok(Value::Dict(Rc::new(RefCell::new(fields))))\n            }\n            _ => Err(HaversError::NotCallable {\n                name: format!(\"{}\", callee),\n                line,\n            }),\n        }\n    }\n\n    /// Handle higher-order function builtins\n    fn call_builtin_hof(\n        &mut self,\n        name: &str,\n        args: Vec<Value>,\n        line: usize,\n    ) -> HaversResult<Value> {\n        match name {\n            // gaun(list, func) - map function over list\n            \"__builtin_gaun__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"gaun\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"gaun() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                let mut result = Vec::new();\n                for item in list {\n                    let mapped = self.call_value(func.clone(), vec![item], line)?;\n                    result.push(mapped);\n                }\n                Ok(Value::List(Rc::new(RefCell::new(result))))\n            }\n\n            // sieve(list, func) - filter list by predicate\n            \"__builtin_sieve__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"sieve\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"sieve() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                let mut result = Vec::new();\n                for item in list {\n                    let keep = self.call_value(func.clone(), vec![item.clone()], line)?;\n                    if keep.is_truthy() {\n                        result.push(item);\n                    }\n                }\n                Ok(Value::List(Rc::new(RefCell::new(result))))\n            }\n\n            // tumble(list, initial, func) - reduce/fold\n            \"__builtin_tumble__\" => {\n                if args.len() != 3 {\n                    return Err(HaversError::WrongArity {\n                        name: \"tumble\".to_string(),\n                        expected: 3,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"tumble() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let mut acc = args[1].clone();\n                let func = args[2].clone();\n                for item in list {\n                    acc = self.call_value(func.clone(), vec![acc, item], line)?;\n                }\n                Ok(acc)\n            }\n\n            // ilk(list, func) - for each (side effects)\n            \"__builtin_ilk__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"ilk\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"ilk() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                for item in list {\n                    self.call_value(func.clone(), vec![item], line)?;\n                }\n                Ok(Value::Nil)\n            }\n\n            // hunt(list, func) - find first matching element\n            \"__builtin_hunt__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"hunt\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"hunt() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                for item in list {\n                    let matches = self.call_value(func.clone(), vec![item.clone()], line)?;\n                    if matches.is_truthy() {\n                        return Ok(item);\n                    }\n                }\n                Ok(Value::Nil)\n            }\n\n            // ony(list, func) - check if any element matches\n            \"__builtin_ony__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"ony\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"ony() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                for item in list {\n                    let matches = self.call_value(func.clone(), vec![item], line)?;\n                    if matches.is_truthy() {\n                        return Ok(Value::Bool(true));\n                    }\n                }\n                Ok(Value::Bool(false))\n            }\n\n            // aw(list, func) - check if all elements match\n            \"__builtin_aw__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"aw\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"aw() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                for item in list {\n                    let matches = self.call_value(func.clone(), vec![item], line)?;\n                    if !matches.is_truthy() {\n                        return Ok(Value::Bool(false));\n                    }\n                }\n                Ok(Value::Bool(true))\n            }\n\n            // grup_up(list, func) - group elements by function result\n            \"__builtin_grup_up__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"grup_up\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"grup_up() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                // Result is a dict where keys are the function results, values are lists\n                let result = Rc::new(RefCell::new(std::collections::HashMap::new()));\n                for item in list {\n                    let key = self.call_value(func.clone(), vec![item.clone()], line)?;\n                    let key_str = format!(\"{}\", key);\n                    let mut dict = result.borrow_mut();\n                    let group = dict\n                        .entry(key_str)\n                        .or_insert_with(|| Value::List(Rc::new(RefCell::new(Vec::new()))));\n                    if let Value::List(l) = group {\n                        l.borrow_mut().push(item);\n                    }\n                }\n                Ok(Value::Dict(result))\n            }\n\n            // pairt_by(list, func) - partition into [matches, non_matches]\n            \"__builtin_pairt_by__\" => {\n                if args.len() != 2 {\n                    return Err(HaversError::WrongArity {\n                        name: \"pairt_by\".to_string(),\n                        expected: 2,\n                        got: args.len(),\n                        line,\n                    });\n                }\n                let list = match &args[0] {\n                    Value::List(l) => l.borrow().clone(),\n                    _ => {\n                        return Err(HaversError::TypeError {\n                            message: \"pairt_by() expects a list as first argument\".to_string(),\n                            line,\n                        })\n                    }\n                };\n                let func = args[1].clone();\n                let mut matches = Vec::new();\n                let mut non_matches = Vec::new();\n                for item in list {\n                    let result = self.call_value(func.clone(), vec![item.clone()], line)?;\n                    if result.is_truthy() {\n                        matches.push(item);\n                    } else {\n                        non_matches.push(item);\n                    }\n                }\n                Ok(Value::List(Rc::new(RefCell::new(vec![\n                    Value::List(Rc::new(RefCell::new(matches))),\n                    Value::List(Rc::new(RefCell::new(non_matches))),\n                ]))))\n            }\n\n            _ => Err(HaversError::NotCallable {\n                name: name.to_string(),\n                line,\n            }),\n        }\n    }\n\n    fn call_function(\n        &mut self,\n        func: &HaversFunction,\n        args: Vec<Value>,\n        line: usize,\n    ) -> HaversResult<Value> {\n        let min_arity = func.min_arity();\n        let max_arity = func.max_arity();\n\n        // Check arity: need at least min_arity, but no more than max_arity\n        if args.len() < min_arity || args.len() > max_arity {\n            if min_arity == max_arity {\n                return Err(HaversError::WrongArity {\n                    name: func.name.clone(),\n                    expected: max_arity,\n                    got: args.len(),\n                    line,\n                });\n            } else {\n                return Err(HaversError::TypeError {\n                    message: format!(\n                        \"Function '{}' expects {} tae {} arguments but ye gave it {}\",\n                        func.name,\n                        min_arity,\n                        max_arity,\n                        args.len()\n                    ),\n                    line,\n                });\n            }\n        }\n\n        let env = Rc::new(RefCell::new(Environment::with_enclosing(\n            func.closure.clone().unwrap_or(self.globals.clone()),\n        )));\n\n        self.call_function_with_env(func, args, env, line)\n    }\n\n    fn call_function_with_env(\n        &mut self,\n        func: &HaversFunction,\n        args: Vec<Value>,\n        env: Rc<RefCell<Environment>>,\n        line: usize,\n    ) -> HaversResult<Value> {\n        // Push stack frame for crash reporting\n        push_stack_frame(&func.name, line);\n\n        // Set up closure environment fer evaluating default values\n        let old_env = self.environment.clone();\n        self.environment = env.clone();\n\n        // Bind parameters, using defaults where nae argument was provided\n        for (i, param) in func.params.iter().enumerate() {\n            let value = if i < args.len() {\n                args[i].clone()\n            } else if let Some(default_expr) = &param.default {\n                // Evaluate the default value in the function's closure\n                self.evaluate(default_expr)?\n            } else {\n                // This shouldnae happen if arity checking worked\n                Value::Nil\n            };\n            env.borrow_mut().define(param.name.clone(), value);\n        }\n\n        // Restore the environment\n        self.environment = old_env;\n\n        let result = match self.execute_block(&func.body, Some(env))? {\n            Ok(v) => Ok(v),\n            Err(ControlFlow::Return(v)) => Ok(v),\n            Err(ControlFlow::Break) => Ok(Value::Nil),\n            Err(ControlFlow::Continue) => Ok(Value::Nil),\n        };\n\n        // Pop stack frame\n        pop_stack_frame();\n\n        result\n    }\n}\n\nimpl Default for Interpreter {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// ========================================\n// JSON Helper Functions\n// ========================================\n\n/// Parse a JSON string into a mdhavers Value\nfn parse_json_value(s: &str) -> Result<Value, String> {\n    let s = s.trim();\n    if s.is_empty() {\n        return Err(\"Empty JSON string\".to_string());\n    }\n\n    let chars: Vec<char> = s.chars().collect();\n    let mut pos = 0;\n    parse_json_inner(&chars, &mut pos)\n}\n\nfn skip_json_whitespace(chars: &[char], pos: &mut usize) {\n    while *pos < chars.len() && chars[*pos].is_whitespace() {\n        *pos += 1;\n    }\n}\n\nfn parse_json_inner(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    skip_json_whitespace(chars, pos);\n    if *pos >= chars.len() {\n        return Err(\"Unexpected end of JSON\".to_string());\n    }\n\n    match chars[*pos] {\n        '{' => parse_json_object(chars, pos),\n        '[' => parse_json_array(chars, pos),\n        '\"' => parse_json_string(chars, pos),\n        't' => parse_json_true(chars, pos),\n        'f' => parse_json_false(chars, pos),\n        'n' => parse_json_null(chars, pos),\n        c if c == '-' || c.is_ascii_digit() => parse_json_number(chars, pos),\n        c => Err(format!(\"Unexpected character '{}' in JSON\", c)),\n    }\n}\n\nfn parse_json_object(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    *pos += 1; // skip '{'\n    skip_json_whitespace(chars, pos);\n\n    let map: HashMap<String, Value> = HashMap::new();\n    let dict = Rc::new(RefCell::new(map));\n\n    if *pos < chars.len() && chars[*pos] == '}' {\n        *pos += 1;\n        return Ok(Value::Dict(dict));\n    }\n\n    loop {\n        skip_json_whitespace(chars, pos);\n\n        // Parse key\n        if *pos >= chars.len() || chars[*pos] != '\"' {\n            return Err(\"Expected string key in JSON object\".to_string());\n        }\n        let key = parse_json_string(chars, pos)?;\n        let key = if let Value::String(s) = key {\n            s\n        } else {\n            return Err(\"Invalid key\".to_string());\n        };\n\n        skip_json_whitespace(chars, pos);\n\n        // Expect ':'\n        if *pos >= chars.len() || chars[*pos] != ':' {\n            return Err(\"Expected ':' in JSON object\".to_string());\n        }\n        *pos += 1;\n\n        // Parse value\n        let value = parse_json_inner(chars, pos)?;\n        dict.borrow_mut().insert(key, value);\n\n        skip_json_whitespace(chars, pos);\n\n        if *pos >= chars.len() {\n            return Err(\"Unterminated JSON object\".to_string());\n        }\n\n        match chars[*pos] {\n            '}' => {\n                *pos += 1;\n                break;\n            }\n            ',' => {\n                *pos += 1;\n            }\n            c => return Err(format!(\"Expected '}}' or ',' in JSON object, got '{}'\", c)),\n        }\n    }\n\n    Ok(Value::Dict(dict))\n}\n\nfn parse_json_array(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    *pos += 1; // skip '['\n    skip_json_whitespace(chars, pos);\n\n    let items: Vec<Value> = Vec::new();\n    let list = Rc::new(RefCell::new(items));\n\n    if *pos < chars.len() && chars[*pos] == ']' {\n        *pos += 1;\n        return Ok(Value::List(list));\n    }\n\n    loop {\n        let value = parse_json_inner(chars, pos)?;\n        list.borrow_mut().push(value);\n\n        skip_json_whitespace(chars, pos);\n\n        if *pos >= chars.len() {\n            return Err(\"Unterminated JSON array\".to_string());\n        }\n\n        match chars[*pos] {\n            ']' => {\n                *pos += 1;\n                break;\n            }\n            ',' => {\n                *pos += 1;\n            }\n            c => return Err(format!(\"Expected ']' or ',' in JSON array, got '{}'\", c)),\n        }\n    }\n\n    Ok(Value::List(list))\n}\n\nfn parse_json_string(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    *pos += 1; // skip opening '\"'\n    let mut result = String::new();\n\n    while *pos < chars.len() {\n        let c = chars[*pos];\n        if c == '\"' {\n            *pos += 1;\n            return Ok(Value::String(result));\n        }\n        if c == '\\\\' {\n            *pos += 1;\n            if *pos >= chars.len() {\n                return Err(\"Unterminated string escape\".to_string());\n            }\n            let escaped = chars[*pos];\n            match escaped {\n                'n' => result.push('\\n'),\n                't' => result.push('\\t'),\n                'r' => result.push('\\r'),\n                '\"' => result.push('\"'),\n                '\\\\' => result.push('\\\\'),\n                '/' => result.push('/'),\n                'u' => {\n                    // Unicode escape \\uXXXX\n                    if *pos + 4 >= chars.len() {\n                        return Err(\"Invalid unicode escape\".to_string());\n                    }\n                    let hex: String = chars[*pos + 1..*pos + 5].iter().collect();\n                    if let Ok(code) = u32::from_str_radix(&hex, 16) {\n                        if let Some(ch) = char::from_u32(code) {\n                            result.push(ch);\n                        }\n                    }\n                    *pos += 4;\n                }\n                _ => result.push(escaped),\n            }\n        } else {\n            result.push(c);\n        }\n        *pos += 1;\n    }\n\n    Err(\"Unterminated JSON string\".to_string())\n}\n\nfn parse_json_number(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    let start = *pos;\n    let mut has_dot = false;\n    let mut has_exp = false;\n\n    if *pos < chars.len() && chars[*pos] == '-' {\n        *pos += 1;\n    }\n\n    while *pos < chars.len() {\n        let c = chars[*pos];\n        if c.is_ascii_digit() {\n            *pos += 1;\n        } else if c == '.' && !has_dot && !has_exp {\n            has_dot = true;\n            *pos += 1;\n        } else if (c == 'e' || c == 'E') && !has_exp {\n            has_exp = true;\n            *pos += 1;\n            if *pos < chars.len() && (chars[*pos] == '+' || chars[*pos] == '-') {\n                *pos += 1;\n            }\n        } else {\n            break;\n        }\n    }\n\n    let num_str: String = chars[start..*pos].iter().collect();\n\n    if has_dot || has_exp {\n        num_str\n            .parse::<f64>()\n            .map(Value::Float)\n            .map_err(|_| format!(\"Invalid number: {}\", num_str))\n    } else {\n        num_str\n            .parse::<i64>()\n            .map(Value::Integer)\n            .map_err(|_| format!(\"Invalid integer: {}\", num_str))\n    }\n}\n\nfn parse_json_true(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    if *pos + 4 <= chars.len() && chars[*pos..*pos + 4].iter().collect::<String>() == \"true\" {\n        *pos += 4;\n        Ok(Value::Bool(true))\n    } else {\n        Err(\"Invalid JSON value 'true'\".to_string())\n    }\n}\n\nfn parse_json_false(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    if *pos + 5 <= chars.len() && chars[*pos..*pos + 5].iter().collect::<String>() == \"false\" {\n        *pos += 5;\n        Ok(Value::Bool(false))\n    } else {\n        Err(\"Invalid JSON value 'false'\".to_string())\n    }\n}\n\nfn parse_json_null(chars: &[char], pos: &mut usize) -> Result<Value, String> {\n    if *pos + 4 <= chars.len() && chars[*pos..*pos + 4].iter().collect::<String>() == \"null\" {\n        *pos += 4;\n        Ok(Value::Nil)\n    } else {\n        Err(\"Invalid JSON value 'null'\".to_string())\n    }\n}\n\n/// Convert a mdhavers Value to a JSON string\nfn value_to_json(value: &Value) -> String {\n    match value {\n        Value::Nil => \"null\".to_string(),\n        Value::Bool(true) => \"true\".to_string(),\n        Value::Bool(false) => \"false\".to_string(),\n        Value::Integer(n) => n.to_string(),\n        Value::Float(f) => {\n            if f.is_nan() || f.is_infinite() {\n                \"null\".to_string()\n            } else {\n                f.to_string()\n            }\n        }\n        Value::String(s) => json_escape_string(s),\n        Value::List(l) => {\n            let items: Vec<String> = l.borrow().iter().map(value_to_json).collect();\n            format!(\"[{}]\", items.join(\", \"))\n        }\n        Value::Dict(d) => {\n            let pairs: Vec<String> = d\n                .borrow()\n                .iter()\n                .map(|(k, v)| format!(\"{}: {}\", json_escape_string(k), value_to_json(v)))\n                .collect();\n            format!(\"{{{}}}\", pairs.join(\", \"))\n        }\n        _ => format!(\"\\\"{}\\\"\", format!(\"{}\", value).replace('\\\"', \"\\\\\\\"\")),\n    }\n}\n\n/// Convert a mdhavers Value to a pretty-printed JSON string\nfn value_to_json_pretty(value: &Value, indent: usize) -> String {\n    let ws = \"  \".repeat(indent);\n    let ws_inner = \"  \".repeat(indent + 1);\n\n    match value {\n        Value::Nil => \"null\".to_string(),\n        Value::Bool(true) => \"true\".to_string(),\n        Value::Bool(false) => \"false\".to_string(),\n        Value::Integer(n) => n.to_string(),\n        Value::Float(f) => {\n            if f.is_nan() || f.is_infinite() {\n                \"null\".to_string()\n            } else {\n                f.to_string()\n            }\n        }\n        Value::String(s) => json_escape_string(s),\n        Value::List(l) => {\n            let items = l.borrow();\n            if items.is_empty() {\n                \"[]\".to_string()\n            } else {\n                let formatted: Vec<String> = items\n                    .iter()\n                    .map(|v| format!(\"{}{}\", ws_inner, value_to_json_pretty(v, indent + 1)))\n                    .collect();\n                format!(\"[\\n{}\\n{}]\", formatted.join(\",\\n\"), ws)\n            }\n        }\n        Value::Dict(d) => {\n            let dict = d.borrow();\n            if dict.is_empty() {\n                \"{}\".to_string()\n            } else {\n                let formatted: Vec<String> = dict\n                    .iter()\n                    .map(|(k, v)| {\n                        format!(\n                            \"{}{}: {}\",\n                            ws_inner,\n                            json_escape_string(k),\n                            value_to_json_pretty(v, indent + 1)\n                        )\n                    })\n                    .collect();\n                format!(\"{{\\n{}\\n{}}}\", formatted.join(\",\\n\"), ws)\n            }\n        }\n        _ => format!(\"\\\"{}\\\"\", format!(\"{}\", value).replace('\\\"', \"\\\\\\\"\")),\n    }\n}\n\n/// Escape a string for JSON output\nfn json_escape_string(s: &str) -> String {\n    let mut result = String::from(\"\\\"\");\n    for c in s.chars() {\n        match c {\n            '\"' => result.push_str(\"\\\\\\\"\"),\n            '\\\\' => result.push_str(\"\\\\\\\\\"),\n            '\\n' => result.push_str(\"\\\\n\"),\n            '\\t' => result.push_str(\"\\\\t\"),\n            '\\r' => result.push_str(\"\\\\r\"),\n            c if c.is_control() => {\n                result.push_str(&format!(\"\\\\u{:04x}\", c as u32));\n            }\n            c => result.push(c),\n        }\n    }\n    result.push('\"');\n    result\n}\n\n#[cfg(test)]\n#[allow(clippy::approx_constant)]\n#[allow(clippy::manual_range_contains)]\nmod tests {\n    use super::*;\n    use crate::parser::parse;\n\n    fn run(source: &str) -> HaversResult<Value> {\n        let program = parse(source)?;\n        let mut interp = Interpreter::new();\n        interp.interpret(&program)\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        assert_eq!(run(\"5 + 3\").unwrap(), Value::Integer(8));\n        assert_eq!(run(\"10 - 4\").unwrap(), Value::Integer(6));\n        assert_eq!(run(\"3 * 4\").unwrap(), Value::Integer(12));\n        assert_eq!(run(\"15 / 3\").unwrap(), Value::Integer(5));\n        assert_eq!(run(\"17 % 5\").unwrap(), Value::Integer(2));\n    }\n\n    #[test]\n    fn test_variables() {\n        assert_eq!(run(\"ken x = 5\\nx\").unwrap(), Value::Integer(5));\n        assert_eq!(run(\"ken x = 5\\nx = 10\\nx\").unwrap(), Value::Integer(10));\n    }\n\n    #[test]\n    fn test_strings() {\n        assert_eq!(\n            run(r#\"\"Hello\" + \" \" + \"World\"\"#).unwrap(),\n            Value::String(\"Hello World\".to_string())\n        );\n        assert_eq!(\n            run(r#\"\"ha\" * 3\"#).unwrap(),\n            Value::String(\"hahaha\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_booleans() {\n        assert_eq!(run(\"aye\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"nae\").unwrap(), Value::Bool(false));\n        assert_eq!(run(\"5 > 3\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"5 < 3\").unwrap(), Value::Bool(false));\n    }\n\n    #[test]\n    fn test_if_statement() {\n        let result = run(r#\"\nken x = 10\nken result = 0\ngin x > 5 {\n    result = 1\n} ither {\n    result = 2\n}\nresult\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_while_loop() {\n        let result = run(r#\"\nken sum = 0\nken i = 1\nwhiles i <= 5 {\n    sum = sum + i\n    i = i + 1\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(15));\n    }\n\n    #[test]\n    fn test_for_loop() {\n        let result = run(r#\"\nken sum = 0\nfer i in 1..6 {\n    sum = sum + i\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(15));\n    }\n\n    #[test]\n    fn test_function() {\n        let result = run(r#\"\ndae add(a, b) {\n    gie a + b\n}\nadd(3, 4)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(7));\n    }\n\n    #[test]\n    fn test_recursion() {\n        let result = run(r#\"\ndae factorial(n) {\n    gin n <= 1 {\n        gie 1\n    }\n    gie n * factorial(n - 1)\n}\nfactorial(5)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(120));\n    }\n\n    #[test]\n    fn test_list() {\n        let result = run(r#\"\nken arr = [1, 2, 3]\narr[1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dict() {\n        let result = run(r#\"\nken d = {\"a\": 1, \"b\": 2}\nd[\"a\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_native_functions() {\n        assert_eq!(run(\"len([1, 2, 3])\").unwrap(), Value::Integer(3));\n        assert_eq!(run(r#\"len(\"hello\")\"#).unwrap(), Value::Integer(5));\n    }\n\n    #[test]\n    fn test_division_by_zero() {\n        assert!(run(\"5 / 0\").is_err());\n    }\n\n    #[test]\n    fn test_undefined_variable() {\n        assert!(run(\"undefined_var\").is_err());\n    }\n\n    #[test]\n    fn test_lambda() {\n        // Basic lambda\n        assert_eq!(\n            run(\"ken double = |x| x * 2\\ndouble(5)\").unwrap(),\n            Value::Integer(10)\n        );\n        // Lambda with multiple params\n        assert_eq!(\n            run(\"ken add = |a, b| a + b\\nadd(3, 4)\").unwrap(),\n            Value::Integer(7)\n        );\n        // No-param lambda\n        assert_eq!(\n            run(\"ken always_five = || 5\\nalways_five()\").unwrap(),\n            Value::Integer(5)\n        );\n    }\n\n    #[test]\n    fn test_gaun_map() {\n        let result = run(\"ken nums = [1, 2, 3]\\ngaun(nums, |x| x * 2)\").unwrap();\n        if let Value::List(list) = result {\n            let items = list.borrow();\n            assert_eq!(items.len(), 3);\n            assert_eq!(items[0], Value::Integer(2));\n            assert_eq!(items[1], Value::Integer(4));\n            assert_eq!(items[2], Value::Integer(6));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_sieve_filter() {\n        let result = run(\"ken nums = [1, 2, 3, 4, 5]\\nsieve(nums, |x| x % 2 == 0)\").unwrap();\n        if let Value::List(list) = result {\n            let items = list.borrow();\n            assert_eq!(items.len(), 2);\n            assert_eq!(items[0], Value::Integer(2));\n            assert_eq!(items[1], Value::Integer(4));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_tumble_reduce() {\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3, 4, 5]\\ntumble(nums, 0, |acc, x| acc + x)\").unwrap(),\n            Value::Integer(15)\n        );\n    }\n\n    #[test]\n    fn test_ony_any() {\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3]\\nony(nums, |x| x > 2)\").unwrap(),\n            Value::Bool(true)\n        );\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3]\\nony(nums, |x| x > 10)\").unwrap(),\n            Value::Bool(false)\n        );\n    }\n\n    #[test]\n    fn test_aw_all() {\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3]\\naw(nums, |x| x > 0)\").unwrap(),\n            Value::Bool(true)\n        );\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3]\\naw(nums, |x| x > 1)\").unwrap(),\n            Value::Bool(false)\n        );\n    }\n\n    #[test]\n    fn test_hunt_find() {\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3, 4, 5]\\nhunt(nums, |x| x > 3)\").unwrap(),\n            Value::Integer(4)\n        );\n        assert_eq!(\n            run(\"ken nums = [1, 2, 3]\\nhunt(nums, |x| x > 10)\").unwrap(),\n            Value::Nil\n        );\n    }\n\n    #[test]\n    fn test_pattern_matching() {\n        let result = run(r#\"\nken x = 2\nken result = naething\nkeek x {\n    whan 1 -> result = \"one\"\n    whan 2 -> result = \"two\"\n    whan _ -> result = \"other\"\n}\nresult\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"two\".to_string()));\n    }\n\n    #[test]\n    fn test_ternary_expression() {\n        // Basic ternary - used in expression context\n        assert_eq!(\n            run(\"ken x = gin 5 > 3 than 1 ither 0\\nx\").unwrap(),\n            Value::Integer(1)\n        );\n        assert_eq!(\n            run(\"ken x = gin 5 < 3 than 1 ither 0\\nx\").unwrap(),\n            Value::Integer(0)\n        );\n        // With strings\n        assert_eq!(\n            run(r#\"ken x = gin aye than \"yes\" ither \"no\"\nx\"#)\n            .unwrap(),\n            Value::String(\"yes\".to_string())\n        );\n        // Nested ternary\n        assert_eq!(\n            run(\"ken x = 5\nken result = gin x > 10 than 1 ither gin x > 3 than 2 ither 3\nresult\")\n            .unwrap(),\n            Value::Integer(2)\n        );\n    }\n\n    #[test]\n    fn test_slice_list() {\n        // Basic slicing\n        let result = run(\"ken x = [0, 1, 2, 3, 4]\\nx[1:3]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 2);\n            assert_eq!(list[0], Value::Integer(1));\n            assert_eq!(list[1], Value::Integer(2));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // Slice to end\n        let result = run(\"ken x = [0, 1, 2, 3, 4]\\nx[3:]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 2);\n            assert_eq!(list[0], Value::Integer(3));\n            assert_eq!(list[1], Value::Integer(4));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // Slice from start\n        let result = run(\"ken x = [0, 1, 2, 3, 4]\\nx[:2]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 2);\n            assert_eq!(list[0], Value::Integer(0));\n            assert_eq!(list[1], Value::Integer(1));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_slice_string() {\n        assert_eq!(\n            run(\"ken s = \\\"Hello\\\"\\ns[0:2]\").unwrap(),\n            Value::String(\"He\".to_string())\n        );\n        assert_eq!(\n            run(\"ken s = \\\"Hello\\\"\\ns[3:]\").unwrap(),\n            Value::String(\"lo\".to_string())\n        );\n        assert_eq!(\n            run(\"ken s = \\\"Hello\\\"\\ns[:3]\").unwrap(),\n            Value::String(\"Hel\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_slice_negative() {\n        // Negative indices\n        let result = run(\"ken x = [0, 1, 2, 3, 4]\\nx[-2:]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 2);\n            assert_eq!(list[0], Value::Integer(3));\n            assert_eq!(list[1], Value::Integer(4));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_slice_step() {\n        // Every second element\n        let result = run(\"ken x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\nx[::2]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 5);\n            assert_eq!(list[0], Value::Integer(0));\n            assert_eq!(list[1], Value::Integer(2));\n            assert_eq!(list[4], Value::Integer(8));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // Every third element from 1 to 8\n        let result = run(\"ken x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\nx[1:8:3]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 3); // 1, 4, 7\n            assert_eq!(list[0], Value::Integer(1));\n            assert_eq!(list[1], Value::Integer(4));\n            assert_eq!(list[2], Value::Integer(7));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // Reverse a list with negative step\n        let result = run(\"ken x = [0, 1, 2, 3, 4]\\nx[::-1]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 5);\n            assert_eq!(list[0], Value::Integer(4));\n            assert_eq!(list[4], Value::Integer(0));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // String with step\n        let result = run(\"ken s = \\\"Hello\\\"\\ns[::2]\").unwrap();\n        assert_eq!(result, Value::String(\"Hlo\".to_string())); // H, l, o\n\n        // String reversed\n        let result = run(\"ken s = \\\"Hello\\\"\\ns[::-1]\").unwrap();\n        assert_eq!(result, Value::String(\"olleH\".to_string()));\n    }\n\n    #[test]\n    fn test_new_list_functions() {\n        // uniq\n        let result = run(\"uniq([1, 2, 2, 3, 3, 3])\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // redd_up\n        let result = run(\"redd_up([1, naething, 2, naething, 3])\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_new_string_functions() {\n        // capitalize\n        assert_eq!(\n            run(r#\"capitalize(\"hello\")\"#).unwrap(),\n            Value::String(\"Hello\".to_string())\n        );\n\n        // title\n        assert_eq!(\n            run(r#\"title(\"hello world\")\"#).unwrap(),\n            Value::String(\"Hello World\".to_string())\n        );\n\n        // words\n        let result = run(r#\"words(\"one two three\")\"#).unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // ord and chr\n        assert_eq!(run(r#\"ord(\"A\")\"#).unwrap(), Value::Integer(65));\n        assert_eq!(run(\"chr(65)\").unwrap(), Value::String(\"A\".to_string()));\n    }\n\n    #[test]\n    fn test_creel_set() {\n        // Create a set from a list\n        let result = run(\"creel([1, 2, 2, 3, 3, 3])\").unwrap();\n        if let Value::Set(set) = result {\n            let set = set.borrow();\n            assert_eq!(set.len(), 3); // Duplicates removed\n        } else {\n            panic!(\"Expected creel\");\n        }\n\n        // Create empty set\n        let result = run(\"empty_creel()\").unwrap();\n        if let Value::Set(set) = result {\n            assert!(set.borrow().is_empty());\n        } else {\n            panic!(\"Expected empty creel\");\n        }\n\n        // Check membership\n        let result = run(r#\"\n            ken s = creel([\"apple\", \"banana\", \"cherry\"])\n            is_in_creel(s, \"banana\")\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n\n        let result = run(r#\"\n            ken s = creel([\"apple\", \"banana\", \"cherry\"])\n            is_in_creel(s, \"mango\")\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(false));\n\n        // Union\n        let result = run(r#\"\n            ken a = creel([1, 2, 3])\n            ken b = creel([3, 4, 5])\n            len(creels_thegither(a, b))\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(5)); // 1, 2, 3, 4, 5\n\n        // Intersection\n        let result = run(r#\"\n            ken a = creel([1, 2, 3])\n            ken b = creel([2, 3, 4])\n            len(creels_baith(a, b))\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2)); // 2, 3\n\n        // Difference\n        let result = run(r#\"\n            ken a = creel([1, 2, 3])\n            ken b = creel([2, 3, 4])\n            len(creels_differ(a, b))\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1)); // just 1\n\n        // Subset\n        let result = run(r#\"\n            ken a = creel([1, 2])\n            ken b = creel([1, 2, 3])\n            is_subset(a, b)\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n\n        // Convert to list\n        let result = run(r#\"\n            ken s = creel([3, 1, 2])\n            creel_tae_list(s)\n        \"#)\n        .unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 3);\n            // Should be sorted\n            assert_eq!(list[0], Value::String(\"1\".to_string()));\n            assert_eq!(list[1], Value::String(\"2\".to_string()));\n            assert_eq!(list[2], Value::String(\"3\".to_string()));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_classes() {\n        // Basic class creation and instantiation\n        let result = run(r#\"\nkin Dug {\n    dae init(name) {\n        masel.name = name\n    }\n    dae bark() {\n        gie \"Woof! Ah'm \" + masel.name\n    }\n}\nken fido = Dug(\"Fido\")\nfido.bark()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Woof! Ah'm Fido\".to_string()));\n    }\n\n    #[test]\n    fn test_inheritance() {\n        let result = run(r#\"\nkin Animal {\n    dae init(name) {\n        masel.name = name\n    }\n    dae speak() {\n        gie \"...\"\n    }\n}\nkin Dug fae Animal {\n    dae speak() {\n        gie \"Woof!\"\n    }\n}\nken d = Dug(\"Rex\")\nd.speak()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Woof!\".to_string()));\n    }\n\n    #[test]\n    fn test_try_catch() {\n        // Try-catch basic - using Scots keywords!\n        let result = run(r#\"\nken result = \"untouched\"\nhae_a_bash {\n    result = 1 / 0\n} gin_it_gangs_wrang e {\n    result = \"caught\"\n}\nresult\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"caught\".to_string()));\n    }\n\n    #[test]\n    fn test_destructuring() {\n        // Basic destructuring\n        let result = run(r#\"\nken [a, b, c] = [1, 2, 3]\nb\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n\n        // Rest destructuring\n        let result = run(r#\"\nken [first, ...rest] = [1, 2, 3, 4]\nlen(rest)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_default_params() {\n        let result = run(r#\"\ndae greet(name, greeting = \"Hullo\") {\n    gie greeting + \", \" + name + \"!\"\n}\ngreet(\"Hamish\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Hullo, Hamish!\".to_string()));\n\n        let result = run(r#\"\ndae greet(name, greeting = \"Hullo\") {\n    gie greeting + \", \" + name + \"!\"\n}\ngreet(\"Hamish\", \"Guid day\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Guid day, Hamish!\".to_string()));\n    }\n\n    #[test]\n    fn test_fstring() {\n        let result = run(r#\"\nken name = \"Scotland\"\nf\"Hello, {name}!\"\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Hello, Scotland!\".to_string()));\n\n        // F-string with expression\n        let result = run(r#\"\nken x = 5\nf\"The answer is {x * 2}\"\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"The answer is 10\".to_string()));\n    }\n\n    #[test]\n    fn test_scots_vocabulary_functions() {\n        // Test crabbit (negative check)\n        assert_eq!(run(\"crabbit(-5)\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"crabbit(5)\").unwrap(), Value::Bool(false));\n\n        // Test glaikit (empty/invalid check)\n        assert_eq!(run(\"glaikit(\\\"\\\")\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"glaikit(0)\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"glaikit(42)\").unwrap(), Value::Bool(false));\n\n        // Test roar (uppercase shout)\n        assert_eq!(\n            run(r#\"roar(\"hello\")\"#).unwrap(),\n            Value::String(\"HELLO!\".to_string())\n        );\n\n        // Test wrang_sort (type check)\n        assert_eq!(\n            run(r#\"wrang_sort(42, \"integer\")\"#).unwrap(),\n            Value::Bool(false) // Not wrong - 42 IS an integer\n        );\n        assert_eq!(\n            run(r#\"wrang_sort(42, \"string\")\"#).unwrap(),\n            Value::Bool(true) // Wrong - 42 is NOT a string\n        );\n    }\n\n    #[test]\n    fn test_new_scots_functions() {\n        // blether_format\n        assert_eq!(\n            run(r#\"blether_format(\"Hullo {name}!\", {\"name\": \"Hamish\"})\"#).unwrap(),\n            Value::String(\"Hullo Hamish!\".to_string())\n        );\n\n        // ceilidh (interleave)\n        let result = run(\"ceilidh([1, 2], [3, 4])\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 4);\n            assert_eq!(list[0], Value::Integer(1));\n            assert_eq!(list[1], Value::Integer(3));\n            assert_eq!(list[2], Value::Integer(2));\n            assert_eq!(list[3], Value::Integer(4));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // birl (rotate)\n        let result = run(\"birl([1, 2, 3, 4, 5], 2)\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list[0], Value::Integer(3));\n            assert_eq!(list[4], Value::Integer(2));\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        // clype (debug info)\n        let result = run(\"clype([1, 2, 3])\").unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"list\"));\n            assert!(s.contains(\"3 items\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n\n        // sclaff (flatten)\n        let result = run(\"sclaff([[1, 2], [3, [4, 5]]])\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 5); // Fully flattened\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_trace_mode() {\n        // Test that trace mode can be set without breaking execution\n        let mut interp = Interpreter::new();\n\n        // Set trace mode\n        interp.set_trace_mode(TraceMode::Off);\n        assert_eq!(interp.trace_mode(), TraceMode::Off);\n\n        interp.set_trace_mode(TraceMode::Statements);\n        assert_eq!(interp.trace_mode(), TraceMode::Statements);\n\n        interp.set_trace_mode(TraceMode::Verbose);\n        assert_eq!(interp.trace_mode(), TraceMode::Verbose);\n\n        // Code should still execute correctly with trace on\n        interp.set_trace_mode(TraceMode::Off); // Turn off to avoid stderr output\n        let program = crate::parser::parse(\"ken x = 42\\ngin x > 10 { x = x * 2 }\\nx\").unwrap();\n        let result = interp.interpret(&program).unwrap();\n        assert_eq!(result, Value::Integer(84));\n    }\n\n    #[test]\n    fn test_get_user_variables() {\n        let mut interp = Interpreter::new();\n        let program = crate::parser::parse(\"ken x = 42\\nken name = \\\"Hamish\\\"\").unwrap();\n        interp.interpret(&program).unwrap();\n\n        let vars = interp.get_user_variables();\n\n        // Should have x and name (and possibly prelude functions if loaded)\n        let x_var = vars.iter().find(|(n, _, _)| n == \"x\");\n        assert!(x_var.is_some());\n        assert_eq!(x_var.unwrap().1, \"integer\");\n\n        let name_var = vars.iter().find(|(n, _, _)| n == \"name\");\n        assert!(name_var.is_some());\n        assert_eq!(name_var.unwrap().1, \"string\");\n    }\n\n    #[test]\n    fn test_timing_functions() {\n        // noo() returns a timestamp\n        let result = run(\"noo()\").unwrap();\n        if let Value::Integer(ts) = result {\n            assert!(ts > 0); // Should be a positive timestamp\n        } else {\n            panic!(\"Expected integer timestamp\");\n        }\n\n        // tick() returns high-precision timestamp\n        let result = run(\"tick()\").unwrap();\n        if let Value::Integer(ts) = result {\n            assert!(ts > 0);\n        } else {\n            panic!(\"Expected integer timestamp\");\n        }\n\n        // Time difference works\n        let result = run(r#\"\n            ken start = noo()\n            ken finish = noo()\n            finish >= start\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    // ==================== Native Function Edge Cases ====================\n\n    #[test]\n    fn test_len_dict() {\n        assert_eq!(run(r#\"len({\"a\": 1, \"b\": 2})\"#).unwrap(), Value::Integer(2));\n    }\n\n    #[test]\n    fn test_len_set() {\n        assert_eq!(run(\"len(creel([1, 2, 3]))\").unwrap(), Value::Integer(3));\n    }\n\n    #[test]\n    fn test_len_error() {\n        assert!(run(\"len(42)\").is_err());\n    }\n\n    #[test]\n    fn test_tae_int_from_int() {\n        assert_eq!(run(\"tae_int(42)\").unwrap(), Value::Integer(42));\n    }\n\n    #[test]\n    fn test_tae_int_from_float() {\n        assert_eq!(run(\"tae_int(3.7)\").unwrap(), Value::Integer(3));\n    }\n\n    #[test]\n    fn test_tae_int_from_string() {\n        assert_eq!(run(\"tae_int(\\\"123\\\")\").unwrap(), Value::Integer(123));\n    }\n\n    #[test]\n    fn test_tae_int_from_bool() {\n        assert_eq!(run(\"tae_int(aye)\").unwrap(), Value::Integer(1));\n        assert_eq!(run(\"tae_int(nae)\").unwrap(), Value::Integer(0));\n    }\n\n    #[test]\n    fn test_tae_int_error() {\n        assert!(run(\"tae_int(\\\"not a number\\\")\").is_err());\n        assert!(run(\"tae_int([1, 2, 3])\").is_err());\n    }\n\n    #[test]\n    fn test_tae_float_from_int() {\n        assert_eq!(run(\"tae_float(42)\").unwrap(), Value::Float(42.0));\n    }\n\n    #[test]\n    fn test_tae_float_from_float() {\n        assert_eq!(run(\"tae_float(3.14)\").unwrap(), Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_tae_float_from_string() {\n        assert_eq!(run(\"tae_float(\\\"3.14\\\")\").unwrap(), Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_tae_float_error() {\n        assert!(run(\"tae_float(\\\"xyz\\\")\").is_err());\n        assert!(run(\"tae_float([1, 2, 3])\").is_err());\n    }\n\n    #[test]\n    fn test_shove_error() {\n        assert!(run(\"shove(42, 1)\").is_err());\n    }\n\n    #[test]\n    fn test_yank_error() {\n        assert!(run(\"yank([])\").is_err());\n        assert!(run(\"yank(42)\").is_err());\n    }\n\n    #[test]\n    fn test_keys_values() {\n        let result = run(r#\"keys({\"a\": 1, \"b\": 2})\"#).unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        let result = run(r#\"values({\"a\": 1, \"b\": 2})\"#).unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_keys_values_error() {\n        assert!(run(\"keys(42)\").is_err());\n        assert!(run(\"values([1, 2])\").is_err());\n    }\n\n    #[test]\n    fn test_abs() {\n        assert_eq!(run(\"abs(-5)\").unwrap(), Value::Integer(5));\n        assert_eq!(run(\"abs(5)\").unwrap(), Value::Integer(5));\n        assert_eq!(run(\"abs(-3.14)\").unwrap(), Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_math_functions() {\n        assert_eq!(run(\"min(1, 5)\").unwrap(), Value::Integer(1));\n        assert_eq!(run(\"max(1, 5)\").unwrap(), Value::Integer(5));\n        assert_eq!(run(\"floor(3.7)\").unwrap(), Value::Integer(3));\n        assert_eq!(run(\"ceil(3.2)\").unwrap(), Value::Integer(4));\n        assert_eq!(run(\"round(3.5)\").unwrap(), Value::Integer(4));\n        assert_eq!(run(\"sqrt(16)\").unwrap(), Value::Float(4.0));\n    }\n\n    #[test]\n    fn test_contains() {\n        assert_eq!(\n            run(r#\"contains(\"hello\", \"ell\")\"#).unwrap(),\n            Value::Bool(true)\n        );\n        assert_eq!(run(\"contains([1, 2, 3], 2)\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"contains([1, 2, 3], 5)\").unwrap(), Value::Bool(false));\n        assert_eq!(\n            run(r#\"contains({\"a\": 1}, \"a\")\"#).unwrap(),\n            Value::Bool(true)\n        );\n    }\n\n    #[test]\n    fn test_reverse() {\n        assert_eq!(\n            run(r#\"reverse(\"hello\")\"#).unwrap(),\n            Value::String(\"olleh\".to_string())\n        );\n        let result = run(\"reverse([1, 2, 3])\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list[0], Value::Integer(3));\n            assert_eq!(list[2], Value::Integer(1));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_sort() {\n        let result = run(\"sort([3, 1, 2])\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list[0], Value::Integer(1));\n            assert_eq!(list[1], Value::Integer(2));\n            assert_eq!(list[2], Value::Integer(3));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_split_join() {\n        let result = run(r#\"split(\"a,b,c\", \",\")\"#).unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        assert_eq!(\n            run(r#\"join([\"a\", \"b\", \"c\"], \"-\")\"#).unwrap(),\n            Value::String(\"a-b-c\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_heid_tail_bum() {\n        assert_eq!(run(\"heid([1, 2, 3])\").unwrap(), Value::Integer(1));\n        assert_eq!(\n            run(r#\"heid(\"hello\")\"#).unwrap(),\n            Value::String(\"h\".to_string())\n        );\n\n        let result = run(\"tail([1, 2, 3])\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n        assert_eq!(\n            run(r#\"tail(\"hello\")\"#).unwrap(),\n            Value::String(\"ello\".to_string())\n        );\n\n        assert_eq!(run(\"bum([1, 2, 3])\").unwrap(), Value::Integer(3));\n        assert_eq!(\n            run(r#\"bum(\"hello\")\"#).unwrap(),\n            Value::String(\"o\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_heid_tail_bum_errors() {\n        assert!(run(\"heid([])\").is_err());\n        assert!(run(\"bum([])\").is_err());\n        assert!(run(\"heid(42)\").is_err());\n    }\n\n    #[test]\n    fn test_scran_slap() {\n        let result = run(\"scran([1, 2, 3, 4], 1, 3)\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        let result = run(\"slap([1, 2], [3, 4])\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 4);\n        } else {\n            panic!(\"Expected list\");\n        }\n\n        assert_eq!(\n            run(r#\"slap(\"hello\", \" world\")\"#).unwrap(),\n            Value::String(\"hello world\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_sumaw_coont() {\n        assert_eq!(run(\"sumaw([1, 2, 3, 4])\").unwrap(), Value::Integer(10));\n        assert_eq!(run(\"coont([1, 2, 2, 3, 2], 2)\").unwrap(), Value::Integer(3));\n        assert_eq!(run(r#\"coont(\"hello\", \"l\")\"#).unwrap(), Value::Integer(2));\n    }\n\n    #[test]\n    fn test_wheesht_upper_lower() {\n        assert_eq!(\n            run(r#\"wheesht(\"  hello  \")\"#).unwrap(),\n            Value::String(\"hello\".to_string())\n        );\n        assert_eq!(\n            run(r#\"upper(\"hello\")\"#).unwrap(),\n            Value::String(\"HELLO\".to_string())\n        );\n        assert_eq!(\n            run(r#\"lower(\"HELLO\")\"#).unwrap(),\n            Value::String(\"hello\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_shuffle() {\n        let result = run(\"len(shuffle([1, 2, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== Arithmetic Edge Cases ====================\n\n    #[test]\n    fn test_float_arithmetic() {\n        assert_eq!(run(\"3.5 + 2.5\").unwrap(), Value::Float(6.0));\n        assert_eq!(run(\"5.0 - 2.0\").unwrap(), Value::Float(3.0));\n        assert_eq!(run(\"2.5 * 4.0\").unwrap(), Value::Float(10.0));\n        assert_eq!(run(\"10.0 / 4.0\").unwrap(), Value::Float(2.5));\n    }\n\n    #[test]\n    fn test_mixed_arithmetic() {\n        assert_eq!(run(\"5 + 2.5\").unwrap(), Value::Float(7.5));\n        assert_eq!(run(\"10.0 / 2\").unwrap(), Value::Float(5.0));\n    }\n\n    #[test]\n    fn test_unary_negate() {\n        assert_eq!(run(\"-5\").unwrap(), Value::Integer(-5));\n        assert_eq!(run(\"-3.14\").unwrap(), Value::Float(-3.14));\n    }\n\n    #[test]\n    fn test_modulo_float() {\n        let result = run(\"7.5 % 2.0\").unwrap();\n        if let Value::Float(f) = result {\n            assert!((f - 1.5).abs() < 0.001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    // ==================== Comparison Operations ====================\n\n    #[test]\n    fn test_string_comparison() {\n        assert_eq!(run(r#\"\"a\" < \"b\"\"#).unwrap(), Value::Bool(true));\n        assert_eq!(run(r#\"\"hello\" == \"hello\"\"#).unwrap(), Value::Bool(true));\n        assert_eq!(run(r#\"\"a\" != \"b\"\"#).unwrap(), Value::Bool(true));\n    }\n\n    #[test]\n    fn test_list_equality() {\n        assert_eq!(run(\"[1, 2, 3] == [1, 2, 3]\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"[1, 2, 3] == [1, 2, 4]\").unwrap(), Value::Bool(false));\n    }\n\n    // ==================== Logical Operations ====================\n\n    #[test]\n    fn test_logical_operations() {\n        assert_eq!(run(\"aye an aye\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"aye an nae\").unwrap(), Value::Bool(false));\n        assert_eq!(run(\"nae or aye\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"nae or nae\").unwrap(), Value::Bool(false));\n    }\n\n    #[test]\n    fn test_logical_not() {\n        assert_eq!(run(\"ken x = aye\\nnae x\").unwrap(), Value::Bool(false));\n        assert_eq!(run(\"ken x = nae\\nnae x\").unwrap(), Value::Bool(true));\n    }\n\n    #[test]\n    fn test_short_circuit_and() {\n        // Should short-circuit and not evaluate second part\n        assert_eq!(run(\"nae an (1/0 > 0)\").unwrap(), Value::Bool(false));\n    }\n\n    #[test]\n    fn test_short_circuit_or() {\n        // Should short-circuit and not evaluate second part\n        assert_eq!(run(\"aye or (1/0 > 0)\").unwrap(), Value::Bool(true));\n    }\n\n    // ==================== Control Flow Edge Cases ====================\n\n    #[test]\n    fn test_break_in_while() {\n        let result = run(r#\"\nken sum = 0\nken i = 1\nwhiles aye {\n    gin i > 5 {\n        brak\n    }\n    sum = sum + i\n    i = i + 1\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(15));\n    }\n\n    #[test]\n    fn test_continue_in_while() {\n        let result = run(r#\"\nken sum = 0\nken i = 0\nwhiles i < 10 {\n    i = i + 1\n    gin i % 2 == 0 {\n        haud\n    }\n    sum = sum + i\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(25)); // 1+3+5+7+9\n    }\n\n    #[test]\n    fn test_break_in_for() {\n        let result = run(r#\"\nken sum = 0\nfer i in 0..100 {\n    gin i >= 5 {\n        brak\n    }\n    sum = sum + i\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10)); // 0+1+2+3+4\n    }\n\n    #[test]\n    fn test_for_over_list() {\n        let result = run(r#\"\nken sum = 0\nfer x in [1, 2, 3, 4, 5] {\n    sum = sum + x\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(15));\n    }\n\n    #[test]\n    fn test_for_over_string() {\n        let result = run(r#\"\nken count = 0\nfer c in \"hello\" {\n    count = count + 1\n}\ncount\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    // ==================== Assert Statement ====================\n\n    #[test]\n    fn test_assert_pass() {\n        assert_eq!(run(\"mak_siccar 5 > 3\\n42\").unwrap(), Value::Integer(42));\n    }\n\n    #[test]\n    fn test_assert_fail() {\n        assert!(run(\"mak_siccar 3 > 5\").is_err());\n    }\n\n    #[test]\n    fn test_assert_with_message() {\n        let result = run(\"mak_siccar 3 > 5, \\\"Should be bigger\\\"\");\n        assert!(result.is_err());\n    }\n\n    // ==================== Spread Operator ====================\n\n    #[test]\n    fn test_spread_list_elements() {\n        let result = run(\"[1, ...[2, 3], 4]\").unwrap();\n        if let Value::List(list) = result {\n            let list = list.borrow();\n            assert_eq!(list.len(), 4);\n            assert_eq!(list[0], Value::Integer(1));\n            assert_eq!(list[1], Value::Integer(2));\n            assert_eq!(list[2], Value::Integer(3));\n            assert_eq!(list[3], Value::Integer(4));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    // ==================== Pipe Operator ====================\n\n    #[test]\n    fn test_pipe_operator() {\n        let result = run(r#\"\ndae double(x) { gie x * 2 }\ndae add_one(x) { gie x + 1 }\n5 |> double |> add_one\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(11));\n    }\n\n    // ==================== Index Assignment ====================\n\n    #[test]\n    fn test_list_index_assignment() {\n        let result = run(r#\"\nken arr = [1, 2, 3]\narr[1] = 99\narr[1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(99));\n    }\n\n    #[test]\n    fn test_dict_index_assignment() {\n        let result = run(r#\"\nken d = {\"a\": 1}\nd[\"b\"] = 2\nd[\"b\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    // ==================== Negative Index ====================\n\n    #[test]\n    fn test_negative_index() {\n        assert_eq!(run(\"[1, 2, 3][-1]\").unwrap(), Value::Integer(3));\n        assert_eq!(run(\"[1, 2, 3][-2]\").unwrap(), Value::Integer(2));\n        assert_eq!(\n            run(r#\"\"hello\"[-1]\"#).unwrap(),\n            Value::String(\"o\".to_string())\n        );\n    }\n\n    // ==================== JSON Functions ====================\n\n    #[test]\n    fn test_json_parse() {\n        let result = run(r#\"json_parse(\"{\\\"name\\\": \\\"test\\\", \\\"value\\\": 42}\")\"#).unwrap();\n        if let Value::Dict(dict) = result {\n            let dict = dict.borrow();\n            assert_eq!(dict.get(\"value\"), Some(&Value::Integer(42)));\n        } else {\n            panic!(\"Expected dict\");\n        }\n    }\n\n    #[test]\n    fn test_json_parse_array() {\n        let result = run(r#\"json_parse(\"[1, 2, 3]\")\"#).unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_json_parse_primitives() {\n        assert_eq!(run(r#\"json_parse(\"true\")\"#).unwrap(), Value::Bool(true));\n        assert_eq!(run(r#\"json_parse(\"false\")\"#).unwrap(), Value::Bool(false));\n        assert_eq!(run(r#\"json_parse(\"null\")\"#).unwrap(), Value::Nil);\n        assert_eq!(run(r#\"json_parse(\"42\")\"#).unwrap(), Value::Integer(42));\n        assert_eq!(run(r#\"json_parse(\"3.14\")\"#).unwrap(), Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_json_stringify() {\n        assert_eq!(\n            run(r#\"json_stringify(42)\"#).unwrap(),\n            Value::String(\"42\".to_string())\n        );\n        assert_eq!(\n            run(r#\"json_stringify(aye)\"#).unwrap(),\n            Value::String(\"true\".to_string())\n        );\n        assert_eq!(\n            run(r#\"json_stringify([1, 2, 3])\"#).unwrap(),\n            Value::String(\"[1, 2, 3]\".to_string())\n        );\n    }\n\n    // ==================== Struct Tests ====================\n\n    #[test]\n    fn test_struct() {\n        let result = run(r#\"\nthing Point { x, y }\nken p = Point(10, 20)\np.x + p.y\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(30));\n    }\n\n    // ==================== Interpreter Default ====================\n\n    #[test]\n    fn test_interpreter_default() {\n        let interp = Interpreter::default();\n        assert!(interp.output.is_empty());\n    }\n\n    // ==================== Output Capture ====================\n\n    #[test]\n    fn test_get_output() {\n        let mut interp = Interpreter::new();\n        let program = crate::parser::parse(\n            r#\"blether \"hello\"\nblether \"world\"\"#,\n        )\n        .unwrap();\n        interp.interpret(&program).unwrap();\n\n        let output = interp.get_output();\n        assert_eq!(output.len(), 2);\n        assert_eq!(output[0], \"hello\");\n        assert_eq!(output[1], \"world\");\n    }\n\n    // ==================== Float Division ====================\n\n    #[test]\n    fn test_float_division() {\n        // Normal float division\n        assert_eq!(run(\"10.0 / 4.0\").unwrap(), Value::Float(2.5));\n        // Mixed int/float division\n        assert_eq!(run(\"10.0 / 2\").unwrap(), Value::Float(5.0));\n    }\n\n    // ==================== Block Statement ====================\n\n    #[test]\n    fn test_block_returns_last_value() {\n        let result = run(\"{ ken x = 1\\n ken y = 2\\n x + y }\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== Closures ====================\n\n    #[test]\n    fn test_closure_basic() {\n        // Test basic closure that captures outer variable\n        let result = run(r#\"\ndae make_adder(x) {\n    gie |y| x + y\n}\nken add5 = make_adder(5)\nadd5(3)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(8));\n    }\n\n    // ==================== Wildcard Pattern ====================\n\n    #[test]\n    fn test_match_wildcard() {\n        let result = run(r#\"\nken x = 999\nkeek x {\n    whan 1 -> \"one\"\n    whan _ -> \"other\"\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"other\".to_string()));\n    }\n\n    // ==================== Match with Identifier Pattern ====================\n\n    #[test]\n    fn test_match_identifier_bind() {\n        let result = run(r#\"\nken x = 42\nkeek x {\n    whan value -> value * 2\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(84));\n    }\n\n    // ==================== Random Functions ====================\n\n    #[test]\n    fn test_jammy_random() {\n        // jammy(min, max) returns random int between min and max\n        let result = run(\"jammy(1, 10)\").unwrap();\n        if let Value::Integer(n) = result {\n            assert!(n >= 1 && n <= 10);\n        } else {\n            panic!(\"Expected integer\");\n        }\n    }\n\n    // ==================== More Scots Functions ====================\n\n    #[test]\n    fn test_dram_single_element() {\n        // dram returns a random element from a list\n        let result = run(\"dram([1, 2, 3])\").unwrap();\n        if let Value::Integer(n) = result {\n            assert!(n >= 1 && n <= 3);\n        } else {\n            panic!(\"Expected integer\");\n        }\n    }\n\n    #[test]\n    fn test_blooter_scramble() {\n        // blooter scrambles a string\n        let result = run(r#\"len(blooter(\"hello\"))\"#).unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_haver_nonsense() {\n        // haver generates a random Scots phrase\n        let result = run(\"haver()\").unwrap();\n        if let Value::String(s) = result {\n            assert!(!s.is_empty());\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    // ==================== Interpreter Configuration Tests ====================\n\n    #[test]\n    fn test_interpreter_with_dir() {\n        let interp = Interpreter::with_dir(\"/tmp\");\n        assert!(interp.current_dir.to_str().unwrap().contains(\"tmp\"));\n    }\n\n    #[test]\n    fn test_interpreter_set_current_dir() {\n        let mut interp = Interpreter::new();\n        interp.set_current_dir(\"/tmp\");\n        assert!(interp.current_dir.to_str().unwrap().contains(\"tmp\"));\n    }\n\n    #[test]\n    fn test_interpreter_get_user_variables() {\n        let mut interp = Interpreter::new();\n        let program = crate::parser::parse(\"ken x = 42\\nken y = \\\"hello\\\"\").unwrap();\n        interp.interpret(&program).unwrap();\n        let vars = interp.get_user_variables();\n        assert!(vars.iter().any(|(name, _, _)| name == \"x\"));\n        assert!(vars.iter().any(|(name, _, _)| name == \"y\"));\n    }\n\n    #[test]\n    fn test_interpreter_get_user_functions() {\n        let mut interp = Interpreter::new();\n        let program = crate::parser::parse(\"dae foo() { gie 1 }\").unwrap();\n        interp.interpret(&program).unwrap();\n        let vars = interp.get_user_variables();\n        assert!(vars\n            .iter()\n            .any(|(name, kind, _)| name == \"foo\" && kind == \"function\"));\n    }\n\n    // ==================== Native Function Edge Cases ====================\n\n    #[test]\n    fn test_scran_slice_list() {\n        let result = run(\"scran([1, 2, 3, 4, 5], 1, 4)\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_scran_slice_string() {\n        let result = run(r#\"scran(\"hello\", 1, 4)\"#).unwrap();\n        assert_eq!(result, Value::String(\"ell\".to_string()));\n    }\n\n    #[test]\n    fn test_scran_negative_indices() {\n        // Negative indices should clamp to 0\n        let result = run(\"scran([1, 2, 3], -5, 2)\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_scran_large_end_index() {\n        // Large end should clamp to list length\n        let result = run(\"scran([1, 2, 3], 0, 100)\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_coont_string_no_match() {\n        let result = run(r#\"coont(\"hello\", \"z\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_coont_string_multiple() {\n        let result = run(r#\"coont(\"hello world\", \"l\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_coont_list_values() {\n        let result = run(\"coont([1, 2, 1, 3, 1], 1)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_wheesht_trim() {\n        let result = run(r#\"wheesht(\"  hello  \")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_unique_list() {\n        let result = run(\"unique([1, 2, 1, 3, 2])\").unwrap();\n        if let Value::List(list) = result {\n            let items = list.borrow();\n            assert_eq!(items.len(), 3);\n            assert_eq!(items[0], Value::Integer(1));\n            assert_eq!(items[1], Value::Integer(2));\n            assert_eq!(items[2], Value::Integer(3));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_scottify_transform() {\n        // Note: scottify replaces \"no\" before \"know\", so \"know\" becomes \"knaew\"\n        let result = run(r#\"scottify(\"yes the small child is beautiful\")\"#).unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"aye\"));\n            assert!(s.contains(\"wee\"));\n            assert!(s.contains(\"bairn\"));\n            assert!(s.contains(\"bonnie\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    // ==================== Error Path Tests ====================\n\n    #[test]\n    fn test_len_error_non_collection() {\n        let result = run(\"len(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_shove_error_non_list() {\n        let result = run(r#\"shove(\"hello\", 1)\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_yank_error_non_list() {\n        let result = run(r#\"yank(\"hello\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_keys_error_non_dict() {\n        let result = run(\"keys([1, 2, 3])\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_values_error_non_dict() {\n        let result = run(\"values([1, 2, 3])\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_sqrt_error_negative() {\n        let result = run(\"sqrt(-1)\").unwrap();\n        if let Value::Float(f) = result {\n            assert!(f.is_nan());\n        }\n    }\n\n    #[test]\n    fn test_sqrt_error_non_number() {\n        let result = run(r#\"sqrt(\"hello\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_scran_error_non_integer_indices() {\n        let result = run(r#\"scran([1, 2, 3], \"a\", \"b\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_scran_error_non_collection() {\n        let result = run(\"scran(42, 0, 1)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_coont_error_non_collection() {\n        let result = run(\"coont(42, 1)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_coont_string_error_non_string_needle() {\n        let result = run(r#\"coont(\"hello\", 1)\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_wheesht_error_non_string() {\n        let result = run(\"wheesht(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unique_error_non_list() {\n        let result = run(r#\"unique(\"hello\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_scottify_error_non_string() {\n        let result = run(\"scottify(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_sumaw_error_non_list() {\n        let result = run(\"sumaw(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_sumaw_error_non_numeric() {\n        let result = run(r#\"sumaw([\"a\", \"b\"])\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== Math Functions Edge Cases ====================\n\n    #[test]\n    fn test_abs_negative_integer() {\n        let result = run(\"abs(-42)\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_abs_negative_float() {\n        let result = run(\"abs(-3.14)\").unwrap();\n        assert_eq!(result, Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_abs_positive() {\n        let result = run(\"abs(42)\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_floor_positive() {\n        let result = run(\"floor(3.9)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_floor_negative() {\n        let result = run(\"floor(-3.1)\").unwrap();\n        assert_eq!(result, Value::Integer(-4));\n    }\n\n    #[test]\n    fn test_ceil_positive() {\n        let result = run(\"ceil(3.1)\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_ceil_negative() {\n        let result = run(\"ceil(-3.9)\").unwrap();\n        assert_eq!(result, Value::Integer(-3));\n    }\n\n    #[test]\n    fn test_round_half_up() {\n        let result = run(\"round(3.5)\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_round_half_down() {\n        let result = run(\"round(3.4)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== Complex Control Flow ====================\n\n    #[test]\n    fn test_nested_if_else() {\n        let result = run(r#\"\nken x = 5\ngin x > 10 {\n    \"big\"\n} ither gin x > 3 {\n    \"medium\"\n} ither {\n    \"small\"\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"medium\".to_string()));\n    }\n\n    #[test]\n    fn test_while_with_break() {\n        let result = run(r#\"\nken total = 0\nken i = 0\nwhiles i < 100 {\n    total = total + i\n    i = i + 1\n    gin i == 5 {\n        brak\n    }\n}\ntotal\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    #[test]\n    fn test_while_with_continue() {\n        let result = run(r#\"\nken total = 0\nken i = 0\nwhiles i < 5 {\n    i = i + 1\n    gin i == 3 {\n        haud\n    }\n    total = total + i\n}\ntotal\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(12)); // 1+2+4+5 = 12\n    }\n\n    #[test]\n    fn test_for_with_break() {\n        let result = run(r#\"\nken total = 0\nfer i in 0..10 {\n    gin i == 5 {\n        brak\n    }\n    total = total + i\n}\ntotal\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10)); // 0+1+2+3+4 = 10\n    }\n\n    #[test]\n    fn test_for_with_continue() {\n        let result = run(r#\"\nken total = 0\nfer i in 0..5 {\n    gin i == 2 {\n        haud\n    }\n    total = total + i\n}\ntotal\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(8)); // 0+1+3+4 = 8\n    }\n\n    // ==================== Class and Method Tests ====================\n\n    #[test]\n    fn test_class_with_init() {\n        let result = run(r#\"\nkin Counter {\n    dae init(start) {\n        masel.count = start\n    }\n    dae increment() {\n        masel.count = masel.count + 1\n    }\n    dae get() {\n        gie masel.count\n    }\n}\nken c = Counter(5)\nc.increment()\nc.get()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    #[test]\n    fn test_class_inheritance() {\n        let result = run(r#\"\nkin Animal {\n    dae init(name) {\n        masel.name = name\n    }\n    dae speak() {\n        gie \"...\"\n    }\n}\nkin Dog fae Animal {\n    dae speak() {\n        gie \"Woof!\"\n    }\n}\nken d = Dog(\"Rover\")\nd.speak()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Woof!\".to_string()));\n    }\n\n    // ==================== Struct Tests ====================\n\n    #[test]\n    fn test_struct_creation() {\n        let result = run(r#\"\nthing Point { x, y }\nken p = Point(3, 4)\np.x + p.y\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(7));\n    }\n\n    #[test]\n    fn test_struct_update() {\n        let result = run(r#\"\nthing Point { x, y }\nken p = Point(1, 2)\np.x = 10\np.x\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    // ==================== List Operations ====================\n\n    #[test]\n    fn test_list_negative_index() {\n        let result = run(r#\"\nken list = [1, 2, 3, 4, 5]\nlist[-1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_list_negative_index_second() {\n        let result = run(r#\"\nken list = [1, 2, 3, 4, 5]\nlist[-2]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_list_index_mutation() {\n        let result = run(r#\"\nken list = [1, 2, 3]\nlist[1] = 99\nlist[1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(99));\n    }\n\n    // ==================== Dict Operations ====================\n\n    #[test]\n    fn test_dict_set_get() {\n        let result = run(r#\"\nken d = {\"a\": 1}\nd[\"b\"] = 2\nd[\"a\"] + d[\"b\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_dict_with_string_keys() {\n        let result = run(r#\"\nken d = {\"name\": \"Alice\", \"age\": 30}\nd[\"name\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Alice\".to_string()));\n    }\n\n    // ==================== String Operations ====================\n\n    #[test]\n    fn test_string_index() {\n        let result = run(r#\"\"hello\"[0]\"#).unwrap();\n        assert_eq!(result, Value::String(\"h\".to_string()));\n    }\n\n    #[test]\n    fn test_string_negative_index() {\n        let result = run(r#\"\"hello\"[-1]\"#).unwrap();\n        assert_eq!(result, Value::String(\"o\".to_string()));\n    }\n\n    #[test]\n    fn test_upper_function() {\n        let result = run(r#\"upper(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"HELLO\".to_string()));\n    }\n\n    #[test]\n    fn test_lower_function() {\n        let result = run(r#\"lower(\"HELLO\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_replace_string() {\n        let result = run(r#\"replace(\"hello world\", \"world\", \"everyone\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello everyone\".to_string()));\n    }\n\n    // ==================== Type Checking Functions ====================\n\n    #[test]\n    fn test_whit_kind_integer() {\n        let result = run(r#\"whit_kind(42)\"#).unwrap();\n        assert_eq!(result, Value::String(\"integer\".to_string()));\n    }\n\n    #[test]\n    fn test_whit_kind_string() {\n        let result = run(r#\"whit_kind(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"string\".to_string()));\n    }\n\n    #[test]\n    fn test_whit_kind_list() {\n        let result = run(r#\"whit_kind([1, 2, 3])\"#).unwrap();\n        assert_eq!(result, Value::String(\"list\".to_string()));\n    }\n\n    #[test]\n    fn test_whit_kind_function_value() {\n        let result = run(r#\"\ndae foo() { gie 1 }\nwhit_kind(foo)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"function\".to_string()));\n    }\n\n    // ==================== Pipe Operator ====================\n\n    #[test]\n    fn test_pipe_chain() {\n        let result = run(r#\"[1, 2, 3] |> len\"#).unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_pipe_multiple() {\n        let result = run(r#\"\n\"  hello  \" |> wheesht |> upper\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"HELLO\".to_string()));\n    }\n\n    // ==================== Spread Operator ====================\n\n    #[test]\n    fn test_spread_list() {\n        let result = run(r#\"\nken a = [1, 2]\nken b = [3, 4]\nken c = [...a, ...b]\nlen(c)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_spread_in_call() {\n        let result = run(r#\"\ndae add(x, y, z) {\n    gie x + y + z\n}\nken args = [1, 2, 3]\nadd(...args)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    // ==================== Try-Catch Tests ====================\n\n    #[test]\n    fn test_try_catch_no_error() {\n        let result = run(r#\"\nhae_a_bash {\n    42\n} gin_it_gangs_wrang e {\n    0\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_try_catch_with_error() {\n        let result = run(r#\"\nhae_a_bash {\n    1 / 0\n} gin_it_gangs_wrang e {\n    \"caught\"\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"caught\".to_string()));\n    }\n\n    // ==================== Assert Tests ====================\n\n    #[test]\n    fn test_mak_siccar_pass() {\n        let result = run(\"mak_siccar aye\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_mak_siccar_fail() {\n        let result = run(\"mak_siccar nae\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mak_siccar_with_message() {\n        let result = run(r#\"mak_siccar nae, \"Custom message\"\"#);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(format!(\"{:?}\", e).contains(\"Custom message\"));\n        }\n    }\n\n    // ==================== Range Iteration ====================\n\n    #[test]\n    fn test_for_range_exclusive() {\n        let result = run(r#\"\nken sum = 0\nfer i in 0..5 {\n    sum = sum + i\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10)); // 0+1+2+3+4\n    }\n\n    #[test]\n    fn test_range_in_list() {\n        let result = run(r#\"\nken r = 1..4\nken sum = 0\nfer i in r {\n    sum = sum + i\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(6)); // 1+2+3\n    }\n\n    // ==================== Lambda Tests ====================\n\n    #[test]\n    fn test_lambda_simple() {\n        let result = run(r#\"\nken double = |x| x * 2\ndouble(5)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    #[test]\n    fn test_lambda_multiple_params() {\n        let result = run(r#\"\nken add = |x, y| x + y\nadd(3, 4)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(7));\n    }\n\n    #[test]\n    fn test_lambda_as_callback() {\n        let result = run(r#\"\ndae apply(f, x) {\n    gie f(x)\n}\napply(|n| n * n, 4)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(16));\n    }\n\n    // ==================== Modulo and Integer Division ====================\n\n    #[test]\n    fn test_modulo_positive() {\n        let result = run(\"10 % 3\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_modulo_negative() {\n        let result = run(\"-10 % 3\").unwrap();\n        assert_eq!(result, Value::Integer(-1));\n    }\n\n    #[test]\n    fn test_floor_division() {\n        // Use floor() for integer division\n        let result = run(\"floor(10 / 3)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== Comparison Edge Cases ====================\n\n    #[test]\n    fn test_string_less_than() {\n        let result = run(r#\"\"apple\" < \"banana\"\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_mixed_numeric_comparison() {\n        let result = run(\"3 == 3.0\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_nil_equality() {\n        let result = run(\"naething == naething\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    // ==================== More Native Functions ====================\n\n    #[test]\n    fn test_heid_list() {\n        let result = run(\"heid([1, 2, 3])\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_heid_string() {\n        let result = run(r#\"heid(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"h\".to_string()));\n    }\n\n    #[test]\n    fn test_tail_list() {\n        let result = run(\"tail([1, 2, 3])\").unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n            assert_eq!(list.borrow()[0], Value::Integer(2));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_tail_string() {\n        let result = run(r#\"tail(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"ello\".to_string()));\n    }\n\n    #[test]\n    fn test_bum_list() {\n        let result = run(\"bum([1, 2, 3])\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_bum_string() {\n        let result = run(r#\"bum(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"o\".to_string()));\n    }\n\n    #[test]\n    fn test_join_string() {\n        let result = run(r#\"join([\"a\", \"b\", \"c\"], \", \")\"#).unwrap();\n        assert_eq!(result, Value::String(\"a, b, c\".to_string()));\n    }\n\n    // ==================== Module/Import Tests ====================\n\n    #[test]\n    fn test_anonymous_function_call() {\n        let result = run(r#\"\n(|x| x * 2)(5)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    // ==================== Default Parameter Tests ====================\n\n    #[test]\n    fn test_function_default_param() {\n        let result = run(r#\"\ndae greet(name, greeting = \"Hello\") {\n    gie greeting + \" \" + name\n}\ngreet(\"World\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Hello World\".to_string()));\n    }\n\n    #[test]\n    fn test_function_override_default() {\n        let result = run(r#\"\ndae greet(name, greeting = \"Hello\") {\n    gie greeting + \" \" + name\n}\ngreet(\"World\", \"Hi\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Hi World\".to_string()));\n    }\n\n    // ==================== Set Operations ====================\n\n    #[test]\n    fn test_creel_basic() {\n        let result = run(r#\"\nken s = creel([1, 2, 3])\nlen(s)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_creel_duplicates() {\n        let result = run(r#\"\nken s = creel([1, 1, 2, 2, 3])\nlen(s)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== More Edge Cases ====================\n\n    #[test]\n    fn test_empty_list_operations() {\n        let result = run(\"len([])\").unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_empty_string_operations() {\n        let result = run(r#\"len(\"\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_nested_list_access() {\n        let result = run(r#\"\nken matrix = [[1, 2], [3, 4]]\nmatrix[1][0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_dict_in_list() {\n        let result = run(r#\"\nken list = [{\"a\": 1}, {\"a\": 2}]\nlist[0][\"a\"] + list[1][\"a\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_conditional_expression() {\n        let result = run(r#\"\nken x = 5\nken result = gin x > 3 than \"big\" ither \"small\"\nresult\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"big\".to_string()));\n    }\n\n    #[test]\n    fn test_contains_list() {\n        let result = run(\"contains([1, 2, 3], 2)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_contains_list_missing() {\n        let result = run(\"contains([1, 2, 3], 5)\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_contains_string() {\n        let result = run(r#\"contains(\"hello\", \"ell\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_sort_integers() {\n        let result = run(\"sort([3, 1, 2])\").unwrap();\n        if let Value::List(list) = result {\n            let items = list.borrow();\n            assert_eq!(items[0], Value::Integer(1));\n            assert_eq!(items[1], Value::Integer(2));\n            assert_eq!(items[2], Value::Integer(3));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_sort_strings() {\n        let result = run(r#\"sort([\"c\", \"a\", \"b\"])\"#).unwrap();\n        if let Value::List(list) = result {\n            let items = list.borrow();\n            assert_eq!(items[0], Value::String(\"a\".to_string()));\n            assert_eq!(items[1], Value::String(\"b\".to_string()));\n            assert_eq!(items[2], Value::String(\"c\".to_string()));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_reverse_list() {\n        let result = run(\"reverse([1, 2, 3])\").unwrap();\n        if let Value::List(list) = result {\n            let items = list.borrow();\n            assert_eq!(items[0], Value::Integer(3));\n            assert_eq!(items[1], Value::Integer(2));\n            assert_eq!(items[2], Value::Integer(1));\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_reverse_string_builtin() {\n        let result = run(r#\"reverse(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"olleh\".to_string()));\n    }\n\n    // ==================== More Native Function Tests ====================\n\n    #[test]\n    fn test_words_function() {\n        let result = run(r#\"words(\"hello world\")\"#).unwrap();\n        if let Value::List(list) = result {\n            assert_eq!(list.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_is_digit_true() {\n        let result = run(r#\"is_digit(\"123\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_digit_false() {\n        let result = run(r#\"is_digit(\"12a\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_is_alpha_true() {\n        let result = run(r#\"is_alpha(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_alpha_false() {\n        let result = run(r#\"is_alpha(\"hello1\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_is_space_true() {\n        let result = run(r#\"is_space(\"   \")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_space_with_letters() {\n        let result = run(r#\"is_space(\"  x  \")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_capitalize_function() {\n        let result = run(r#\"capitalize(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"Hello\".to_string()));\n    }\n\n    #[test]\n    fn test_title_function() {\n        let result = run(r#\"title(\"hello world\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"Hello World\".to_string()));\n    }\n\n    #[test]\n    fn test_the_noo_timestamp() {\n        let result = run(\"the_noo()\").unwrap();\n        if let Value::Integer(n) = result {\n            assert!(n > 0);\n        } else {\n            panic!(\"Expected integer timestamp\");\n        }\n    }\n\n    #[test]\n    fn test_jammy_error_min_gte_max() {\n        let result = run(\"jammy(10, 5)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_shuffle_preserves_length() {\n        let result = run(\"len(shuffle([1, 2, 3, 4, 5]))\").unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_sort_error_non_list() {\n        let result = run(r#\"sort(\"hello\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_shuffle_error_non_list() {\n        let result = run(r#\"shuffle(\"hello\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_lower_error_non_string() {\n        let result = run(\"lower(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_upper_error_non_string() {\n        let result = run(\"upper(42)\");\n        assert!(result.is_err());\n    }\n\n    // ==================== Set Function Tests ====================\n\n    #[test]\n    fn test_toss_in_set() {\n        let result = run(r#\"\nken s = creel([1, 2, 3])\ntoss_in(s, 4)\nlen(s)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_heave_oot_set() {\n        let result = run(r#\"\nken s = creel([1, 2, 3])\nheave_oot(s, \"1\")\nlen(s)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_is_in_creel_true() {\n        let result = run(r#\"\nken s = creel([1, 2, 3])\nis_in_creel(s, \"1\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_in_creel_false() {\n        let result = run(r#\"\nken s = creel([1, 2, 3])\nis_in_creel(s, \"5\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    // ==================== More Math Tests ====================\n\n    #[test]\n    fn test_pow_function() {\n        let result = run(\"pow(2, 3)\").unwrap();\n        assert_eq!(result, Value::Float(8.0));\n    }\n\n    #[test]\n    fn test_log_function() {\n        // log is natural log (ln)\n        let result = run(\"log10(100)\").unwrap();\n        if let Value::Float(f) = result {\n            assert!((f - 2.0).abs() < 0.0001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_sin_function() {\n        let result = run(\"sin(0)\").unwrap();\n        if let Value::Float(f) = result {\n            assert!(f.abs() < 0.0001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_cos_function() {\n        let result = run(\"cos(0)\").unwrap();\n        if let Value::Float(f) = result {\n            assert!((f - 1.0).abs() < 0.0001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    // ==================== More Error Path Tests ====================\n\n    #[test]\n    fn test_index_error_list() {\n        let result = run(\"[1, 2, 3][10]\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_index_error_string() {\n        let result = run(r#\"\"hi\"[10]\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_heid_error_empty_list() {\n        let result = run(\"heid([])\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_tail_empty_list_returns_empty() {\n        // tail on empty list returns empty list (not error)\n        let result = run(\"len(tail([1]))\").unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_bum_error_empty_list() {\n        let result = run(\"bum([])\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_heid_error_empty_string() {\n        let result = run(r#\"heid(\"\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_bum_error_empty_string() {\n        let result = run(r#\"bum(\"\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_digit_error_non_string() {\n        let result = run(\"is_digit(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_alpha_error_non_string() {\n        let result = run(\"is_alpha(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_words_error_non_string() {\n        let result = run(\"words(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_capitalize_error_non_string() {\n        let result = run(\"capitalize(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_title_error_non_string() {\n        let result = run(\"title(42)\");\n        assert!(result.is_err());\n    }\n\n    // ==================== Method Access Tests ====================\n\n    #[test]\n    fn test_instance_method_call() {\n        let result = run(r#\"\nkin Calculator {\n    dae init(val) {\n        masel.val = val\n    }\n    dae double() {\n        gie masel.val * 2\n    }\n}\nken c = Calculator(21)\nc.double()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_instance_field_access() {\n        let result = run(r#\"\nkin Point {\n    dae init(x, y) {\n        masel.x = x\n        masel.y = y\n    }\n}\nken p = Point(3, 4)\np.x + p.y\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(7));\n    }\n\n    // ==================== Range Tests ====================\n\n    #[test]\n    fn test_range_with_variable_bounds() {\n        let result = run(r#\"\nken start = 0\nken end = 5\nken sum = 0\nfer i in start..end {\n    sum = sum + i\n}\nsum\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10)); // 0+1+2+3+4 = 10\n    }\n\n    // ==================== Dictionary Key Tests ====================\n\n    #[test]\n    fn test_dict_keys_iteration() {\n        let result = run(r#\"\nken d = {\"a\": 1, \"b\": 2}\nlen(keys(d))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dict_values_iteration() {\n        let result = run(r#\"\nken d = {\"a\": 1, \"b\": 2}\nlen(values(d))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dict_update_existing() {\n        let result = run(r#\"\nken d = {\"a\": 1}\nd[\"a\"] = 42\nd[\"a\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_dict_add_new_key() {\n        let result = run(r#\"\nken d = {\"a\": 1}\nd[\"b\"] = 2\nd[\"b\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    // ==================== More Complex Expression Tests ====================\n\n    #[test]\n    fn test_chained_method_calls() {\n        let result = run(r#\"\nkin Builder {\n    dae init() {\n        masel.val = 0\n    }\n    dae add(n) {\n        masel.val = masel.val + n\n        gie masel\n    }\n    dae get() {\n        gie masel.val\n    }\n}\nken b = Builder()\nb.add(1).add(2).add(3).get()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    // ==================== String Interpolation Tests ====================\n\n    #[test]\n    fn test_fstring_nested_expr() {\n        let result = run(r#\"\nken x = 10\nf\"Result: {x * 2}\"\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Result: 20\".to_string()));\n    }\n\n    #[test]\n    fn test_fstring_function_call() {\n        let result = run(r#\"\ndae greet(name) { gie \"Hi \" + name }\nf\"Greeting: {greet(\\\"World\\\")}\"\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Greeting: Hi World\".to_string()));\n    }\n\n    // ==================== Empty Structure Tests ====================\n\n    #[test]\n    fn test_empty_dict() {\n        let result = run(r#\"\nken d = {}\nlen(keys(d))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_struct_with_fields() {\n        let result = run(r#\"\nthing Person { name, age }\nken p = Person(\"Alice\", 30)\np.name\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Alice\".to_string()));\n    }\n\n    // ==================== Assignment Operators ====================\n\n    #[test]\n    fn test_plus_equals() {\n        let result = run(r#\"\nken x = 5\nx += 3\nx\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(8));\n    }\n\n    #[test]\n    fn test_minus_equals() {\n        let result = run(r#\"\nken x = 10\nx -= 3\nx\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(7));\n    }\n\n    #[test]\n    fn test_times_equals() {\n        let result = run(r#\"\nken x = 4\nx *= 3\nx\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(12));\n    }\n\n    #[test]\n    fn test_divide_equals() {\n        let result = run(r#\"\nken x = 12\nx /= 3\nx\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    // ==================== Boolean Short Circuit Proof ====================\n\n    #[test]\n    fn test_and_short_circuit_side_effect() {\n        // If short circuit works, second expression shouldn't run\n        let result = run(r#\"\nken x = 0\nnae an (x = 1)\nx\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(0)); // x should still be 0\n    }\n\n    #[test]\n    fn test_or_short_circuit_side_effect() {\n        // If short circuit works, second expression shouldn't run\n        let result = run(r#\"\nken x = 0\naye or (x = 1)\nx\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(0)); // x should still be 0\n    }\n\n    // ==================== Slice Tests ====================\n\n    #[test]\n    fn test_list_slice_basic() {\n        let result = run(r#\"\nken l = [1, 2, 3, 4, 5]\nl[1:4]\n\"#)\n        .unwrap();\n        if let Value::List(items) = result {\n            assert_eq!(items.borrow().len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_list_slice_negative_index() {\n        let result = run(r#\"\nken l = [1, 2, 3, 4, 5]\nl[-3:-1]\n\"#)\n        .unwrap();\n        if let Value::List(items) = result {\n            assert_eq!(items.borrow().len(), 2);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_list_slice_with_step() {\n        let result = run(r#\"\nken l = [1, 2, 3, 4, 5, 6]\nl[0:6:2]\n\"#)\n        .unwrap();\n        if let Value::List(items) = result {\n            assert_eq!(items.borrow().len(), 3); // 1, 3, 5\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_list_slice_negative_step() {\n        let result = run(r#\"\nken l = [1, 2, 3, 4, 5]\nl[4:0:-1]\n\"#)\n        .unwrap();\n        if let Value::List(items) = result {\n            assert_eq!(items.borrow().len(), 4); // 5, 4, 3, 2\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_string_slice_basic() {\n        let result = run(r#\"\nken s = \"hello\"\ns[1:4]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"ell\".to_string()));\n    }\n\n    #[test]\n    fn test_string_slice_negative_step() {\n        let result = run(r#\"\nken s = \"hello\"\ns[4:0:-1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"olle\".to_string()));\n    }\n\n    #[test]\n    fn test_slice_step_zero_error() {\n        let result = run(\"ken l = [1,2,3]\\nl[::0]\");\n        assert!(result.is_err());\n    }\n\n    // ==================== More Set (Creel) Tests ====================\n\n    #[test]\n    fn test_creel_from_set() {\n        let result = run(r#\"\nken s = creel([1, 2, 3])\nlen(creel(s))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_creels_thegither() {\n        let result = run(r#\"\nken s1 = creel([1, 2])\nken s2 = creel([2, 3])\nlen(creels_thegither(s1, s2))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3)); // Union: 1, 2, 3\n    }\n\n    #[test]\n    fn test_creels_baith() {\n        let result = run(r#\"\nken s1 = creel([1, 2, 3])\nken s2 = creel([2, 3, 4])\nlen(creels_baith(s1, s2))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2)); // Intersection: 2, 3\n    }\n\n    #[test]\n    fn test_creels_differ() {\n        let result = run(r#\"\nken s1 = creel([1, 2, 3])\nken s2 = creel([2, 3])\nlen(creels_differ(s1, s2))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1)); // Difference: 1\n    }\n\n    #[test]\n    fn test_creel_tae_list() {\n        let result = run(r#\"\nken s = creel([3, 1, 2])\nwhit_kind(creel_tae_list(s))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"list\".to_string()));\n    }\n\n    #[test]\n    fn test_is_subset() {\n        let result = run(r#\"\nken s1 = creel([1, 2])\nken s2 = creel([1, 2, 3])\nis_subset(s1, s2)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_superset() {\n        let result = run(r#\"\nken s1 = creel([1, 2, 3])\nken s2 = creel([1, 2])\nis_superset(s1, s2)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_disjoint() {\n        let result = run(r#\"\nken s1 = creel([1, 2])\nken s2 = creel([3, 4])\nis_disjoint(s1, s2)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    // ==================== Match Statement Tests ====================\n\n    #[test]\n    fn test_match_literal_int() {\n        let result = run(r#\"\nken x = 2\nkeek x {\n    whan 1 -> 10\n    whan 2 -> 20\n    whan 3 -> 30\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(20));\n    }\n\n    #[test]\n    fn test_match_literal_string() {\n        let result = run(r#\"\nken s = \"hello\"\nkeek s {\n    whan \"hi\" -> 1\n    whan \"hello\" -> 2\n    whan \"bye\" -> 3\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_match_catchall() {\n        let result = run(r#\"\nken x = 99\nkeek x {\n    whan 1 -> 10\n    whan _ -> 42\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_match_binding() {\n        let result = run(r#\"\nken x = 5\nkeek x {\n    whan n -> n * 2\n}\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    #[test]\n    fn test_match_no_match_error() {\n        let result = run(r#\"\nken x = 99\nkeek x {\n    whan 1 -> 10\n    whan 2 -> 20\n}\n\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== Destructuring Tests ====================\n\n    #[test]\n    fn test_destructure_basic() {\n        let result = run(r#\"\nken [a, b, c] = [1, 2, 3]\na + b + c\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    #[test]\n    fn test_destructure_with_rest() {\n        let result = run(r#\"\nken [first, ...rest] = [1, 2, 3, 4, 5]\nlen(rest)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_destructure_with_ignore() {\n        let result = run(r#\"\nken [a, _, c] = [1, 2, 3]\na + c\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_destructure_string() {\n        let result = run(r#\"\nken [a, b, c] = \"abc\"\na + b + c\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"abc\".to_string()));\n    }\n\n    #[test]\n    fn test_destructure_not_enough_elements() {\n        let result = run(r#\"\nken [a, b, c] = [1, 2]\n\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== More Native Function Tests ====================\n\n    #[test]\n    fn test_shuffle_length() {\n        // Shuffle should return a list of the same length\n        let result = run(\"len(shuffle([1, 2, 3, 4, 5]))\").unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_shuffle_reject_string() {\n        let result = run(r#\"shuffle(\"hello\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_sort_string_list() {\n        let result = run(r#\"\nken l = sort([\"c\", \"a\", \"b\"])\nl[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"a\".to_string()));\n    }\n\n    #[test]\n    fn test_sort_float_list() {\n        let result = run(r#\"\nken l = sort([3.5, 1.5, 2.5])\nl[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Float(1.5));\n    }\n\n    #[test]\n    fn test_sort_rejects_non_list() {\n        let result = run(r#\"sort(\"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_jammy_min_max() {\n        let result = run(\"jammy(1, 10)\").unwrap();\n        if let Value::Integer(n) = result {\n            assert!(n >= 1 && n < 10);\n        } else {\n            panic!(\"Expected integer\");\n        }\n    }\n\n    #[test]\n    fn test_jammy_bounds_error() {\n        let result = run(\"jammy(10, 5)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_the_noo() {\n        let result = run(\"the_noo()\").unwrap();\n        if let Value::Integer(ts) = result {\n            assert!(ts > 0);\n        } else {\n            panic!(\"Expected integer timestamp\");\n        }\n    }\n\n    #[test]\n    fn test_clype_debug_info() {\n        let result = run(\"clype([1, 2, 3])\").unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"list\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_is_a_integer() {\n        let result = run(r#\"is_a(42, \"integer\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_a_function() {\n        let result = run(r#\"\ndae foo() { gie 1 }\nis_a(foo, \"function\")\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_a_nil() {\n        let result = run(r#\"is_a(naething, \"nil\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_a_range() {\n        let result = run(r#\"is_a(1..10, \"range\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_tae_bool() {\n        let result = run(\"tae_bool(0)\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_char_at_positive() {\n        let result = run(r#\"char_at(\"hello\", 1)\"#).unwrap();\n        assert_eq!(result, Value::String(\"e\".to_string()));\n    }\n\n    #[test]\n    fn test_char_at_negative() {\n        let result = run(r#\"char_at(\"hello\", -1)\"#).unwrap();\n        assert_eq!(result, Value::String(\"o\".to_string()));\n    }\n\n    #[test]\n    fn test_char_at_out_of_bounds() {\n        let result = run(r#\"char_at(\"hi\", 10)\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_repeat_string() {\n        let result = run(r#\"repeat(\"ab\", 3)\"#).unwrap();\n        assert_eq!(result, Value::String(\"ababab\".to_string()));\n    }\n\n    #[test]\n    fn test_repeat_negative_error() {\n        let result = run(r#\"repeat(\"ab\", -1)\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_index_of_string() {\n        let result = run(r#\"index_of(\"hello\", \"ll\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_index_of_string_not_found() {\n        let result = run(r#\"index_of(\"hello\", \"xyz\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(-1));\n    }\n\n    #[test]\n    fn test_index_of_list() {\n        let result = run(r#\"index_of([10, 20, 30], 20)\"#).unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_index_of_list_not_found() {\n        let result = run(r#\"index_of([1, 2, 3], 99)\"#).unwrap();\n        assert_eq!(result, Value::Integer(-1));\n    }\n\n    // ==================== More String Functions ====================\n\n    #[test]\n    fn test_pad_left() {\n        let result = run(r#\"pad_left(\"5\", 3, \"0\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"005\".to_string()));\n    }\n\n    #[test]\n    fn test_pad_right() {\n        let result = run(r#\"pad_right(\"5\", 3, \"0\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"500\".to_string()));\n    }\n\n    #[test]\n    fn test_pad_left_already_wide() {\n        let result = run(r#\"pad_left(\"hello\", 3, \" \")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_lines() {\n        let result = run(r#\"len(lines(\"a\\nb\\nc\"))\"#).unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_lines_error_non_string() {\n        let result = run(\"lines(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_space() {\n        let result = run(r#\"is_space(\"   \")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_space_mixed_chars() {\n        let result = run(r#\"is_space(\"a b\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_is_space_error_non_string() {\n        let result = run(\"is_space(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_chars() {\n        let result = run(r#\"len(chars(\"abc\"))\"#).unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_chars_error_non_string() {\n        let result = run(\"chars(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_ord() {\n        let result = run(r#\"ord(\"A\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(65));\n    }\n\n    #[test]\n    fn test_ord_empty_string_error() {\n        let result = run(r#\"ord(\"\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_chr() {\n        let result = run(\"chr(65)\").unwrap();\n        assert_eq!(result, Value::String(\"A\".to_string()));\n    }\n\n    #[test]\n    fn test_chr_invalid_codepoint() {\n        let result = run(\"chr(-1)\");\n        assert!(result.is_err());\n    }\n\n    // ==================== More List Functions ====================\n\n    #[test]\n    fn test_flatten() {\n        let result = run(\"len(flatten([[1, 2], [3, 4]]))\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_flatten_mixed() {\n        let result = run(\"len(flatten([1, [2, 3], 4]))\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_flatten_error_non_list() {\n        let result = run(r#\"flatten(\"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_zip() {\n        let result = run(\"len(zip([1, 2], [3, 4]))\").unwrap();\n        assert_eq!(result, Value::Integer(2)); // Two pairs\n    }\n\n    #[test]\n    fn test_zip_error_non_lists() {\n        let result = run(r#\"zip([1], \"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_enumerate() {\n        let result = run(r#\"\nken e = enumerate([\"a\", \"b\"])\ne[0][0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_enumerate_error_non_list() {\n        let result = run(r#\"enumerate(\"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_uniq() {\n        let result = run(\"len(uniq([1, 2, 2, 3, 3, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_uniq_error_non_list() {\n        let result = run(r#\"uniq(\"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_chynge_insert() {\n        let result = run(r#\"\nken l = chynge([1, 3], 1, 2)\nl[1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_chynge_negative_index() {\n        let result = run(r#\"\nken l = chynge([1, 2, 3], -1, 99)\nlen(l)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_dicht_remove() {\n        let result = run(\"len(dicht([1, 2, 3], 1))\").unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dicht_negative_index() {\n        let result = run(r#\"\nken l = dicht([1, 2, 3], -1)\nlen(l)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_tak() {\n        let result = run(\"len(tak([1, 2, 3, 4], 2))\").unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_string_slice_take() {\n        let result = run(r#\"\"hello\"[0:3]\"#).unwrap();\n        assert_eq!(result, Value::String(\"hel\".to_string()));\n    }\n\n    #[test]\n    fn test_drap() {\n        let result = run(\"len(drap([1, 2, 3, 4], 2))\").unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_string_slice_drop() {\n        let result = run(r#\"\"hello\"[2:]\"#).unwrap();\n        assert_eq!(result, Value::String(\"llo\".to_string()));\n    }\n\n    #[test]\n    fn test_redd_up() {\n        let result = run(\"len(redd_up([1, naething, 2, naething, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_redd_up_error_non_list() {\n        let result = run(r#\"redd_up(\"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_split_by_even() {\n        let result = run(r#\"\nken parts = split_by([1, 2, 3, 4], \"even\")\nlen(parts[0])\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2)); // 2, 4 are even\n    }\n\n    #[test]\n    fn test_split_by_positive() {\n        let result = run(r#\"\nken parts = split_by([-1, 0, 1, 2], \"positive\")\nlen(parts[0])\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2)); // 1, 2 are positive\n    }\n\n    #[test]\n    fn test_split_by_unknown_predicate() {\n        let result = run(r#\"split_by([1, 2], \"unknown\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_grup_runs() {\n        let result = run(\"len(grup_runs([1, 1, 2, 2, 2, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3)); // [[1,1], [2,2,2], [3]]\n    }\n\n    #[test]\n    fn test_grup_runs_error_non_list() {\n        let result = run(r#\"grup_runs(\"aab\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_chunks() {\n        let result = run(\"len(chunks([1, 2, 3, 4, 5], 2))\").unwrap();\n        assert_eq!(result, Value::Integer(3)); // [[1,2], [3,4], [5]]\n    }\n\n    #[test]\n    fn test_chunks_zero_size_error() {\n        let result = run(\"chunks([1, 2, 3], 0)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_interleave() {\n        let result = run(\"len(interleave([1, 2], [3, 4]))\").unwrap();\n        assert_eq!(result, Value::Integer(4)); // [1, 3, 2, 4]\n    }\n\n    #[test]\n    fn test_interleave_error_non_lists() {\n        let result = run(r#\"interleave([1], \"abc\")\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== Math Functions ====================\n\n    #[test]\n    fn test_pooer_integers() {\n        let result = run(\"pooer(2, 10)\").unwrap();\n        assert_eq!(result, Value::Integer(1024));\n    }\n\n    #[test]\n    fn test_pooer_negative_exponent() {\n        let result = run(\"pooer(2, -2)\").unwrap();\n        assert_eq!(result, Value::Float(0.25));\n    }\n\n    #[test]\n    fn test_pooer_floats() {\n        let result = run(\"pooer(2.0, 3.0)\").unwrap();\n        assert_eq!(result, Value::Float(8.0));\n    }\n\n    #[test]\n    fn test_pooer_error_non_numbers() {\n        let result = run(r#\"pooer(\"a\", 2)\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_sign_positive() {\n        let result = run(\"sign(42)\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_sign_negative() {\n        let result = run(\"sign(-42)\").unwrap();\n        assert_eq!(result, Value::Integer(-1));\n    }\n\n    #[test]\n    fn test_sign_zero() {\n        let result = run(\"sign(0)\").unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_sign_float() {\n        let result = run(\"sign(-3.14)\").unwrap();\n        assert_eq!(result, Value::Integer(-1));\n    }\n\n    #[test]\n    fn test_clamp_integers() {\n        let result = run(\"clamp(15, 0, 10)\").unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    #[test]\n    fn test_clamp_floats() {\n        let result = run(\"clamp(-5.0, 0.0, 10.0)\").unwrap();\n        assert_eq!(result, Value::Float(0.0));\n    }\n\n    #[test]\n    fn test_lerp() {\n        let result = run(\"lerp(0.0, 10.0, 0.5)\").unwrap();\n        assert_eq!(result, Value::Float(5.0));\n    }\n\n    #[test]\n    fn test_lerp_integers() {\n        let result = run(\"lerp(0, 100, 0)\").unwrap();\n        assert_eq!(result, Value::Float(0.0));\n    }\n\n    #[test]\n    fn test_gcd() {\n        let result = run(\"gcd(48, 18)\").unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    #[test]\n    fn test_gcd_negative() {\n        let result = run(\"gcd(-48, 18)\").unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    #[test]\n    fn test_lcm() {\n        let result = run(\"lcm(4, 6)\").unwrap();\n        assert_eq!(result, Value::Integer(12));\n    }\n\n    #[test]\n    fn test_lcm_zero() {\n        let result = run(\"lcm(0, 5)\").unwrap();\n        assert_eq!(result, Value::Integer(0));\n    }\n\n    #[test]\n    fn test_factorial() {\n        let result = run(\"factorial(5)\").unwrap();\n        assert_eq!(result, Value::Integer(120));\n    }\n\n    #[test]\n    fn test_factorial_zero() {\n        let result = run(\"factorial(0)\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_factorial_negative_error() {\n        let result = run(\"factorial(-1)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_factorial_too_big_error() {\n        let result = run(\"factorial(21)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_even() {\n        let result = run(\"is_even(4)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_odd() {\n        let result = run(\"is_odd(3)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    // ==================== Scots-themed Functions ====================\n\n    #[test]\n    fn test_clarty_list_duplicates() {\n        let result = run(\"clarty([1, 2, 2, 3])\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_clarty_list_no_duplicates() {\n        let result = run(\"clarty([1, 2, 3])\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_clarty_string() {\n        let result = run(r#\"clarty(\"hello\")\"#).unwrap(); // has duplicate 'l'\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_dreich_empty() {\n        let result = run(r#\"dreich(\"\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_dreich_same_chars() {\n        let result = run(r#\"dreich(\"aaaa\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_dreich_varied() {\n        let result = run(r#\"dreich(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_stoater_numbers() {\n        let result = run(\"stoater([1, 5, 3, 2])\").unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_stoater_floats() {\n        let result = run(\"stoater([1.0, 5.0, 3.0])\").unwrap();\n        assert_eq!(result, Value::Float(5.0));\n    }\n\n    #[test]\n    fn test_stoater_strings() {\n        let result = run(r#\"stoater([\"a\", \"abc\", \"ab\"])\"#).unwrap();\n        assert_eq!(result, Value::String(\"abc\".to_string())); // longest\n    }\n\n    #[test]\n    fn test_stoater_empty_list_error() {\n        let result = run(\"stoater([])\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_numpty_check_nil() {\n        let result = run(\"numpty_check(naething)\").unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"naething\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_numpty_check_empty_string() {\n        let result = run(r#\"numpty_check(\"\")\"#).unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"Empty string\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_numpty_check_valid() {\n        let result = run(\"numpty_check(42)\").unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"braw\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_bampot_mode() {\n        // Should return a list of same length\n        let result = run(\"len(bampot_mode([1, 2, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_crabbit_negative() {\n        let result = run(\"crabbit(-5)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_crabbit_positive() {\n        let result = run(\"crabbit(5)\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_crabbit_float() {\n        let result = run(\"crabbit(-3.14)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_gallus_large_number() {\n        let result = run(\"gallus(200)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_gallus_small_number() {\n        let result = run(\"gallus(50)\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_drookit_has_duplicates() {\n        let result = run(\"drookit([1, 2, 2, 3])\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_drookit_no_duplicates() {\n        let result = run(\"drookit([1, 2, 3])\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_glaikit_nil() {\n        let result = run(\"glaikit(naething)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_glaikit_zero() {\n        let result = run(\"glaikit(0)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_glaikit_valid() {\n        let result = run(\"glaikit(42)\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_cannie_valid() {\n        let result = run(\"cannie(500)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_geggie() {\n        let result = run(r#\"geggie(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"ho\".to_string()));\n    }\n\n    #[test]\n    fn test_geggie_empty() {\n        let result = run(r#\"geggie(\"\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"\".to_string()));\n    }\n\n    #[test]\n    fn test_banter() {\n        let result = run(r#\"banter(\"ab\", \"12\")\"#).unwrap();\n        if let Value::String(s) = result {\n            assert!(s.len() >= 2);\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    // ==================== Timing Functions ====================\n\n    #[test]\n    fn test_noo() {\n        let result = run(\"noo()\").unwrap();\n        if let Value::Integer(ts) = result {\n            assert!(ts > 0);\n        } else {\n            panic!(\"Expected integer\");\n        }\n    }\n\n    #[test]\n    fn test_tick() {\n        let result = run(\"tick()\").unwrap();\n        if let Value::Integer(ts) = result {\n            assert!(ts > 0);\n        } else {\n            panic!(\"Expected integer\");\n        }\n    }\n\n    #[test]\n    fn test_braw_time() {\n        let result = run(\"braw_time()\").unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\":\")); // Should contain time\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_haver() {\n        let result = run(\"haver()\").unwrap();\n        if let Value::String(s) = result {\n            assert!(!s.is_empty());\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_slainte() {\n        let result = run(\"slainte()\").unwrap();\n        if let Value::String(s) = result {\n            assert!(!s.is_empty());\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    // ==================== Dictionary Functions ====================\n\n    #[test]\n    fn test_dict_merge() {\n        let result = run(r#\"\nken d1 = {\"a\": 1}\nken d2 = {\"b\": 2}\nlen(keys(dict_merge(d1, d2)))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dict_merge_override() {\n        let result = run(r#\"\nken d1 = {\"a\": 1}\nken d2 = {\"a\": 2}\nken merged = dict_merge(d1, d2)\nmerged[\"a\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dict_get_existing() {\n        let result = run(r#\"dict_get({\"a\": 42}, \"a\", 0)\"#).unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_dict_get_default() {\n        let result = run(r#\"dict_get({\"a\": 1}, \"b\", 99)\"#).unwrap();\n        assert_eq!(result, Value::Integer(99));\n    }\n\n    #[test]\n    fn test_dict_has() {\n        let result = run(r#\"dict_has({\"a\": 1}, \"a\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_dict_has_missing() {\n        let result = run(r#\"dict_has({\"a\": 1}, \"b\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_dict_remove() {\n        let result = run(r#\"\nken d = dict_remove({\"a\": 1, \"b\": 2}, \"a\")\nlen(keys(d))\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_dict_invert() {\n        let result = run(r#\"\nken d = dict_invert({\"a\": \"1\", \"b\": \"2\"})\nd[\"1\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"a\".to_string()));\n    }\n\n    #[test]\n    fn test_items() {\n        let result = run(r#\"len(items({\"a\": 1, \"b\": 2}))\"#).unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_fae_pairs() {\n        let result = run(r#\"\nken d = fae_pairs([[\"a\", 1], [\"b\", 2]])\nd[\"a\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    // ==================== More String Functions ====================\n\n    #[test]\n    fn test_center() {\n        let result = run(r#\"center(\"hi\", 6, \"-\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"--hi--\".to_string()));\n    }\n\n    #[test]\n    fn test_is_upper() {\n        let result = run(r#\"is_upper(\"HELLO\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_upper_mixed() {\n        let result = run(r#\"is_upper(\"Hello\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_is_lower() {\n        let result = run(r#\"is_lower(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_swapcase() {\n        let result = run(r#\"swapcase(\"Hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hELLO\".to_string()));\n    }\n\n    #[test]\n    fn test_strip_left() {\n        let result = run(r#\"strip_left(\"xxxhello\", \"x\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_strip_right() {\n        let result = run(r#\"strip_right(\"helloyyy\", \"y\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_replace_first() {\n        let result = run(r#\"replace_first(\"hello hello\", \"hello\", \"hi\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hi hello\".to_string()));\n    }\n\n    #[test]\n    fn test_substr_between() {\n        let result = run(r#\"substr_between(\"Hello [World]!\", \"[\", \"]\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"World\".to_string()));\n    }\n\n    #[test]\n    fn test_substr_between_not_found() {\n        let result = run(r#\"substr_between(\"Hello World\", \"[\", \"]\")\"#).unwrap();\n        assert_eq!(result, Value::Nil);\n    }\n\n    // ==================== Ternary Operator ====================\n\n    #[test]\n    fn test_ternary_true() {\n        let result = run(\"ken x = gin aye than 1 ither 2\\nx\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_ternary_false() {\n        let result = run(\"ken x = gin nae than 1 ither 2\\nx\").unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_ternary_nested() {\n        let result = run(\"ken x = gin aye than (gin nae than 1 ither 2) ither 3\\nx\").unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    // ==================== More Edge Cases ====================\n\n    #[test]\n    fn test_list_concat() {\n        let result = run(\"len([1, 2] + [3, 4])\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_string_multiply() {\n        let result = run(r#\"\"ab\" * 3\"#).unwrap();\n        assert_eq!(result, Value::String(\"ababab\".to_string()));\n    }\n\n    #[test]\n    fn test_integer_multiply_string() {\n        let result = run(r#\"3 * \"ab\"\"#).unwrap();\n        assert_eq!(result, Value::String(\"ababab\".to_string()));\n    }\n\n    #[test]\n    fn test_modulo_floats() {\n        let result = run(\"7.5 % 2.5\").unwrap();\n        assert_eq!(result, Value::Float(0.0));\n    }\n\n    #[test]\n    fn test_division_by_zero_float() {\n        let result = run(\"5.0 / 0.0\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_modulo_by_zero() {\n        let result = run(\"5 % 0\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_contains_dict() {\n        let result = run(r#\"contains({\"a\": 1}, \"a\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_contains_dict_missing() {\n        let result = run(r#\"contains({\"a\": 1}, \"b\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_reverse_str_builtin() {\n        let result = run(r#\"reverse(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"olleh\".to_string()));\n    }\n\n    #[test]\n    fn test_reverse_error_invalid_type() {\n        let result = run(\"reverse(42)\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_birl_rotate() {\n        let result = run(r#\"\nken l = birl([1, 2, 3, 4], 1)\nl[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_birl_negative() {\n        let result = run(r#\"\nken l = birl([1, 2, 3, 4], -1)\nl[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_stooshie() {\n        // Just verify it returns a string of same length\n        let result = run(r#\"len(chars(stooshie(\"hello\")))\"#).unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_sclaff_deep_flatten() {\n        let result = run(\"len(sclaff([[1, [2, 3]], [[4]]]))\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_dram_singleton() {\n        // Should return something from the list\n        let result = run(\"dram([1])\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_dram_empty_list() {\n        let result = run(\"dram([])\").unwrap();\n        assert_eq!(result, Value::Nil);\n    }\n\n    #[test]\n    fn test_ceilidh_interleave() {\n        let result = run(\"len(ceilidh([1, 2], [3, 4]))\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_blether_format() {\n        let result = run(r#\"blether_format(\"Hello {name}!\", {\"name\": \"World\"})\"#).unwrap();\n        assert_eq!(result, Value::String(\"Hello World!\".to_string()));\n    }\n\n    #[test]\n    fn test_wheesht_aw() {\n        let result = run(r#\"wheesht_aw(\"  hello   world  \")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello world\".to_string()));\n    }\n\n    #[test]\n    fn test_scunner_check_pass() {\n        let result = run(r#\"scunner_check(42, \"integer\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_scunner_check_fail() {\n        let result = run(r#\"scunner_check(42, \"string\")\"#).unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"scunner\"));\n        } else {\n            panic!(\"Expected string error message\");\n        }\n    }\n\n    #[test]\n    fn test_wrang_sort() {\n        let result = run(r#\"wrang_sort(42, \"string\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_tattie_scone() {\n        let result = run(r#\"tattie_scone(\"yum\", 3)\"#).unwrap();\n        assert_eq!(result, Value::String(\"yum | yum | yum\".to_string()));\n    }\n\n    #[test]\n    fn test_haggis_hunt() {\n        let result = run(r#\"len(haggis_hunt(\"aba aba\", \"aba\"))\"#).unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_sporran_fill() {\n        let result = run(r#\"sporran_fill(\"hi\", 6, \"*\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"**hi**\".to_string()));\n    }\n\n    // ==================== Hex Conversion ====================\n\n    #[test]\n    fn test_tae_hex() {\n        let result = run(\"tae_hex(255)\").unwrap();\n        assert_eq!(result, Value::String(\"ff\".to_string()));\n    }\n\n    #[test]\n    fn test_fae_hex() {\n        let result = run(r#\"fae_hex(\"ff\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(255));\n    }\n\n    #[test]\n    fn test_fae_hex_invalid() {\n        let result = run(r#\"fae_hex(\"zz\")\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== Statistics Functions ====================\n\n    #[test]\n    fn test_minaw() {\n        let result = run(\"minaw([3, 1, 4, 1, 5])\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_maxaw() {\n        let result = run(\"maxaw([3, 1, 4, 1, 5])\").unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_range_o() {\n        let result = run(\"range_o([1, 5, 3])\").unwrap();\n        assert_eq!(result, Value::Float(4.0)); // 5 - 1 = 4\n    }\n\n    #[test]\n    fn test_sumaw_integers() {\n        let result = run(\"sumaw([1, 2, 3, 4])\").unwrap();\n        assert_eq!(result, Value::Integer(10));\n    }\n\n    #[test]\n    fn test_sumaw_floats() {\n        let result = run(\"sumaw([1.0, 2.0, 3.0])\").unwrap();\n        assert_eq!(result, Value::Float(6.0));\n    }\n\n    // ==================== Inheritance Tests ====================\n\n    #[test]\n    fn test_class_inheritance_method() {\n        let result = run(r#\"\nkin Animal {\n    dae speak() {\n        gie \"...\"\n    }\n}\nkin Dog fae Animal {\n    dae speak() {\n        gie \"Woof!\"\n    }\n}\nken d = Dog()\nd.speak()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"Woof!\".to_string()));\n    }\n\n    #[test]\n    fn test_inheritance_superclass_not_a_class() {\n        let result = run(r#\"\nken notAClass = 42\nkin Dog fae notAClass {\n    dae speak() { gie \"woof\" }\n}\n\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== Spread Operator ====================\n\n    #[test]\n    fn test_spread_list_expr() {\n        let result = run(r#\"\nken a = [1, 2]\nken b = [0, ...a, 3]\nlen(b)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_spread_string_in_list() {\n        let result = run(r#\"\nken s = \"ab\"\nken l = [...s]\nlen(l)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_spread_invalid_context() {\n        let result = run(\"...42\");\n        assert!(result.is_err());\n    }\n\n    // ==================== Index Set Tests ====================\n\n    #[test]\n    fn test_list_index_set_negative() {\n        let result = run(r#\"\nken l = [1, 2, 3]\nl[-1] = 99\nl[-1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(99));\n    }\n\n    #[test]\n    fn test_dict_index_set_non_string() {\n        let result = run(r#\"\nken d = {}\nd[42] = \"answer\"\nd[\"42\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"answer\".to_string()));\n    }\n\n    // ==================== Property Access/Set ====================\n\n    #[test]\n    fn test_set_property_on_invalid_type() {\n        let result = run(r#\"\nken x = 42\nx.foo = 5\n\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_get_property_on_invalid_type() {\n        let result = run(r#\"\nken x = 42\nx.foo\n\"#);\n        assert!(result.is_err());\n    }\n\n    // ==================== Interpreter Config Tests ====================\n\n    #[test]\n    fn test_interp_with_dir() {\n        let interp = Interpreter::with_dir(\"/tmp\");\n        assert!(!interp.has_prelude());\n    }\n\n    #[test]\n    fn test_interp_set_dir() {\n        let mut interp = Interpreter::new();\n        interp.set_current_dir(\"/tmp\");\n        // Should not panic\n    }\n\n    #[test]\n    fn test_interp_user_vars() {\n        let code = \"ken x = 42\\nken y = \\\"hello\\\"\";\n        let program = crate::parser::parse(code).unwrap();\n        let mut interp = Interpreter::new();\n        interp.interpret(&program).unwrap();\n        let vars = interp.get_user_variables();\n        assert!(vars.len() >= 2);\n    }\n\n    #[test]\n    fn test_interp_output() {\n        let code = r#\"blether \"test output\"\"#;\n        let program = crate::parser::parse(code).unwrap();\n        let mut interp = Interpreter::new();\n        interp.interpret(&program).unwrap();\n        let output = interp.get_output();\n        assert!(!output.is_empty());\n    }\n\n    // ==================== More Native Function Tests ====================\n\n    #[test]\n    fn test_coont_list() {\n        let result = run(\"coont([1, 2, 2, 3, 2], 2)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_coont_in_string() {\n        let result = run(r#\"coont(\"hello\", \"l\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_unique_integers() {\n        let result = run(\"len(unique([1, 2, 2, 3, 3, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_average_floats() {\n        let result = run(\"average([1.0, 2.0, 3.0, 4.0, 5.0])\").unwrap();\n        assert_eq!(result, Value::Float(3.0));\n    }\n\n    #[test]\n    fn test_average_int_list() {\n        let result = run(\"average([10, 20, 30])\").unwrap();\n        assert_eq!(result, Value::Float(20.0));\n    }\n\n    #[test]\n    fn test_median() {\n        let result = run(\"median([1.0, 2.0, 3.0])\").unwrap();\n        assert_eq!(result, Value::Float(2.0));\n    }\n\n    #[test]\n    fn test_median_even() {\n        let result = run(\"median([1.0, 2.0, 3.0, 4.0])\").unwrap();\n        assert_eq!(result, Value::Float(2.5));\n    }\n\n    #[test]\n    fn test_sumaw_list_integers() {\n        let result = run(\"sumaw([1, 2, 3, 4, 5])\").unwrap();\n        assert_eq!(result, Value::Integer(15));\n    }\n\n    #[test]\n    fn test_sumaw_list_floats() {\n        let result = run(\"sumaw([1.5, 2.5, 3.0])\").unwrap();\n        assert_eq!(result, Value::Float(7.0));\n    }\n\n    #[test]\n    fn test_product() {\n        let result = run(\"product([1, 2, 3, 4])\").unwrap();\n        assert_eq!(result, Value::Integer(24));\n    }\n\n    #[test]\n    fn test_product_floats() {\n        let result = run(\"product([2.0, 3.0, 4.0])\").unwrap();\n        assert_eq!(result, Value::Float(24.0));\n    }\n\n    #[test]\n    fn test_minaw_list() {\n        let result = run(\"minaw([5, 3, 8, 1, 9])\").unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_maxaw_list() {\n        let result = run(\"maxaw([5, 3, 8, 1, 9])\").unwrap();\n        assert_eq!(result, Value::Integer(9));\n    }\n\n    #[test]\n    fn test_wheesht_aw_string_trim() {\n        // wheesht_aw cleans and trims a string\n        let result = run(r#\"wheesht_aw(\"  hello   world  \")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello world\".to_string()));\n    }\n\n    #[test]\n    fn test_redd_up_with_nils() {\n        // redd_up filters out nil values from a list\n        let result = run(\"len(redd_up([1, naething, 2, naething, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_split_by_even_count() {\n        let result = run(r#\"\nken parts = split_by([1, 2, 3, 4, 5, 6], \"even\")\nlen(parts[0])\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_split_by_odd_count() {\n        let result = run(r#\"\nken parts = split_by([1, 2, 3, 4, 5, 6], \"odd\")\nlen(parts[0])\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== String Methods ====================\n\n    #[test]\n    fn test_upper() {\n        let result = run(r#\"upper(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"HELLO\".to_string()));\n    }\n\n    #[test]\n    fn test_lower() {\n        let result = run(r#\"lower(\"HELLO\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_wheesht_string() {\n        // Using wheesht to filter a string (removes whitespace-ish behavior via replace)\n        let result = run(r#\"replace(\"  hello  \", \" \", \"\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_split() {\n        let result = run(r#\"len(split(\"a,b,c\", \",\"))\"#).unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_join() {\n        let result = run(r#\"join([\"a\", \"b\", \"c\"], \"-\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"a-b-c\".to_string()));\n    }\n\n    #[test]\n    fn test_replace() {\n        let result = run(r#\"replace(\"hello\", \"l\", \"x\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"hexxo\".to_string()));\n    }\n\n    #[test]\n    fn test_starts_wi() {\n        let result = run(r#\"starts_wi(\"hello\", \"hel\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_starts_wi_false() {\n        let result = run(r#\"starts_wi(\"hello\", \"wor\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_ends_wi() {\n        let result = run(r#\"ends_wi(\"hello\", \"llo\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_ends_wi_false() {\n        let result = run(r#\"ends_wi(\"hello\", \"abc\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    // ==================== List Operations ====================\n\n    #[test]\n    fn test_shove_list() {\n        let result = run(r#\"\nken l = [1, 2, 3]\nshove(l, 4)\nlen(l)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_yank_list() {\n        let result = run(r#\"\nken l = [1, 2, 3]\nyank(l)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_chynge_list() {\n        // chynge inserts at an index\n        let result = run(r#\"\nken l = [1, 3, 4]\nken updated = chynge(l, 1, 2)\nupdated[1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dicht_list() {\n        // dicht removes at an index\n        let result = run(r#\"\nken l = [1, 2, 3]\nken updated = dicht(l, 1)\nlen(updated)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_redd_up_list() {\n        // redd_up removes nil values\n        let result = run(r#\"\nken l = [1, naething, 2, naething, 3]\nken cleaned = redd_up(l)\nlen(cleaned)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_flatten_nested() {\n        let result = run(\"len(flatten([[1, 2], [3, 4], [5]]))\").unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    // ==================== Type Conversion ====================\n\n    #[test]\n    fn test_tae_string() {\n        let result = run(\"tae_string(42)\").unwrap();\n        assert_eq!(result, Value::String(\"42\".to_string()));\n    }\n\n    #[test]\n    fn test_tae_int() {\n        let result = run(r#\"tae_int(\"42\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_tae_int_float() {\n        let result = run(\"tae_int(3.14)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_tae_float() {\n        let result = run(r#\"tae_float(\"3.14\")\"#).unwrap();\n        assert_eq!(result, Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_tae_float_int() {\n        let result = run(\"tae_float(42)\").unwrap();\n        assert_eq!(result, Value::Float(42.0));\n    }\n\n    // ==================== Math Functions ====================\n\n    #[test]\n    fn test_sqrt() {\n        let result = run(\"sqrt(16.0)\").unwrap();\n        assert_eq!(result, Value::Float(4.0));\n    }\n\n    #[test]\n    fn test_sqrt_int() {\n        let result = run(\"sqrt(9)\").unwrap();\n        assert_eq!(result, Value::Float(3.0));\n    }\n\n    #[test]\n    fn test_abs_int() {\n        let result = run(\"abs(-42)\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_abs_float() {\n        let result = run(\"abs(-3.14)\").unwrap();\n        assert_eq!(result, Value::Float(3.14));\n    }\n\n    #[test]\n    fn test_floor() {\n        let result = run(\"floor(3.7)\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_ceil() {\n        let result = run(\"ceil(3.2)\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_round() {\n        let result = run(\"round(3.5)\").unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_log() {\n        let result = run(\"log(2.718281828)\").unwrap();\n        if let Value::Float(n) = result {\n            assert!((n - 1.0).abs() < 0.01);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_exp() {\n        let result = run(\"exp(1.0)\").unwrap();\n        if let Value::Float(n) = result {\n            assert!((n - 2.718281828).abs() < 0.001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_sin() {\n        let result = run(\"sin(0.0)\").unwrap();\n        assert_eq!(result, Value::Float(0.0));\n    }\n\n    #[test]\n    fn test_cos() {\n        let result = run(\"cos(0.0)\").unwrap();\n        assert_eq!(result, Value::Float(1.0));\n    }\n\n    #[test]\n    fn test_tan() {\n        let result = run(\"tan(0.0)\").unwrap();\n        assert_eq!(result, Value::Float(0.0));\n    }\n\n    // ==================== Error Handling ====================\n\n    #[test]\n    fn test_throw() {\n        let result = run(r#\"fling(\"test error\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_catch_catches() {\n        let result = run(r#\"\nhae_a_bash {\n    fling(\"oops\")\n} gin_it_gangs_wrang e {\n    blether e\n}\n42\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_try_catch_error_value() {\n        // Test that we can catch and handle errors\n        let result = run(r#\"\nken caught = nae\nhae_a_bash {\n    fling(\"my error\")\n} gin_it_gangs_wrang e {\n    caught = aye\n}\ncaught\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    // ==================== Complex Expression Tests ====================\n\n    #[test]\n    fn test_nested_function_calls() {\n        let result = run(\"len(split(upper(\\\"hello,world\\\"), \\\",\\\"))\").unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_list_comprehension_like() {\n        // Using map-like functionality with shove\n        let result = run(r#\"\nken l = [1, 2, 3]\nken result = []\nfer x in l {\n    shove(result, x * 2)\n}\nresult[1]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(4));\n    }\n\n    #[test]\n    fn test_dict_iteration_keys() {\n        let result = run(r#\"\nken d = {\"a\": 1, \"b\": 2}\nken k = keys(d)\nlen(k)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_dict_iteration_values() {\n        let result = run(r#\"\nken d = {\"a\": 1, \"b\": 2}\nken v = values(d)\nlen(v)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    // ==================== Closure Tests ====================\n\n    #[test]\n    fn test_closure_captures_variable() {\n        let result = run(r#\"\nken x = 10\ndae add_x(n) {\n    gie n + x\n}\nadd_x(5)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(15));\n    }\n\n    #[test]\n    fn test_closure_counter() {\n        let result = run(r#\"\ndae make_counter() {\n    ken count = 0\n    dae counter() {\n        count = count + 1\n        gie count\n    }\n    gie counter\n}\nken c = make_counter()\nc()\nc()\nc()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    // ==================== More Edge Cases ====================\n\n    #[test]\n    fn test_empty_function() {\n        let result = run(r#\"\ndae empty() {\n}\nempty()\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Nil);\n    }\n\n    #[test]\n    fn test_recursive_function() {\n        let result = run(r#\"\ndae fib(n) {\n    gin n <= 1 {\n        gie n\n    }\n    gie fib(n - 1) + fib(n - 2)\n}\nfib(10)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(55));\n    }\n\n    #[test]\n    fn test_mutual_recursion() {\n        let result = run(r#\"\ndae is_even(n) {\n    gin n == 0 { gie aye }\n    gie is_odd(n - 1)\n}\ndae is_odd(n) {\n    gin n == 0 { gie nae }\n    gie is_even(n - 1)\n}\nis_even(10)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    // ==================== Native Function Coverage Tests ====================\n\n    #[test]\n    fn test_range_function() {\n        let result = run(r#\"\nken r = range(1, 5)\nken total = 0\nfer i in r {\n    total = total + i\n}\ntotal\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(10)); // 1+2+3+4 = 10\n    }\n\n    #[test]\n    fn test_min_floats() {\n        let result = run(\"min(3.5, 2.1)\").unwrap();\n        assert_eq!(result, Value::Float(2.1));\n    }\n\n    #[test]\n    fn test_max_floats() {\n        let result = run(\"max(3.5, 2.1)\").unwrap();\n        assert_eq!(result, Value::Float(3.5));\n    }\n\n    #[test]\n    fn test_floor_integer() {\n        let result = run(\"floor(42)\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_ceil_integer() {\n        let result = run(\"ceil(42)\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_round_integer() {\n        let result = run(\"round(42)\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_title_case_string() {\n        let result = run(r#\"title(\"hello world\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"Hello World\".to_string()));\n    }\n\n    #[test]\n    fn test_center_function() {\n        let result = run(r#\"center(\"hi\", 6, \" \")\"#).unwrap();\n        assert_eq!(result, Value::String(\"  hi  \".to_string()));\n    }\n\n    #[test]\n    fn test_repeat_function() {\n        let result = run(r#\"repeat(\"ab\", 3)\"#).unwrap();\n        assert_eq!(result, Value::String(\"ababab\".to_string()));\n    }\n\n    #[test]\n    fn test_lines_function() {\n        let result = run(r#\"\nken l = lines(\"one\ntwo\nthree\")\nlen(l)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_words_split() {\n        let result = run(r#\"len(words(\"hello beautiful world\"))\"#).unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_is_alpha_letter() {\n        let result = run(r#\"is_alpha(\"hello\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_alpha_mixed() {\n        let result = run(r#\"is_alpha(\"hello123\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_is_digit_numeric() {\n        let result = run(r#\"is_digit(\"12345\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_digit_alphanumeric() {\n        let result = run(r#\"is_digit(\"123abc\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_is_space_whitespace() {\n        let result = run(r#\"is_space(\"   \")\"#).unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_is_space_with_chars() {\n        let result = run(r#\"is_space(\"  a  \")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_pad_left_function() {\n        let result = run(r#\"pad_left(\"42\", 5, \"0\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"00042\".to_string()));\n    }\n\n    #[test]\n    fn test_pad_right_function() {\n        let result = run(r#\"pad_right(\"42\", 5, \"0\")\"#).unwrap();\n        assert_eq!(result, Value::String(\"42000\".to_string()));\n    }\n\n    #[test]\n    fn test_index_of_found() {\n        let result = run(r#\"index_of(\"hello\", \"l\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(2));\n    }\n\n    #[test]\n    fn test_index_of_not_found() {\n        let result = run(r#\"index_of(\"hello\", \"z\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(-1));\n    }\n\n    #[test]\n    fn test_ord_function() {\n        let result = run(r#\"ord(\"A\")\"#).unwrap();\n        assert_eq!(result, Value::Integer(65));\n    }\n\n    #[test]\n    fn test_chr_function() {\n        let result = run(\"chr(65)\").unwrap();\n        assert_eq!(result, Value::String(\"A\".to_string()));\n    }\n\n    #[test]\n    fn test_chr_unicode() {\n        let result = run(\"chr(128512)\").unwrap();\n        assert_eq!(result, Value::String(\"\".to_string()));\n    }\n\n    #[test]\n    fn test_tae_bool_truthy() {\n        let result = run(\"tae_bool(1)\").unwrap();\n        assert_eq!(result, Value::Bool(true));\n    }\n\n    #[test]\n    fn test_tae_bool_falsy() {\n        let result = run(\"tae_bool(0)\").unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_scran_string_range() {\n        let result = run(r#\"scran(\"hello\", 1, 4)\"#).unwrap();\n        assert_eq!(result, Value::String(\"ell\".to_string()));\n    }\n\n    #[test]\n    fn test_scran_list_range() {\n        let result = run(\"len(scran([1,2,3,4,5], 1, 4))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_append_file() {\n        // Test that append_file function exists (may error on missing file)\n        let result = run(r#\"append_file(\"/tmp/nonexistent_test\", \"data\")\"#);\n        // Just checking it doesn't crash - file may or may not exist\n        assert!(result.is_ok() || result.is_err());\n    }\n\n    #[test]\n    fn test_file_exists_false() {\n        let result = run(r#\"file_exists(\"/nonexistent/path/to/file\")\"#).unwrap();\n        assert_eq!(result, Value::Bool(false));\n    }\n\n    #[test]\n    fn test_read_lines_error() {\n        let result = run(r#\"read_lines(\"/nonexistent/path\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_read_file_error() {\n        let result = run(r#\"read_file(\"/nonexistent/path\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_json_parse_object() {\n        let result = run(r#\"\nken obj = json_parse(\"{\\\"a\\\": 1}\")\nobj[\"a\"]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_json_stringify_dict() {\n        let result = run(r#\"json_stringify({\"a\": 1})\"#).unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"\\\"a\\\"\") && s.contains(\"1\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_json_pretty_format() {\n        let result = run(r#\"json_pretty({\"a\": 1})\"#).unwrap();\n        if let Value::String(s) = result {\n            assert!(s.contains(\"a\"));\n        } else {\n            panic!(\"Expected string\");\n        }\n    }\n\n    #[test]\n    fn test_sin_pi() {\n        let result = run(\"sin(3.14159265359)\").unwrap();\n        if let Value::Float(n) = result {\n            assert!(n.abs() < 0.0001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_cos_pi() {\n        let result = run(\"cos(3.14159265359)\").unwrap();\n        if let Value::Float(n) = result {\n            assert!((n + 1.0).abs() < 0.0001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_tan_function() {\n        let result = run(\"tan(0.785398)\").unwrap();\n        if let Value::Float(n) = result {\n            assert!((n - 1.0).abs() < 0.001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_atan2_function() {\n        let result = run(\"atan2(1.0, 1.0)\").unwrap();\n        if let Value::Float(n) = result {\n            assert!((n - 0.785398).abs() < 0.001);\n        } else {\n            panic!(\"Expected float\");\n        }\n    }\n\n    #[test]\n    fn test_hypot_function() {\n        let result = run(\"hypot(3.0, 4.0)\").unwrap();\n        assert_eq!(result, Value::Float(5.0));\n    }\n\n    #[test]\n    fn test_pow_integer_exponent() {\n        let result = run(\"pow(2, 10)\").unwrap();\n        assert_eq!(result, Value::Integer(1024));\n    }\n\n    #[test]\n    fn test_pow_float() {\n        let result = run(\"pow(2.0, 3.0)\").unwrap();\n        assert_eq!(result, Value::Float(8.0));\n    }\n\n    #[test]\n    fn test_gcd_function() {\n        let result = run(\"gcd(48, 18)\").unwrap();\n        assert_eq!(result, Value::Integer(6));\n    }\n\n    #[test]\n    fn test_lcm_function() {\n        let result = run(\"lcm(4, 6)\").unwrap();\n        assert_eq!(result, Value::Integer(12));\n    }\n\n    #[test]\n    fn test_zip_lists() {\n        let result = run(r#\"\nken z = zip([1, 2, 3], [\"a\", \"b\", \"c\"])\nlen(z)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_enumerate_function() {\n        let result = run(r#\"\nken e = enumerate([\"a\", \"b\", \"c\"])\nlen(e)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_unique_function() {\n        let result = run(\"len(unique([1, 2, 2, 3, 3, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_uniq_function() {\n        // uniq is alias for unique\n        let result = run(\"len(uniq([1, 1, 2, 2, 3]))\").unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n\n    #[test]\n    fn test_sort_numbers() {\n        let result = run(r#\"\nken s = sort([3, 1, 4, 1, 5, 9])\ns[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(1));\n    }\n\n    #[test]\n    fn test_sort_strings_alpha() {\n        let result = run(r#\"\nken s = sort([\"banana\", \"apple\", \"cherry\"])\ns[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::String(\"apple\".to_string()));\n    }\n\n    #[test]\n    fn test_shuffle_function() {\n        let result = run(r#\"\nken l = [1, 2, 3, 4, 5]\nken s = shuffle(l)\nlen(s)\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(5));\n    }\n\n    #[test]\n    fn test_birl_rotate_list() {\n        let result = run(r#\"\nken l = [1, 2, 3, 4, 5]\nken r = birl(l, 2)\nr[0]\n\"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(3));\n    }\n}\n","traces":[{"line":39,"address":[55206080],"length":1,"stats":{"Line":0}},{"line":40,"address":[54897151],"length":1,"stats":{"Line":0}},{"line":49,"address":[55465821,55465827,55465280],"length":1,"stats":{"Line":6}},{"line":50,"address":[55465326,55465383],"length":1,"stats":{"Line":6}},{"line":53,"address":[55141722],"length":1,"stats":{"Line":9}},{"line":55,"address":[55465515,55465645],"length":1,"stats":{"Line":6}},{"line":56,"address":[55141818],"length":1,"stats":{"Line":3}},{"line":57,"address":[53785574],"length":1,"stats":{"Line":3}},{"line":64,"address":[54629660,54629666,54629456],"length":1,"stats":{"Line":12}},{"line":65,"address":[55137972,55137924],"length":1,"stats":{"Line":7}},{"line":66,"address":[53781771,53781723],"length":1,"stats":{"Line":6}},{"line":71,"address":[53780480],"length":1,"stats":{"Line":0}},{"line":72,"address":[54628286],"length":1,"stats":{"Line":0}},{"line":77,"address":[55142112,55142277,55142283],"length":1,"stats":{"Line":0}},{"line":78,"address":[53785844,53785892],"length":1,"stats":{"Line":0}},{"line":79,"address":[55466017,55465959],"length":1,"stats":{"Line":0}},{"line":84,"address":[55136320,55136706,55136700],"length":1,"stats":{"Line":0}},{"line":85,"address":[55459963,55460027],"length":1,"stats":{"Line":0}},{"line":86,"address":[54628013,54628066,54627987,54627933,54628198],"length":1,"stats":{"Line":0}},{"line":91,"address":[53792560,53793066,53793072],"length":1,"stats":{"Line":0}},{"line":92,"address":[54640663],"length":1,"stats":{"Line":0}},{"line":93,"address":[55148859,55148911],"length":1,"stats":{"Line":0}},{"line":94,"address":[53792671,53793038],"length":1,"stats":{"Line":0}},{"line":97,"address":[55472917,55472865],"length":1,"stats":{"Line":0}},{"line":98,"address":[55148993],"length":1,"stats":{"Line":0}},{"line":99,"address":[55473209,55473163],"length":1,"stats":{"Line":0}},{"line":104,"address":[53794064],"length":1,"stats":{"Line":0}},{"line":105,"address":[54642221],"length":1,"stats":{"Line":0}},{"line":109,"address":[55477568],"length":1,"stats":{"Line":0}},{"line":110,"address":[53797201],"length":1,"stats":{"Line":0}},{"line":114,"address":[53794112],"length":1,"stats":{"Line":1}},{"line":115,"address":[55150388],"length":1,"stats":{"Line":1}},{"line":116,"address":[55150442],"length":1,"stats":{"Line":1}},{"line":117,"address":[53794177],"length":1,"stats":{"Line":1}},{"line":118,"address":[55474440],"length":1,"stats":{"Line":0}},{"line":119,"address":[54642335],"length":1,"stats":{"Line":0}},{"line":120,"address":[54642342],"length":1,"stats":{"Line":0}},{"line":121,"address":[53794205],"length":1,"stats":{"Line":0}},{"line":122,"address":[55150435],"length":1,"stats":{"Line":0}},{"line":127,"address":[53794224],"length":1,"stats":{"Line":23}},{"line":128,"address":[54642376],"length":1,"stats":{"Line":27}},{"line":174,"address":[54573178,54573206,54572320],"length":1,"stats":{"Line":3}},{"line":175,"address":[54572337],"length":1,"stats":{"Line":3}},{"line":178,"address":[54572420],"length":1,"stats":{"Line":9}},{"line":181,"address":[53726413],"length":1,"stats":{"Line":27}},{"line":184,"address":[54572596,54572484],"length":1,"stats":{"Line":50}},{"line":186,"address":[53622665,53622656],"length":1,"stats":{"Line":23}},{"line":187,"address":[54572569],"length":1,"stats":{"Line":27}},{"line":190,"address":[53726531],"length":1,"stats":{"Line":27}},{"line":193,"address":[54572617],"length":1,"stats":{"Line":23}},{"line":195,"address":[55404782],"length":1,"stats":{"Line":27}},{"line":196,"address":[53726657],"length":1,"stats":{"Line":23}},{"line":197,"address":[54454304,54454288],"length":1,"stats":{"Line":50}},{"line":202,"address":[53726791],"length":1,"stats":{"Line":27}},{"line":207,"address":[53678656,53678755],"length":1,"stats":{"Line":0}},{"line":208,"address":[54523387,54523281,54523320],"length":1,"stats":{"Line":0}},{"line":210,"address":[55035078],"length":1,"stats":{"Line":0}},{"line":215,"address":[53557824],"length":1,"stats":{"Line":0}},{"line":216,"address":[54914092],"length":1,"stats":{"Line":0}},{"line":221,"address":[54914064],"length":1,"stats":{"Line":0}},{"line":222,"address":[54914069],"length":1,"stats":{"Line":0}},{"line":226,"address":[54902256],"length":1,"stats":{"Line":0}},{"line":228,"address":[54902276],"length":1,"stats":{"Line":0}},{"line":229,"address":[55211540],"length":1,"stats":{"Line":0}},{"line":233,"address":[54385969,54384656,54385963],"length":1,"stats":{"Line":0}},{"line":234,"address":[53551065],"length":1,"stats":{"Line":0}},{"line":238,"address":[53551090],"length":1,"stats":{"Line":0}},{"line":239,"address":[55216906,55216971],"length":1,"stats":{"Line":0}},{"line":241,"address":[53551693,53551320,53551583],"length":1,"stats":{"Line":0}},{"line":242,"address":[54907746],"length":1,"stats":{"Line":0}},{"line":243,"address":[54205856,54205881],"length":1,"stats":{"Line":0}},{"line":244,"address":[53551568],"length":1,"stats":{"Line":0}},{"line":245,"address":[55217434],"length":1,"stats":{"Line":0}},{"line":246,"address":[54385341],"length":1,"stats":{"Line":0}},{"line":247,"address":[54907980,54907692,54907840],"length":1,"stats":{"Line":0}},{"line":249,"address":[54908026],"length":1,"stats":{"Line":0}},{"line":261,"address":[55330208],"length":1,"stats":{"Line":2}},{"line":262,"address":[54498108],"length":1,"stats":{"Line":2}},{"line":267,"address":[54379456],"length":1,"stats":{"Line":2}},{"line":268,"address":[55211573],"length":1,"stats":{"Line":2}},{"line":272,"address":[54573548,54573554,54573248],"length":1,"stats":{"Line":26}},{"line":273,"address":[54573278],"length":1,"stats":{"Line":22}},{"line":274,"address":[55405427],"length":1,"stats":{"Line":0}},{"line":275,"address":[53727322,53727241],"length":1,"stats":{"Line":0}},{"line":280,"address":[53558161,53557856,53558155],"length":1,"stats":{"Line":3}},{"line":281,"address":[54914142],"length":1,"stats":{"Line":3}},{"line":282,"address":[55223938],"length":1,"stats":{"Line":0}},{"line":283,"address":[54391865,54391946],"length":1,"stats":{"Line":0}},{"line":289,"address":[53093626,53093351,53093312],"length":1,"stats":{"Line":2}},{"line":290,"address":[55742624],"length":1,"stats":{"Line":2}},{"line":291,"address":[55742771,55742736,55742666],"length":1,"stats":{"Line":4}},{"line":292,"address":[53093598],"length":1,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[53084124,53084085,53084023],"length":1,"stats":{"Line":4}},{"line":301,"address":[55357392,55358454,55358863],"length":1,"stats":{"Line":2}},{"line":302,"address":[54525318],"length":1,"stats":{"Line":2}},{"line":303,"address":[53680712,53680653],"length":1,"stats":{"Line":4}},{"line":304,"address":[53680727],"length":1,"stats":{"Line":2}},{"line":307,"address":[54525500,54525565],"length":1,"stats":{"Line":4}},{"line":309,"address":[53680993],"length":1,"stats":{"Line":2}},{"line":313,"address":[53681121],"length":1,"stats":{"Line":2}},{"line":315,"address":[55358016,55358076],"length":1,"stats":{"Line":4}},{"line":317,"address":[55038095],"length":1,"stats":{"Line":3}},{"line":318,"address":[54525935],"length":1,"stats":{"Line":2}},{"line":319,"address":[53681579,53681656],"length":1,"stats":{"Line":4}},{"line":320,"address":[55037995,55037947],"length":1,"stats":{"Line":4}},{"line":326,"address":[55357876],"length":1,"stats":{"Line":7}},{"line":327,"address":[55357931],"length":1,"stats":{"Line":3}},{"line":332,"address":[54910770,54911208,54909232],"length":1,"stats":{"Line":0}},{"line":333,"address":[54909262],"length":1,"stats":{"Line":0}},{"line":334,"address":[53553126],"length":1,"stats":{"Line":0}},{"line":342,"address":[54909554],"length":1,"stats":{"Line":0}},{"line":344,"address":[54909271],"length":1,"stats":{"Line":0}},{"line":345,"address":[53553071],"length":1,"stats":{"Line":0}},{"line":346,"address":[55495504,55495680,55495531,55495702],"length":1,"stats":{"Line":0}},{"line":348,"address":[54386874,54386782],"length":1,"stats":{"Line":0}},{"line":350,"address":[55219090,55219018],"length":1,"stats":{"Line":0}},{"line":353,"address":[55219215,55219297],"length":1,"stats":{"Line":0}},{"line":354,"address":[53553625,53553762,53553679],"length":1,"stats":{"Line":0}},{"line":355,"address":[55219643,55219714],"length":1,"stats":{"Line":0}},{"line":356,"address":[54387743],"length":1,"stats":{"Line":0}},{"line":358,"address":[54910294,54910361],"length":1,"stats":{"Line":0}},{"line":359,"address":[54387971,54388024],"length":1,"stats":{"Line":0}},{"line":361,"address":[55220100],"length":1,"stats":{"Line":0}},{"line":362,"address":[55220107],"length":1,"stats":{"Line":0}},{"line":364,"address":[53553916],"length":1,"stats":{"Line":0}},{"line":366,"address":[54388442],"length":1,"stats":{"Line":0}},{"line":367,"address":[54387713,54388337],"length":1,"stats":{"Line":0}},{"line":377,"address":[53553642],"length":1,"stats":{"Line":0}},{"line":378,"address":[54909897],"length":1,"stats":{"Line":0}},{"line":383,"address":[54379472],"length":1,"stats":{"Line":2}},{"line":384,"address":[53546101],"length":1,"stats":{"Line":2}},{"line":387,"address":[54392080,54491368,54491374],"length":1,"stats":{"Line":11}},{"line":390,"address":[53558226,53560648],"length":1,"stats":{"Line":17}},{"line":391,"address":[53560485],"length":1,"stats":{"Line":5}},{"line":392,"address":[55576385,55576411,55573760],"length":1,"stats":{"Line":22}},{"line":393,"address":[53617477,53617456,53422748,53425351,53422686],"length":1,"stats":{"Line":0}},{"line":395,"address":[55574060,55573958],"length":1,"stats":{"Line":0}},{"line":396,"address":[54254528],"length":1,"stats":{"Line":0}},{"line":397,"address":[55574434,55575369],"length":1,"stats":{"Line":0}},{"line":398,"address":[53423176,53423656],"length":1,"stats":{"Line":0}},{"line":399,"address":[52865086,52866102],"length":1,"stats":{"Line":0}},{"line":400,"address":[53423490,53423142],"length":1,"stats":{"Line":0}},{"line":401,"address":[55574869,55574298],"length":1,"stats":{"Line":0}},{"line":402,"address":[53423244,53423906],"length":1,"stats":{"Line":0}},{"line":403,"address":[53424031,53423278],"length":1,"stats":{"Line":0}},{"line":404,"address":[54255660,54254816],"length":1,"stats":{"Line":0}},{"line":405,"address":[52864807,52866227],"length":1,"stats":{"Line":0}},{"line":407,"address":[53423080,53424656],"length":1,"stats":{"Line":0}},{"line":408,"address":[53422926,53424781],"length":1,"stats":{"Line":0}},{"line":411,"address":[53077248,52866683,53077269,52866765],"length":1,"stats":{"Line":0}},{"line":413,"address":[54256729],"length":1,"stats":{"Line":0}},{"line":417,"address":[55227047,55226757],"length":1,"stats":{"Line":19}},{"line":418,"address":[54917063],"length":1,"stats":{"Line":7}},{"line":419,"address":[54394799,54394876],"length":1,"stats":{"Line":28}},{"line":420,"address":[53449794,53449876],"length":1,"stats":{"Line":8}},{"line":421,"address":[53024259,53024401],"length":1,"stats":{"Line":6}},{"line":422,"address":[54281499,54281719],"length":1,"stats":{"Line":8}},{"line":423,"address":[55710710,55711090],"length":1,"stats":{"Line":4}},{"line":424,"address":[55711292,55710745],"length":1,"stats":{"Line":6}},{"line":425,"address":[54281425,54282392],"length":1,"stats":{"Line":4}},{"line":431,"address":[54395293,54395003],"length":1,"stats":{"Line":22}},{"line":432,"address":[55227230],"length":1,"stats":{"Line":8}},{"line":433,"address":[53508779,53508528],"length":1,"stats":{"Line":50}},{"line":434,"address":[54340137,54340067],"length":1,"stats":{"Line":6}},{"line":439,"address":[54395651,54395361],"length":1,"stats":{"Line":35}},{"line":440,"address":[54395476],"length":1,"stats":{"Line":9}},{"line":441,"address":[55674745,55674448],"length":1,"stats":{"Line":53}},{"line":442,"address":[55674484,55674556],"length":1,"stats":{"Line":6}},{"line":447,"address":[55228121,55227831],"length":1,"stats":{"Line":35}},{"line":448,"address":[53561776],"length":1,"stats":{"Line":10}},{"line":449,"address":[54918149,54918071],"length":1,"stats":{"Line":54}},{"line":452,"address":[53566784,53566895,53567689,53566822],"length":1,"stats":{"Line":11}},{"line":453,"address":[54398479],"length":1,"stats":{"Line":2}},{"line":454,"address":[53567054],"length":1,"stats":{"Line":3}},{"line":455,"address":[55661113,55661281],"length":1,"stats":{"Line":9}},{"line":456,"address":[53057875],"length":1,"stats":{"Line":4}},{"line":457,"address":[54398799],"length":1,"stats":{"Line":5}},{"line":458,"address":[53567327,53617664,53617694],"length":1,"stats":{"Line":8}},{"line":459,"address":[55661155,55661283],"length":1,"stats":{"Line":4}},{"line":460,"address":[53058088],"length":1,"stats":{"Line":2}},{"line":462,"address":[53058047,53057535],"length":1,"stats":{"Line":4}},{"line":469,"address":[54918256,54918519],"length":1,"stats":{"Line":39}},{"line":470,"address":[54918355],"length":1,"stats":{"Line":10}},{"line":471,"address":[53562138,53562216],"length":1,"stats":{"Line":56}},{"line":474,"address":[52857799,52857734,52858422,52857696],"length":1,"stats":{"Line":23}},{"line":475,"address":[52857889],"length":1,"stats":{"Line":4}},{"line":476,"address":[55666019],"length":1,"stats":{"Line":2}},{"line":477,"address":[54340825,54340676],"length":1,"stats":{"Line":8}},{"line":478,"address":[55666174],"length":1,"stats":{"Line":5}},{"line":479,"address":[53509262],"length":1,"stats":{"Line":3}},{"line":480,"address":[54340798,54447328,54447360],"length":1,"stats":{"Line":7}},{"line":481,"address":[55665901,55666251],"length":1,"stats":{"Line":4}},{"line":487,"address":[55228547,55228837],"length":1,"stats":{"Line":39}},{"line":488,"address":[53562422],"length":1,"stats":{"Line":10}},{"line":489,"address":[54241028,54240976,54240496],"length":1,"stats":{"Line":63}},{"line":490,"address":[55558070,55558135,55558525],"length":1,"stats":{"Line":9}},{"line":491,"address":[53409129,53409184],"length":1,"stats":{"Line":6}},{"line":492,"address":[55558397],"length":1,"stats":{"Line":3}},{"line":494,"address":[54240987,54240649],"length":1,"stats":{"Line":7}},{"line":500,"address":[55229195,55228905],"length":1,"stats":{"Line":40}},{"line":501,"address":[54919001],"length":1,"stats":{"Line":10}},{"line":502,"address":[54919040,54919118],"length":1,"stats":{"Line":66}},{"line":503,"address":[54286543,54286470,54286855],"length":1,"stats":{"Line":9}},{"line":504,"address":[52998353,52998401],"length":1,"stats":{"Line":6}},{"line":505,"address":[54286734],"length":1,"stats":{"Line":3}},{"line":506,"address":[52998524,53079100,53079088],"length":1,"stats":{"Line":7}},{"line":508,"address":[55670701,55670913],"length":1,"stats":{"Line":4}},{"line":514,"address":[54919488,54919225],"length":1,"stats":{"Line":42}},{"line":515,"address":[55229378],"length":1,"stats":{"Line":10}},{"line":516,"address":[54919363,54919441],"length":1,"stats":{"Line":66}},{"line":517,"address":[53599462,53600140,53599543],"length":1,"stats":{"Line":9}},{"line":518,"address":[54431073,54431166],"length":1,"stats":{"Line":7}},{"line":519,"address":[53067868],"length":1,"stats":{"Line":4}},{"line":520,"address":[53067991],"length":1,"stats":{"Line":4}},{"line":521,"address":[53607941,53599770,53607904],"length":1,"stats":{"Line":10}},{"line":522,"address":[55673436,55673354],"length":1,"stats":{"Line":4}},{"line":523,"address":[53599883],"length":1,"stats":{"Line":4}},{"line":525,"address":[54431605,54431089],"length":1,"stats":{"Line":7}},{"line":531,"address":[55229621,55229911],"length":1,"stats":{"Line":42}},{"line":532,"address":[54919647],"length":1,"stats":{"Line":10}},{"line":533,"address":[55700213,55699600,55700265],"length":1,"stats":{"Line":66}},{"line":534,"address":[52988527,52988454,52989079],"length":1,"stats":{"Line":6}},{"line":535,"address":[53516561,53516616],"length":1,"stats":{"Line":4}},{"line":536,"address":[52988835],"length":1,"stats":{"Line":2}},{"line":538,"address":[54348081,54348597],"length":1,"stats":{"Line":4}},{"line":544,"address":[54919871,54920134],"length":1,"stats":{"Line":42}},{"line":545,"address":[54919970],"length":1,"stats":{"Line":10}},{"line":546,"address":[52925407,52924768],"length":1,"stats":{"Line":66}},{"line":547,"address":[52924871,52925405,52924806],"length":1,"stats":{"Line":4}},{"line":548,"address":[55716031,55716383],"length":1,"stats":{"Line":2}},{"line":549,"address":[52925253],"length":1,"stats":{"Line":2}},{"line":554,"address":[54398225,54398515],"length":1,"stats":{"Line":43}},{"line":555,"address":[55230452],"length":1,"stats":{"Line":10}},{"line":556,"address":[55230491,55230568],"length":1,"stats":{"Line":72}},{"line":557,"address":[54214118,54214191],"length":1,"stats":{"Line":14}},{"line":558,"address":[53011655,53011733],"length":1,"stats":{"Line":10}},{"line":559,"address":[54214412,54214291],"length":1,"stats":{"Line":11}},{"line":560,"address":[55598595,55598840],"length":1,"stats":{"Line":0}},{"line":566,"address":[53564261,53564524],"length":1,"stats":{"Line":47}},{"line":567,"address":[54920616],"length":1,"stats":{"Line":12}},{"line":568,"address":[55230926,55230849],"length":1,"stats":{"Line":71}},{"line":569,"address":[55521991,55521926,55522087],"length":1,"stats":{"Line":9}},{"line":570,"address":[53440236],"length":1,"stats":{"Line":3}},{"line":571,"address":[52874190],"length":1,"stats":{"Line":3}},{"line":573,"address":[54271883],"length":1,"stats":{"Line":2}},{"line":574,"address":[54272006,54271660],"length":1,"stats":{"Line":0}},{"line":580,"address":[53564584,53564847],"length":1,"stats":{"Line":47}},{"line":581,"address":[53564683],"length":1,"stats":{"Line":13}},{"line":582,"address":[54437664,54438226],"length":1,"stats":{"Line":71}},{"line":583,"address":[53606271,53606198,53606371],"length":1,"stats":{"Line":10}},{"line":584,"address":[53606412],"length":1,"stats":{"Line":3}},{"line":585,"address":[52942750],"length":1,"stats":{"Line":3}},{"line":587,"address":[52942858],"length":1,"stats":{"Line":2}},{"line":588,"address":[55615737,55615392],"length":1,"stats":{"Line":0}},{"line":594,"address":[53564907,53565170],"length":1,"stats":{"Line":48}},{"line":595,"address":[54399414],"length":1,"stats":{"Line":13}},{"line":596,"address":[54921301,54921379],"length":1,"stats":{"Line":66}},{"line":599,"address":[52876150,52876112,52876215,52876556],"length":1,"stats":{"Line":18}},{"line":600,"address":[54431915,54431983],"length":1,"stats":{"Line":8}},{"line":601,"address":[54431844],"length":1,"stats":{"Line":3}},{"line":602,"address":[54431803,54432076],"length":1,"stats":{"Line":0}},{"line":608,"address":[53565230,53565493],"length":1,"stats":{"Line":53}},{"line":609,"address":[54399772],"length":1,"stats":{"Line":14}},{"line":610,"address":[54921624,54921702],"length":1,"stats":{"Line":54}},{"line":613,"address":[52858486,52858551,52858892,52858448],"length":1,"stats":{"Line":17}},{"line":614,"address":[53440827,53440895],"length":1,"stats":{"Line":9}},{"line":615,"address":[53440756],"length":1,"stats":{"Line":2}},{"line":616,"address":[55572307,55572579],"length":1,"stats":{"Line":0}},{"line":622,"address":[53565816,53565553],"length":1,"stats":{"Line":47}},{"line":623,"address":[53565652],"length":1,"stats":{"Line":20}},{"line":624,"address":[54921947,54922025],"length":1,"stats":{"Line":54}},{"line":627,"address":[54283334,54283296,54283407,54283749],"length":1,"stats":{"Line":6}},{"line":628,"address":[54283547,54283615],"length":1,"stats":{"Line":4}},{"line":629,"address":[55521372],"length":1,"stats":{"Line":2}},{"line":630,"address":[55521331,55521603],"length":1,"stats":{"Line":0}},{"line":636,"address":[54922132,54922395],"length":1,"stats":{"Line":47}},{"line":637,"address":[53565975],"length":1,"stats":{"Line":20}},{"line":638,"address":[55232639,55232716],"length":1,"stats":{"Line":55}},{"line":641,"address":[54338620,54338303,54338230,54338192],"length":1,"stats":{"Line":6}},{"line":642,"address":[54338529,54338406],"length":1,"stats":{"Line":4}},{"line":643,"address":[54338449,54338367],"length":1,"stats":{"Line":4}},{"line":644,"address":[53506827,53507078],"length":1,"stats":{"Line":4}},{"line":650,"address":[53566199,53566462],"length":1,"stats":{"Line":48}},{"line":651,"address":[53566298],"length":1,"stats":{"Line":20}},{"line":652,"address":[53566337,53566415],"length":1,"stats":{"Line":56}},{"line":655,"address":[54293168,54293206,54294146,54293279],"length":1,"stats":{"Line":3}},{"line":656,"address":[54293406],"length":1,"stats":{"Line":1}},{"line":657,"address":[54293801,54293415,54294092,54293943,54293853],"length":1,"stats":{"Line":4}},{"line":658,"address":[53462359,53462344],"length":1,"stats":{"Line":2}},{"line":659,"address":[54293903],"length":1,"stats":{"Line":1}},{"line":661,"address":[55696486,55696412],"length":1,"stats":{"Line":0}},{"line":667,"address":[52872058],"length":1,"stats":{"Line":0}},{"line":668,"address":[53461854],"length":1,"stats":{"Line":0}},{"line":669,"address":[52872178],"length":1,"stats":{"Line":0}},{"line":670,"address":[52872188],"length":1,"stats":{"Line":0}},{"line":671,"address":[53461986],"length":1,"stats":{"Line":0}},{"line":672,"address":[55696052],"length":1,"stats":{"Line":0}},{"line":673,"address":[52872218],"length":1,"stats":{"Line":0}},{"line":674,"address":[54293520],"length":1,"stats":{"Line":0}},{"line":675,"address":[54293440,54293623],"length":1,"stats":{"Line":0}},{"line":677,"address":[52872236],"length":1,"stats":{"Line":0}},{"line":678,"address":[52872256],"length":1,"stats":{"Line":0}},{"line":680,"address":[52872019,52872796],"length":1,"stats":{"Line":0}},{"line":686,"address":[53566784,53566522],"length":1,"stats":{"Line":48}},{"line":687,"address":[54922877],"length":1,"stats":{"Line":20}},{"line":688,"address":[55233355,55233429],"length":1,"stats":{"Line":57}},{"line":689,"address":[53420324,53420267],"length":1,"stats":{"Line":2}},{"line":690,"address":[52909173],"length":1,"stats":{"Line":1}},{"line":695,"address":[54401731,54401444],"length":1,"stats":{"Line":48}},{"line":696,"address":[54401559],"length":1,"stats":{"Line":20}},{"line":697,"address":[55603424,55604161],"length":1,"stats":{"Line":56}},{"line":698,"address":[53602926],"length":1,"stats":{"Line":0}},{"line":699,"address":[53603177,53602991],"length":1,"stats":{"Line":0}},{"line":700,"address":[53603065],"length":1,"stats":{"Line":0}},{"line":701,"address":[52860772],"length":1,"stats":{"Line":0}},{"line":702,"address":[53603127,53608704,53608740],"length":1,"stats":{"Line":0}},{"line":703,"address":[55603666],"length":1,"stats":{"Line":0}},{"line":704,"address":[54434710],"length":1,"stats":{"Line":0}},{"line":705,"address":[54434952,54434990,54434875],"length":1,"stats":{"Line":0}},{"line":706,"address":[52861114,52861265],"length":1,"stats":{"Line":0}},{"line":708,"address":[54434896],"length":1,"stats":{"Line":0}},{"line":714,"address":[54401799,54402089],"length":1,"stats":{"Line":48}},{"line":715,"address":[54923521],"length":1,"stats":{"Line":20}},{"line":716,"address":[53567382,53567304],"length":1,"stats":{"Line":56}},{"line":719,"address":[52997288,52997453,52997200,52997230],"length":1,"stats":{"Line":0}},{"line":720,"address":[55538390],"length":1,"stats":{"Line":0}},{"line":721,"address":[54437049],"length":1,"stats":{"Line":0}},{"line":722,"address":[55538445],"length":1,"stats":{"Line":0}},{"line":724,"address":[54437162,54437064],"length":1,"stats":{"Line":0}},{"line":730,"address":[54924008,54923745],"length":1,"stats":{"Line":49}},{"line":731,"address":[55234384],"length":1,"stats":{"Line":21}},{"line":732,"address":[54402388,54402311],"length":1,"stats":{"Line":59}},{"line":733,"address":[54259542,54259615],"length":1,"stats":{"Line":6}},{"line":734,"address":[52899191],"length":1,"stats":{"Line":3}},{"line":735,"address":[53428240],"length":1,"stats":{"Line":3}},{"line":736,"address":[52899262],"length":1,"stats":{"Line":3}},{"line":737,"address":[52899330,53080823,53080768],"length":1,"stats":{"Line":9}},{"line":738,"address":[53428365],"length":1,"stats":{"Line":3}},{"line":739,"address":[54259893],"length":1,"stats":{"Line":3}},{"line":741,"address":[53428167,53428539],"length":1,"stats":{"Line":0}},{"line":747,"address":[55234917,55234627],"length":1,"stats":{"Line":49}},{"line":748,"address":[53567911],"length":1,"stats":{"Line":21}},{"line":749,"address":[53036688,53037480,53037535],"length":1,"stats":{"Line":60}},{"line":750,"address":[54218114,54218196],"length":1,"stats":{"Line":7}},{"line":751,"address":[53386807],"length":1,"stats":{"Line":3}},{"line":753,"address":[53607456,53607485,53386839],"length":1,"stats":{"Line":9}},{"line":754,"address":[55672784],"length":1,"stats":{"Line":3}},{"line":756,"address":[54218919,54218261],"length":1,"stats":{"Line":0}},{"line":762,"address":[54402873,54403163],"length":1,"stats":{"Line":49}},{"line":763,"address":[55235100],"length":1,"stats":{"Line":21}},{"line":764,"address":[54924607,54924529],"length":1,"stats":{"Line":56}},{"line":767,"address":[54351410,54351492,54351360,54352931,54352494],"length":1,"stats":{"Line":24}},{"line":768,"address":[53520152],"length":1,"stats":{"Line":4}},{"line":769,"address":[53069776,52955896,53069789,52956363],"length":1,"stats":{"Line":16}},{"line":770,"address":[53520920],"length":1,"stats":{"Line":5}},{"line":772,"address":[52955829],"length":1,"stats":{"Line":4}},{"line":773,"address":[54352134,54351768,54351617],"length":1,"stats":{"Line":8}},{"line":774,"address":[55499681,55499778],"length":1,"stats":{"Line":10}},{"line":776,"address":[55499704,55499962],"length":1,"stats":{"Line":0}},{"line":779,"address":[55499578],"length":1,"stats":{"Line":3}},{"line":780,"address":[53521370,53520222,53521004],"length":1,"stats":{"Line":6}},{"line":781,"address":[55500560,55500389,55500440],"length":1,"stats":{"Line":9}},{"line":783,"address":[53521062,53521331],"length":1,"stats":{"Line":0}},{"line":786,"address":[55499427,55500702],"length":1,"stats":{"Line":0}},{"line":792,"address":[54403231,54403521],"length":1,"stats":{"Line":50}},{"line":793,"address":[53568557],"length":1,"stats":{"Line":21}},{"line":794,"address":[54403385,54403462],"length":1,"stats":{"Line":54}},{"line":797,"address":[54231244,54232231,54231200,54231331,54232173],"length":1,"stats":{"Line":20}},{"line":798,"address":[53007223],"length":1,"stats":{"Line":2}},{"line":799,"address":[55700771,55700531],"length":1,"stats":{"Line":6}},{"line":800,"address":[54231921],"length":1,"stats":{"Line":2}},{"line":801,"address":[53400467],"length":1,"stats":{"Line":3}},{"line":803,"address":[53399898,53399976],"length":1,"stats":{"Line":7}},{"line":804,"address":[55700440,55701218],"length":1,"stats":{"Line":4}},{"line":810,"address":[53568781,53569044],"length":1,"stats":{"Line":51}},{"line":811,"address":[55235816],"length":1,"stats":{"Line":22}},{"line":812,"address":[54338640,54339939,54340016],"length":1,"stats":{"Line":53}},{"line":813,"address":[53000256,53000159,53000086],"length":1,"stats":{"Line":6}},{"line":814,"address":[54339261],"length":1,"stats":{"Line":2}},{"line":815,"address":[55701917],"length":1,"stats":{"Line":2}},{"line":816,"address":[53508033],"length":1,"stats":{"Line":2}},{"line":817,"address":[53001107],"length":1,"stats":{"Line":2}},{"line":819,"address":[53000297],"length":1,"stats":{"Line":2}},{"line":820,"address":[53507429],"length":1,"stats":{"Line":2}},{"line":822,"address":[54338821,54339972],"length":1,"stats":{"Line":0}},{"line":828,"address":[55236059,55236349],"length":1,"stats":{"Line":52}},{"line":829,"address":[54404062],"length":1,"stats":{"Line":24}},{"line":830,"address":[55236290,55236213],"length":1,"stats":{"Line":48}},{"line":833,"address":[54268160,54268703,54268296,54269129,54268201],"length":1,"stats":{"Line":10}},{"line":834,"address":[54268841,54268752,54268993,54268404],"length":1,"stats":{"Line":13}},{"line":835,"address":[55588993],"length":1,"stats":{"Line":4}},{"line":836,"address":[53437368],"length":1,"stats":{"Line":2}},{"line":837,"address":[55589160],"length":1,"stats":{"Line":4}},{"line":838,"address":[53437497,53437288,53437416],"length":1,"stats":{"Line":6}},{"line":839,"address":[54268367,54268611,54268472],"length":1,"stats":{"Line":10}},{"line":840,"address":[55588737],"length":1,"stats":{"Line":4}},{"line":841,"address":[55588788],"length":1,"stats":{"Line":4}},{"line":842,"address":[53619825,53437007,53619808],"length":1,"stats":{"Line":9}},{"line":843,"address":[53437034,53437115,53437177],"length":1,"stats":{"Line":8}},{"line":844,"address":[55589328,55588621],"length":1,"stats":{"Line":4}},{"line":850,"address":[55236707,55236417],"length":1,"stats":{"Line":50}},{"line":851,"address":[53569526],"length":1,"stats":{"Line":27}},{"line":852,"address":[53569565,53569643],"length":1,"stats":{"Line":46}},{"line":855,"address":[54262253,54261339,54261216,54262311,54261260],"length":1,"stats":{"Line":6}},{"line":856,"address":[52849407],"length":1,"stats":{"Line":2}},{"line":857,"address":[53429955,53430205],"length":1,"stats":{"Line":4}},{"line":858,"address":[54261763,54261836,54262248],"length":1,"stats":{"Line":4}},{"line":859,"address":[55602318,55602096],"length":1,"stats":{"Line":0}},{"line":861,"address":[53430357,53430408],"length":1,"stats":{"Line":4}},{"line":864,"address":[53429984,53429906],"length":1,"stats":{"Line":4}},{"line":865,"address":[53430763,53429864],"length":1,"stats":{"Line":0}},{"line":871,"address":[53570013,53569750],"length":1,"stats":{"Line":54}},{"line":872,"address":[54404778],"length":1,"stats":{"Line":27}},{"line":873,"address":[52949380,52948496,52948990],"length":1,"stats":{"Line":40}},{"line":874,"address":[54375881,54375976],"length":1,"stats":{"Line":5}},{"line":875,"address":[54376084,54376497,54376649,54376408],"length":1,"stats":{"Line":14}},{"line":876,"address":[54376370],"length":1,"stats":{"Line":4}},{"line":877,"address":[55627863],"length":1,"stats":{"Line":3}},{"line":878,"address":[53545045],"length":1,"stats":{"Line":3}},{"line":879,"address":[52949183,52949280,52949079],"length":1,"stats":{"Line":6}},{"line":880,"address":[52948695,52948907],"length":1,"stats":{"Line":4}},{"line":881,"address":[52948769],"length":1,"stats":{"Line":3}},{"line":882,"address":[52948796],"length":1,"stats":{"Line":3}},{"line":883,"address":[52948819,53075200,53075217],"length":1,"stats":{"Line":7}},{"line":884,"address":[54376194,54376275,54376337],"length":1,"stats":{"Line":5}},{"line":885,"address":[54376741,54376005],"length":1,"stats":{"Line":0}},{"line":891,"address":[54926592,54926329],"length":1,"stats":{"Line":50}},{"line":892,"address":[54926428],"length":1,"stats":{"Line":31}},{"line":893,"address":[55568080,55569686,55569779],"length":1,"stats":{"Line":45}},{"line":894,"address":[55569777,55568130,55568288,55568366],"length":1,"stats":{"Line":12}},{"line":895,"address":[53420965],"length":1,"stats":{"Line":3}},{"line":896,"address":[55568244,55568334],"length":1,"stats":{"Line":7}},{"line":897,"address":[54252695,54252907,54252809,54254117],"length":1,"stats":{"Line":11}},{"line":898,"address":[52977458],"length":1,"stats":{"Line":3}},{"line":899,"address":[54252875,54252777],"length":1,"stats":{"Line":8}},{"line":900,"address":[53421456],"length":1,"stats":{"Line":9}},{"line":901,"address":[54253134],"length":1,"stats":{"Line":3}},{"line":902,"address":[55568842,55569279],"length":1,"stats":{"Line":10}},{"line":903,"address":[54253727,54253658],"length":1,"stats":{"Line":10}},{"line":904,"address":[54253735],"length":1,"stats":{"Line":7}},{"line":905,"address":[53422414],"length":1,"stats":{"Line":7}},{"line":906,"address":[55569497],"length":1,"stats":{"Line":3}},{"line":909,"address":[55568779],"length":1,"stats":{"Line":4}},{"line":910,"address":[52977811,52977880],"length":1,"stats":{"Line":8}},{"line":911,"address":[55568884],"length":1,"stats":{"Line":4}},{"line":912,"address":[55569150],"length":1,"stats":{"Line":4}},{"line":913,"address":[53421762],"length":1,"stats":{"Line":4}},{"line":916,"address":[53421529,53422553],"length":1,"stats":{"Line":4}},{"line":922,"address":[55237491,55237781],"length":1,"stats":{"Line":50}},{"line":923,"address":[53570495],"length":1,"stats":{"Line":31}},{"line":924,"address":[53025168,53026150,53026205],"length":1,"stats":{"Line":40}},{"line":925,"address":[54384726,54384805,54385770],"length":1,"stats":{"Line":8}},{"line":926,"address":[53553330],"length":1,"stats":{"Line":3}},{"line":927,"address":[54384846],"length":1,"stats":{"Line":3}},{"line":928,"address":[54384854,54384909,54385036],"length":1,"stats":{"Line":13}},{"line":929,"address":[53025673],"length":1,"stats":{"Line":6}},{"line":930,"address":[55675585],"length":1,"stats":{"Line":3}},{"line":931,"address":[55675633],"length":1,"stats":{"Line":2}},{"line":932,"address":[53554106],"length":1,"stats":{"Line":2}},{"line":933,"address":[53026067],"length":1,"stats":{"Line":2}},{"line":935,"address":[55675685,55675550],"length":1,"stats":{"Line":4}},{"line":938,"address":[53025855,53025727],"length":1,"stats":{"Line":6}},{"line":939,"address":[53553922],"length":1,"stats":{"Line":2}},{"line":941,"address":[55675342],"length":1,"stats":{"Line":4}},{"line":944,"address":[53026161,53025338],"length":1,"stats":{"Line":4}},{"line":950,"address":[54405737,54406027],"length":1,"stats":{"Line":52}},{"line":951,"address":[53570818],"length":1,"stats":{"Line":31}},{"line":952,"address":[55238080,55238003],"length":1,"stats":{"Line":35}},{"line":955,"address":[53030343,53030285,53029346,53029296,53029420],"length":1,"stats":{"Line":6}},{"line":956,"address":[55527688],"length":1,"stats":{"Line":3}},{"line":957,"address":[53029572,53080542,53029964,53080528],"length":1,"stats":{"Line":14}},{"line":958,"address":[53030217],"length":1,"stats":{"Line":4}},{"line":960,"address":[55527633],"length":1,"stats":{"Line":2}},{"line":961,"address":[53505886,53506251,53505805],"length":1,"stats":{"Line":6}},{"line":962,"address":[53505928,53506010],"length":1,"stats":{"Line":4}},{"line":963,"address":[53029815],"length":1,"stats":{"Line":4}},{"line":965,"address":[54337452,54337716],"length":1,"stats":{"Line":4}},{"line":968,"address":[55527583,55528427],"length":1,"stats":{"Line":4}},{"line":974,"address":[54927561,54927298],"length":1,"stats":{"Line":51}},{"line":975,"address":[53571141],"length":1,"stats":{"Line":33}},{"line":976,"address":[52925888,52926265],"length":1,"stats":{"Line":35}},{"line":977,"address":[55539159,55539431,55539094],"length":1,"stats":{"Line":6}},{"line":978,"address":[54367990,54367929],"length":1,"stats":{"Line":4}},{"line":980,"address":[55539392,55539202],"length":1,"stats":{"Line":4}},{"line":986,"address":[54406743,54406453],"length":1,"stats":{"Line":50}},{"line":987,"address":[53571464],"length":1,"stats":{"Line":34}},{"line":988,"address":[55238719,55238796],"length":1,"stats":{"Line":34}},{"line":989,"address":[54372927,54372854,54373161],"length":1,"stats":{"Line":6}},{"line":990,"address":[55638705,55638760],"length":1,"stats":{"Line":4}},{"line":992,"address":[54372970,54373128],"length":1,"stats":{"Line":4}},{"line":998,"address":[54928207,54927944],"length":1,"stats":{"Line":51}},{"line":999,"address":[55239038],"length":1,"stats":{"Line":34}},{"line":1000,"address":[54928082,54928160],"length":1,"stats":{"Line":35}},{"line":1001,"address":[53433049,53432742,53432815],"length":1,"stats":{"Line":12}},{"line":1002,"address":[54264345,54264400],"length":1,"stats":{"Line":8}},{"line":1004,"address":[54264520,54264362],"length":1,"stats":{"Line":4}},{"line":1010,"address":[55239281,55239571],"length":1,"stats":{"Line":50}},{"line":1011,"address":[54407284],"length":1,"stats":{"Line":35}},{"line":1012,"address":[55622927,55621600,55622985],"length":1,"stats":{"Line":37}},{"line":1013,"address":[53039364,53040612,53039282],"length":1,"stats":{"Line":13}},{"line":1015,"address":[53039401,53039574,53039476,53039628],"length":1,"stats":{"Line":20}},{"line":1016,"address":[53039491],"length":1,"stats":{"Line":5}},{"line":1017,"address":[55621890],"length":1,"stats":{"Line":4}},{"line":1018,"address":[55621965],"length":1,"stats":{"Line":5}},{"line":1019,"address":[54285387],"length":1,"stats":{"Line":5}},{"line":1021,"address":[53454157],"length":1,"stats":{"Line":5}},{"line":1022,"address":[55622281],"length":1,"stats":{"Line":5}},{"line":1023,"address":[54285871,54286114],"length":1,"stats":{"Line":12}},{"line":1024,"address":[55622853,55622735],"length":1,"stats":{"Line":7}},{"line":1025,"address":[54286237,54286303],"length":1,"stats":{"Line":12}},{"line":1027,"address":[53040131],"length":1,"stats":{"Line":5}},{"line":1029,"address":[54285163,54286362],"length":1,"stats":{"Line":4}},{"line":1035,"address":[53572334,53572597],"length":1,"stats":{"Line":52}},{"line":1036,"address":[53572433],"length":1,"stats":{"Line":35}},{"line":1037,"address":[54928728,54928806],"length":1,"stats":{"Line":38}},{"line":1038,"address":[55602534,55602607,55603150],"length":1,"stats":{"Line":14}},{"line":1039,"address":[53567857,53567912],"length":1,"stats":{"Line":9}},{"line":1040,"address":[53071232,53030744,53071313,53071260],"length":1,"stats":{"Line":17}},{"line":1041,"address":[53616101],"length":1,"stats":{"Line":3}},{"line":1042,"address":[55727810],"length":1,"stats":{"Line":2}},{"line":1043,"address":[53616164],"length":1,"stats":{"Line":2}},{"line":1045,"address":[53071458],"length":1,"stats":{"Line":4}},{"line":1046,"address":[55727701],"length":1,"stats":{"Line":0}},{"line":1048,"address":[53030778],"length":1,"stats":{"Line":3}},{"line":1050,"address":[53567873,53568380],"length":1,"stats":{"Line":6}},{"line":1056,"address":[54929176,54928913],"length":1,"stats":{"Line":50}},{"line":1057,"address":[54408000],"length":1,"stats":{"Line":38}},{"line":1058,"address":[54929051,54929129],"length":1,"stats":{"Line":29}},{"line":1060,"address":[54358807,54357780,54357698],"length":1,"stats":{"Line":8}},{"line":1061,"address":[53526487,53527301],"length":1,"stats":{"Line":6}},{"line":1062,"address":[53526728],"length":1,"stats":{"Line":6}},{"line":1063,"address":[52868165,52868653],"length":1,"stats":{"Line":6}},{"line":1065,"address":[52868334,52868208,52868294,52868145],"length":1,"stats":{"Line":13}},{"line":1066,"address":[52868223],"length":1,"stats":{"Line":3}},{"line":1067,"address":[55625166],"length":1,"stats":{"Line":3}},{"line":1068,"address":[52868317],"length":1,"stats":{"Line":3}},{"line":1069,"address":[54358443],"length":1,"stats":{"Line":4}},{"line":1070,"address":[53526996,53527030],"length":1,"stats":{"Line":4}},{"line":1071,"address":[54358564,54358705,54358526],"length":1,"stats":{"Line":8}},{"line":1072,"address":[52868538],"length":1,"stats":{"Line":4}},{"line":1077,"address":[54929498,54929236],"length":1,"stats":{"Line":50}},{"line":1078,"address":[53573079],"length":1,"stats":{"Line":38}},{"line":1079,"address":[53477152,53477450],"length":1,"stats":{"Line":25}},{"line":1081,"address":[53477366,53477327,53477182,53477252],"length":1,"stats":{"Line":8}},{"line":1082,"address":[52886601],"length":1,"stats":{"Line":2}},{"line":1083,"address":[52886626],"length":1,"stats":{"Line":2}},{"line":1084,"address":[52886677],"length":1,"stats":{"Line":2}},{"line":1085,"address":[54308878],"length":1,"stats":{"Line":2}},{"line":1090,"address":[54408598,54408888],"length":1,"stats":{"Line":51}},{"line":1091,"address":[55240825],"length":1,"stats":{"Line":38}},{"line":1092,"address":[53498448,53498894],"length":1,"stats":{"Line":23}},{"line":1093,"address":[52986919,52986854],"length":1,"stats":{"Line":0}},{"line":1094,"address":[55581372],"length":1,"stats":{"Line":0}},{"line":1099,"address":[54409246,54408956],"length":1,"stats":{"Line":50}},{"line":1100,"address":[55241183],"length":1,"stats":{"Line":39}},{"line":1101,"address":[54409110,54409187],"length":1,"stats":{"Line":30}},{"line":1102,"address":[53572466,53572549],"length":1,"stats":{"Line":16}},{"line":1103,"address":[53572566,53572651],"length":1,"stats":{"Line":16}},{"line":1104,"address":[53572601,53574081],"length":1,"stats":{"Line":0}},{"line":1107,"address":[53572689,53574025],"length":1,"stats":{"Line":10}},{"line":1108,"address":[55653676,55654716,55653596],"length":1,"stats":{"Line":6}},{"line":1109,"address":[53572954,53572889,53573964],"length":1,"stats":{"Line":12}},{"line":1110,"address":[52950403,52950483,52951250],"length":1,"stats":{"Line":4}},{"line":1111,"address":[53573906,53573112,53573177,53573230],"length":1,"stats":{"Line":12}},{"line":1112,"address":[55653943,55654600,55654057,55654004],"length":1,"stats":{"Line":12}},{"line":1113,"address":[54404790,54404855,54404942],"length":1,"stats":{"Line":16}},{"line":1114,"address":[53573831,53573404],"length":1,"stats":{"Line":4}},{"line":1116,"address":[53573460,53573802],"length":1,"stats":{"Line":6}},{"line":1117,"address":[53573776,53573647,53573596],"length":1,"stats":{"Line":6}},{"line":1118,"address":[53573629],"length":1,"stats":{"Line":0}},{"line":1120,"address":[53573689],"length":1,"stats":{"Line":2}},{"line":1125,"address":[55241426,55241716],"length":1,"stats":{"Line":50}},{"line":1126,"address":[54930303],"length":1,"stats":{"Line":36}},{"line":1127,"address":[53377292,53377104],"length":1,"stats":{"Line":26}},{"line":1128,"address":[53377136,53377200],"length":1,"stats":{"Line":8}},{"line":1133,"address":[55241784,55242074],"length":1,"stats":{"Line":50}},{"line":1134,"address":[55241899],"length":1,"stats":{"Line":39}},{"line":1135,"address":[53413010,53412224],"length":1,"stats":{"Line":28}},{"line":1136,"address":[55514333,55514262],"length":1,"stats":{"Line":12}},{"line":1137,"address":[52861491],"length":1,"stats":{"Line":6}},{"line":1138,"address":[54243912,54244473],"length":1,"stats":{"Line":0}},{"line":1140,"address":[53412380,53412605,53412510,53412949],"length":1,"stats":{"Line":12}},{"line":1141,"address":[53412447],"length":1,"stats":{"Line":6}},{"line":1142,"address":[55514462,55514549],"length":1,"stats":{"Line":6}},{"line":1143,"address":[52861841,52861755],"length":1,"stats":{"Line":8}},{"line":1144,"address":[53412791,53412706],"length":1,"stats":{"Line":10}},{"line":1145,"address":[54244346],"length":1,"stats":{"Line":6}},{"line":1146,"address":[54447905,54244373,54447888],"length":1,"stats":{"Line":14}},{"line":1147,"address":[53412898,53614640],"length":1,"stats":{"Line":4}},{"line":1148,"address":[54446210],"length":1,"stats":{"Line":2}},{"line":1151,"address":[54446195],"length":1,"stats":{"Line":2}},{"line":1158,"address":[53574857,53574594],"length":1,"stats":{"Line":50}},{"line":1159,"address":[53574693],"length":1,"stats":{"Line":39}},{"line":1160,"address":[54306112,54306851],"length":1,"stats":{"Line":25}},{"line":1161,"address":[54306418,54306162,54306244],"length":1,"stats":{"Line":11}},{"line":1162,"address":[52888099],"length":1,"stats":{"Line":4}},{"line":1163,"address":[55630153],"length":1,"stats":{"Line":4}},{"line":1165,"address":[52888469,52888048],"length":1,"stats":{"Line":0}},{"line":1171,"address":[54931436,54931173],"length":1,"stats":{"Line":50}},{"line":1172,"address":[54931272],"length":1,"stats":{"Line":39}},{"line":1173,"address":[55242654,55242731],"length":1,"stats":{"Line":28}},{"line":1174,"address":[52991014,52991079],"length":1,"stats":{"Line":8}},{"line":1176,"address":[52991175],"length":1,"stats":{"Line":4}},{"line":1177,"address":[52991204],"length":1,"stats":{"Line":4}},{"line":1179,"address":[55569947,55570201],"length":1,"stats":{"Line":0}},{"line":1184,"address":[54411036,54410746],"length":1,"stats":{"Line":50}},{"line":1185,"address":[54410861],"length":1,"stats":{"Line":39}},{"line":1186,"address":[55243089,55243012],"length":1,"stats":{"Line":24}},{"line":1187,"address":[52985094,52985159],"length":1,"stats":{"Line":5}},{"line":1188,"address":[52985255],"length":1,"stats":{"Line":3}},{"line":1189,"address":[53510752],"length":1,"stats":{"Line":3}},{"line":1191,"address":[55552347,55552597],"length":1,"stats":{"Line":0}},{"line":1197,"address":[55243216,55243506],"length":1,"stats":{"Line":50}},{"line":1198,"address":[54411219],"length":1,"stats":{"Line":39}},{"line":1199,"address":[55669909,55669392],"length":1,"stats":{"Line":26}},{"line":1200,"address":[52914743,52914678],"length":1,"stats":{"Line":8}},{"line":1201,"address":[54366083],"length":1,"stats":{"Line":4}},{"line":1202,"address":[53534616,53534850],"length":1,"stats":{"Line":6}},{"line":1203,"address":[53534644,53534820],"length":1,"stats":{"Line":4}},{"line":1205,"address":[55669640,55669701],"length":1,"stats":{"Line":6}},{"line":1208,"address":[54366361,54366039],"length":1,"stats":{"Line":0}},{"line":1214,"address":[54411462,54411752],"length":1,"stats":{"Line":50}},{"line":1215,"address":[55243689],"length":1,"stats":{"Line":39}},{"line":1216,"address":[55663675,55662448,55663733],"length":1,"stats":{"Line":25}},{"line":1217,"address":[52899804,52899618,52899692],"length":1,"stats":{"Line":7}},{"line":1218,"address":[54354949,54354701],"length":1,"stats":{"Line":5}},{"line":1219,"address":[54354733,54447736,54447728],"length":1,"stats":{"Line":12}},{"line":1221,"address":[53523139],"length":1,"stats":{"Line":4}},{"line":1222,"address":[52899851,52900218],"length":1,"stats":{"Line":8}},{"line":1223,"address":[52900333,52900276],"length":1,"stats":{"Line":8}},{"line":1224,"address":[53524048,53523940],"length":1,"stats":{"Line":8}},{"line":1225,"address":[53524069],"length":1,"stats":{"Line":2}},{"line":1228,"address":[52900626],"length":1,"stats":{"Line":2}},{"line":1230,"address":[55663689,55662642],"length":1,"stats":{"Line":0}},{"line":1238,"address":[54932728,54932465],"length":1,"stats":{"Line":50}},{"line":1239,"address":[54932564],"length":1,"stats":{"Line":39}},{"line":1240,"address":[53593010,53592842,53591776],"length":1,"stats":{"Line":22}},{"line":1241,"address":[55513033,55513264,55513101],"length":1,"stats":{"Line":0}},{"line":1242,"address":[53592081],"length":1,"stats":{"Line":0}},{"line":1243,"address":[54423653],"length":1,"stats":{"Line":0}},{"line":1244,"address":[55514143,55513366],"length":1,"stats":{"Line":0}},{"line":1245,"address":[55514040,55513423],"length":1,"stats":{"Line":0}},{"line":1247,"address":[52979582,52979646],"length":1,"stats":{"Line":0}},{"line":1249,"address":[55513563],"length":1,"stats":{"Line":0}},{"line":1250,"address":[55513686,55513773],"length":1,"stats":{"Line":0}},{"line":1253,"address":[53592966],"length":1,"stats":{"Line":0}},{"line":1254,"address":[55513230],"length":1,"stats":{"Line":0}},{"line":1261,"address":[53576532,53576795],"length":1,"stats":{"Line":49}},{"line":1262,"address":[54932887],"length":1,"stats":{"Line":39}},{"line":1263,"address":[52860117,52858912,52859949,52859184,52859092],"length":1,"stats":{"Line":22}},{"line":1264,"address":[53597465,53597541],"length":1,"stats":{"Line":0}},{"line":1266,"address":[52859201],"length":1,"stats":{"Line":0}},{"line":1267,"address":[55677301],"length":1,"stats":{"Line":0}},{"line":1268,"address":[54429318,54430108],"length":1,"stats":{"Line":0}},{"line":1269,"address":[55677992,55677375],"length":1,"stats":{"Line":0}},{"line":1271,"address":[53597854,53597918],"length":1,"stats":{"Line":0}},{"line":1272,"address":[53598015],"length":1,"stats":{"Line":0}},{"line":1273,"address":[52859693,52859606],"length":1,"stats":{"Line":0}},{"line":1277,"address":[55678105,55677182],"length":1,"stats":{"Line":0}},{"line":1283,"address":[54933111,54933374],"length":1,"stats":{"Line":50}},{"line":1284,"address":[54412651],"length":1,"stats":{"Line":39}},{"line":1285,"address":[54933249,54933327],"length":1,"stats":{"Line":26}},{"line":1286,"address":[55634340,55633958,55634023],"length":1,"stats":{"Line":10}},{"line":1287,"address":[55634049],"length":1,"stats":{"Line":2}},{"line":1288,"address":[52940646],"length":1,"stats":{"Line":2}},{"line":1289,"address":[55634138,55729623,55729568],"length":1,"stats":{"Line":9}},{"line":1290,"address":[55634155],"length":1,"stats":{"Line":3}},{"line":1291,"address":[55634175],"length":1,"stats":{"Line":3}},{"line":1293,"address":[53571514,53571766],"length":1,"stats":{"Line":4}},{"line":1299,"address":[54933697,54933434],"length":1,"stats":{"Line":50}},{"line":1300,"address":[54413009],"length":1,"stats":{"Line":39}},{"line":1301,"address":[52860566,52860144],"length":1,"stats":{"Line":24}},{"line":1302,"address":[55691911,55692228,55691846],"length":1,"stats":{"Line":6}},{"line":1303,"address":[52860273],"length":1,"stats":{"Line":2}},{"line":1304,"address":[52860342],"length":1,"stats":{"Line":2}},{"line":1305,"address":[54438848,54438903,54232469],"length":1,"stats":{"Line":6}},{"line":1306,"address":[54232493],"length":1,"stats":{"Line":2}},{"line":1307,"address":[54232514],"length":1,"stats":{"Line":2}},{"line":1309,"address":[55691954,55692189],"length":1,"stats":{"Line":4}},{"line":1315,"address":[54933757,54934020],"length":1,"stats":{"Line":50}},{"line":1316,"address":[55245479],"length":1,"stats":{"Line":39}},{"line":1317,"address":[55667817,55667392],"length":1,"stats":{"Line":32}},{"line":1318,"address":[53513716,53513318,53513391],"length":1,"stats":{"Line":22}},{"line":1319,"address":[54345101],"length":1,"stats":{"Line":6}},{"line":1320,"address":[54344975,54344926,54441981,54441968],"length":1,"stats":{"Line":32}},{"line":1323,"address":[53513677,53513433],"length":1,"stats":{"Line":4}},{"line":1329,"address":[54413610,54413900],"length":1,"stats":{"Line":48}},{"line":1330,"address":[54413725],"length":1,"stats":{"Line":39}},{"line":1331,"address":[54333638,54333200],"length":1,"stats":{"Line":28}},{"line":1332,"address":[54333238,54333311,54333636],"length":1,"stats":{"Line":14}},{"line":1333,"address":[55662305],"length":1,"stats":{"Line":5}},{"line":1334,"address":[55719440,55662183,55719464,55662134],"length":1,"stats":{"Line":20}},{"line":1337,"address":[53502093,53501849],"length":1,"stats":{"Line":4}},{"line":1343,"address":[55246370,55246080],"length":1,"stats":{"Line":49}},{"line":1344,"address":[55246195],"length":1,"stats":{"Line":38}},{"line":1345,"address":[55246234,55246311],"length":1,"stats":{"Line":28}},{"line":1346,"address":[53048166,53048231,53048551],"length":1,"stats":{"Line":13}},{"line":1347,"address":[53048433],"length":1,"stats":{"Line":6}},{"line":1348,"address":[54444328,54426302,54444304,54426351],"length":1,"stats":{"Line":25}},{"line":1351,"address":[53048512,53048273],"length":1,"stats":{"Line":4}},{"line":1357,"address":[54934989,54934726],"length":1,"stats":{"Line":50}},{"line":1358,"address":[55246553],"length":1,"stats":{"Line":37}},{"line":1359,"address":[54207168,54208021,54208073],"length":1,"stats":{"Line":29}},{"line":1360,"address":[54207279,54208071,54207206,54207644],"length":1,"stats":{"Line":10}},{"line":1361,"address":[55550174,55550113],"length":1,"stats":{"Line":4}},{"line":1362,"address":[52982968],"length":1,"stats":{"Line":2}},{"line":1363,"address":[54207454],"length":1,"stats":{"Line":2}},{"line":1364,"address":[53376145,53375969],"length":1,"stats":{"Line":4}},{"line":1366,"address":[52983048],"length":1,"stats":{"Line":0}},{"line":1368,"address":[52983062],"length":1,"stats":{"Line":2}},{"line":1370,"address":[52983575,52982882],"length":1,"stats":{"Line":4}},{"line":1376,"address":[54935049,54935312],"length":1,"stats":{"Line":45}},{"line":1377,"address":[54414799],"length":1,"stats":{"Line":37}},{"line":1378,"address":[52926688,52927315,52927263],"length":1,"stats":{"Line":33}},{"line":1379,"address":[55565654,55566241,55565719],"length":1,"stats":{"Line":6}},{"line":1380,"address":[53465858,53465737],"length":1,"stats":{"Line":4}},{"line":1381,"address":[52926886],"length":1,"stats":{"Line":2}},{"line":1382,"address":[53613792,53614403,53614409,53465813],"length":1,"stats":{"Line":4}},{"line":1383,"address":[55730675],"length":1,"stats":{"Line":2}},{"line":1384,"address":[54445378],"length":1,"stats":{"Line":2}},{"line":1385,"address":[53076091,53076171,53076227,53076304],"length":1,"stats":{"Line":4}},{"line":1387,"address":[53613934],"length":1,"stats":{"Line":2}},{"line":1388,"address":[53076115,53076277,53076211],"length":1,"stats":{"Line":6}},{"line":1390,"address":[54445477],"length":1,"stats":{"Line":0}},{"line":1393,"address":[53465837],"length":1,"stats":{"Line":2}},{"line":1394,"address":[52926956],"length":1,"stats":{"Line":0}},{"line":1395,"address":[53466026],"length":1,"stats":{"Line":2}},{"line":1397,"address":[52926834,52927274],"length":1,"stats":{"Line":4}},{"line":1403,"address":[53579379,53579116],"length":1,"stats":{"Line":50}},{"line":1404,"address":[53579215],"length":1,"stats":{"Line":32}},{"line":1405,"address":[54415196,54415273],"length":1,"stats":{"Line":38}},{"line":1406,"address":[54279423,54279759,54279350],"length":1,"stats":{"Line":8}},{"line":1408,"address":[53447945,53612870,53448006,53612848],"length":1,"stats":{"Line":8}},{"line":1409,"address":[55571741],"length":1,"stats":{"Line":2}},{"line":1411,"address":[54279466,54279720],"length":1,"stats":{"Line":4}},{"line":1417,"address":[55247802,55247512],"length":1,"stats":{"Line":49}},{"line":1418,"address":[54935794],"length":1,"stats":{"Line":32}},{"line":1419,"address":[54935833,54935911],"length":1,"stats":{"Line":40}},{"line":1420,"address":[53375318,53375391,53375642],"length":1,"stats":{"Line":7}},{"line":1421,"address":[54206921,54207076,54206982],"length":1,"stats":{"Line":12}},{"line":1422,"address":[55702821],"length":1,"stats":{"Line":4}},{"line":1423,"address":[52903897,53079143,53079136],"length":1,"stats":{"Line":11}},{"line":1424,"address":[53074128,53074140,52903914],"length":1,"stats":{"Line":6}},{"line":1426,"address":[52903794,52903951],"length":1,"stats":{"Line":0}},{"line":1432,"address":[54415758,54416048],"length":1,"stats":{"Line":50}},{"line":1433,"address":[54936117],"length":1,"stats":{"Line":31}},{"line":1434,"address":[53579900,53579978],"length":1,"stats":{"Line":43}},{"line":1435,"address":[52880957,52880534,52880599],"length":1,"stats":{"Line":12}},{"line":1436,"address":[52880622,52880689],"length":1,"stats":{"Line":11}},{"line":1437,"address":[54357076,54356859],"length":1,"stats":{"Line":10}},{"line":1438,"address":[54451472,54451489,54357034],"length":1,"stats":{"Line":13}},{"line":1439,"address":[52880904,53079241,53079216],"length":1,"stats":{"Line":4}},{"line":1441,"address":[54356821,54356880],"length":1,"stats":{"Line":4}},{"line":1447,"address":[54356787,54357083],"length":1,"stats":{"Line":0}},{"line":1453,"address":[54936604,54936341],"length":1,"stats":{"Line":50}},{"line":1454,"address":[55248343],"length":1,"stats":{"Line":31}},{"line":1455,"address":[54416347,54416270],"length":1,"stats":{"Line":43}},{"line":1456,"address":[55548834,55548916,55549962],"length":1,"stats":{"Line":15}},{"line":1457,"address":[53405777],"length":1,"stats":{"Line":5}},{"line":1458,"address":[52960858,52960786,52960979],"length":1,"stats":{"Line":16}},{"line":1459,"address":[54237996,54237749],"length":1,"stats":{"Line":8}},{"line":1460,"address":[54238008,54238052],"length":1,"stats":{"Line":10}},{"line":1462,"address":[54238037,54238267],"length":1,"stats":{"Line":4}},{"line":1465,"address":[53406282],"length":1,"stats":{"Line":6}},{"line":1467,"address":[52961699,52960744],"length":1,"stats":{"Line":4}},{"line":1473,"address":[54936664,54936927],"length":1,"stats":{"Line":49}},{"line":1474,"address":[55248701],"length":1,"stats":{"Line":31}},{"line":1475,"address":[54936880,54936802],"length":1,"stats":{"Line":41}},{"line":1476,"address":[55587612,55587538],"length":1,"stats":{"Line":4}},{"line":1477,"address":[52939355],"length":1,"stats":{"Line":2}},{"line":1478,"address":[53511287],"length":1,"stats":{"Line":2}},{"line":1479,"address":[53511388,53511459],"length":1,"stats":{"Line":5}},{"line":1480,"address":[53511513,53511586],"length":1,"stats":{"Line":5}},{"line":1481,"address":[52939685],"length":1,"stats":{"Line":3}},{"line":1482,"address":[52939730],"length":1,"stats":{"Line":3}},{"line":1483,"address":[54343282,54448499,54448908,54448902,54448448],"length":1,"stats":{"Line":7}},{"line":1484,"address":[55724398,55724045],"length":1,"stats":{"Line":2}},{"line":1486,"address":[53511805],"length":1,"stats":{"Line":2}},{"line":1487,"address":[52939888],"length":1,"stats":{"Line":2}},{"line":1489,"address":[55587673,55588408],"length":1,"stats":{"Line":4}},{"line":1495,"address":[55248944,55249234],"length":1,"stats":{"Line":50}},{"line":1496,"address":[53580830],"length":1,"stats":{"Line":30}},{"line":1497,"address":[54417063,54416986],"length":1,"stats":{"Line":42}},{"line":1498,"address":[54247383,54247302,54248048],"length":1,"stats":{"Line":9}},{"line":1499,"address":[53415905,53415998,53416087],"length":1,"stats":{"Line":11}},{"line":1500,"address":[55604380],"length":1,"stats":{"Line":4}},{"line":1501,"address":[52997802],"length":1,"stats":{"Line":2}},{"line":1502,"address":[54247653],"length":1,"stats":{"Line":4}},{"line":1503,"address":[53081543,53081561,53081187,52997860,53081136],"length":1,"stats":{"Line":12}},{"line":1504,"address":[55728349,55728399,55728431,55728666,55728690],"length":1,"stats":{"Line":8}},{"line":1505,"address":[53608209],"length":1,"stats":{"Line":4}},{"line":1506,"address":[53081251],"length":1,"stats":{"Line":4}},{"line":1509,"address":[54247699,54247542],"length":1,"stats":{"Line":4}},{"line":1510,"address":[55604671],"length":1,"stats":{"Line":4}},{"line":1512,"address":[52998156,52997621],"length":1,"stats":{"Line":4}},{"line":1520,"address":[54937573,54937310],"length":1,"stats":{"Line":50}},{"line":1521,"address":[55249417],"length":1,"stats":{"Line":30}},{"line":1522,"address":[54279792,54281151,54281231],"length":1,"stats":{"Line":40}},{"line":1523,"address":[53448436,53449722,53448338],"length":1,"stats":{"Line":6}},{"line":1524,"address":[55688094],"length":1,"stats":{"Line":2}},{"line":1525,"address":[53448523],"length":1,"stats":{"Line":2}},{"line":1526,"address":[54280095,54280289,54280162,54281105],"length":1,"stats":{"Line":8}},{"line":1527,"address":[52962827,52962611],"length":1,"stats":{"Line":4}},{"line":1528,"address":[54280919,54280839],"length":1,"stats":{"Line":4}},{"line":1529,"address":[54280952],"length":1,"stats":{"Line":2}},{"line":1530,"address":[53449534],"length":1,"stats":{"Line":2}},{"line":1533,"address":[53449027],"length":1,"stats":{"Line":2}},{"line":1535,"address":[55688113,55689239],"length":1,"stats":{"Line":4}},{"line":1541,"address":[54937896,54937633],"length":1,"stats":{"Line":50}},{"line":1542,"address":[55249775],"length":1,"stats":{"Line":30}},{"line":1543,"address":[55249814,55249891],"length":1,"stats":{"Line":42}},{"line":1544,"address":[55522978,55523060,55524408],"length":1,"stats":{"Line":6}},{"line":1545,"address":[53473326,53473424,53474513,53473190],"length":1,"stats":{"Line":6}},{"line":1546,"address":[53473263],"length":1,"stats":{"Line":3}},{"line":1547,"address":[53473392,53473294],"length":1,"stats":{"Line":3}},{"line":1548,"address":[52958323],"length":1,"stats":{"Line":5}},{"line":1549,"address":[52958546,52958565,52958656],"length":1,"stats":{"Line":9}},{"line":1550,"address":[54305342,54305243,54305314],"length":1,"stats":{"Line":4}},{"line":1552,"address":[52958557],"length":1,"stats":{"Line":3}},{"line":1554,"address":[53473868,53473763],"length":1,"stats":{"Line":7}},{"line":1555,"address":[54305725],"length":1,"stats":{"Line":0}},{"line":1558,"address":[54305709,54305426],"length":1,"stats":{"Line":0}},{"line":1561,"address":[52958774,52958701],"length":1,"stats":{"Line":8}},{"line":1562,"address":[54305512],"length":1,"stats":{"Line":5}},{"line":1564,"address":[53474539,53473221],"length":1,"stats":{"Line":0}},{"line":1570,"address":[54937956,54938219],"length":1,"stats":{"Line":49}},{"line":1571,"address":[53581799],"length":1,"stats":{"Line":30}},{"line":1572,"address":[53581916,53581838],"length":1,"stats":{"Line":43}},{"line":1573,"address":[55649147,55650433,55649068],"length":1,"stats":{"Line":6}},{"line":1574,"address":[55649320,55650368,55649186,55649398],"length":1,"stats":{"Line":7}},{"line":1575,"address":[53045841],"length":1,"stats":{"Line":5}},{"line":1576,"address":[54378046,54377948],"length":1,"stats":{"Line":3}},{"line":1577,"address":[54378125],"length":1,"stats":{"Line":4}},{"line":1578,"address":[55649774,55649664,55649683],"length":1,"stats":{"Line":10}},{"line":1579,"address":[53046340,53046285,53046368],"length":1,"stats":{"Line":4}},{"line":1581,"address":[53046267],"length":1,"stats":{"Line":3}},{"line":1583,"address":[53547018,53546913],"length":1,"stats":{"Line":7}},{"line":1584,"address":[53046680],"length":1,"stats":{"Line":0}},{"line":1587,"address":[53547305,53547065],"length":1,"stats":{"Line":0}},{"line":1590,"address":[54378527,54378596],"length":1,"stats":{"Line":8}},{"line":1591,"address":[53547111],"length":1,"stats":{"Line":4}},{"line":1593,"address":[54377878,54379140],"length":1,"stats":{"Line":0}},{"line":1599,"address":[55250666,55250376],"length":1,"stats":{"Line":50}},{"line":1600,"address":[55250491],"length":1,"stats":{"Line":29}},{"line":1601,"address":[54938417,54938495],"length":1,"stats":{"Line":42}},{"line":1602,"address":[55585485,55585410],"length":1,"stats":{"Line":0}},{"line":1603,"address":[54392183],"length":1,"stats":{"Line":0}},{"line":1604,"address":[52881348],"length":1,"stats":{"Line":0}},{"line":1605,"address":[54392358],"length":1,"stats":{"Line":0}},{"line":1606,"address":[55585862,55586095],"length":1,"stats":{"Line":0}},{"line":1607,"address":[53561235,53561162],"length":1,"stats":{"Line":0}},{"line":1608,"address":[52881970],"length":1,"stats":{"Line":0}},{"line":1610,"address":[53560820],"length":1,"stats":{"Line":0}},{"line":1611,"address":[55585887,55585828],"length":1,"stats":{"Line":0}},{"line":1612,"address":[53560981],"length":1,"stats":{"Line":0}},{"line":1614,"address":[54393016,54392285],"length":1,"stats":{"Line":0}},{"line":1620,"address":[54938602,54938865],"length":1,"stats":{"Line":50}},{"line":1621,"address":[54938701],"length":1,"stats":{"Line":29}},{"line":1622,"address":[53601056,53602218,53602308],"length":1,"stats":{"Line":42}},{"line":1623,"address":[52923870,52923634,52923792],"length":1,"stats":{"Line":0}},{"line":1624,"address":[53601189],"length":1,"stats":{"Line":0}},{"line":1625,"address":[53601330,53601232],"length":1,"stats":{"Line":0}},{"line":1626,"address":[55623327],"length":1,"stats":{"Line":0}},{"line":1627,"address":[54432944],"length":1,"stats":{"Line":0}},{"line":1628,"address":[54433078],"length":1,"stats":{"Line":0}},{"line":1629,"address":[53601828,53601586],"length":1,"stats":{"Line":0}},{"line":1630,"address":[52924369,52924426],"length":1,"stats":{"Line":0}},{"line":1631,"address":[54433599],"length":1,"stats":{"Line":0}},{"line":1633,"address":[52924036],"length":1,"stats":{"Line":0}},{"line":1634,"address":[54433056,54433119],"length":1,"stats":{"Line":0}},{"line":1635,"address":[52924185],"length":1,"stats":{"Line":0}},{"line":1637,"address":[55624103,55623425],"length":1,"stats":{"Line":0}},{"line":1643,"address":[53582669,53582932],"length":1,"stats":{"Line":49}},{"line":1644,"address":[55251207],"length":1,"stats":{"Line":29}},{"line":1645,"address":[54939063,54939141],"length":1,"stats":{"Line":45}},{"line":1646,"address":[55656038,55656117,55656752],"length":1,"stats":{"Line":6}},{"line":1647,"address":[54266362,54266544,54266455],"length":1,"stats":{"Line":6}},{"line":1648,"address":[55656197],"length":1,"stats":{"Line":2}},{"line":1649,"address":[54266575],"length":1,"stats":{"Line":2}},{"line":1650,"address":[55727056,55727066,55656366],"length":1,"stats":{"Line":6}},{"line":1651,"address":[53435133],"length":1,"stats":{"Line":2}},{"line":1652,"address":[52941987,52942140],"length":1,"stats":{"Line":2}},{"line":1653,"address":[55656499],"length":1,"stats":{"Line":4}},{"line":1655,"address":[53434874,53435478],"length":1,"stats":{"Line":4}},{"line":1662,"address":[54939248,54939511],"length":1,"stats":{"Line":49}},{"line":1663,"address":[54939347],"length":1,"stats":{"Line":28}},{"line":1664,"address":[53055316,53052208,53053672],"length":1,"stats":{"Line":52}},{"line":1665,"address":[55594780,55594690],"length":1,"stats":{"Line":18}},{"line":1666,"address":[53052459],"length":1,"stats":{"Line":6}},{"line":1667,"address":[53052499],"length":1,"stats":{"Line":9}},{"line":1668,"address":[54310170],"length":1,"stats":{"Line":6}},{"line":1669,"address":[55595079,55595212,55595010],"length":1,"stats":{"Line":24}},{"line":1670,"address":[55596125,55595424],"length":1,"stats":{"Line":15}},{"line":1671,"address":[53479946,53481276,53480017],"length":1,"stats":{"Line":14}},{"line":1672,"address":[53481173,53480039,53480083,53479989],"length":1,"stats":{"Line":13}},{"line":1673,"address":[53480149,53480105,53480983,53480055],"length":1,"stats":{"Line":10}},{"line":1674,"address":[53053884,53054541,53053978,53053934],"length":1,"stats":{"Line":4}},{"line":1675,"address":[55596432,55596476,55596957,55596382],"length":1,"stats":{"Line":4}},{"line":1676,"address":[54311757,54311807,54311851],"length":1,"stats":{"Line":4}},{"line":1677,"address":[53480375,53480319,53480419],"length":1,"stats":{"Line":4}},{"line":1678,"address":[53054150,53054206,53054484,53054244],"length":1,"stats":{"Line":4}},{"line":1679,"address":[55596691,55596644],"length":1,"stats":{"Line":4}},{"line":1681,"address":[53480756],"length":1,"stats":{"Line":4}},{"line":1682,"address":[53055193,53055151],"length":1,"stats":{"Line":6}},{"line":1684,"address":[53055158,53055131],"length":1,"stats":{"Line":9}},{"line":1687,"address":[53053141,53053285,53053358,53053678,53053045],"length":1,"stats":{"Line":16}},{"line":1688,"address":[53053181,53053070],"length":1,"stats":{"Line":16}},{"line":1689,"address":[53479537,53479426],"length":1,"stats":{"Line":16}},{"line":1692,"address":[54313046,54310069],"length":1,"stats":{"Line":0}},{"line":1698,"address":[54939834,54939571],"length":1,"stats":{"Line":52}},{"line":1699,"address":[55251923],"length":1,"stats":{"Line":27}},{"line":1700,"address":[54419850,54419927],"length":1,"stats":{"Line":46}},{"line":1701,"address":[54248114,54249947,54248212],"length":1,"stats":{"Line":6}},{"line":1702,"address":[52946889,52946946],"length":1,"stats":{"Line":4}},{"line":1703,"address":[53416864],"length":1,"stats":{"Line":2}},{"line":1704,"address":[55553703],"length":1,"stats":{"Line":2}},{"line":1706,"address":[53416992,53417067],"length":1,"stats":{"Line":4}},{"line":1707,"address":[55554450,55554984,55554020,55554518],"length":1,"stats":{"Line":8}},{"line":1708,"address":[55554487,55555000],"length":1,"stats":{"Line":4}},{"line":1710,"address":[52947923],"length":1,"stats":{"Line":2}},{"line":1711,"address":[53418308,53418012],"length":1,"stats":{"Line":2}},{"line":1714,"address":[52947402],"length":1,"stats":{"Line":2}},{"line":1715,"address":[53417319,53417453],"length":1,"stats":{"Line":4}},{"line":1718,"address":[53417386,53417537],"length":1,"stats":{"Line":4}},{"line":1720,"address":[55555079,55553544],"length":1,"stats":{"Line":4}},{"line":1726,"address":[55252456,55252166],"length":1,"stats":{"Line":49}},{"line":1727,"address":[53583737],"length":1,"stats":{"Line":29}},{"line":1728,"address":[53415745,53415618,53414752],"length":1,"stats":{"Line":44}},{"line":1729,"address":[53414790,53415740,53414863],"length":1,"stats":{"Line":5}},{"line":1730,"address":[52915532,52916039,52915323,52915457],"length":1,"stats":{"Line":8}},{"line":1731,"address":[53414966],"length":1,"stats":{"Line":4}},{"line":1732,"address":[54246501,54246596],"length":1,"stats":{"Line":4}},{"line":1733,"address":[53415166],"length":1,"stats":{"Line":4}},{"line":1734,"address":[53415206,53415629],"length":1,"stats":{"Line":4}},{"line":1736,"address":[54246686],"length":1,"stats":{"Line":2}},{"line":1737,"address":[52915594,52915645],"length":1,"stats":{"Line":4}},{"line":1738,"address":[55584311,55584368],"length":1,"stats":{"Line":4}},{"line":1739,"address":[53415408],"length":1,"stats":{"Line":2}},{"line":1740,"address":[54441271,54246938,54441216],"length":1,"stats":{"Line":6}},{"line":1741,"address":[54246965],"length":1,"stats":{"Line":2}},{"line":1742,"address":[52915876],"length":1,"stats":{"Line":2}},{"line":1744,"address":[52916059,52915347],"length":1,"stats":{"Line":0}},{"line":1750,"address":[54940217,54940480],"length":1,"stats":{"Line":49}},{"line":1751,"address":[53584060],"length":1,"stats":{"Line":28}},{"line":1752,"address":[53584099,53584177],"length":1,"stats":{"Line":45}},{"line":1755,"address":[52972816,52972866,52974274,52972948,52974216],"length":1,"stats":{"Line":12}},{"line":1756,"address":[55515235],"length":1,"stats":{"Line":2}},{"line":1757,"address":[53407679],"length":1,"stats":{"Line":2}},{"line":1758,"address":[52973184,52973247],"length":1,"stats":{"Line":4}},{"line":1759,"address":[53407917],"length":1,"stats":{"Line":2}},{"line":1760,"address":[55515617,55515540],"length":1,"stats":{"Line":4}},{"line":1761,"address":[54239677],"length":1,"stats":{"Line":2}},{"line":1762,"address":[54239818,54240069],"length":1,"stats":{"Line":4}},{"line":1763,"address":[52973967],"length":1,"stats":{"Line":2}},{"line":1765,"address":[54240100,54240245],"length":1,"stats":{"Line":4}},{"line":1766,"address":[52974104],"length":1,"stats":{"Line":2}},{"line":1769,"address":[55515881],"length":1,"stats":{"Line":2}},{"line":1771,"address":[55515185,55516406],"length":1,"stats":{"Line":4}},{"line":1779,"address":[54940803,54940540],"length":1,"stats":{"Line":50}},{"line":1780,"address":[55252997],"length":1,"stats":{"Line":27}},{"line":1781,"address":[53434111,53433072],"length":1,"stats":{"Line":51}},{"line":1782,"address":[54264614,54264687,54264787],"length":1,"stats":{"Line":15}},{"line":1783,"address":[55599894],"length":1,"stats":{"Line":3}},{"line":1784,"address":[55600229,55599931],"length":1,"stats":{"Line":5}},{"line":1785,"address":[52911787,52911660],"length":1,"stats":{"Line":4}},{"line":1787,"address":[53433485,53433542],"length":1,"stats":{"Line":4}},{"line":1790,"address":[54265294],"length":1,"stats":{"Line":0}},{"line":1791,"address":[55600445,55600351],"length":1,"stats":{"Line":0}},{"line":1793,"address":[55600524,55600382],"length":1,"stats":{"Line":4}},{"line":1794,"address":[55599950],"length":1,"stats":{"Line":0}},{"line":1795,"address":[52911858,52911596],"length":1,"stats":{"Line":0}},{"line":1797,"address":[55599776,55600598],"length":1,"stats":{"Line":4}},{"line":1803,"address":[54421418,54421128],"length":1,"stats":{"Line":50}},{"line":1804,"address":[54421243],"length":1,"stats":{"Line":27}},{"line":1805,"address":[53509584,53510012],"length":1,"stats":{"Line":50}},{"line":1806,"address":[55670150,55670215],"length":1,"stats":{"Line":8}},{"line":1807,"address":[53014414,53014536],"length":1,"stats":{"Line":6}},{"line":1808,"address":[53509841,53509759],"length":1,"stats":{"Line":4}},{"line":1809,"address":[54341227,54341478],"length":1,"stats":{"Line":0}},{"line":1815,"address":[54421486,54421776],"length":1,"stats":{"Line":49}},{"line":1816,"address":[55253713],"length":1,"stats":{"Line":27}},{"line":1817,"address":[54941324,54941402],"length":1,"stats":{"Line":49}},{"line":1818,"address":[52910422,52910487],"length":1,"stats":{"Line":7}},{"line":1819,"address":[52910712,52910590],"length":1,"stats":{"Line":6}},{"line":1820,"address":[55667111,55667193],"length":1,"stats":{"Line":4}},{"line":1821,"address":[53591467,53591718],"length":1,"stats":{"Line":0}},{"line":1827,"address":[54421844,54422134],"length":1,"stats":{"Line":49}},{"line":1828,"address":[55254071],"length":1,"stats":{"Line":26}},{"line":1829,"address":[53585391,53585469],"length":1,"stats":{"Line":52}},{"line":1830,"address":[53588943,53588870],"length":1,"stats":{"Line":6}},{"line":1831,"address":[54420550,54420673],"length":1,"stats":{"Line":6}},{"line":1832,"address":[53047223,53047305],"length":1,"stats":{"Line":0}},{"line":1833,"address":[53588971,53589222],"length":1,"stats":{"Line":0}},{"line":1839,"address":[53585576,53585839],"length":1,"stats":{"Line":50}},{"line":1840,"address":[54422317],"length":1,"stats":{"Line":25}},{"line":1841,"address":[54332752,54333180],"length":1,"stats":{"Line":52}},{"line":1842,"address":[53501286,53501359],"length":1,"stats":{"Line":4}},{"line":1843,"address":[54333089,54332966],"length":1,"stats":{"Line":4}},{"line":1844,"address":[52903449,52903367],"length":1,"stats":{"Line":0}},{"line":1845,"address":[55659069,55658819],"length":1,"stats":{"Line":0}},{"line":1851,"address":[54942418,54942155],"length":1,"stats":{"Line":49}},{"line":1852,"address":[54942254],"length":1,"stats":{"Line":25}},{"line":1853,"address":[55254826,55254903],"length":1,"stats":{"Line":50}},{"line":1856,"address":[55571443,55571062,55571127,55571024],"length":1,"stats":{"Line":6}},{"line":1857,"address":[54437430,54437553],"length":1,"stats":{"Line":0}},{"line":1858,"address":[55571191,55571273],"length":1,"stats":{"Line":4}},{"line":1859,"address":[53606102,53605851],"length":1,"stats":{"Line":0}},{"line":1865,"address":[54942478,54942522],"length":1,"stats":{"Line":50}},{"line":1867,"address":[54942545],"length":1,"stats":{"Line":0}},{"line":1870,"address":[55255306,55255262],"length":1,"stats":{"Line":50}},{"line":1872,"address":[54942753],"length":1,"stats":{"Line":0}},{"line":1875,"address":[54423426,54423382],"length":1,"stats":{"Line":50}},{"line":1877,"address":[53586705],"length":1,"stats":{"Line":0}},{"line":1880,"address":[54423614,54423904],"length":1,"stats":{"Line":50}},{"line":1881,"address":[53586945],"length":1,"stats":{"Line":25}},{"line":1882,"address":[54423768,54423845],"length":1,"stats":{"Line":52}},{"line":1883,"address":[55529222,55529287],"length":1,"stats":{"Line":4}},{"line":1884,"address":[53605190,53605313],"length":1,"stats":{"Line":4}},{"line":1885,"address":[53037801,53037719],"length":1,"stats":{"Line":0}},{"line":1886,"address":[54436619,54436870],"length":1,"stats":{"Line":0}},{"line":1892,"address":[54424262,54423972],"length":1,"stats":{"Line":50}},{"line":1893,"address":[53587268],"length":1,"stats":{"Line":25}},{"line":1894,"address":[54424203,54424126],"length":1,"stats":{"Line":54}},{"line":1895,"address":[53552598,53552671],"length":1,"stats":{"Line":8}},{"line":1896,"address":[53552769],"length":1,"stats":{"Line":2}},{"line":1897,"address":[54384239],"length":1,"stats":{"Line":3}},{"line":1898,"address":[55584867,55585294],"length":1,"stats":{"Line":0}},{"line":1900,"address":[55584968],"length":1,"stats":{"Line":5}},{"line":1901,"address":[54384435],"length":1,"stats":{"Line":2}},{"line":1902,"address":[53034981],"length":1,"stats":{"Line":3}},{"line":1903,"address":[53034945,53035167],"length":1,"stats":{"Line":0}},{"line":1905,"address":[53552957],"length":1,"stats":{"Line":5}},{"line":1910,"address":[55256442,55256732],"length":1,"stats":{"Line":50}},{"line":1911,"address":[53587591],"length":1,"stats":{"Line":25}},{"line":1912,"address":[54424484,54424561],"length":1,"stats":{"Line":50}},{"line":1915,"address":[53063427,53063008,53063046,53063111],"length":1,"stats":{"Line":0}},{"line":1916,"address":[53063214,53063336],"length":1,"stats":{"Line":0}},{"line":1917,"address":[53063257,53063175],"length":1,"stats":{"Line":0}},{"line":1918,"address":[54365814,54365563],"length":1,"stats":{"Line":0}},{"line":1924,"address":[53588078,53587815],"length":1,"stats":{"Line":50}},{"line":1925,"address":[53587914],"length":1,"stats":{"Line":25}},{"line":1926,"address":[54944287,54944209],"length":1,"stats":{"Line":50}},{"line":1929,"address":[52853127,52853024,52853443,52853062],"length":1,"stats":{"Line":0}},{"line":1930,"address":[55599496,55599374],"length":1,"stats":{"Line":0}},{"line":1931,"address":[54416433,54416351],"length":1,"stats":{"Line":0}},{"line":1932,"address":[52853155,52853405],"length":1,"stats":{"Line":0}},{"line":1938,"address":[55257448,55257158],"length":1,"stats":{"Line":50}},{"line":1939,"address":[54944493],"length":1,"stats":{"Line":21}},{"line":1940,"address":[54944532,54944610],"length":1,"stats":{"Line":50}},{"line":1943,"address":[54214060,54213743,54213670,54213632],"length":1,"stats":{"Line":0}},{"line":1944,"address":[52862334,52862456],"length":1,"stats":{"Line":0}},{"line":1945,"address":[54213889,54213807],"length":1,"stats":{"Line":0}},{"line":1946,"address":[55573021,55572771],"length":1,"stats":{"Line":0}},{"line":1952,"address":[54944717,54944980],"length":1,"stats":{"Line":50}},{"line":1953,"address":[53588560],"length":1,"stats":{"Line":25}},{"line":1954,"address":[53588599,53588677],"length":1,"stats":{"Line":52}},{"line":1955,"address":[55689654,55689719],"length":1,"stats":{"Line":4}},{"line":1956,"address":[53595329],"length":1,"stats":{"Line":2}},{"line":1957,"address":[54426799],"length":1,"stats":{"Line":0}},{"line":1958,"address":[55689747,55690174],"length":1,"stats":{"Line":0}},{"line":1960,"address":[55689848],"length":1,"stats":{"Line":2}},{"line":1961,"address":[55689975],"length":1,"stats":{"Line":2}},{"line":1962,"address":[54426961],"length":1,"stats":{"Line":0}},{"line":1963,"address":[55690127,55689905],"length":1,"stats":{"Line":0}},{"line":1965,"address":[54427021],"length":1,"stats":{"Line":2}},{"line":1970,"address":[54945040,54945303],"length":1,"stats":{"Line":50}},{"line":1971,"address":[53588883],"length":1,"stats":{"Line":25}},{"line":1972,"address":[54425993,54425916],"length":1,"stats":{"Line":52}},{"line":1973,"address":[54374214,54374287],"length":1,"stats":{"Line":4}},{"line":1974,"address":[53542881],"length":1,"stats":{"Line":2}},{"line":1975,"address":[55707063],"length":1,"stats":{"Line":0}},{"line":1976,"address":[55707027,55707454],"length":1,"stats":{"Line":0}},{"line":1978,"address":[55707128],"length":1,"stats":{"Line":2}},{"line":1979,"address":[53062167],"length":1,"stats":{"Line":2}},{"line":1980,"address":[54374513],"length":1,"stats":{"Line":0}},{"line":1981,"address":[55707185,55707407],"length":1,"stats":{"Line":0}},{"line":1983,"address":[53062193],"length":1,"stats":{"Line":2}},{"line":1988,"address":[55258232,55258522],"length":1,"stats":{"Line":50}},{"line":1989,"address":[53589206],"length":1,"stats":{"Line":25}},{"line":1990,"address":[55258463,55258386],"length":1,"stats":{"Line":50}},{"line":1993,"address":[53068368,53068787,53068471,53068406],"length":1,"stats":{"Line":0}},{"line":1994,"address":[55666824,55666702],"length":1,"stats":{"Line":0}},{"line":1995,"address":[54260943,54261025],"length":1,"stats":{"Line":0}},{"line":1996,"address":[53068499,53068749],"length":1,"stats":{"Line":0}},{"line":2002,"address":[53589693,53589430],"length":1,"stats":{"Line":50}},{"line":2003,"address":[55258705],"length":1,"stats":{"Line":25}},{"line":2004,"address":[54945902,54945824],"length":1,"stats":{"Line":50}},{"line":2007,"address":[53003299,53002880,53002918,53002983],"length":1,"stats":{"Line":0}},{"line":2008,"address":[53446849,53446726],"length":1,"stats":{"Line":0}},{"line":2009,"address":[53003129,53003047],"length":1,"stats":{"Line":0}},{"line":2010,"address":[53446902,53446651],"length":1,"stats":{"Line":0}},{"line":2018,"address":[55258948,55259238],"length":1,"stats":{"Line":50}},{"line":2019,"address":[55259063],"length":1,"stats":{"Line":25}},{"line":2020,"address":[55259102,55259179],"length":1,"stats":{"Line":50}},{"line":2021,"address":[55631062,55631189,55631255,55631498],"length":1,"stats":{"Line":0}},{"line":2022,"address":[53436239],"length":1,"stats":{"Line":0}},{"line":2023,"address":[55631229,55631154],"length":1,"stats":{"Line":0}},{"line":2024,"address":[53436418],"length":1,"stats":{"Line":0}},{"line":2025,"address":[53436445,53436582],"length":1,"stats":{"Line":0}},{"line":2027,"address":[54267986,54267933],"length":1,"stats":{"Line":0}},{"line":2028,"address":[55631375],"length":1,"stats":{"Line":0}},{"line":2035,"address":[53590076,53590339],"length":1,"stats":{"Line":50}},{"line":2036,"address":[54946431],"length":1,"stats":{"Line":25}},{"line":2037,"address":[53590214,53590292],"length":1,"stats":{"Line":52}},{"line":2038,"address":[53434255,53434689,53434182],"length":1,"stats":{"Line":4}},{"line":2040,"address":[52855201,52855260],"length":1,"stats":{"Line":4}},{"line":2042,"address":[55633009,55632657],"length":1,"stats":{"Line":0}},{"line":2048,"address":[55259954,55259664],"length":1,"stats":{"Line":50}},{"line":2049,"address":[55259779],"length":1,"stats":{"Line":25}},{"line":2050,"address":[53602883,53602336,53602831],"length":1,"stats":{"Line":50}},{"line":2051,"address":[55581750,55582248,55581815],"length":1,"stats":{"Line":0}},{"line":2052,"address":[53602473,53602532],"length":1,"stats":{"Line":0}},{"line":2054,"address":[52867537,52867185],"length":1,"stats":{"Line":0}},{"line":2060,"address":[54427910,54428200],"length":1,"stats":{"Line":50}},{"line":2061,"address":[54428025],"length":1,"stats":{"Line":25}},{"line":2062,"address":[55635984,55637309,55637251],"length":1,"stats":{"Line":52}},{"line":2063,"address":[55636034,55636116,55637304],"length":1,"stats":{"Line":4}},{"line":2065,"address":[55636153,55636380,55636228,55636326],"length":1,"stats":{"Line":8}},{"line":2066,"address":[55636243],"length":1,"stats":{"Line":2}},{"line":2067,"address":[53066370],"length":1,"stats":{"Line":2}},{"line":2068,"address":[54215081],"length":1,"stats":{"Line":2}},{"line":2069,"address":[55636399],"length":1,"stats":{"Line":2}},{"line":2071,"address":[55636502],"length":1,"stats":{"Line":2}},{"line":2072,"address":[53066614,53066672],"length":1,"stats":{"Line":4}},{"line":2073,"address":[53384266,53383985],"length":1,"stats":{"Line":4}},{"line":2074,"address":[53067269,53067151],"length":1,"stats":{"Line":2}},{"line":2075,"address":[55637156,55637210],"length":1,"stats":{"Line":4}},{"line":2077,"address":[54215517],"length":1,"stats":{"Line":2}},{"line":2079,"address":[55636179,55637265],"length":1,"stats":{"Line":0}},{"line":2085,"address":[53591308,53591045],"length":1,"stats":{"Line":50}},{"line":2086,"address":[54428383],"length":1,"stats":{"Line":26}},{"line":2087,"address":[55541865,55540480,55541691],"length":1,"stats":{"Line":52}},{"line":2088,"address":[53496258,53496002,53496084],"length":1,"stats":{"Line":18}},{"line":2089,"address":[54327779],"length":1,"stats":{"Line":6}},{"line":2090,"address":[54327844],"length":1,"stats":{"Line":6}},{"line":2091,"address":[55540977],"length":1,"stats":{"Line":6}},{"line":2092,"address":[55540993,55541808],"length":1,"stats":{"Line":8}},{"line":2093,"address":[54328051,54328702],"length":1,"stats":{"Line":4}},{"line":2095,"address":[53035917,53036083],"length":1,"stats":{"Line":3}},{"line":2097,"address":[53035828,53035900,53035981],"length":1,"stats":{"Line":10}},{"line":2102,"address":[53035536,53036621],"length":1,"stats":{"Line":0}},{"line":2108,"address":[54428626,54428916],"length":1,"stats":{"Line":50}},{"line":2109,"address":[54428741],"length":1,"stats":{"Line":26}},{"line":2110,"address":[55609625,55608240,55609451,55608438,55608530],"length":1,"stats":{"Line":58}},{"line":2111,"address":[55608364,55608290],"length":1,"stats":{"Line":7}},{"line":2113,"address":[52954499],"length":1,"stats":{"Line":4}},{"line":2114,"address":[53388612],"length":1,"stats":{"Line":4}},{"line":2115,"address":[55608737],"length":1,"stats":{"Line":3}},{"line":2116,"address":[54220261,54221077],"length":1,"stats":{"Line":3}},{"line":2117,"address":[55608815,55609465],"length":1,"stats":{"Line":0}},{"line":2119,"address":[53388881,53389047],"length":1,"stats":{"Line":3}},{"line":2122,"address":[55608941,55608788,55608860],"length":1,"stats":{"Line":9}},{"line":2126,"address":[53389586,53388496],"length":1,"stats":{"Line":0}},{"line":2133,"address":[53591691,53591954],"length":1,"stats":{"Line":50}},{"line":2134,"address":[54948046],"length":1,"stats":{"Line":26}},{"line":2135,"address":[54429138,54429215],"length":1,"stats":{"Line":50}},{"line":2136,"address":[52913990,52914055],"length":1,"stats":{"Line":4}},{"line":2137,"address":[53405059],"length":1,"stats":{"Line":2}},{"line":2138,"address":[53405086],"length":1,"stats":{"Line":2}},{"line":2139,"address":[55598019],"length":1,"stats":{"Line":2}},{"line":2140,"address":[52914318,52914264],"length":1,"stats":{"Line":4}},{"line":2141,"address":[54236886],"length":1,"stats":{"Line":2}},{"line":2143,"address":[54236519,54237035],"length":1,"stats":{"Line":0}},{"line":2149,"address":[54429632,54429342],"length":1,"stats":{"Line":50}},{"line":2150,"address":[53592113],"length":1,"stats":{"Line":26}},{"line":2151,"address":[53598672,53599344,53599396],"length":1,"stats":{"Line":50}},{"line":2152,"address":[54430287,54430214],"length":1,"stats":{"Line":4}},{"line":2153,"address":[53598883],"length":1,"stats":{"Line":2}},{"line":2154,"address":[55555362],"length":1,"stats":{"Line":2}},{"line":2155,"address":[55555379],"length":1,"stats":{"Line":2}},{"line":2156,"address":[55555448,55555502],"length":1,"stats":{"Line":4}},{"line":2157,"address":[52891558],"length":1,"stats":{"Line":2}},{"line":2159,"address":[54430859,54430343],"length":1,"stats":{"Line":0}},{"line":2165,"address":[54429700,54429990],"length":1,"stats":{"Line":51}},{"line":2166,"address":[54948692],"length":1,"stats":{"Line":25}},{"line":2167,"address":[55261966,55262043],"length":1,"stats":{"Line":46}},{"line":2168,"address":[52987367,52987302],"length":1,"stats":{"Line":0}},{"line":2169,"address":[54418643],"length":1,"stats":{"Line":0}},{"line":2170,"address":[54418680],"length":1,"stats":{"Line":0}},{"line":2171,"address":[52987545,52987934],"length":1,"stats":{"Line":0}},{"line":2173,"address":[53587193],"length":1,"stats":{"Line":0}},{"line":2174,"address":[52987584,52987533],"length":1,"stats":{"Line":0}},{"line":2175,"address":[53587391,53587318],"length":1,"stats":{"Line":0}},{"line":2176,"address":[54418931],"length":1,"stats":{"Line":0}},{"line":2177,"address":[55504969,55724864,55724919],"length":1,"stats":{"Line":0}},{"line":2178,"address":[55504992],"length":1,"stats":{"Line":0}},{"line":2179,"address":[54419011],"length":1,"stats":{"Line":0}},{"line":2181,"address":[55504619,55505196],"length":1,"stats":{"Line":0}},{"line":2187,"address":[53592923,53592660],"length":1,"stats":{"Line":50}},{"line":2188,"address":[53592759],"length":1,"stats":{"Line":27}},{"line":2189,"address":[54430289,54430212],"length":1,"stats":{"Line":46}},{"line":2190,"address":[53418838,53419405,53418911],"length":1,"stats":{"Line":0}},{"line":2191,"address":[53418992,53418937],"length":1,"stats":{"Line":0}},{"line":2192,"address":[55696987,55696933],"length":1,"stats":{"Line":0}},{"line":2193,"address":[54250642],"length":1,"stats":{"Line":0}},{"line":2194,"address":[53618432,53618487,53419169],"length":1,"stats":{"Line":0}},{"line":2195,"address":[52857493],"length":1,"stats":{"Line":0}},{"line":2196,"address":[52857513],"length":1,"stats":{"Line":0}},{"line":2198,"address":[52857633,52857261],"length":1,"stats":{"Line":0}},{"line":2204,"address":[54949502,54949239],"length":1,"stats":{"Line":50}},{"line":2205,"address":[54430531],"length":1,"stats":{"Line":28}},{"line":2206,"address":[53002798,53001360,53002856],"length":1,"stats":{"Line":44}},{"line":2207,"address":[53001410,53001492],"length":1,"stats":{"Line":0}},{"line":2208,"address":[54396031],"length":1,"stats":{"Line":0}},{"line":2209,"address":[53001635],"length":1,"stats":{"Line":0}},{"line":2210,"address":[53001791,53001728],"length":1,"stats":{"Line":0}},{"line":2211,"address":[55582767],"length":1,"stats":{"Line":0}},{"line":2212,"address":[53001973,53001902],"length":1,"stats":{"Line":0}},{"line":2213,"address":[54396511],"length":1,"stats":{"Line":0}},{"line":2215,"address":[53565114],"length":1,"stats":{"Line":0}},{"line":2216,"address":[53565582],"length":1,"stats":{"Line":0}},{"line":2217,"address":[53565704,53565627],"length":1,"stats":{"Line":0}},{"line":2218,"address":[53002738],"length":1,"stats":{"Line":0}},{"line":2220,"address":[55583541],"length":1,"stats":{"Line":0}},{"line":2221,"address":[55583218,55583454],"length":1,"stats":{"Line":0}},{"line":2225,"address":[55583252],"length":1,"stats":{"Line":0}},{"line":2227,"address":[53564477,53565833],"length":1,"stats":{"Line":0}},{"line":2235,"address":[54431064,54430774],"length":1,"stats":{"Line":50}},{"line":2236,"address":[54949661],"length":1,"stats":{"Line":28}},{"line":2237,"address":[55263117,55263040],"length":1,"stats":{"Line":44}},{"line":2238,"address":[54252108,54252036],"length":1,"stats":{"Line":0}},{"line":2243,"address":[55263244,55263534],"length":1,"stats":{"Line":50}},{"line":2244,"address":[54431247],"length":1,"stats":{"Line":28}},{"line":2245,"address":[55699145,55698848],"length":1,"stats":{"Line":44}},{"line":2246,"address":[55698956,55698884],"length":1,"stats":{"Line":0}},{"line":2251,"address":[54431490,54431780],"length":1,"stats":{"Line":50}},{"line":2252,"address":[54431605],"length":1,"stats":{"Line":28}},{"line":2253,"address":[53594090,53594168],"length":1,"stats":{"Line":44}},{"line":2254,"address":[53403836,53403764],"length":1,"stats":{"Line":0}},{"line":2259,"address":[53594275,53594538],"length":1,"stats":{"Line":50}},{"line":2260,"address":[53594374],"length":1,"stats":{"Line":28}},{"line":2261,"address":[53594491,53594413],"length":1,"stats":{"Line":44}},{"line":2262,"address":[54419316,54419388],"length":1,"stats":{"Line":0}},{"line":2267,"address":[53594598,53594860],"length":1,"stats":{"Line":49}},{"line":2268,"address":[53594697],"length":1,"stats":{"Line":28}},{"line":2269,"address":[54432434,54432360],"length":1,"stats":{"Line":45}},{"line":2272,"address":[55507040,55507063],"length":1,"stats":{"Line":0}},{"line":2277,"address":[54951439,54951176],"length":1,"stats":{"Line":49}},{"line":2278,"address":[53595019],"length":1,"stats":{"Line":27}},{"line":2279,"address":[54951392,54951314],"length":1,"stats":{"Line":46}},{"line":2281,"address":[55589495,55589430],"length":1,"stats":{"Line":0}},{"line":2282,"address":[53050783],"length":1,"stats":{"Line":0}},{"line":2283,"address":[53586339],"length":1,"stats":{"Line":0}},{"line":2284,"address":[55589678],"length":1,"stats":{"Line":0}},{"line":2285,"address":[55589556],"length":1,"stats":{"Line":0}},{"line":2286,"address":[54417734],"length":1,"stats":{"Line":0}},{"line":2287,"address":[55589647,55589885],"length":1,"stats":{"Line":0}},{"line":2288,"address":[53051183,53051002],"length":1,"stats":{"Line":0}},{"line":2289,"address":[55590073,55589754],"length":1,"stats":{"Line":0}},{"line":2290,"address":[54417674],"length":1,"stats":{"Line":0}},{"line":2292,"address":[53586431],"length":1,"stats":{"Line":0}},{"line":2297,"address":[54433209,54432919],"length":1,"stats":{"Line":51}},{"line":2298,"address":[54433034],"length":1,"stats":{"Line":27}},{"line":2299,"address":[53032508,53031040,53031985],"length":1,"stats":{"Line":46}},{"line":2300,"address":[53514866,53514948],"length":1,"stats":{"Line":7}},{"line":2301,"address":[53031253,53031193],"length":1,"stats":{"Line":8}},{"line":2302,"address":[53031323],"length":1,"stats":{"Line":4}},{"line":2303,"address":[54346678,54346754],"length":1,"stats":{"Line":6}},{"line":2304,"address":[53031803,53031670],"length":1,"stats":{"Line":7}},{"line":2305,"address":[54347201],"length":1,"stats":{"Line":2}},{"line":2307,"address":[54347259,54347186],"length":1,"stats":{"Line":8}},{"line":2309,"address":[54347034],"length":1,"stats":{"Line":2}},{"line":2310,"address":[53515794,53515857,53516397,53515004,53515569,53515130,53515201,53515736],"length":1,"stats":{"Line":10}},{"line":2312,"address":[55693305,55693244],"length":1,"stats":{"Line":4}},{"line":2313,"address":[55693426,55693355],"length":1,"stats":{"Line":4}},{"line":2314,"address":[53032347,53032287],"length":1,"stats":{"Line":4}},{"line":2316,"address":[53515903,53516358],"length":1,"stats":{"Line":0}},{"line":2322,"address":[55265679,55265389],"length":1,"stats":{"Line":50}},{"line":2323,"address":[54951921],"length":1,"stats":{"Line":28}},{"line":2324,"address":[55524544,55525204],"length":1,"stats":{"Line":48}},{"line":2325,"address":[54359430,54359503,54360064],"length":1,"stats":{"Line":8}},{"line":2326,"address":[53528079,53528030],"length":1,"stats":{"Line":12}},{"line":2327,"address":[55524765],"length":1,"stats":{"Line":2}},{"line":2329,"address":[52959586,52959696],"length":1,"stats":{"Line":8}},{"line":2330,"address":[53607881,53607872,53528305],"length":1,"stats":{"Line":12}},{"line":2331,"address":[54359931],"length":1,"stats":{"Line":4}},{"line":2333,"address":[54360025,54359545],"length":1,"stats":{"Line":0}},{"line":2339,"address":[54952145,54952408],"length":1,"stats":{"Line":50}},{"line":2340,"address":[54952244],"length":1,"stats":{"Line":28}},{"line":2341,"address":[53529648,53531637,53531495],"length":1,"stats":{"Line":49}},{"line":2342,"address":[53529780,53529698,53531632],"length":1,"stats":{"Line":13}},{"line":2343,"address":[54361374,54361313],"length":1,"stats":{"Line":11}},{"line":2344,"address":[52876913,52876856],"length":1,"stats":{"Line":11}},{"line":2345,"address":[53531509,53530058],"length":1,"stats":{"Line":4}},{"line":2348,"address":[54361601,54361538],"length":1,"stats":{"Line":9}},{"line":2349,"address":[52877044,52877101],"length":1,"stats":{"Line":9}},{"line":2350,"address":[54362138,54361971],"length":1,"stats":{"Line":6}},{"line":2351,"address":[53530699],"length":1,"stats":{"Line":2}},{"line":2352,"address":[52877593,52877801],"length":1,"stats":{"Line":4}},{"line":2353,"address":[52877624],"length":1,"stats":{"Line":2}},{"line":2356,"address":[53530956],"length":1,"stats":{"Line":2}},{"line":2357,"address":[55578886,55579096],"length":1,"stats":{"Line":4}},{"line":2358,"address":[52877879],"length":1,"stats":{"Line":2}},{"line":2361,"address":[52878066],"length":1,"stats":{"Line":2}},{"line":2362,"address":[55579139,55579377],"length":1,"stats":{"Line":4}},{"line":2363,"address":[54362813],"length":1,"stats":{"Line":2}},{"line":2369,"address":[54362040],"length":1,"stats":{"Line":4}},{"line":2371,"address":[53529828,53531593],"length":1,"stats":{"Line":0}},{"line":2377,"address":[54952468,54952731],"length":1,"stats":{"Line":50}},{"line":2378,"address":[53596311],"length":1,"stats":{"Line":28}},{"line":2379,"address":[53596428,53596350],"length":1,"stats":{"Line":44}},{"line":2382,"address":[53497414,53497487,53498432,53497376,53498313],"length":1,"stats":{"Line":7}},{"line":2383,"address":[52991687,52991957],"length":1,"stats":{"Line":4}},{"line":2384,"address":[53497713,53497568],"length":1,"stats":{"Line":4}},{"line":2385,"address":[53497722],"length":1,"stats":{"Line":2}},{"line":2387,"address":[55717019,55716702],"length":1,"stats":{"Line":0}},{"line":2388,"address":[52992212],"length":1,"stats":{"Line":0}},{"line":2390,"address":[52991601,52992367],"length":1,"stats":{"Line":4}},{"line":2396,"address":[55266463,55266753],"length":1,"stats":{"Line":50}},{"line":2397,"address":[54952890],"length":1,"stats":{"Line":28}},{"line":2398,"address":[55535408,55529632,55535463],"length":1,"stats":{"Line":48}},{"line":2399,"address":[54405796,54405714,54411502],"length":1,"stats":{"Line":9}},{"line":2400,"address":[52964511,52964919,52965735,52966415,52966959,52967337,52966823,52964375,52965191,52966143,52965463,52966687,52967585,52964249,52967089,52967709,52967833,52966551,52966007,52964783,52965327,52966279,52967213,52965871,52965055,52964647,52965599,52967461],"length":1,"stats":{"Line":56}},{"line":2401,"address":[54405898],"length":1,"stats":{"Line":2}},{"line":2402,"address":[54406038],"length":1,"stats":{"Line":2}},{"line":2403,"address":[53574674],"length":1,"stats":{"Line":2}},{"line":2404,"address":[54406318],"length":1,"stats":{"Line":2}},{"line":2405,"address":[54406458],"length":1,"stats":{"Line":2}},{"line":2406,"address":[55530558],"length":1,"stats":{"Line":2}},{"line":2407,"address":[52965138],"length":1,"stats":{"Line":2}},{"line":2408,"address":[55530838],"length":1,"stats":{"Line":2}},{"line":2409,"address":[52965410],"length":1,"stats":{"Line":2}},{"line":2410,"address":[53575654],"length":1,"stats":{"Line":2}},{"line":2411,"address":[52965682],"length":1,"stats":{"Line":2}},{"line":2412,"address":[54407438],"length":1,"stats":{"Line":2}},{"line":2413,"address":[52965954],"length":1,"stats":{"Line":2}},{"line":2414,"address":[54407718],"length":1,"stats":{"Line":2}},{"line":2415,"address":[52966226],"length":1,"stats":{"Line":2}},{"line":2416,"address":[52966362],"length":1,"stats":{"Line":2}},{"line":2417,"address":[55532098],"length":1,"stats":{"Line":2}},{"line":2418,"address":[54408278],"length":1,"stats":{"Line":2}},{"line":2419,"address":[54408418],"length":1,"stats":{"Line":2}},{"line":2420,"address":[53577054],"length":1,"stats":{"Line":2}},{"line":2421,"address":[52967036],"length":1,"stats":{"Line":2}},{"line":2422,"address":[53577316],"length":1,"stats":{"Line":2}},{"line":2423,"address":[53577444],"length":1,"stats":{"Line":2}},{"line":2424,"address":[54409076],"length":1,"stats":{"Line":2}},{"line":2425,"address":[54409204],"length":1,"stats":{"Line":2}},{"line":2426,"address":[52967656],"length":1,"stats":{"Line":2}},{"line":2427,"address":[55533420],"length":1,"stats":{"Line":2}},{"line":2428,"address":[52967726,52965622,52965758,52966710,52966302,52964398,52967478,52965350,52967106,52967850,52966846,52964670,52965214,52964534,52965894,52966030,52966166,52966438,52965078,52964942,52966979,52967230,52964806,52965486,52966574,52967354,52967602],"length":1,"stats":{"Line":0}},{"line":2429,"address":[52969580],"length":1,"stats":{"Line":2}},{"line":2431,"address":[55529808,55535422],"length":1,"stats":{"Line":4}},{"line":2437,"address":[53597121,53596858],"length":1,"stats":{"Line":50}},{"line":2438,"address":[54953213],"length":1,"stats":{"Line":28}},{"line":2439,"address":[53513261,53512080,53513181],"length":1,"stats":{"Line":47}},{"line":2440,"address":[55606818,55607852,55606900],"length":1,"stats":{"Line":16}},{"line":2441,"address":[54343761],"length":1,"stats":{"Line":4}},{"line":2442,"address":[54343814],"length":1,"stats":{"Line":5}},{"line":2443,"address":[53512448,53512575,53512381],"length":1,"stats":{"Line":13}},{"line":2444,"address":[54344277,54344543],"length":1,"stats":{"Line":9}},{"line":2445,"address":[55607689],"length":1,"stats":{"Line":5}},{"line":2446,"address":[52931995],"length":1,"stats":{"Line":4}},{"line":2449,"address":[54344328],"length":1,"stats":{"Line":5}},{"line":2451,"address":[54343780,54344721],"length":1,"stats":{"Line":4}},{"line":2459,"address":[53597444,53597181],"length":1,"stats":{"Line":50}},{"line":2460,"address":[54435182],"length":1,"stats":{"Line":28}},{"line":2461,"address":[55562720,55563679,55563606],"length":1,"stats":{"Line":44}},{"line":2464,"address":[53532934,53533007],"length":1,"stats":{"Line":0}},{"line":2465,"address":[54364525],"length":1,"stats":{"Line":0}},{"line":2466,"address":[55563647,55562872],"length":1,"stats":{"Line":0}},{"line":2468,"address":[52887004,52887079],"length":1,"stats":{"Line":0}},{"line":2469,"address":[52887099,52887269,52887708,52887188],"length":1,"stats":{"Line":0}},{"line":2470,"address":[54364748,54364849,54442320,54442349],"length":1,"stats":{"Line":0}},{"line":2471,"address":[54365007,54365159,54365058,54364936],"length":1,"stats":{"Line":0}},{"line":2472,"address":[54365127,54441344,54365034,54441373],"length":1,"stats":{"Line":0}},{"line":2473,"address":[54365190],"length":1,"stats":{"Line":0}},{"line":2478,"address":[54953760,54954023],"length":1,"stats":{"Line":51}},{"line":2479,"address":[53597603],"length":1,"stats":{"Line":28}},{"line":2480,"address":[52913101,52912544,52913058],"length":1,"stats":{"Line":44}},{"line":2482,"address":[52912647,52912582],"length":1,"stats":{"Line":4}},{"line":2483,"address":[55543861],"length":1,"stats":{"Line":2}},{"line":2484,"address":[55544269,55543896],"length":1,"stats":{"Line":0}},{"line":2486,"address":[54284700,54284637,54284543],"length":1,"stats":{"Line":6}},{"line":2487,"address":[54284674,54447968,54447997,54284608],"length":1,"stats":{"Line":8}},{"line":2488,"address":[55544128],"length":1,"stats":{"Line":0}},{"line":2493,"address":[54435783,54436073],"length":1,"stats":{"Line":49}},{"line":2494,"address":[54435898],"length":1,"stats":{"Line":29}},{"line":2495,"address":[53562370,53561616,53562442],"length":1,"stats":{"Line":44}},{"line":2497,"address":[55637879,55637814],"length":1,"stats":{"Line":4}},{"line":2498,"address":[53561741],"length":1,"stats":{"Line":2}},{"line":2499,"address":[54393914,54393280],"length":1,"stats":{"Line":0}},{"line":2501,"address":[54393486,54393311,54393408],"length":1,"stats":{"Line":6}},{"line":2502,"address":[55638090,55728720,55638041,55728749],"length":1,"stats":{"Line":8}},{"line":2503,"address":[52864005],"length":1,"stats":{"Line":0}},{"line":2504,"address":[52864081],"length":1,"stats":{"Line":0}},{"line":2505,"address":[54447744,54393664,54447799],"length":1,"stats":{"Line":0}},{"line":2506,"address":[55638335],"length":1,"stats":{"Line":0}},{"line":2507,"address":[55638358],"length":1,"stats":{"Line":0}},{"line":2512,"address":[53598150,53598413],"length":1,"stats":{"Line":50}},{"line":2513,"address":[54436256],"length":1,"stats":{"Line":28}},{"line":2514,"address":[54436372,54436295],"length":1,"stats":{"Line":47}},{"line":2516,"address":[55557654,55557719],"length":1,"stats":{"Line":6}},{"line":2517,"address":[53064101],"length":1,"stats":{"Line":3}},{"line":2518,"address":[53554661,53554448],"length":1,"stats":{"Line":0}},{"line":2520,"address":[53064172,53064240],"length":1,"stats":{"Line":6}},{"line":2525,"address":[55268901,55268611],"length":1,"stats":{"Line":50}},{"line":2526,"address":[54954828],"length":1,"stats":{"Line":28}},{"line":2527,"address":[54413424,54414437,54414511],"length":1,"stats":{"Line":46}},{"line":2530,"address":[55558647,55558582],"length":1,"stats":{"Line":4}},{"line":2531,"address":[55558661],"length":1,"stats":{"Line":2}},{"line":2532,"address":[53043633,53042776],"length":1,"stats":{"Line":0}},{"line":2534,"address":[55558732,55558810],"length":1,"stats":{"Line":4}},{"line":2535,"address":[54413721,54413877,54413978,54414443],"length":1,"stats":{"Line":4}},{"line":2536,"address":[53042966],"length":1,"stats":{"Line":2}},{"line":2537,"address":[54413804],"length":1,"stats":{"Line":2}},{"line":2538,"address":[54413821],"length":1,"stats":{"Line":2}},{"line":2539,"address":[54440672,54413946,54440701,54413845],"length":1,"stats":{"Line":2}},{"line":2540,"address":[53043204,53043338,53043275,53043419],"length":1,"stats":{"Line":6}},{"line":2541,"address":[54414227,54452352,54414134,54452381],"length":1,"stats":{"Line":2}},{"line":2542,"address":[53043446],"length":1,"stats":{"Line":2}},{"line":2549,"address":[54955314,54955052],"length":1,"stats":{"Line":50}},{"line":2550,"address":[54436972],"length":1,"stats":{"Line":28}},{"line":2551,"address":[54955190,54955267],"length":1,"stats":{"Line":46}},{"line":2553,"address":[55567182],"length":1,"stats":{"Line":3}},{"line":2570,"address":[53432250,53432180,53432340,53432380],"length":1,"stats":{"Line":12}},{"line":2571,"address":[55567653],"length":1,"stats":{"Line":3}},{"line":2572,"address":[52971924],"length":1,"stats":{"Line":3}},{"line":2573,"address":[54263867],"length":1,"stats":{"Line":3}},{"line":2574,"address":[55567777],"length":1,"stats":{"Line":3}},{"line":2575,"address":[55567829],"length":1,"stats":{"Line":3}},{"line":2576,"address":[53432467],"length":1,"stats":{"Line":3}},{"line":2581,"address":[54955636,54955374],"length":1,"stats":{"Line":50}},{"line":2582,"address":[53599217],"length":1,"stats":{"Line":28}},{"line":2583,"address":[54212944,54213612],"length":1,"stats":{"Line":46}},{"line":2585,"address":[54212974],"length":1,"stats":{"Line":2}},{"line":2593,"address":[55528673,55528739,55528865,55528825],"length":1,"stats":{"Line":8}},{"line":2594,"address":[55528754],"length":1,"stats":{"Line":2}},{"line":2595,"address":[54213237],"length":1,"stats":{"Line":2}},{"line":2596,"address":[55528848],"length":1,"stats":{"Line":2}},{"line":2597,"address":[54213334],"length":1,"stats":{"Line":2}},{"line":2598,"address":[54213386],"length":1,"stats":{"Line":2}},{"line":2599,"address":[53381904],"length":1,"stats":{"Line":2}},{"line":2604,"address":[53599440,53599702],"length":1,"stats":{"Line":50}},{"line":2605,"address":[54437682],"length":1,"stats":{"Line":28}},{"line":2606,"address":[53599578,53599655],"length":1,"stats":{"Line":46}},{"line":2608,"address":[55693920,55693951,55693774,55693840],"length":1,"stats":{"Line":8}},{"line":2609,"address":[55693855],"length":1,"stats":{"Line":2}},{"line":2610,"address":[53384719],"length":1,"stats":{"Line":2}},{"line":2611,"address":[55693934],"length":1,"stats":{"Line":2}},{"line":2613,"address":[53040860],"length":1,"stats":{"Line":2}},{"line":2614,"address":[53040903],"length":1,"stats":{"Line":2}},{"line":2615,"address":[53041035],"length":1,"stats":{"Line":2}},{"line":2616,"address":[53040941,53042422,53040970],"length":1,"stats":{"Line":4}},{"line":2617,"address":[53041048,53040953,53042250],"length":1,"stats":{"Line":4}},{"line":2618,"address":[55694225,55694292],"length":1,"stats":{"Line":0}},{"line":2619,"address":[55694268,55694657,55695182],"length":1,"stats":{"Line":6}},{"line":2620,"address":[53385614,53385481,53385851],"length":1,"stats":{"Line":0}},{"line":2621,"address":[53385571,53385679],"length":1,"stats":{"Line":0}},{"line":2623,"address":[53385311],"length":1,"stats":{"Line":2}},{"line":2628,"address":[54956281,54956018],"length":1,"stats":{"Line":50}},{"line":2629,"address":[54956117],"length":1,"stats":{"Line":28}},{"line":2630,"address":[55270188,55270265],"length":1,"stats":{"Line":46}},{"line":2631,"address":[55505894,55505959,55506458],"length":1,"stats":{"Line":7}},{"line":2633,"address":[55506051,55505985],"length":1,"stats":{"Line":8}},{"line":2634,"address":[52897075],"length":1,"stats":{"Line":4}},{"line":2636,"address":[52897251,52896850],"length":1,"stats":{"Line":0}},{"line":2642,"address":[54438570,54438280],"length":1,"stats":{"Line":51}},{"line":2643,"address":[55270507],"length":1,"stats":{"Line":28}},{"line":2644,"address":[53494881,53494096],"length":1,"stats":{"Line":44}},{"line":2645,"address":[53494134,53494212],"length":1,"stats":{"Line":7}},{"line":2646,"address":[53494220],"length":1,"stats":{"Line":4}},{"line":2647,"address":[54325771,54325846],"length":1,"stats":{"Line":8}},{"line":2648,"address":[53494843,53494296],"length":1,"stats":{"Line":0}},{"line":2650,"address":[53013652],"length":1,"stats":{"Line":3}},{"line":2651,"address":[54325903,54326057],"length":1,"stats":{"Line":5}},{"line":2652,"address":[53013786],"length":1,"stats":{"Line":2}},{"line":2654,"address":[53494442,53494558],"length":1,"stats":{"Line":4}},{"line":2663,"address":[54438638,54438928],"length":1,"stats":{"Line":51}},{"line":2664,"address":[54438753],"length":1,"stats":{"Line":29}},{"line":2665,"address":[55270904,55270981],"length":1,"stats":{"Line":43}},{"line":2667,"address":[53538818,53538908,53540351],"length":1,"stats":{"Line":4}},{"line":2668,"address":[53538998,53538937],"length":1,"stats":{"Line":4}},{"line":2669,"address":[55610224,55610085,55610270],"length":1,"stats":{"Line":6}},{"line":2670,"address":[54370797],"length":1,"stats":{"Line":2}},{"line":2671,"address":[55610172],"length":1,"stats":{"Line":2}},{"line":2672,"address":[53015975],"length":1,"stats":{"Line":2}},{"line":2673,"address":[53539434],"length":1,"stats":{"Line":2}},{"line":2675,"address":[54370946],"length":1,"stats":{"Line":2}},{"line":2676,"address":[55610397,55610673],"length":1,"stats":{"Line":4}},{"line":2677,"address":[54371531],"length":1,"stats":{"Line":2}},{"line":2678,"address":[55611034,55610915],"length":1,"stats":{"Line":2}},{"line":2679,"address":[53016800,53016745],"length":1,"stats":{"Line":4}},{"line":2682,"address":[53539575],"length":1,"stats":{"Line":2}},{"line":2683,"address":[53016197],"length":1,"stats":{"Line":2}},{"line":2685,"address":[55609824,55611123],"length":1,"stats":{"Line":0}},{"line":2691,"address":[54957250,54956987],"length":1,"stats":{"Line":50}},{"line":2692,"address":[55271223],"length":1,"stats":{"Line":30}},{"line":2693,"address":[54957125,54957203],"length":1,"stats":{"Line":40}},{"line":2696,"address":[53558592,53558986,53558630,53558703],"length":1,"stats":{"Line":15}},{"line":2697,"address":[54390274],"length":1,"stats":{"Line":4}},{"line":2698,"address":[53558852],"length":1,"stats":{"Line":2}},{"line":2699,"address":[54390458,54390233],"length":1,"stats":{"Line":0}},{"line":2705,"address":[54439644,54439354],"length":1,"stats":{"Line":52}},{"line":2706,"address":[53601153],"length":1,"stats":{"Line":30}},{"line":2707,"address":[53390372,53389648],"length":1,"stats":{"Line":40}},{"line":2708,"address":[53014694,53014759],"length":1,"stats":{"Line":8}},{"line":2709,"address":[53390086,53389963,53389809],"length":1,"stats":{"Line":6}},{"line":2710,"address":[53014843,53015100],"length":1,"stats":{"Line":0}},{"line":2711,"address":[55639601,55639883],"length":1,"stats":{"Line":0}},{"line":2712,"address":[53390210,53389932],"length":1,"stats":{"Line":0}},{"line":2713,"address":[55639498],"length":1,"stats":{"Line":0}},{"line":2715,"address":[53389993],"length":1,"stats":{"Line":2}},{"line":2720,"address":[54439712,54440002],"length":1,"stats":{"Line":50}},{"line":2721,"address":[54439827],"length":1,"stats":{"Line":32}},{"line":2722,"address":[54391503,54390512,54391445],"length":1,"stats":{"Line":38}},{"line":2723,"address":[52990012,52989148,52989219],"length":1,"stats":{"Line":5}},{"line":2724,"address":[52989299,52989248],"length":1,"stats":{"Line":6}},{"line":2725,"address":[53559269],"length":1,"stats":{"Line":3}},{"line":2726,"address":[55698282,55698228],"length":1,"stats":{"Line":6}},{"line":2727,"address":[55698596,55698472],"length":1,"stats":{"Line":6}},{"line":2728,"address":[55698645],"length":1,"stats":{"Line":2}},{"line":2730,"address":[54391360,54391287],"length":1,"stats":{"Line":6}},{"line":2732,"address":[53559637],"length":1,"stats":{"Line":2}},{"line":2734,"address":[55698789,55698076],"length":1,"stats":{"Line":0}},{"line":2740,"address":[54957956,54958219],"length":1,"stats":{"Line":50}},{"line":2741,"address":[54958055],"length":1,"stats":{"Line":32}},{"line":2742,"address":[52908000,52908882,52909075],"length":1,"stats":{"Line":40}},{"line":2743,"address":[53499122,53498978,53499060],"length":1,"stats":{"Line":12}},{"line":2744,"address":[52908344],"length":1,"stats":{"Line":2}},{"line":2746,"address":[52908216],"length":1,"stats":{"Line":0}},{"line":2747,"address":[52908585,52908294],"length":1,"stats":{"Line":4}},{"line":2748,"address":[55678538,55678876],"length":1,"stats":{"Line":0}},{"line":2749,"address":[55678597,55679069],"length":1,"stats":{"Line":0}},{"line":2750,"address":[53499101],"length":1,"stats":{"Line":0}},{"line":2752,"address":[53499432],"length":1,"stats":{"Line":4}},{"line":2757,"address":[54958542,54958279],"length":1,"stats":{"Line":49}},{"line":2758,"address":[54958378],"length":1,"stats":{"Line":32}},{"line":2759,"address":[54440659,54440582],"length":1,"stats":{"Line":37}},{"line":2760,"address":[54225010,54225092],"length":1,"stats":{"Line":0}},{"line":2761,"address":[55564944,55564730],"length":1,"stats":{"Line":0}},{"line":2762,"address":[53393700,53394019],"length":1,"stats":{"Line":0}},{"line":2763,"address":[53394100,53612248,53393759,53612224],"length":1,"stats":{"Line":0}},{"line":2764,"address":[55564882,55565260],"length":1,"stats":{"Line":0}},{"line":2765,"address":[54225892,54225345],"length":1,"stats":{"Line":0}},{"line":2766,"address":[53020837],"length":1,"stats":{"Line":0}},{"line":2768,"address":[55564997],"length":1,"stats":{"Line":0}},{"line":2773,"address":[53602346,53602609],"length":1,"stats":{"Line":52}},{"line":2774,"address":[53602445],"length":1,"stats":{"Line":31}},{"line":2775,"address":[55273129,55273052],"length":1,"stats":{"Line":37}},{"line":2776,"address":[55651996,55651078,55651149],"length":1,"stats":{"Line":6}},{"line":2777,"address":[55651232,55651183],"length":1,"stats":{"Line":6}},{"line":2778,"address":[55651831,55651260],"length":1,"stats":{"Line":4}},{"line":2780,"address":[54373453,54373395],"length":1,"stats":{"Line":4}},{"line":2781,"address":[54373557],"length":1,"stats":{"Line":2}},{"line":2782,"address":[55651515],"length":1,"stats":{"Line":2}},{"line":2784,"address":[54373346,54374111],"length":1,"stats":{"Line":0}},{"line":2790,"address":[55273256,55273546],"length":1,"stats":{"Line":49}},{"line":2791,"address":[55273371],"length":1,"stats":{"Line":34}},{"line":2792,"address":[52889936,52890929,52891040],"length":1,"stats":{"Line":34}},{"line":2793,"address":[54223701,54223622],"length":1,"stats":{"Line":4}},{"line":2794,"address":[53392219],"length":1,"stats":{"Line":2}},{"line":2795,"address":[54223768,54224661],"length":1,"stats":{"Line":0}},{"line":2797,"address":[55497331,55497268],"length":1,"stats":{"Line":4}},{"line":2798,"address":[55497345],"length":1,"stats":{"Line":2}},{"line":2799,"address":[53392349,53393097],"length":1,"stats":{"Line":0}},{"line":2801,"address":[52890186],"length":1,"stats":{"Line":2}},{"line":2802,"address":[53392459,53392388],"length":1,"stats":{"Line":4}},{"line":2803,"address":[54224011],"length":1,"stats":{"Line":2}},{"line":2805,"address":[55497613],"length":1,"stats":{"Line":2}},{"line":2806,"address":[55497987],"length":1,"stats":{"Line":2}},{"line":2807,"address":[52890835],"length":1,"stats":{"Line":2}},{"line":2808,"address":[52890902],"length":1,"stats":{"Line":2}},{"line":2810,"address":[53393014],"length":1,"stats":{"Line":0}},{"line":2811,"address":[55497982,55497764],"length":1,"stats":{"Line":0}},{"line":2815,"address":[53392785],"length":1,"stats":{"Line":2}},{"line":2820,"address":[53602992,53603255],"length":1,"stats":{"Line":53}},{"line":2821,"address":[55273729],"length":1,"stats":{"Line":33}},{"line":2822,"address":[54959386,54959464],"length":1,"stats":{"Line":27}},{"line":2823,"address":[53377350,53377431],"length":1,"stats":{"Line":0}},{"line":2824,"address":[55709506],"length":1,"stats":{"Line":0}},{"line":2825,"address":[53377495,53378374],"length":1,"stats":{"Line":0}},{"line":2827,"address":[54209871,54208971,54209038],"length":1,"stats":{"Line":0}},{"line":2828,"address":[55709770],"length":1,"stats":{"Line":0}},{"line":2829,"address":[55710318,55709798],"length":1,"stats":{"Line":0}},{"line":2831,"address":[55709781,55709892],"length":1,"stats":{"Line":0}},{"line":2832,"address":[55709842],"length":1,"stats":{"Line":0}},{"line":2833,"address":[53023493],"length":1,"stats":{"Line":0}},{"line":2834,"address":[53377940],"length":1,"stats":{"Line":0}},{"line":2835,"address":[53377966,53609040,53609095],"length":1,"stats":{"Line":0}},{"line":2836,"address":[55710029,55709909],"length":1,"stats":{"Line":0}},{"line":2837,"address":[55710104],"length":1,"stats":{"Line":0}},{"line":2842,"address":[53603578,53603315],"length":1,"stats":{"Line":49}},{"line":2843,"address":[54959670],"length":1,"stats":{"Line":36}},{"line":2844,"address":[54442091,54442014],"length":1,"stats":{"Line":24}},{"line":2847,"address":[52849111,52849169,52847840,52847890,52847964],"length":1,"stats":{"Line":0}},{"line":2848,"address":[54242564],"length":1,"stats":{"Line":0}},{"line":2849,"address":[52848116,52848694],"length":1,"stats":{"Line":0}},{"line":2850,"address":[53411738,53411815],"length":1,"stats":{"Line":0}},{"line":2851,"address":[53411823],"length":1,"stats":{"Line":0}},{"line":2852,"address":[54243387],"length":1,"stats":{"Line":0}},{"line":2853,"address":[54243418],"length":1,"stats":{"Line":0}},{"line":2854,"address":[53411933,53608576,53608603],"length":1,"stats":{"Line":0}},{"line":2855,"address":[52848970,53069840,53069858],"length":1,"stats":{"Line":0}},{"line":2856,"address":[55512789],"length":1,"stats":{"Line":0}},{"line":2857,"address":[52849016],"length":1,"stats":{"Line":0}},{"line":2859,"address":[54242505],"length":1,"stats":{"Line":0}},{"line":2860,"address":[53411021,53411102],"length":1,"stats":{"Line":0}},{"line":2861,"address":[53411119],"length":1,"stats":{"Line":0}},{"line":2863,"address":[54243115],"length":1,"stats":{"Line":0}},{"line":2864,"address":[52848193],"length":1,"stats":{"Line":0}},{"line":2868,"address":[54242698,54242643],"length":1,"stats":{"Line":0}},{"line":2869,"address":[55512363,55512057],"length":1,"stats":{"Line":0}},{"line":2871,"address":[52848248],"length":1,"stats":{"Line":0}},{"line":2872,"address":[52848327],"length":1,"stats":{"Line":0}},{"line":2873,"address":[53616352,53411343,53616360],"length":1,"stats":{"Line":0}},{"line":2874,"address":[55512214],"length":1,"stats":{"Line":0}},{"line":2875,"address":[54242901],"length":1,"stats":{"Line":0}},{"line":2877,"address":[53410951,53412159],"length":1,"stats":{"Line":0}},{"line":2883,"address":[53603901,53603638],"length":1,"stats":{"Line":51}},{"line":2884,"address":[54442333],"length":1,"stats":{"Line":37}},{"line":2885,"address":[53058288,53061774],"length":1,"stats":{"Line":24}},{"line":2887,"address":[53058412,53058338],"length":1,"stats":{"Line":0}},{"line":2888,"address":[53058488],"length":1,"stats":{"Line":0}},{"line":2889,"address":[53548833,53548731,53548669,53548879],"length":1,"stats":{"Line":0}},{"line":2890,"address":[53548746],"length":1,"stats":{"Line":0}},{"line":2891,"address":[54380281],"length":1,"stats":{"Line":0}},{"line":2892,"address":[53548856],"length":1,"stats":{"Line":0}},{"line":2893,"address":[55591278,55594564],"length":1,"stats":{"Line":0}},{"line":2896,"address":[54380404,54380199],"length":1,"stats":{"Line":0}},{"line":2897,"address":[53058773],"length":1,"stats":{"Line":0}},{"line":2899,"address":[54380517],"length":1,"stats":{"Line":0}},{"line":2910,"address":[53059046],"length":1,"stats":{"Line":0}},{"line":2911,"address":[54380714],"length":1,"stats":{"Line":0}},{"line":2912,"address":[55592678],"length":1,"stats":{"Line":0}},{"line":2913,"address":[54380726,54380944],"length":1,"stats":{"Line":0}},{"line":2914,"address":[55592104],"length":1,"stats":{"Line":0}},{"line":2916,"address":[53549519],"length":1,"stats":{"Line":0}},{"line":2918,"address":[53549531],"length":1,"stats":{"Line":0}},{"line":2921,"address":[54381441,54381053,54381472],"length":1,"stats":{"Line":0}},{"line":2922,"address":[53059789,53059851,53059838],"length":1,"stats":{"Line":0}},{"line":2925,"address":[54381094],"length":1,"stats":{"Line":0}},{"line":2940,"address":[55592709,55592590,55593023],"length":1,"stats":{"Line":0}},{"line":2941,"address":[54381707],"length":1,"stats":{"Line":0}},{"line":2943,"address":[53060271],"length":1,"stats":{"Line":0}},{"line":2946,"address":[55593247],"length":1,"stats":{"Line":0}},{"line":2947,"address":[54382087,54382451],"length":1,"stats":{"Line":0}},{"line":2948,"address":[53550852],"length":1,"stats":{"Line":0}},{"line":2949,"address":[53550924],"length":1,"stats":{"Line":0}},{"line":2952,"address":[54382443,54382456,54382400],"length":1,"stats":{"Line":0}},{"line":2954,"address":[53060692,53060925,53060806],"length":1,"stats":{"Line":0}},{"line":2956,"address":[55593646],"length":1,"stats":{"Line":0}},{"line":2957,"address":[53551147],"length":1,"stats":{"Line":0}},{"line":2958,"address":[53551176],"length":1,"stats":{"Line":0}},{"line":2959,"address":[54382709],"length":1,"stats":{"Line":0}},{"line":2960,"address":[55593778],"length":1,"stats":{"Line":0}},{"line":2963,"address":[54382846,54382980,54382758],"length":1,"stats":{"Line":0}},{"line":2965,"address":[55593934,55594110,55593900],"length":1,"stats":{"Line":0}},{"line":2974,"address":[53604216,53603961],"length":1,"stats":{"Line":24}},{"line":2975,"address":[53604060],"length":1,"stats":{"Line":38}},{"line":2976,"address":[54442730,54442810],"length":1,"stats":{"Line":50}},{"line":2980,"address":[54442918,54443192],"length":1,"stats":{"Line":76}},{"line":2981,"address":[54443033],"length":1,"stats":{"Line":12}},{"line":2982,"address":[54960670,54960747],"length":1,"stats":{"Line":50}},{"line":2986,"address":[54443260,54443534],"length":1,"stats":{"Line":24}},{"line":2987,"address":[54960946],"length":1,"stats":{"Line":38}},{"line":2988,"address":[55275606,55275526],"length":1,"stats":{"Line":50}},{"line":2992,"address":[55275988,55275714],"length":1,"stats":{"Line":76}},{"line":2993,"address":[54961261],"length":1,"stats":{"Line":12}},{"line":2994,"address":[53605044,53605121],"length":1,"stats":{"Line":50}},{"line":2998,"address":[54443944,54444218],"length":1,"stats":{"Line":24}},{"line":2999,"address":[55276171],"length":1,"stats":{"Line":38}},{"line":3000,"address":[54444098,54444178],"length":1,"stats":{"Line":50}},{"line":3004,"address":[53605536,53605791],"length":1,"stats":{"Line":76}},{"line":3005,"address":[54444401],"length":1,"stats":{"Line":12}},{"line":3006,"address":[53605751,53605674],"length":1,"stats":{"Line":50}},{"line":3010,"address":[54962362,54962107],"length":1,"stats":{"Line":22}},{"line":3011,"address":[55276855],"length":1,"stats":{"Line":39}},{"line":3012,"address":[53606066,53605989],"length":1,"stats":{"Line":50}},{"line":3016,"address":[54444970,54445244],"length":1,"stats":{"Line":78}},{"line":3017,"address":[54445085],"length":1,"stats":{"Line":11}},{"line":3018,"address":[55277316,55277236],"length":1,"stats":{"Line":50}},{"line":3022,"address":[54962992,54962737],"length":1,"stats":{"Line":21}},{"line":3023,"address":[54445427],"length":1,"stats":{"Line":39}},{"line":3024,"address":[54445546,54445466],"length":1,"stats":{"Line":50}},{"line":3030,"address":[54445944,54445654],"length":1,"stats":{"Line":50}},{"line":3031,"address":[54445769],"length":1,"stats":{"Line":10}},{"line":3032,"address":[54445885,54445808],"length":1,"stats":{"Line":80}},{"line":3035,"address":[55536512,55536556,55537352,55536627],"length":1,"stats":{"Line":0}},{"line":3036,"address":[55536761],"length":1,"stats":{"Line":0}},{"line":3037,"address":[55536773,55536911],"length":1,"stats":{"Line":0}},{"line":3038,"address":[53568918],"length":1,"stats":{"Line":0}},{"line":3040,"address":[55536798],"length":1,"stats":{"Line":0}},{"line":3041,"address":[53020170,53020451],"length":1,"stats":{"Line":0}},{"line":3042,"address":[53568629],"length":1,"stats":{"Line":0}},{"line":3048,"address":[55278124,55278414],"length":1,"stats":{"Line":50}},{"line":3049,"address":[54963474],"length":1,"stats":{"Line":10}},{"line":3050,"address":[54963591,54963513],"length":1,"stats":{"Line":80}},{"line":3053,"address":[55580455,55579574,55579536,55579639],"length":1,"stats":{"Line":0}},{"line":3054,"address":[52873197],"length":1,"stats":{"Line":0}},{"line":3055,"address":[54353706],"length":1,"stats":{"Line":0}},{"line":3056,"address":[54354058,54353798],"length":1,"stats":{"Line":0}},{"line":3057,"address":[53522626,53522493],"length":1,"stats":{"Line":0}},{"line":3058,"address":[53522330],"length":1,"stats":{"Line":0}},{"line":3059,"address":[53522423],"length":1,"stats":{"Line":0}},{"line":3060,"address":[52873119],"length":1,"stats":{"Line":0}},{"line":3066,"address":[54963698,54963961],"length":1,"stats":{"Line":50}},{"line":3067,"address":[55278597],"length":1,"stats":{"Line":10}},{"line":3068,"address":[53377076,53376592],"length":1,"stats":{"Line":80}},{"line":3069,"address":[52972428,52972356],"length":1,"stats":{"Line":0}},{"line":3070,"address":[53376869,53376804],"length":1,"stats":{"Line":0}},{"line":3075,"address":[55278840,55279130],"length":1,"stats":{"Line":53}},{"line":3076,"address":[54964120],"length":1,"stats":{"Line":10}},{"line":3077,"address":[55279071,55278994],"length":1,"stats":{"Line":77}},{"line":3080,"address":[53500207,53500957,53500134,53500096],"length":1,"stats":{"Line":0}},{"line":3081,"address":[53500320,53500470],"length":1,"stats":{"Line":0}},{"line":3082,"address":[54331860,54332069],"length":1,"stats":{"Line":0}},{"line":3083,"address":[52892357,52892612],"length":1,"stats":{"Line":0}},{"line":3084,"address":[54331933,54332243],"length":1,"stats":{"Line":0}},{"line":3085,"address":[54331751],"length":1,"stats":{"Line":0}},{"line":3091,"address":[55279198,55279488],"length":1,"stats":{"Line":50}},{"line":3092,"address":[54447201],"length":1,"stats":{"Line":13}},{"line":3093,"address":[54964482,54964560],"length":1,"stats":{"Line":74}},{"line":3096,"address":[54397408,54398269,54397519,54397446],"length":1,"stats":{"Line":0}},{"line":3097,"address":[55655096,55655242],"length":1,"stats":{"Line":0}},{"line":3098,"address":[53566164,53566373],"length":1,"stats":{"Line":0}},{"line":3099,"address":[53566205,53566465],"length":1,"stats":{"Line":0}},{"line":3100,"address":[54398051,54397741],"length":1,"stats":{"Line":0}},{"line":3101,"address":[54397559],"length":1,"stats":{"Line":0}},{"line":3107,"address":[55279556,55279846],"length":1,"stats":{"Line":50}},{"line":3108,"address":[54447559],"length":1,"stats":{"Line":13}},{"line":3109,"address":[53608627,53608549],"length":1,"stats":{"Line":74}},{"line":3112,"address":[55682064,55682102,55682167,55683077],"length":1,"stats":{"Line":6}},{"line":3113,"address":[53514245],"length":1,"stats":{"Line":0}},{"line":3114,"address":[55682285],"length":1,"stats":{"Line":2}},{"line":3115,"address":[55682383,55682665],"length":1,"stats":{"Line":0}},{"line":3116,"address":[53514496,53514119],"length":1,"stats":{"Line":0}},{"line":3117,"address":[53514574,53514303],"length":1,"stats":{"Line":0}},{"line":3118,"address":[52909747],"length":1,"stats":{"Line":0}},{"line":3119,"address":[55682207],"length":1,"stats":{"Line":0}},{"line":3125,"address":[53608734,53608997],"length":1,"stats":{"Line":50}},{"line":3126,"address":[53608833],"length":1,"stats":{"Line":13}},{"line":3127,"address":[52918240,52918676],"length":1,"stats":{"Line":76}},{"line":3128,"address":[54341648,54341574],"length":1,"stats":{"Line":4}},{"line":3129,"address":[54341662,54341737],"length":1,"stats":{"Line":4}},{"line":3130,"address":[53510187,53510452],"length":1,"stats":{"Line":0}},{"line":3132,"address":[52918443],"length":1,"stats":{"Line":2}},{"line":3133,"address":[55703743],"length":1,"stats":{"Line":2}},{"line":3138,"address":[53609320,53609057],"length":1,"stats":{"Line":50}},{"line":3139,"address":[55280387],"length":1,"stats":{"Line":13}},{"line":3140,"address":[55705377,55704480,55705253],"length":1,"stats":{"Line":76}},{"line":3141,"address":[55704518,55704591],"length":1,"stats":{"Line":4}},{"line":3142,"address":[53460252,53460181],"length":1,"stats":{"Line":4}},{"line":3143,"address":[54291720,54292435],"length":1,"stats":{"Line":0}},{"line":3145,"address":[55704684,55704754],"length":1,"stats":{"Line":4}},{"line":3146,"address":[55704768],"length":1,"stats":{"Line":2}},{"line":3147,"address":[53044059,53044464],"length":1,"stats":{"Line":0}},{"line":3149,"address":[55704795,55704890],"length":1,"stats":{"Line":4}},{"line":3150,"address":[53460660],"length":1,"stats":{"Line":2}},{"line":3155,"address":[55280920,55280630],"length":1,"stats":{"Line":50}},{"line":3156,"address":[54965735],"length":1,"stats":{"Line":13}},{"line":3157,"address":[52889184,52889811,52889914],"length":1,"stats":{"Line":76}},{"line":3158,"address":[52889222,52889287],"length":1,"stats":{"Line":4}},{"line":3159,"address":[54296445],"length":1,"stats":{"Line":2}},{"line":3160,"address":[55570424,55570970],"length":1,"stats":{"Line":0}},{"line":3162,"address":[52889372,52889442],"length":1,"stats":{"Line":4}},{"line":3163,"address":[52889456],"length":1,"stats":{"Line":2}},{"line":3164,"address":[55570579,55570910],"length":1,"stats":{"Line":0}},{"line":3166,"address":[52889530],"length":1,"stats":{"Line":2}},{"line":3167,"address":[52889611],"length":1,"stats":{"Line":2}},{"line":3168,"address":[55731448,55731440,55570722],"length":1,"stats":{"Line":6}},{"line":3169,"address":[53465293],"length":1,"stats":{"Line":2}},{"line":3170,"address":[52889680],"length":1,"stats":{"Line":2}},{"line":3175,"address":[53609703,53609966],"length":1,"stats":{"Line":50}},{"line":3176,"address":[54966058],"length":1,"stats":{"Line":13}},{"line":3177,"address":[54209936,54211731,54211942],"length":1,"stats":{"Line":76}},{"line":3178,"address":[55517620,55517538],"length":1,"stats":{"Line":4}},{"line":3179,"address":[53378589,53378669],"length":1,"stats":{"Line":4}},{"line":3180,"address":[52905067,52906823],"length":1,"stats":{"Line":0}},{"line":3182,"address":[53378677,53378760],"length":1,"stats":{"Line":4}},{"line":3183,"address":[54210289],"length":1,"stats":{"Line":2}},{"line":3184,"address":[52906729,52905277],"length":1,"stats":{"Line":0}},{"line":3186,"address":[54210321,54210388],"length":1,"stats":{"Line":4}},{"line":3187,"address":[52905330,52905403],"length":1,"stats":{"Line":4}},{"line":3188,"address":[52905359,52906680],"length":1,"stats":{"Line":0}},{"line":3190,"address":[53379076],"length":1,"stats":{"Line":2}},{"line":3191,"address":[55518170],"length":1,"stats":{"Line":0}},{"line":3193,"address":[52905767,52905539,52905736],"length":1,"stats":{"Line":4}},{"line":3194,"address":[53379364,53379337],"length":1,"stats":{"Line":4}},{"line":3195,"address":[55518419,55518475],"length":1,"stats":{"Line":2}},{"line":3196,"address":[52906076,52906154,52905910,52906011],"length":1,"stats":{"Line":2}},{"line":3198,"address":[55518501,55518448,55518585],"length":1,"stats":{"Line":6}},{"line":3200,"address":[52906139,52906060,52905984],"length":1,"stats":{"Line":6}},{"line":3202,"address":[52906535],"length":1,"stats":{"Line":2}},{"line":3212,"address":[55281636,55281346],"length":1,"stats":{"Line":51}},{"line":3213,"address":[53610125],"length":1,"stats":{"Line":13}},{"line":3214,"address":[54299717,54299574,54297776],"length":1,"stats":{"Line":75}},{"line":3215,"address":[55546934,55547007],"length":1,"stats":{"Line":4}},{"line":3216,"address":[54297983,54297909],"length":1,"stats":{"Line":4}},{"line":3217,"address":[53006934,53005264],"length":1,"stats":{"Line":0}},{"line":3219,"address":[53466487,53466561],"length":1,"stats":{"Line":4}},{"line":3220,"address":[53466575,53466642],"length":1,"stats":{"Line":4}},{"line":3221,"address":[53466603,53468081],"length":1,"stats":{"Line":0}},{"line":3223,"address":[53005603],"length":1,"stats":{"Line":2}},{"line":3224,"address":[53005707,53005793,53005656],"length":1,"stats":{"Line":6}},{"line":3225,"address":[53467110,53467391],"length":1,"stats":{"Line":4}},{"line":3226,"address":[53467580,53467499],"length":1,"stats":{"Line":4}},{"line":3228,"address":[54298673],"length":1,"stats":{"Line":2}},{"line":3233,"address":[54966868,54966605],"length":1,"stats":{"Line":50}},{"line":3234,"address":[55281819],"length":1,"stats":{"Line":14}},{"line":3235,"address":[54449823,54449746],"length":1,"stats":{"Line":74}},{"line":3236,"address":[55628178,55628260],"length":1,"stats":{"Line":4}},{"line":3237,"address":[53503949,53504022],"length":1,"stats":{"Line":4}},{"line":3238,"address":[55629714,55628304],"length":1,"stats":{"Line":0}},{"line":3240,"address":[53504220,53504303],"length":1,"stats":{"Line":4}},{"line":3241,"address":[54335897,54335824],"length":1,"stats":{"Line":4}},{"line":3242,"address":[55628643,55629646],"length":1,"stats":{"Line":0}},{"line":3244,"address":[53504571],"length":1,"stats":{"Line":2}},{"line":3245,"address":[55628898,55628972],"length":1,"stats":{"Line":4}},{"line":3246,"address":[55629023],"length":1,"stats":{"Line":2}},{"line":3247,"address":[54336668,54336412],"length":1,"stats":{"Line":4}},{"line":3248,"address":[53505198],"length":1,"stats":{"Line":2}},{"line":3250,"address":[54336799,54336673],"length":1,"stats":{"Line":4}},{"line":3251,"address":[53505309],"length":1,"stats":{"Line":2}},{"line":3254,"address":[54336439],"length":1,"stats":{"Line":2}},{"line":3259,"address":[54450240,54449950],"length":1,"stats":{"Line":50}},{"line":3260,"address":[55282177],"length":1,"stats":{"Line":14}},{"line":3261,"address":[53380464,53381369,53381421],"length":1,"stats":{"Line":76}},{"line":3263,"address":[54212088,54212009],"length":1,"stats":{"Line":8}},{"line":3264,"address":[53380601,53380668],"length":1,"stats":{"Line":9}},{"line":3265,"address":[55538230,55537529],"length":1,"stats":{"Line":0}},{"line":3267,"address":[54212344,54212415],"length":1,"stats":{"Line":9}},{"line":3268,"address":[53380942],"length":1,"stats":{"Line":2}},{"line":3270,"address":[54212508,54212638,54212421,54212598],"length":1,"stats":{"Line":12}},{"line":3271,"address":[54212523],"length":1,"stats":{"Line":3}},{"line":3272,"address":[55537918],"length":1,"stats":{"Line":3}},{"line":3273,"address":[52851821],"length":1,"stats":{"Line":3}},{"line":3274,"address":[54212654,54212746],"length":1,"stats":{"Line":3}},{"line":3275,"address":[52851911,52851971],"length":1,"stats":{"Line":6}},{"line":3280,"address":[53610995,53611258],"length":1,"stats":{"Line":50}},{"line":3281,"address":[54967350],"length":1,"stats":{"Line":14}},{"line":3282,"address":[54369548,54369829,54368208],"length":1,"stats":{"Line":76}},{"line":3283,"address":[55667884,55667971],"length":1,"stats":{"Line":7}},{"line":3284,"address":[53536927,53536860],"length":1,"stats":{"Line":6}},{"line":3285,"address":[52971330,52970012],"length":1,"stats":{"Line":0}},{"line":3287,"address":[55668216,55668286],"length":1,"stats":{"Line":6}},{"line":3288,"address":[54368704],"length":1,"stats":{"Line":2}},{"line":3289,"address":[53538170,53537255],"length":1,"stats":{"Line":0}},{"line":3291,"address":[52970389,52970340],"length":1,"stats":{"Line":6}},{"line":3292,"address":[54368827,54369554],"length":1,"stats":{"Line":0}},{"line":3294,"address":[53537398,53537299],"length":1,"stats":{"Line":8}},{"line":3295,"address":[52970494,52970776],"length":1,"stats":{"Line":5}},{"line":3296,"address":[55668738],"length":1,"stats":{"Line":4}},{"line":3297,"address":[55668797,55668746],"length":1,"stats":{"Line":9}},{"line":3298,"address":[55668886,55668813],"length":1,"stats":{"Line":9}},{"line":3299,"address":[52970893],"length":1,"stats":{"Line":5}},{"line":3304,"address":[54967837,54967574],"length":1,"stats":{"Line":50}},{"line":3305,"address":[54450781],"length":1,"stats":{"Line":15}},{"line":3306,"address":[53611534,53611456],"length":1,"stats":{"Line":72}},{"line":3308,"address":[54424668,54424578],"length":1,"stats":{"Line":4}},{"line":3309,"address":[55717621],"length":1,"stats":{"Line":2}},{"line":3310,"address":[52856943,52855819],"length":1,"stats":{"Line":0}},{"line":3312,"address":[54424848,54424765],"length":1,"stats":{"Line":4}},{"line":3314,"address":[53593634,53593492,53593410,53593594],"length":1,"stats":{"Line":8}},{"line":3315,"address":[53593507],"length":1,"stats":{"Line":2}},{"line":3316,"address":[53593538],"length":1,"stats":{"Line":2}},{"line":3317,"address":[53593617],"length":1,"stats":{"Line":2}},{"line":3318,"address":[55718074],"length":1,"stats":{"Line":2}},{"line":3319,"address":[55718090],"length":1,"stats":{"Line":2}},{"line":3320,"address":[55718280,55718535],"length":1,"stats":{"Line":4}},{"line":3321,"address":[54425646,54425768],"length":1,"stats":{"Line":2}},{"line":3322,"address":[55718720,55718666],"length":1,"stats":{"Line":4}},{"line":3324,"address":[53593880],"length":1,"stats":{"Line":2}},{"line":3329,"address":[53611904,53611641],"length":1,"stats":{"Line":50}},{"line":3330,"address":[54451139],"length":1,"stats":{"Line":15}},{"line":3331,"address":[54451255,54451178],"length":1,"stats":{"Line":72}},{"line":3332,"address":[52927826,52927900],"length":1,"stats":{"Line":4}},{"line":3333,"address":[52927908],"length":1,"stats":{"Line":2}},{"line":3334,"address":[54226735],"length":1,"stats":{"Line":2}},{"line":3335,"address":[52928260,52929128],"length":1,"stats":{"Line":4}},{"line":3336,"address":[54227074,54228255],"length":1,"stats":{"Line":0}},{"line":3337,"address":[54227116,54228570],"length":1,"stats":{"Line":0}},{"line":3338,"address":[52928150,52928787],"length":1,"stats":{"Line":0}},{"line":3339,"address":[52928518,52928058],"length":1,"stats":{"Line":0}},{"line":3340,"address":[53395970,53395368],"length":1,"stats":{"Line":0}},{"line":3341,"address":[53395456,53396223],"length":1,"stats":{"Line":0}},{"line":3342,"address":[55508575,55507678],"length":1,"stats":{"Line":0}},{"line":3343,"address":[54228885,54227158],"length":1,"stats":{"Line":0}},{"line":3344,"address":[52928412,52930157],"length":1,"stats":{"Line":0}},{"line":3345,"address":[52928450,52930289],"length":1,"stats":{"Line":0}},{"line":3346,"address":[55509881,55507948],"length":1,"stats":{"Line":0}},{"line":3347,"address":[53395272,53398068],"length":1,"stats":{"Line":0}},{"line":3349,"address":[52930741,52928628],"length":1,"stats":{"Line":4}},{"line":3354,"address":[54451672,54451382],"length":1,"stats":{"Line":51}},{"line":3355,"address":[54451497],"length":1,"stats":{"Line":15}},{"line":3356,"address":[53612180,53612102],"length":1,"stats":{"Line":70}},{"line":3357,"address":[53654385,53654000,53654379],"length":1,"stats":{"Line":2}},{"line":3358,"address":[54497345],"length":1,"stats":{"Line":2}},{"line":3359,"address":[55010303],"length":1,"stats":{"Line":2}},{"line":3360,"address":[54497519,54497371],"length":1,"stats":{"Line":4}},{"line":3361,"address":[54497723,54497697],"length":1,"stats":{"Line":4}},{"line":3364,"address":[54497435],"length":1,"stats":{"Line":2}},{"line":3367,"address":[54394096,54394009],"length":1,"stats":{"Line":4}},{"line":3368,"address":[53562676,53562609],"length":1,"stats":{"Line":4}},{"line":3369,"address":[53562637,53563416],"length":1,"stats":{"Line":0}},{"line":3371,"address":[54394188],"length":1,"stats":{"Line":2}},{"line":3372,"address":[53562747,53562949,53562822],"length":1,"stats":{"Line":6}},{"line":3373,"address":[54394877,54394654],"length":1,"stats":{"Line":4}},{"line":3375,"address":[54394683],"length":1,"stats":{"Line":2}},{"line":3384,"address":[54968805,54968543],"length":1,"stats":{"Line":50}},{"line":3385,"address":[55283967],"length":1,"stats":{"Line":16}},{"line":3386,"address":[53612425,53612502],"length":1,"stats":{"Line":70}},{"line":3388,"address":[52986592,52986526],"length":1,"stats":{"Line":4}},{"line":3389,"address":[52986677],"length":1,"stats":{"Line":2}},{"line":3394,"address":[54452382,54452095],"length":1,"stats":{"Line":50}},{"line":3395,"address":[54452210],"length":1,"stats":{"Line":16}},{"line":3396,"address":[53612747,53612824],"length":1,"stats":{"Line":70}},{"line":3398,"address":[52981856,52981790],"length":1,"stats":{"Line":4}},{"line":3399,"address":[54391709],"length":1,"stats":{"Line":2}},{"line":3404,"address":[53612931,53613194],"length":1,"stats":{"Line":50}},{"line":3405,"address":[53613030],"length":1,"stats":{"Line":17}},{"line":3406,"address":[54969403,54969325],"length":1,"stats":{"Line":66}},{"line":3407,"address":[52960118,52960183],"length":1,"stats":{"Line":0}},{"line":3408,"address":[52960247],"length":1,"stats":{"Line":0}},{"line":3409,"address":[55510678],"length":1,"stats":{"Line":0}},{"line":3410,"address":[53525787,53526076],"length":1,"stats":{"Line":0}},{"line":3412,"address":[53525956],"length":1,"stats":{"Line":0}},{"line":3413,"address":[52960431],"length":1,"stats":{"Line":0}},{"line":3418,"address":[54969773,54969510],"length":1,"stats":{"Line":50}},{"line":3419,"address":[53613353],"length":1,"stats":{"Line":17}},{"line":3420,"address":[53613470,53613392],"length":1,"stats":{"Line":66}},{"line":3423,"address":[54421343,54421270],"length":1,"stats":{"Line":0}},{"line":3424,"address":[55657205,55657268],"length":1,"stats":{"Line":0}},{"line":3426,"address":[52847505],"length":1,"stats":{"Line":0}},{"line":3428,"address":[55657481,55657229],"length":1,"stats":{"Line":0}},{"line":3438,"address":[53613577,53613840],"length":1,"stats":{"Line":50}},{"line":3439,"address":[55285393],"length":1,"stats":{"Line":17}},{"line":3440,"address":[54969971,54970049],"length":1,"stats":{"Line":69}},{"line":3441,"address":[54333702,54333789],"length":1,"stats":{"Line":10}},{"line":3442,"address":[54333860],"length":1,"stats":{"Line":5}},{"line":3444,"address":[53069872,52852328,53069901,52852380],"length":1,"stats":{"Line":30}},{"line":3445,"address":[54334239],"length":1,"stats":{"Line":8}},{"line":3447,"address":[55566476,55567018],"length":1,"stats":{"Line":4}},{"line":3448,"address":[55566402,55567088],"length":1,"stats":{"Line":0}},{"line":3454,"address":[54970156,54970419],"length":1,"stats":{"Line":49}},{"line":3455,"address":[54453639],"length":1,"stats":{"Line":17}},{"line":3456,"address":[55285790,55285867],"length":1,"stats":{"Line":68}},{"line":3457,"address":[53484502,53484583,53485265],"length":1,"stats":{"Line":4}},{"line":3458,"address":[53484686,53484619],"length":1,"stats":{"Line":4}},{"line":3459,"address":[55580867,55580809],"length":1,"stats":{"Line":4}},{"line":3460,"address":[53485075],"length":1,"stats":{"Line":2}},{"line":3462,"address":[53484647,53485226],"length":1,"stats":{"Line":0}},{"line":3468,"address":[54454172,54453882],"length":1,"stats":{"Line":50}},{"line":3469,"address":[53614322],"length":1,"stats":{"Line":16}},{"line":3470,"address":[54454036,54454113],"length":1,"stats":{"Line":70}},{"line":3471,"address":[53032566,53032631,53033196],"length":1,"stats":{"Line":4}},{"line":3472,"address":[53455590,53455523],"length":1,"stats":{"Line":4}},{"line":3473,"address":[55552985,55553043],"length":1,"stats":{"Line":4}},{"line":3474,"address":[55553190],"length":1,"stats":{"Line":2}},{"line":3476,"address":[55553301,55552835],"length":1,"stats":{"Line":0}},{"line":3482,"address":[55286352,55286642],"length":1,"stats":{"Line":50}},{"line":3483,"address":[54970901],"length":1,"stats":{"Line":16}},{"line":3484,"address":[53614684,53614762],"length":1,"stats":{"Line":70}},{"line":3485,"address":[52885814,52885879,52886470],"length":1,"stats":{"Line":4}},{"line":3486,"address":[52885915,52885986],"length":1,"stats":{"Line":4}},{"line":3487,"address":[53387863,53387801,53387984],"length":1,"stats":{"Line":6}},{"line":3489,"address":[55562163,55562655],"length":1,"stats":{"Line":0}},{"line":3495,"address":[55287000,55286710],"length":1,"stats":{"Line":50}},{"line":3496,"address":[55286825],"length":1,"stats":{"Line":16}},{"line":3497,"address":[54971341,54971263],"length":1,"stats":{"Line":68}},{"line":3500,"address":[54375754,54375825,54374919,54374800,54374838],"length":1,"stats":{"Line":6}},{"line":3501,"address":[55520447],"length":1,"stats":{"Line":2}},{"line":3503,"address":[52985772],"length":1,"stats":{"Line":2}},{"line":3504,"address":[53544043],"length":1,"stats":{"Line":2}},{"line":3506,"address":[54375784,54374975],"length":1,"stats":{"Line":0}},{"line":3512,"address":[54454956,54455246],"length":1,"stats":{"Line":50}},{"line":3513,"address":[54971547],"length":1,"stats":{"Line":16}},{"line":3514,"address":[54971586,54971664],"length":1,"stats":{"Line":68}},{"line":3517,"address":[55555824,55556768,55555862,55556701,55555935],"length":1,"stats":{"Line":6}},{"line":3518,"address":[55556031],"length":1,"stats":{"Line":2}},{"line":3520,"address":[52943292],"length":1,"stats":{"Line":2}},{"line":3521,"address":[54436187],"length":1,"stats":{"Line":2}},{"line":3523,"address":[52943959,52943219],"length":1,"stats":{"Line":0}},{"line":3529,"address":[53615515,53615778],"length":1,"stats":{"Line":49}},{"line":3530,"address":[55287541],"length":1,"stats":{"Line":16}},{"line":3531,"address":[53615653,53615731],"length":1,"stats":{"Line":68}},{"line":3534,"address":[53028336,53028374,53029213,53028447,53029280],"length":1,"stats":{"Line":6}},{"line":3535,"address":[53495131],"length":1,"stats":{"Line":2}},{"line":3537,"address":[54326664],"length":1,"stats":{"Line":2}},{"line":3538,"address":[53029015],"length":1,"stats":{"Line":2}},{"line":3540,"address":[54327400,54326591],"length":1,"stats":{"Line":0}},{"line":3546,"address":[54455672,54455962],"length":1,"stats":{"Line":50}},{"line":3547,"address":[54972193],"length":1,"stats":{"Line":20}},{"line":3548,"address":[54455826,54455903],"length":1,"stats":{"Line":62}},{"line":3549,"address":[55681375,55682041,55681302],"length":1,"stats":{"Line":4}},{"line":3550,"address":[54363313,54363368],"length":1,"stats":{"Line":4}},{"line":3551,"address":[55681688],"length":1,"stats":{"Line":2}},{"line":3552,"address":[53038458],"length":1,"stats":{"Line":2}},{"line":3553,"address":[54363789],"length":1,"stats":{"Line":2}},{"line":3555,"address":[53532471,53531825],"length":1,"stats":{"Line":0}},{"line":3561,"address":[54456320,54456030],"length":1,"stats":{"Line":51}},{"line":3562,"address":[53616260],"length":1,"stats":{"Line":20}},{"line":3563,"address":[55288296,55288373],"length":1,"stats":{"Line":62}},{"line":3564,"address":[54307958,54308031],"length":1,"stats":{"Line":4}},{"line":3566,"address":[53476627],"length":1,"stats":{"Line":2}},{"line":3567,"address":[55511457,55511320,55511188],"length":1,"stats":{"Line":6}},{"line":3569,"address":[54308590,54308087],"length":1,"stats":{"Line":0}},{"line":3574,"address":[54456388,54456678],"length":1,"stats":{"Line":52}},{"line":3575,"address":[54456503],"length":1,"stats":{"Line":21}},{"line":3576,"address":[54972878,54972956],"length":1,"stats":{"Line":56}},{"line":3579,"address":[54379911,54379859,54379200,54379238,54379311],"length":1,"stats":{"Line":6}},{"line":3580,"address":[53547907],"length":1,"stats":{"Line":2}},{"line":3581,"address":[54379588,54379741,54379440],"length":1,"stats":{"Line":6}},{"line":3583,"address":[55606261,55605803],"length":1,"stats":{"Line":0}},{"line":3589,"address":[53616807,53617070],"length":1,"stats":{"Line":50}},{"line":3590,"address":[53616906],"length":1,"stats":{"Line":23}},{"line":3591,"address":[54456900,54456977],"length":1,"stats":{"Line":54}},{"line":3594,"address":[54233395,54232736,54232774,54232847,54233447],"length":1,"stats":{"Line":6}},{"line":3595,"address":[52918903],"length":1,"stats":{"Line":2}},{"line":3596,"address":[54232976,54233124,54233277],"length":1,"stats":{"Line":6}},{"line":3598,"address":[53401399,53401902],"length":1,"stats":{"Line":0}},{"line":3604,"address":[55289216,55289503],"length":1,"stats":{"Line":49}},{"line":3605,"address":[54973485],"length":1,"stats":{"Line":23}},{"line":3606,"address":[53617268,53617345],"length":1,"stats":{"Line":56}},{"line":3607,"address":[52883535,52883478],"length":1,"stats":{"Line":4}},{"line":3612,"address":[55289571,55289861],"length":1,"stats":{"Line":50}},{"line":3613,"address":[53617551],"length":1,"stats":{"Line":22}},{"line":3614,"address":[52912526,52912288],"length":1,"stats":{"Line":60}},{"line":3615,"address":[52912320,52912524,52912379],"length":1,"stats":{"Line":14}},{"line":3616,"address":[55599084,55599026],"length":1,"stats":{"Line":14}},{"line":3618,"address":[53501191,53501114],"length":1,"stats":{"Line":0}},{"line":3624,"address":[54974031,54974294],"length":1,"stats":{"Line":50}},{"line":3625,"address":[54457932],"length":1,"stats":{"Line":22}},{"line":3626,"address":[53617913,53617991],"length":1,"stats":{"Line":60}},{"line":3627,"address":[55560256,55560192],"length":1,"stats":{"Line":8}},{"line":3632,"address":[54974354,54974617],"length":1,"stats":{"Line":50}},{"line":3633,"address":[54458290],"length":1,"stats":{"Line":22}},{"line":3634,"address":[55521664,55521866],"length":1,"stats":{"Line":59}},{"line":3635,"address":[54435232,54435308],"length":1,"stats":{"Line":6}},{"line":3644,"address":[55290645,55290935],"length":1,"stats":{"Line":49}},{"line":3645,"address":[54974776],"length":1,"stats":{"Line":22}},{"line":3646,"address":[54458764,54458687],"length":1,"stats":{"Line":57}},{"line":3647,"address":[52902099,52902158],"length":1,"stats":{"Line":0}},{"line":3648,"address":[52902250],"length":1,"stats":{"Line":0}},{"line":3649,"address":[55502640,55502790],"length":1,"stats":{"Line":0}},{"line":3655,"address":[53618744,53619007],"length":1,"stats":{"Line":50}},{"line":3656,"address":[54459006],"length":1,"stats":{"Line":21}},{"line":3657,"address":[53618960,53618882],"length":1,"stats":{"Line":58}},{"line":3658,"address":[54250963,54251030],"length":1,"stats":{"Line":0}},{"line":3659,"address":[53419622],"length":1,"stats":{"Line":0}},{"line":3660,"address":[53419731,53419580],"length":1,"stats":{"Line":0}},{"line":3666,"address":[54975586,54975323],"length":1,"stats":{"Line":48}},{"line":3667,"address":[54459364],"length":1,"stats":{"Line":21}},{"line":3668,"address":[53532528,53532867],"length":1,"stats":{"Line":59}},{"line":3669,"address":[53532630,53532563],"length":1,"stats":{"Line":0}},{"line":3670,"address":[54364230],"length":1,"stats":{"Line":0}},{"line":3671,"address":[52988208,52988358],"length":1,"stats":{"Line":0}},{"line":3677,"address":[53619390,53619653],"length":1,"stats":{"Line":50}},{"line":3678,"address":[54975745],"length":1,"stats":{"Line":20}},{"line":3679,"address":[54459761,54459838],"length":1,"stats":{"Line":60}},{"line":3682,"address":[53534958,53535195,53534928,53535024],"length":1,"stats":{"Line":0}},{"line":3683,"address":[55561819],"length":1,"stats":{"Line":0}},{"line":3684,"address":[53535110,53535163],"length":1,"stats":{"Line":0}},{"line":3690,"address":[55292367,55292077],"length":1,"stats":{"Line":49}},{"line":3691,"address":[54976068],"length":1,"stats":{"Line":19}},{"line":3692,"address":[55292231,55292308],"length":1,"stats":{"Line":62}},{"line":3695,"address":[54383488,54383526,54384030,54383599],"length":1,"stats":{"Line":0}},{"line":3696,"address":[55506679],"length":1,"stats":{"Line":0}},{"line":3697,"address":[53552232],"length":1,"stats":{"Line":0}},{"line":3698,"address":[53552250,53552431],"length":1,"stats":{"Line":0}},{"line":3700,"address":[53552291,53552388],"length":1,"stats":{"Line":0}},{"line":3702,"address":[53044747,53045079],"length":1,"stats":{"Line":0}},{"line":3708,"address":[54460613,54460323],"length":1,"stats":{"Line":50}},{"line":3709,"address":[54976391],"length":1,"stats":{"Line":19}},{"line":3710,"address":[55292589,55292666],"length":1,"stats":{"Line":62}},{"line":3713,"address":[52869296,52869334,52869399,52869824],"length":1,"stats":{"Line":0}},{"line":3714,"address":[53452483],"length":1,"stats":{"Line":0}},{"line":3715,"address":[53452520],"length":1,"stats":{"Line":0}},{"line":3716,"address":[55665438,55665618],"length":1,"stats":{"Line":0}},{"line":3718,"address":[54284083,54284180],"length":1,"stats":{"Line":0}},{"line":3720,"address":[55665671,55665339],"length":1,"stats":{"Line":0}},{"line":3726,"address":[54460681,54460971],"length":1,"stats":{"Line":50}},{"line":3727,"address":[54976714],"length":1,"stats":{"Line":19}},{"line":3728,"address":[55292947,55293024],"length":1,"stats":{"Line":62}},{"line":3731,"address":[55630814,55630720,55630755,55631002],"length":1,"stats":{"Line":0}},{"line":3732,"address":[54223447,54223380],"length":1,"stats":{"Line":0}},{"line":3733,"address":[55630970,55630858],"length":1,"stats":{"Line":0}},{"line":3739,"address":[55293151,55293441],"length":1,"stats":{"Line":50}},{"line":3740,"address":[55293266],"length":1,"stats":{"Line":20}},{"line":3741,"address":[54461193,54461270],"length":1,"stats":{"Line":60}},{"line":3744,"address":[55606735,55606358,55606320,55606423],"length":1,"stats":{"Line":0}},{"line":3745,"address":[53535341,53535408],"length":1,"stats":{"Line":0}},{"line":3746,"address":[52898690,52898918],"length":1,"stats":{"Line":0}},{"line":3752,"address":[54461687,54461397],"length":1,"stats":{"Line":49}},{"line":3753,"address":[53621104],"length":1,"stats":{"Line":19}},{"line":3754,"address":[53621221,53621143],"length":1,"stats":{"Line":62}},{"line":3757,"address":[52957158,52957120,52957535,52957223],"length":1,"stats":{"Line":6}},{"line":3758,"address":[52957300,52957237],"length":1,"stats":{"Line":4}},{"line":3759,"address":[53521827,53521598],"length":1,"stats":{"Line":0}},{"line":3765,"address":[53621328,53621591],"length":1,"stats":{"Line":47}},{"line":3766,"address":[54461870],"length":1,"stats":{"Line":19}},{"line":3767,"address":[54977722,54977800],"length":1,"stats":{"Line":63}},{"line":3770,"address":[55637328,55637366,55637743,55637431],"length":1,"stats":{"Line":0}},{"line":3771,"address":[54251488,54251421],"length":1,"stats":{"Line":0}},{"line":3772,"address":[55637474,55637702],"length":1,"stats":{"Line":0}},{"line":3778,"address":[53621914,53621651],"length":1,"stats":{"Line":50}},{"line":3779,"address":[53621750],"length":1,"stats":{"Line":16}},{"line":3780,"address":[55294456,55294379],"length":1,"stats":{"Line":68}},{"line":3783,"address":[55557335,55557586,55557232,55557270],"length":1,"stats":{"Line":0}},{"line":3784,"address":[53010709,53010781,53010878],"length":1,"stats":{"Line":0}},{"line":3785,"address":[54236207],"length":1,"stats":{"Line":0}},{"line":3786,"address":[53010871,53081008,53081038],"length":1,"stats":{"Line":0}},{"line":3787,"address":[53010740,53010908],"length":1,"stats":{"Line":0}},{"line":3793,"address":[55294583,55294873],"length":1,"stats":{"Line":50}},{"line":3794,"address":[54462586],"length":1,"stats":{"Line":16}},{"line":3795,"address":[54462625,54462702],"length":1,"stats":{"Line":68}},{"line":3798,"address":[54287616,54287654,54287727,54287987],"length":1,"stats":{"Line":12}},{"line":3799,"address":[53456414,53456309,53456237],"length":1,"stats":{"Line":10}},{"line":3800,"address":[53456367],"length":1,"stats":{"Line":4}},{"line":3801,"address":[55727262,55727232,55690519],"length":1,"stats":{"Line":8}},{"line":3802,"address":[54287772,54287949],"length":1,"stats":{"Line":0}},{"line":3812,"address":[55295231,55294941],"length":1,"stats":{"Line":50}},{"line":3813,"address":[55295056],"length":1,"stats":{"Line":16}},{"line":3814,"address":[54978691,54978769],"length":1,"stats":{"Line":68}},{"line":3817,"address":[53519752,53519832,53518600,53518464,53518508],"length":1,"stats":{"Line":6}},{"line":3818,"address":[53518706],"length":1,"stats":{"Line":2}},{"line":3819,"address":[52893171],"length":1,"stats":{"Line":2}},{"line":3820,"address":[52893527,52893387],"length":1,"stats":{"Line":4}},{"line":3821,"address":[53519318,53519589],"length":1,"stats":{"Line":4}},{"line":3823,"address":[54350870],"length":1,"stats":{"Line":2}},{"line":3825,"address":[54351292,54350163],"length":1,"stats":{"Line":0}},{"line":3831,"address":[54978876,54979139],"length":1,"stats":{"Line":51}},{"line":3832,"address":[55295414],"length":1,"stats":{"Line":16}},{"line":3833,"address":[55295453,55295530],"length":1,"stats":{"Line":66}},{"line":3836,"address":[53490623,53489936,53490737,53489974,53490047],"length":1,"stats":{"Line":8}},{"line":3837,"address":[53490066],"length":1,"stats":{"Line":3}},{"line":3838,"address":[53490083,53490150],"length":1,"stats":{"Line":8}},{"line":3839,"address":[53490164],"length":1,"stats":{"Line":4}},{"line":3840,"address":[55542866,55542459],"length":1,"stats":{"Line":0}},{"line":3842,"address":[54321739,54321801,54322012],"length":1,"stats":{"Line":8}},{"line":3843,"address":[53490421],"length":1,"stats":{"Line":3}},{"line":3844,"address":[55542697],"length":1,"stats":{"Line":3}},{"line":3845,"address":[53071488,53071520,52963829],"length":1,"stats":{"Line":7}},{"line":3847,"address":[52963491,52964042],"length":1,"stats":{"Line":0}},{"line":3853,"address":[54463835,54463545],"length":1,"stats":{"Line":50}},{"line":3854,"address":[55295772],"length":1,"stats":{"Line":17}},{"line":3855,"address":[53623159,53623081],"length":1,"stats":{"Line":66}},{"line":3858,"address":[54395750,54395103,54394992,54395030,54395636],"length":1,"stats":{"Line":6}},{"line":3859,"address":[54395122],"length":1,"stats":{"Line":2}},{"line":3860,"address":[52999146,52999083],"length":1,"stats":{"Line":4}},{"line":3861,"address":[53563716],"length":1,"stats":{"Line":2}},{"line":3862,"address":[52999195,52999567],"length":1,"stats":{"Line":0}},{"line":3864,"address":[53563849,53563787,53563970],"length":1,"stats":{"Line":6}},{"line":3866,"address":[54395167,54395709],"length":1,"stats":{"Line":0}},{"line":3872,"address":[55296015,55296305],"length":1,"stats":{"Line":50}},{"line":3873,"address":[54464018],"length":1,"stats":{"Line":17}},{"line":3874,"address":[54464057,54464134],"length":1,"stats":{"Line":66}},{"line":3877,"address":[54222310,54222391,54222272,54223119,54223236],"length":1,"stats":{"Line":6}},{"line":3878,"address":[54222410],"length":1,"stats":{"Line":2}},{"line":3879,"address":[54222494,54222427],"length":1,"stats":{"Line":4}},{"line":3880,"address":[55685568],"length":1,"stats":{"Line":2}},{"line":3881,"address":[54223135,54222543],"length":1,"stats":{"Line":0}},{"line":3883,"address":[53019175,53019233],"length":1,"stats":{"Line":4}},{"line":3884,"address":[53391351],"length":1,"stats":{"Line":2}},{"line":3885,"address":[53019470],"length":1,"stats":{"Line":2}},{"line":3887,"address":[53019051,53019742],"length":1,"stats":{"Line":0}},{"line":3893,"address":[54464551,54464261],"length":1,"stats":{"Line":50}},{"line":3894,"address":[54464376],"length":1,"stats":{"Line":17}},{"line":3895,"address":[55296527,55296604],"length":1,"stats":{"Line":66}},{"line":3898,"address":[52995952,52995990,52997172,52997102,52996071],"length":1,"stats":{"Line":6}},{"line":3899,"address":[55641173],"length":1,"stats":{"Line":2}},{"line":3900,"address":[53517310],"length":1,"stats":{"Line":2}},{"line":3901,"address":[54348869,54348939,54349066],"length":1,"stats":{"Line":6}},{"line":3902,"address":[55641621,55641846],"length":1,"stats":{"Line":4}},{"line":3903,"address":[52996863],"length":1,"stats":{"Line":2}},{"line":3905,"address":[55641646],"length":1,"stats":{"Line":2}},{"line":3907,"address":[52996114,52997128],"length":1,"stats":{"Line":0}},{"line":3913,"address":[54464619,54464909],"length":1,"stats":{"Line":47}},{"line":3914,"address":[53624011],"length":1,"stats":{"Line":16}},{"line":3915,"address":[54464850,54464773],"length":1,"stats":{"Line":70}},{"line":3918,"address":[55649001,55648447,55648336,55648949,55648374],"length":1,"stats":{"Line":6}},{"line":3919,"address":[54295717],"length":1,"stats":{"Line":2}},{"line":3920,"address":[54295822,54295729],"length":1,"stats":{"Line":4}},{"line":3921,"address":[52919564],"length":1,"stats":{"Line":2}},{"line":3922,"address":[54295911],"length":1,"stats":{"Line":2}},{"line":3923,"address":[55648667,55732144,55732628,55732634,55732195],"length":1,"stats":{"Line":6}},{"line":3924,"address":[54449373,54449509,54449547,54449778,54449414],"length":1,"stats":{"Line":4}},{"line":3925,"address":[55732236,55732304],"length":1,"stats":{"Line":4}},{"line":3926,"address":[54449502],"length":1,"stats":{"Line":2}},{"line":3929,"address":[55648684,55648602],"length":1,"stats":{"Line":2}},{"line":3930,"address":[53464539],"length":1,"stats":{"Line":2}},{"line":3932,"address":[55648960,55648485],"length":1,"stats":{"Line":0}},{"line":3938,"address":[55297089,55297379],"length":1,"stats":{"Line":50}},{"line":3939,"address":[53624334],"length":1,"stats":{"Line":14}},{"line":3940,"address":[53624451,53624373],"length":1,"stats":{"Line":72}},{"line":3943,"address":[55625648,55627200,55625788,55625698,55627124],"length":1,"stats":{"Line":6}},{"line":3944,"address":[55625805],"length":1,"stats":{"Line":2}},{"line":3945,"address":[55625833],"length":1,"stats":{"Line":2}},{"line":3946,"address":[55625882,55625954,55626087],"length":1,"stats":{"Line":6}},{"line":3947,"address":[55626281,55626528],"length":1,"stats":{"Line":4}},{"line":3948,"address":[55626540],"length":1,"stats":{"Line":2}},{"line":3949,"address":[52933319,52933376],"length":1,"stats":{"Line":4}},{"line":3950,"address":[55626721],"length":1,"stats":{"Line":2}},{"line":3951,"address":[53443486],"length":1,"stats":{"Line":2}},{"line":3955,"address":[52933015],"length":1,"stats":{"Line":2}},{"line":3957,"address":[55625840,55627156],"length":1,"stats":{"Line":0}},{"line":3967,"address":[54980814,54981077],"length":1,"stats":{"Line":49}},{"line":3968,"address":[54980913],"length":1,"stats":{"Line":13}},{"line":3969,"address":[54980952,54981030],"length":1,"stats":{"Line":78}},{"line":3970,"address":[54319548,54319458],"length":1,"stats":{"Line":8}},{"line":3971,"address":[54319645,54319565],"length":1,"stats":{"Line":8}},{"line":3972,"address":[54321373,54319603],"length":1,"stats":{"Line":0}},{"line":3974,"address":[53488149,53488232],"length":1,"stats":{"Line":8}},{"line":3975,"address":[54319761],"length":1,"stats":{"Line":4}},{"line":3976,"address":[54321278,54319821],"length":1,"stats":{"Line":0}},{"line":3978,"address":[55618900,55618837],"length":1,"stats":{"Line":8}},{"line":3979,"address":[53488443,53488370],"length":1,"stats":{"Line":8}},{"line":3980,"address":[53489725,53488399],"length":1,"stats":{"Line":0}},{"line":3982,"address":[54320052],"length":1,"stats":{"Line":4}},{"line":3983,"address":[52879178],"length":1,"stats":{"Line":0}},{"line":3985,"address":[52879155,52879383,52879352],"length":1,"stats":{"Line":8}},{"line":3986,"address":[53488836,53488809],"length":1,"stats":{"Line":8}},{"line":3987,"address":[55619395,55619451],"length":1,"stats":{"Line":4}},{"line":3988,"address":[54320624,54320702,54320559,54320458],"length":1,"stats":{"Line":4}},{"line":3990,"address":[54320441,54320525,54320388],"length":1,"stats":{"Line":12}},{"line":3992,"address":[54320532,54320687,54320608],"length":1,"stats":{"Line":12}},{"line":3998,"address":[53624881,53625144],"length":1,"stats":{"Line":50}},{"line":3999,"address":[53624980],"length":1,"stats":{"Line":13}},{"line":4000,"address":[55297959,55298036],"length":1,"stats":{"Line":74}},{"line":4003,"address":[55651011,55650567,55650464,55650502],"length":1,"stats":{"Line":8}},{"line":4004,"address":[55650581],"length":1,"stats":{"Line":3}},{"line":4005,"address":[53435678,53608064,53608088,53435739],"length":1,"stats":{"Line":12}},{"line":4006,"address":[55650778],"length":1,"stats":{"Line":3}},{"line":4007,"address":[55650737],"length":1,"stats":{"Line":3}},{"line":4008,"address":[53062724,53062830,53077728,53077756],"length":1,"stats":{"Line":12}},{"line":4011,"address":[53435695,53436059],"length":1,"stats":{"Line":0}},{"line":4017,"address":[55298163,55298453],"length":1,"stats":{"Line":49}},{"line":4018,"address":[54466166],"length":1,"stats":{"Line":12}},{"line":4019,"address":[54981676,54981598],"length":1,"stats":{"Line":76}},{"line":4022,"address":[52984583,52984518,52984480,52985027],"length":1,"stats":{"Line":6}},{"line":4023,"address":[54277549],"length":1,"stats":{"Line":2}},{"line":4024,"address":[53612944,53446062,53446123,53612968],"length":1,"stats":{"Line":8}},{"line":4025,"address":[54277750],"length":1,"stats":{"Line":2}},{"line":4026,"address":[53446205],"length":1,"stats":{"Line":2}},{"line":4027,"address":[53446224,53619888,53619916,53446330],"length":1,"stats":{"Line":8}},{"line":4030,"address":[52984631,52984986],"length":1,"stats":{"Line":0}},{"line":4036,"address":[53625527,53625790],"length":1,"stats":{"Line":50}},{"line":4037,"address":[53625626],"length":1,"stats":{"Line":12}},{"line":4038,"address":[55298675,55298752],"length":1,"stats":{"Line":76}},{"line":4041,"address":[53589391,53589318,53589280,53589709],"length":1,"stats":{"Line":6}},{"line":4042,"address":[54420909],"length":1,"stats":{"Line":2}},{"line":4043,"address":[55577313],"length":1,"stats":{"Line":2}},{"line":4044,"address":[54420982],"length":1,"stats":{"Line":2}},{"line":4045,"address":[55577401,55721376,55721610,55721616],"length":1,"stats":{"Line":4}},{"line":4046,"address":[54450994],"length":1,"stats":{"Line":2}},{"line":4047,"address":[53083291,53083064],"length":1,"stats":{"Line":4}},{"line":4048,"address":[53619503,53619787,53619718,53619564],"length":1,"stats":{"Line":4}},{"line":4049,"address":[53083116,53083195],"length":1,"stats":{"Line":4}},{"line":4051,"address":[53619560],"length":1,"stats":{"Line":0}},{"line":4054,"address":[53039049],"length":1,"stats":{"Line":2}},{"line":4055,"address":[53589557],"length":1,"stats":{"Line":2}},{"line":4057,"address":[53038946,53039171],"length":1,"stats":{"Line":0}},{"line":4063,"address":[55298879,55299169],"length":1,"stats":{"Line":51}},{"line":4064,"address":[53625949],"length":1,"stats":{"Line":12}},{"line":4065,"address":[53626066,53625988],"length":1,"stats":{"Line":75}},{"line":4068,"address":[53026749,53026801,53026262,53026327,53026224],"length":1,"stats":{"Line":6}},{"line":4069,"address":[53026423],"length":1,"stats":{"Line":2}},{"line":4070,"address":[54262576],"length":1,"stats":{"Line":2}},{"line":4071,"address":[53026647],"length":1,"stats":{"Line":2}},{"line":4072,"address":[55727984,55505636,55727997,55505563],"length":1,"stats":{"Line":8}},{"line":4075,"address":[53430999,53431389],"length":1,"stats":{"Line":0}},{"line":4081,"address":[54982692,54982429],"length":1,"stats":{"Line":49}},{"line":4082,"address":[53626272],"length":1,"stats":{"Line":12}},{"line":4083,"address":[54982567,54982645],"length":1,"stats":{"Line":76}},{"line":4086,"address":[53535664,53535702,53536210,53536262,53535775],"length":1,"stats":{"Line":6}},{"line":4087,"address":[55605143],"length":1,"stats":{"Line":2}},{"line":4088,"address":[53535904],"length":1,"stats":{"Line":2}},{"line":4089,"address":[55605367],"length":1,"stats":{"Line":2}},{"line":4090,"address":[53609005,53608992,53536047,53535979],"length":1,"stats":{"Line":8}},{"line":4093,"address":[52904171,52904552],"length":1,"stats":{"Line":0}},{"line":4099,"address":[55299885,55299595],"length":1,"stats":{"Line":51}},{"line":4100,"address":[54467598],"length":1,"stats":{"Line":12}},{"line":4101,"address":[54467637,54467714],"length":1,"stats":{"Line":74}},{"line":4104,"address":[55520214,55519488,55519778,55519612,55519538],"length":1,"stats":{"Line":8}},{"line":4105,"address":[53477907],"length":1,"stats":{"Line":2}},{"line":4106,"address":[54309481],"length":1,"stats":{"Line":2}},{"line":4108,"address":[54309360,54309794],"length":1,"stats":{"Line":0}},{"line":4114,"address":[54983075,54983338],"length":1,"stats":{"Line":50}},{"line":4115,"address":[53626918],"length":1,"stats":{"Line":13}},{"line":4116,"address":[53626957,53627035],"length":1,"stats":{"Line":74}},{"line":4119,"address":[52883419,52882176,52882300,52882226,52882478],"length":1,"stats":{"Line":14}},{"line":4120,"address":[55705711],"length":1,"stats":{"Line":4}},{"line":4121,"address":[54230323],"length":1,"stats":{"Line":4}},{"line":4122,"address":[55706093,55706158,55706003],"length":1,"stats":{"Line":4}},{"line":4123,"address":[55706130,55706206],"length":1,"stats":{"Line":4}},{"line":4124,"address":[54230983],"length":1,"stats":{"Line":2}},{"line":4125,"address":[53399353],"length":1,"stats":{"Line":2}},{"line":4129,"address":[54230551],"length":1,"stats":{"Line":2}},{"line":4131,"address":[54230188,54231132],"length":1,"stats":{"Line":0}},{"line":4141,"address":[54468489,54468199],"length":1,"stats":{"Line":50}},{"line":4142,"address":[54983497],"length":1,"stats":{"Line":13}},{"line":4143,"address":[53627280,53627358],"length":1,"stats":{"Line":74}},{"line":4146,"address":[55560132,55559703,55559600,55559638],"length":1,"stats":{"Line":12}},{"line":4147,"address":[53476156,53476034,53476129],"length":1,"stats":{"Line":9}},{"line":4148,"address":[55559856],"length":1,"stats":{"Line":2}},{"line":4149,"address":[55559876,55559848],"length":1,"stats":{"Line":5}},{"line":4150,"address":[54307646],"length":1,"stats":{"Line":2}},{"line":4152,"address":[53476131],"length":1,"stats":{"Line":2}},{"line":4154,"address":[52870505,52870284,52870472],"length":1,"stats":{"Line":4}},{"line":4155,"address":[55559980],"length":1,"stats":{"Line":0}},{"line":4156,"address":[54307738,54307775],"length":1,"stats":{"Line":2}},{"line":4157,"address":[52870488],"length":1,"stats":{"Line":2}},{"line":4159,"address":[52870474],"length":1,"stats":{"Line":0}},{"line":4161,"address":[53475995,53476353],"length":1,"stats":{"Line":0}},{"line":4167,"address":[54983721,54983984],"length":1,"stats":{"Line":50}},{"line":4168,"address":[54983820],"length":1,"stats":{"Line":13}},{"line":4169,"address":[54468711,54468788],"length":1,"stats":{"Line":77}},{"line":4170,"address":[54282736,54282575,54282502,54283004],"length":1,"stats":{"Line":12}},{"line":4171,"address":[53451285],"length":1,"stats":{"Line":2}},{"line":4172,"address":[53056950],"length":1,"stats":{"Line":2}},{"line":4174,"address":[54283025],"length":1,"stats":{"Line":2}},{"line":4175,"address":[53057181],"length":1,"stats":{"Line":2}},{"line":4177,"address":[53451198,53451722],"length":1,"stats":{"Line":0}},{"line":4183,"address":[53628051,53627788],"length":1,"stats":{"Line":50}},{"line":4184,"address":[55301142],"length":1,"stats":{"Line":13}},{"line":4185,"address":[53627926,53628004],"length":1,"stats":{"Line":77}},{"line":4186,"address":[55712455,55712390],"length":1,"stats":{"Line":6}},{"line":4187,"address":[53447169],"length":1,"stats":{"Line":2}},{"line":4188,"address":[54278639],"length":1,"stats":{"Line":2}},{"line":4189,"address":[52913899,52913251],"length":1,"stats":{"Line":0}},{"line":4191,"address":[54278704],"length":1,"stats":{"Line":3}},{"line":4192,"address":[55712711],"length":1,"stats":{"Line":2}},{"line":4193,"address":[55712677],"length":1,"stats":{"Line":2}},{"line":4194,"address":[54279218,54278765],"length":1,"stats":{"Line":0}},{"line":4196,"address":[53447362],"length":1,"stats":{"Line":3}},{"line":4197,"address":[55712875],"length":1,"stats":{"Line":2}},{"line":4198,"address":[54278966],"length":1,"stats":{"Line":2}},{"line":4199,"address":[54278927,54279161],"length":1,"stats":{"Line":0}},{"line":4201,"address":[55712914],"length":1,"stats":{"Line":3}},{"line":4206,"address":[54984367,54984630],"length":1,"stats":{"Line":50}},{"line":4207,"address":[54984466],"length":1,"stats":{"Line":13}},{"line":4208,"address":[54403904,54403536],"length":1,"stats":{"Line":78}},{"line":4209,"address":[55329856],"length":1,"stats":{"Line":5}},{"line":4210,"address":[54497767],"length":1,"stats":{"Line":4}},{"line":4211,"address":[55329889],"length":1,"stats":{"Line":5}},{"line":4213,"address":[53654450,53654477],"length":1,"stats":{"Line":9}},{"line":4216,"address":[53572137,53572067],"length":1,"stats":{"Line":9}},{"line":4217,"address":[52953310],"length":1,"stats":{"Line":4}},{"line":4218,"address":[53572368,53572193],"length":1,"stats":{"Line":0}},{"line":4224,"address":[54469631,54469921],"length":1,"stats":{"Line":50}},{"line":4225,"address":[53628533],"length":1,"stats":{"Line":13}},{"line":4226,"address":[55301974,55301897],"length":1,"stats":{"Line":78}},{"line":4227,"address":[53654576],"length":1,"stats":{"Line":4}},{"line":4228,"address":[54497943],"length":1,"stats":{"Line":4}},{"line":4229,"address":[54497953],"length":1,"stats":{"Line":4}},{"line":4231,"address":[55010882,55010909],"length":1,"stats":{"Line":8}},{"line":4234,"address":[52952551,52952486],"length":1,"stats":{"Line":11}},{"line":4235,"address":[53461187],"length":1,"stats":{"Line":6}},{"line":4236,"address":[53461224,53461566,53461285],"length":1,"stats":{"Line":12}},{"line":4237,"address":[53461236],"length":1,"stats":{"Line":2}},{"line":4239,"address":[55573670,55573408,55573455],"length":1,"stats":{"Line":8}},{"line":4242,"address":[55573243,55573696],"length":1,"stats":{"Line":0}},{"line":4248,"address":[53628757,53629020],"length":1,"stats":{"Line":51}},{"line":4249,"address":[55302216],"length":1,"stats":{"Line":13}},{"line":4250,"address":[54985151,54985229],"length":1,"stats":{"Line":73}},{"line":4253,"address":[54271454,54270815,54270742,54270704],"length":1,"stats":{"Line":16}},{"line":4254,"address":[55576549],"length":1,"stats":{"Line":8}},{"line":4255,"address":[53439345],"length":1,"stats":{"Line":8}},{"line":4256,"address":[54271360],"length":1,"stats":{"Line":2}},{"line":4257,"address":[53439401],"length":1,"stats":{"Line":2}},{"line":4260,"address":[55576617],"length":1,"stats":{"Line":6}},{"line":4261,"address":[55576697,55577023],"length":1,"stats":{"Line":4}},{"line":4263,"address":[53439437],"length":1,"stats":{"Line":4}},{"line":4264,"address":[52995508,52995438,52995757],"length":1,"stats":{"Line":8}},{"line":4265,"address":[55576880,55576988,55576998],"length":1,"stats":{"Line":4}},{"line":4267,"address":[54271191],"length":1,"stats":{"Line":2}},{"line":4269,"address":[52995884,52995346],"length":1,"stats":{"Line":0}},{"line":4275,"address":[55302749,55302459],"length":1,"stats":{"Line":50}},{"line":4276,"address":[54470462],"length":1,"stats":{"Line":14}},{"line":4277,"address":[55302690,55302613],"length":1,"stats":{"Line":72}},{"line":4280,"address":[52854704,52854739,52855052,52854798],"length":1,"stats":{"Line":6}},{"line":4281,"address":[55661802,55661740],"length":1,"stats":{"Line":4}},{"line":4282,"address":[52855020,52854838],"length":1,"stats":{"Line":0}},{"line":4288,"address":[53629666,53629403],"length":1,"stats":{"Line":50}},{"line":4289,"address":[54470820],"length":1,"stats":{"Line":14}},{"line":4290,"address":[55303048,55302971],"length":1,"stats":{"Line":72}},{"line":4293,"address":[52999680,52999715,52999774,53000028],"length":1,"stats":{"Line":6}},{"line":4294,"address":[53438994,53438932],"length":1,"stats":{"Line":4}},{"line":4295,"address":[55608006,55608188],"length":1,"stats":{"Line":0}},{"line":4301,"address":[54985982,54986245],"length":1,"stats":{"Line":50}},{"line":4302,"address":[54986081],"length":1,"stats":{"Line":14}},{"line":4303,"address":[54986120,54986198],"length":1,"stats":{"Line":72}},{"line":4306,"address":[53055344,53055447,53055382,53056441],"length":1,"stats":{"Line":0}},{"line":4307,"address":[55611957],"length":1,"stats":{"Line":0}},{"line":4308,"address":[55611977],"length":1,"stats":{"Line":0}},{"line":4309,"address":[54316990],"length":1,"stats":{"Line":0}},{"line":4311,"address":[55612025],"length":1,"stats":{"Line":0}},{"line":4312,"address":[54317042],"length":1,"stats":{"Line":0}},{"line":4314,"address":[53485608,53485639],"length":1,"stats":{"Line":0}},{"line":4315,"address":[53485709],"length":1,"stats":{"Line":0}},{"line":4317,"address":[55612333],"length":1,"stats":{"Line":0}},{"line":4318,"address":[53485855],"length":1,"stats":{"Line":0}},{"line":4319,"address":[53486169,53486059],"length":1,"stats":{"Line":0}},{"line":4320,"address":[54317777],"length":1,"stats":{"Line":0}},{"line":4323,"address":[53486080],"length":1,"stats":{"Line":0}},{"line":4325,"address":[55612897,55611986],"length":1,"stats":{"Line":0}},{"line":4335,"address":[55303533,55303823],"length":1,"stats":{"Line":50}},{"line":4336,"address":[53630148],"length":1,"stats":{"Line":14}},{"line":4337,"address":[54471575,54471652],"length":1,"stats":{"Line":72}},{"line":4338,"address":[54290870,54290943],"length":1,"stats":{"Line":0}},{"line":4339,"address":[52934327,52934226],"length":1,"stats":{"Line":0}},{"line":4340,"address":[52934235,52934337],"length":1,"stats":{"Line":0}},{"line":4341,"address":[54291171,54291103],"length":1,"stats":{"Line":0}},{"line":4342,"address":[55540071,55540137],"length":1,"stats":{"Line":0}},{"line":4344,"address":[54291173,54291355],"length":1,"stats":{"Line":0}},{"line":4346,"address":[55539944],"length":1,"stats":{"Line":0}},{"line":4352,"address":[54986628,54986891],"length":1,"stats":{"Line":50}},{"line":4353,"address":[55304006],"length":1,"stats":{"Line":14}},{"line":4354,"address":[53011469,53010976],"length":1,"stats":{"Line":72}},{"line":4355,"address":[53011014,53011079,53011212],"length":1,"stats":{"Line":0}},{"line":4356,"address":[53590419],"length":1,"stats":{"Line":0}},{"line":4358,"address":[54422014],"length":1,"stats":{"Line":0}},{"line":4360,"address":[53011139,53011222],"length":1,"stats":{"Line":0}},{"line":4367,"address":[55304249,55304539],"length":1,"stats":{"Line":51}},{"line":4368,"address":[54987050],"length":1,"stats":{"Line":14}},{"line":4369,"address":[54472368,54472291],"length":1,"stats":{"Line":71}},{"line":4372,"address":[54288542,54288016],"length":1,"stats":{"Line":0}},{"line":4373,"address":[54288054,54288127,54288272],"length":1,"stats":{"Line":0}},{"line":4374,"address":[53456723],"length":1,"stats":{"Line":0}},{"line":4376,"address":[54288318],"length":1,"stats":{"Line":0}},{"line":4378,"address":[53456691,53456778],"length":1,"stats":{"Line":0}},{"line":4390,"address":[53631018,53631281],"length":1,"stats":{"Line":50}},{"line":4391,"address":[53631117],"length":1,"stats":{"Line":15}},{"line":4392,"address":[54987490,54987412],"length":1,"stats":{"Line":74}},{"line":4393,"address":[52902038,52901004,52900930],"length":1,"stats":{"Line":8}},{"line":4394,"address":[54257041,54257102],"length":1,"stats":{"Line":8}},{"line":4395,"address":[52901217,52901160],"length":1,"stats":{"Line":8}},{"line":4396,"address":[54257302,54257980],"length":1,"stats":{"Line":0}},{"line":4398,"address":[53425762],"length":1,"stats":{"Line":4}},{"line":4399,"address":[55691002,55691053],"length":1,"stats":{"Line":8}},{"line":4400,"address":[54257539],"length":1,"stats":{"Line":4}},{"line":4401,"address":[53426310],"length":1,"stats":{"Line":2}},{"line":4402,"address":[52901802],"length":1,"stats":{"Line":2}},{"line":4403,"address":[54257914,54257778],"length":1,"stats":{"Line":0}},{"line":4406,"address":[54257578],"length":1,"stats":{"Line":4}},{"line":4408,"address":[52901999,52901048],"length":1,"stats":{"Line":0}},{"line":4414,"address":[53631604,53631341],"length":1,"stats":{"Line":50}},{"line":4415,"address":[53631440],"length":1,"stats":{"Line":15}},{"line":4416,"address":[54313600,54315312,54315175],"length":1,"stats":{"Line":73}},{"line":4417,"address":[55502972,55504445,55502898],"length":1,"stats":{"Line":7}},{"line":4418,"address":[55503058,55503001],"length":1,"stats":{"Line":8}},{"line":4419,"address":[53482463,53482384],"length":1,"stats":{"Line":8}},{"line":4420,"address":[54315189,54314017],"length":1,"stats":{"Line":0}},{"line":4422,"address":[54313998],"length":1,"stats":{"Line":4}},{"line":4423,"address":[54314051,54314130],"length":1,"stats":{"Line":8}},{"line":4424,"address":[53482848],"length":1,"stats":{"Line":4}},{"line":4425,"address":[52938805,52938895],"length":1,"stats":{"Line":0}},{"line":4426,"address":[55504244,55504197],"length":1,"stats":{"Line":8}},{"line":4427,"address":[53483454,53483606],"length":1,"stats":{"Line":0}},{"line":4430,"address":[54449824,54314391,54449867],"length":1,"stats":{"Line":12}},{"line":4431,"address":[53482937],"length":1,"stats":{"Line":4}},{"line":4432,"address":[52938731,52938332],"length":1,"stats":{"Line":6}},{"line":4433,"address":[54314584,54314716],"length":1,"stats":{"Line":4}},{"line":4435,"address":[52938449,52938380],"length":1,"stats":{"Line":4}},{"line":4438,"address":[55503016,55504406],"length":1,"stats":{"Line":0}},{"line":4444,"address":[54987920,54988183],"length":1,"stats":{"Line":50}},{"line":4445,"address":[53631763],"length":1,"stats":{"Line":15}},{"line":4446,"address":[54988058,54988136],"length":1,"stats":{"Line":74}},{"line":4447,"address":[54303355,54303276,54304491],"length":1,"stats":{"Line":7}},{"line":4448,"address":[52853616,52853667],"length":1,"stats":{"Line":8}},{"line":4449,"address":[52853725,52853782],"length":1,"stats":{"Line":8}},{"line":4450,"address":[55683489],"length":1,"stats":{"Line":0}},{"line":4452,"address":[55683445],"length":1,"stats":{"Line":4}},{"line":4453,"address":[52853821],"length":1,"stats":{"Line":4}},{"line":4454,"address":[52853934,52853837],"length":1,"stats":{"Line":8}},{"line":4455,"address":[53472419],"length":1,"stats":{"Line":4}},{"line":4456,"address":[54304246],"length":1,"stats":{"Line":2}},{"line":4457,"address":[52854481],"length":1,"stats":{"Line":2}},{"line":4458,"address":[54304309],"length":1,"stats":{"Line":2}},{"line":4459,"address":[54304332],"length":1,"stats":{"Line":2}},{"line":4461,"address":[52854540,52854398],"length":1,"stats":{"Line":0}},{"line":4464,"address":[55683917,55683786],"length":1,"stats":{"Line":4}},{"line":4465,"address":[53472599],"length":1,"stats":{"Line":2}},{"line":4467,"address":[52854172],"length":1,"stats":{"Line":2}},{"line":4470,"address":[54304452,54303400],"length":1,"stats":{"Line":0}},{"line":4476,"address":[54473569,54473859],"length":1,"stats":{"Line":50}},{"line":4477,"address":[54473684],"length":1,"stats":{"Line":15}},{"line":4478,"address":[54235215,54235078,54233472],"length":1,"stats":{"Line":72}},{"line":4479,"address":[53402018,53402100,53403706],"length":1,"stats":{"Line":6}},{"line":4480,"address":[54233688,54233633],"length":1,"stats":{"Line":7}},{"line":4481,"address":[54233742,54233815],"length":1,"stats":{"Line":8}},{"line":4482,"address":[52975480,52976655],"length":1,"stats":{"Line":0}},{"line":4484,"address":[53402399,53402336],"length":1,"stats":{"Line":8}},{"line":4485,"address":[52975570,52975627],"length":1,"stats":{"Line":8}},{"line":4486,"address":[52975857,52976033],"length":1,"stats":{"Line":8}},{"line":4487,"address":[53402986],"length":1,"stats":{"Line":4}},{"line":4488,"address":[52976312,52976104],"length":1,"stats":{"Line":8}},{"line":4489,"address":[53403052],"length":1,"stats":{"Line":4}},{"line":4492,"address":[52976322],"length":1,"stats":{"Line":0}},{"line":4493,"address":[53403278,53403496],"length":1,"stats":{"Line":0}},{"line":4494,"address":[52976394],"length":1,"stats":{"Line":0}},{"line":4498,"address":[53403509,53402911],"length":1,"stats":{"Line":0}},{"line":4502,"address":[55526018],"length":1,"stats":{"Line":4}},{"line":4504,"address":[55525397,55526845],"length":1,"stats":{"Line":0}},{"line":4510,"address":[54473927,54474217],"length":1,"stats":{"Line":51}},{"line":4511,"address":[53632409],"length":1,"stats":{"Line":15}},{"line":4512,"address":[54474158,54474081],"length":1,"stats":{"Line":72}},{"line":4513,"address":[53556964,53556882,53558566],"length":1,"stats":{"Line":8}},{"line":4514,"address":[53556993,53557048],"length":1,"stats":{"Line":8}},{"line":4515,"address":[55643510,55643567],"length":1,"stats":{"Line":8}},{"line":4516,"address":[53557224,53558448],"length":1,"stats":{"Line":0}},{"line":4518,"address":[53557200,53557263],"length":1,"stats":{"Line":8}},{"line":4519,"address":[54388887,54388814],"length":1,"stats":{"Line":8}},{"line":4520,"address":[53065313,53065137],"length":1,"stats":{"Line":8}},{"line":4521,"address":[55644197],"length":1,"stats":{"Line":4}},{"line":4522,"address":[53065384,53065592],"length":1,"stats":{"Line":8}},{"line":4523,"address":[55644263],"length":1,"stats":{"Line":4}},{"line":4526,"address":[55644450],"length":1,"stats":{"Line":0}},{"line":4527,"address":[53065637,53065847],"length":1,"stats":{"Line":0}},{"line":4528,"address":[55644518],"length":1,"stats":{"Line":0}},{"line":4532,"address":[54389873,54389279],"length":1,"stats":{"Line":0}},{"line":4536,"address":[53065186],"length":1,"stats":{"Line":4}},{"line":4538,"address":[53557009,53558527],"length":1,"stats":{"Line":0}},{"line":4544,"address":[55306397,55306687],"length":1,"stats":{"Line":52}},{"line":4545,"address":[54988988],"length":1,"stats":{"Line":16}},{"line":4546,"address":[52871804,52871862,52870640],"length":1,"stats":{"Line":66}},{"line":4547,"address":[53459307,53458082,53458164],"length":1,"stats":{"Line":4}},{"line":4548,"address":[53458254,53458193],"length":1,"stats":{"Line":4}},{"line":4549,"address":[54289812,54289885],"length":1,"stats":{"Line":4}},{"line":4550,"address":[54290687,54289970],"length":1,"stats":{"Line":0}},{"line":4552,"address":[54289920],"length":1,"stats":{"Line":2}},{"line":4553,"address":[54289938],"length":1,"stats":{"Line":2}},{"line":4554,"address":[53458505,53458442],"length":1,"stats":{"Line":4}},{"line":4555,"address":[54290207],"length":1,"stats":{"Line":2}},{"line":4556,"address":[54290390],"length":1,"stats":{"Line":2}},{"line":4557,"address":[52871456],"length":1,"stats":{"Line":2}},{"line":4558,"address":[53458922,53459022],"length":1,"stats":{"Line":4}},{"line":4559,"address":[54290517],"length":1,"stats":{"Line":2}},{"line":4561,"address":[55660442,55660394],"length":1,"stats":{"Line":4}},{"line":4562,"address":[55660433],"length":1,"stats":{"Line":2}},{"line":4565,"address":[55660347],"length":1,"stats":{"Line":0}},{"line":4566,"address":[54290589,54290467],"length":1,"stats":{"Line":0}},{"line":4567,"address":[53459072],"length":1,"stats":{"Line":0}},{"line":4569,"address":[53459048,53459104],"length":1,"stats":{"Line":0}},{"line":4570,"address":[54290595],"length":1,"stats":{"Line":0}},{"line":4573,"address":[55660250,55660520],"length":1,"stats":{"Line":0}},{"line":4576,"address":[54290251],"length":1,"stats":{"Line":2}},{"line":4578,"address":[53458212,53459268],"length":1,"stats":{"Line":0}},{"line":4588,"address":[54474933,54474643],"length":1,"stats":{"Line":50}},{"line":4589,"address":[55306870],"length":1,"stats":{"Line":18}},{"line":4590,"address":[54989350,54989428],"length":1,"stats":{"Line":64}},{"line":4593,"address":[53021847,53021782],"length":1,"stats":{"Line":0}},{"line":4594,"address":[55713301],"length":1,"stats":{"Line":0}},{"line":4595,"address":[54246200,54245120],"length":1,"stats":{"Line":0}},{"line":4597,"address":[53022002,53021932],"length":1,"stats":{"Line":0}},{"line":4598,"address":[53022016,53022090],"length":1,"stats":{"Line":0}},{"line":4599,"address":[55713499,55713550],"length":1,"stats":{"Line":0}},{"line":4601,"address":[53414660,53413828,53414092,53414193],"length":1,"stats":{"Line":0}},{"line":4602,"address":[53413997],"length":1,"stats":{"Line":0}},{"line":4603,"address":[55713731],"length":1,"stats":{"Line":0}},{"line":4604,"address":[53022321],"length":1,"stats":{"Line":0}},{"line":4605,"address":[54245564,54450717,54245665,54450688],"length":1,"stats":{"Line":0}},{"line":4606,"address":[53022578,53022643,53022724,53022507],"length":1,"stats":{"Line":0}},{"line":4607,"address":[53022692,53022620,53077837,53077808],"length":1,"stats":{"Line":0}},{"line":4608,"address":[53022751],"length":1,"stats":{"Line":0}},{"line":4613,"address":[54475001,54475291],"length":1,"stats":{"Line":49}},{"line":4614,"address":[54989634],"length":1,"stats":{"Line":18}},{"line":4615,"address":[53633417,53633495],"length":1,"stats":{"Line":65}},{"line":4616,"address":[53027911,53027846],"length":1,"stats":{"Line":0}},{"line":4617,"address":[53590893],"length":1,"stats":{"Line":0}},{"line":4618,"address":[53028289,53027960],"length":1,"stats":{"Line":0}},{"line":4620,"address":[54422463,54422551,54422637],"length":1,"stats":{"Line":0}},{"line":4621,"address":[53071901,53028064,53028127,53071872],"length":1,"stats":{"Line":0}},{"line":4622,"address":[55561108],"length":1,"stats":{"Line":0}},{"line":4627,"address":[54990121,54989858],"length":1,"stats":{"Line":50}},{"line":4628,"address":[53633701],"length":1,"stats":{"Line":17}},{"line":4629,"address":[53633740,53633818],"length":1,"stats":{"Line":67}},{"line":4630,"address":[52981023,52980950],"length":1,"stats":{"Line":2}},{"line":4631,"address":[55590381],"length":1,"stats":{"Line":1}},{"line":4632,"address":[54416792,54417475],"length":1,"stats":{"Line":0}},{"line":4634,"address":[54416920,54417021,54416823],"length":1,"stats":{"Line":2}},{"line":4635,"address":[53585485,53618560,53618589,53585384],"length":1,"stats":{"Line":1}},{"line":4636,"address":[54417103],"length":1,"stats":{"Line":1}},{"line":4637,"address":[55726992,55727020,55590735],"length":1,"stats":{"Line":3}},{"line":4638,"address":[52981457,53080176,53080211],"length":1,"stats":{"Line":3}},{"line":4639,"address":[55590832],"length":1,"stats":{"Line":1}},{"line":4640,"address":[52981525],"length":1,"stats":{"Line":1}},{"line":4645,"address":[54476007,54475717],"length":1,"stats":{"Line":50}},{"line":4646,"address":[54475832],"length":1,"stats":{"Line":17}},{"line":4647,"address":[54206224,54206720,54206763],"length":1,"stats":{"Line":66}},{"line":4648,"address":[54206262,54206335],"length":1,"stats":{"Line":0}},{"line":4649,"address":[55647349],"length":1,"stats":{"Line":0}},{"line":4650,"address":[54206384,54206731],"length":1,"stats":{"Line":0}},{"line":4652,"address":[54206415,54206503,54206589],"length":1,"stats":{"Line":0}},{"line":4653,"address":[53614928,53614957,53374978,53375059],"length":1,"stats":{"Line":0}},{"line":4654,"address":[55647604],"length":1,"stats":{"Line":0}},{"line":4659,"address":[54990767,54990504],"length":1,"stats":{"Line":53}},{"line":4660,"address":[54990603],"length":1,"stats":{"Line":17}},{"line":4661,"address":[55308341,55308418],"length":1,"stats":{"Line":61}},{"line":4662,"address":[55601078,55601143],"length":1,"stats":{"Line":2}},{"line":4663,"address":[53033333],"length":1,"stats":{"Line":1}},{"line":4664,"address":[55601192,55601404],"length":1,"stats":{"Line":0}},{"line":4666,"address":[54273423,54273500],"length":1,"stats":{"Line":2}},{"line":4671,"address":[55308545,55308835],"length":1,"stats":{"Line":53}},{"line":4672,"address":[53634670],"length":1,"stats":{"Line":15}},{"line":4673,"address":[55653164,55653121,55652528],"length":1,"stats":{"Line":54}},{"line":4674,"address":[52982183,52982118],"length":1,"stats":{"Line":2}},{"line":4675,"address":[52982197],"length":1,"stats":{"Line":1}},{"line":4676,"address":[55653132,55652680],"length":1,"stats":{"Line":0}},{"line":4678,"address":[54372508,54372319,54372416],"length":1,"stats":{"Line":2}},{"line":4679,"address":[55729181,55729152,55652793,55652856],"length":1,"stats":{"Line":1}},{"line":4680,"address":[54372617],"length":1,"stats":{"Line":1}},{"line":4685,"address":[54991150,54991413],"length":1,"stats":{"Line":50}},{"line":4686,"address":[54476906],"length":1,"stats":{"Line":23}},{"line":4687,"address":[54991288,54991366],"length":1,"stats":{"Line":55}},{"line":4688,"address":[53026854,53026919],"length":1,"stats":{"Line":2}},{"line":4689,"address":[53487005],"length":1,"stats":{"Line":1}},{"line":4690,"address":[55631672,55632463],"length":1,"stats":{"Line":0}},{"line":4692,"address":[53487076,53487150],"length":1,"stats":{"Line":2}},{"line":4693,"address":[53027088],"length":1,"stats":{"Line":1}},{"line":4694,"address":[54318703,54319288],"length":1,"stats":{"Line":0}},{"line":4696,"address":[55631947,55631866],"length":1,"stats":{"Line":2}},{"line":4697,"address":[54318920,54318846,54319000],"length":1,"stats":{"Line":3}},{"line":4706,"address":[55309551,55309261],"length":1,"stats":{"Line":50}},{"line":4707,"address":[53635316],"length":1,"stats":{"Line":23}},{"line":4708,"address":[52941312,52941689],"length":1,"stats":{"Line":55}},{"line":4709,"address":[54369894,54369967,54370240],"length":1,"stats":{"Line":2}},{"line":4710,"address":[55663889,55663950],"length":1,"stats":{"Line":2}},{"line":4712,"address":[52941458,52941648],"length":1,"stats":{"Line":0}},{"line":4718,"address":[55309619,55309909],"length":1,"stats":{"Line":50}},{"line":4719,"address":[53635639],"length":1,"stats":{"Line":23}},{"line":4720,"address":[54432530,54432144],"length":1,"stats":{"Line":55}},{"line":4721,"address":[53600751,53601024,53600678],"length":1,"stats":{"Line":2}},{"line":4722,"address":[55671505,55671566],"length":1,"stats":{"Line":2}},{"line":4724,"address":[52926624,52926434],"length":1,"stats":{"Line":0}},{"line":4730,"address":[54992382,54992119],"length":1,"stats":{"Line":50}},{"line":4731,"address":[55310092],"length":1,"stats":{"Line":23}},{"line":4732,"address":[52911209,52910832],"length":1,"stats":{"Line":55}},{"line":4733,"address":[53413078,53413424,53413151],"length":1,"stats":{"Line":2}},{"line":4734,"address":[52911022,52910961],"length":1,"stats":{"Line":2}},{"line":4736,"address":[55671122,55671312],"length":1,"stats":{"Line":0}},{"line":4742,"address":[54478513,54478223],"length":1,"stats":{"Line":50}},{"line":4743,"address":[55310450],"length":1,"stats":{"Line":23}},{"line":4744,"address":[53636324,53636402],"length":1,"stats":{"Line":54}},{"line":4747,"address":[55620914,55620464,55620567,55620502],"length":1,"stats":{"Line":3}},{"line":4748,"address":[55620663],"length":1,"stats":{"Line":1}},{"line":4749,"address":[53481840],"length":1,"stats":{"Line":1}},{"line":4751,"address":[54313526,54313271],"length":1,"stats":{"Line":0}},{"line":4757,"address":[54993028,54992765],"length":1,"stats":{"Line":50}},{"line":4758,"address":[53636608],"length":1,"stats":{"Line":23}},{"line":4759,"address":[53636647,53636725],"length":1,"stats":{"Line":56}},{"line":4760,"address":[54238438,54238511],"length":1,"stats":{"Line":2}},{"line":4762,"address":[54238611],"length":1,"stats":{"Line":1}},{"line":4763,"address":[52894436],"length":1,"stats":{"Line":1}},{"line":4765,"address":[55657979,55658229],"length":1,"stats":{"Line":0}},{"line":4770,"address":[53637095,53636832],"length":1,"stats":{"Line":51}},{"line":4771,"address":[54993187],"length":1,"stats":{"Line":23}},{"line":4772,"address":[53636970,53637048],"length":1,"stats":{"Line":52}},{"line":4775,"address":[54377104,54377142,54377658,54377218],"length":1,"stats":{"Line":3}},{"line":4776,"address":[55685185,55684992],"length":1,"stats":{"Line":2}},{"line":4777,"address":[53079424,53079432,52868973],"length":1,"stats":{"Line":3}},{"line":4779,"address":[53545773,53546113],"length":1,"stats":{"Line":0}},{"line":4785,"address":[55311699,55311409],"length":1,"stats":{"Line":50}},{"line":4786,"address":[54993510],"length":1,"stats":{"Line":24}},{"line":4787,"address":[54993549,54993627],"length":1,"stats":{"Line":53}},{"line":4788,"address":[53003826,53003900],"length":1,"stats":{"Line":2}},{"line":4789,"address":[55714573],"length":1,"stats":{"Line":1}},{"line":4790,"address":[54295519,54294363],"length":1,"stats":{"Line":0}},{"line":4792,"address":[53463989,53463059,53463157,53462901],"length":1,"stats":{"Line":2}},{"line":4793,"address":[53004076],"length":1,"stats":{"Line":1}},{"line":4794,"address":[54294629,54294531],"length":1,"stats":{"Line":1}},{"line":4796,"address":[54295472,54294922,54294824,54294722],"length":1,"stats":{"Line":2}},{"line":4797,"address":[53004329],"length":1,"stats":{"Line":1}},{"line":4798,"address":[53463386,53463288],"length":1,"stats":{"Line":1}},{"line":4799,"address":[53463476],"length":1,"stats":{"Line":1}},{"line":4800,"address":[55715265,55715334],"length":1,"stats":{"Line":2}},{"line":4801,"address":[54295163],"length":1,"stats":{"Line":1}},{"line":4802,"address":[54295231],"length":1,"stats":{"Line":1}},{"line":4807,"address":[54993997,54993734],"length":1,"stats":{"Line":49}},{"line":4808,"address":[54993833],"length":1,"stats":{"Line":24}},{"line":4809,"address":[55311921,55311998],"length":1,"stats":{"Line":53}},{"line":4812,"address":[53524351,53524844,53525118,53524278,53524240],"length":1,"stats":{"Line":3}},{"line":4813,"address":[54356040,54355936],"length":1,"stats":{"Line":2}},{"line":4814,"address":[54355964,54356134],"length":1,"stats":{"Line":2}},{"line":4815,"address":[53524496,53524855],"length":1,"stats":{"Line":2}},{"line":4816,"address":[52994497,52995129],"length":1,"stats":{"Line":0}},{"line":4822,"address":[53637801,53638064],"length":1,"stats":{"Line":50}},{"line":4823,"address":[55312240],"length":1,"stats":{"Line":23}},{"line":4824,"address":[54438256,54438609],"length":1,"stats":{"Line":55}},{"line":4825,"address":[54438294,54438607,54438367],"length":1,"stats":{"Line":2}},{"line":4826,"address":[53606889,53606947],"length":1,"stats":{"Line":2}},{"line":4828,"address":[53606906,53607070],"length":1,"stats":{"Line":0}},{"line":4838,"address":[54480658,54480371],"length":1,"stats":{"Line":50}},{"line":4839,"address":[53638223],"length":1,"stats":{"Line":24}},{"line":4840,"address":[53486852,53486432],"length":1,"stats":{"Line":53}},{"line":4842,"address":[53013006,53013146,53013177,53013072],"length":1,"stats":{"Line":4}},{"line":4843,"address":[54318048],"length":1,"stats":{"Line":1}},{"line":4844,"address":[53486569],"length":1,"stats":{"Line":1}},{"line":4845,"address":[53486624],"length":1,"stats":{"Line":1}},{"line":4846,"address":[54318158],"length":1,"stats":{"Line":1}},{"line":4847,"address":[55699437],"length":1,"stats":{"Line":1}},{"line":4848,"address":[55699497],"length":1,"stats":{"Line":1}},{"line":4853,"address":[53638709,53638446],"length":1,"stats":{"Line":51}},{"line":4854,"address":[53638545],"length":1,"stats":{"Line":24}},{"line":4855,"address":[53410765,53409552],"length":1,"stats":{"Line":51}},{"line":4857,"address":[55679314,55679549,55679471,55680425],"length":1,"stats":{"Line":2}},{"line":4858,"address":[55679388],"length":1,"stats":{"Line":1}},{"line":4859,"address":[53409825,53409727],"length":1,"stats":{"Line":1}},{"line":4860,"address":[53409907,53410761,53410003,53410101],"length":1,"stats":{"Line":2}},{"line":4861,"address":[55679624],"length":1,"stats":{"Line":1}},{"line":4862,"address":[53409971,53410069],"length":1,"stats":{"Line":1}},{"line":4863,"address":[52945592],"length":1,"stats":{"Line":1}},{"line":4864,"address":[52946145,52945617],"length":1,"stats":{"Line":0}},{"line":4866,"address":[55680010,55679970,55679884,55679821],"length":1,"stats":{"Line":4}},{"line":4867,"address":[54241735],"length":1,"stats":{"Line":1}},{"line":4868,"address":[54241766],"length":1,"stats":{"Line":1}},{"line":4869,"address":[52945769],"length":1,"stats":{"Line":1}},{"line":4870,"address":[52945799],"length":1,"stats":{"Line":1}},{"line":4871,"address":[53410416,53410490],"length":1,"stats":{"Line":1}},{"line":4872,"address":[54242165,54241986,54242022],"length":1,"stats":{"Line":2}},{"line":4873,"address":[53410590],"length":1,"stats":{"Line":1}},{"line":4878,"address":[53639032,53638769],"length":1,"stats":{"Line":50}},{"line":4879,"address":[54481199],"length":1,"stats":{"Line":25}},{"line":4880,"address":[53068816,53069753,53069698],"length":1,"stats":{"Line":51}},{"line":4882,"address":[53068940,53069751,53068866],"length":1,"stats":{"Line":2}},{"line":4883,"address":[53470942,53470881],"length":1,"stats":{"Line":2}},{"line":4884,"address":[55642562,55642619],"length":1,"stats":{"Line":2}},{"line":4885,"address":[53069196],"length":1,"stats":{"Line":0}},{"line":4887,"address":[55642726,55642640,55642812,55642852],"length":1,"stats":{"Line":4}},{"line":4888,"address":[54302709],"length":1,"stats":{"Line":1}},{"line":4889,"address":[53069300],"length":1,"stats":{"Line":1}},{"line":4890,"address":[54302807],"length":1,"stats":{"Line":1}},{"line":4891,"address":[53069393],"length":1,"stats":{"Line":1}},{"line":4892,"address":[54302995,54302884],"length":1,"stats":{"Line":1}},{"line":4893,"address":[53471521,53471467],"length":1,"stats":{"Line":2}},{"line":4895,"address":[53069712,53068984],"length":1,"stats":{"Line":0}},{"line":4901,"address":[53639354,53639092],"length":1,"stats":{"Line":53}},{"line":4902,"address":[55313669],"length":1,"stats":{"Line":23}},{"line":4903,"address":[54226096],"length":1,"stats":{"Line":50}},{"line":4904,"address":[52857036],"length":1,"stats":{"Line":1}},{"line":4909,"address":[54995670,54995932],"length":1,"stats":{"Line":50}},{"line":4910,"address":[54481912],"length":1,"stats":{"Line":32}},{"line":4911,"address":[53639552,53639629],"length":1,"stats":{"Line":37}},{"line":4912,"address":[55605564],"length":1,"stats":{"Line":1}},{"line":4917,"address":[53639998,53639736],"length":1,"stats":{"Line":50}},{"line":4918,"address":[54996091],"length":1,"stats":{"Line":32}},{"line":4919,"address":[52872864],"length":1,"stats":{"Line":37}},{"line":4920,"address":[54309004],"length":1,"stats":{"Line":1}},{"line":4925,"address":[54482507,54482797],"length":1,"stats":{"Line":49}},{"line":4926,"address":[54996413],"length":1,"stats":{"Line":32}},{"line":4927,"address":[54996452,54996530],"length":1,"stats":{"Line":37}},{"line":4930,"address":[53045152,53045255,53045596,53045190],"length":1,"stats":{"Line":3}},{"line":4931,"address":[53475627,53475695],"length":1,"stats":{"Line":2}},{"line":4932,"address":[54307060],"length":1,"stats":{"Line":1}},{"line":4933,"address":[54307019,54307292],"length":1,"stats":{"Line":0}},{"line":4939,"address":[55315267,55314977],"length":1,"stats":{"Line":50}},{"line":4940,"address":[54482980],"length":1,"stats":{"Line":31}},{"line":4941,"address":[54996853,54996775],"length":1,"stats":{"Line":38}},{"line":4944,"address":[53527756,53527366,53527328,53527439],"length":1,"stats":{"Line":3}},{"line":4945,"address":[53527542,53527665],"length":1,"stats":{"Line":0}},{"line":4946,"address":[53527503,53527585],"length":1,"stats":{"Line":2}},{"line":4947,"address":[55665117,55664867],"length":1,"stats":{"Line":0}},{"line":4957,"address":[54483510,54483223],"length":1,"stats":{"Line":50}},{"line":4958,"address":[54997059],"length":1,"stats":{"Line":31}},{"line":4959,"address":[54483451,54483377],"length":1,"stats":{"Line":39}},{"line":4961,"address":[54400878],"length":1,"stats":{"Line":1}},{"line":4962,"address":[53569495],"length":1,"stats":{"Line":1}},{"line":4963,"address":[54402808,54401015,54401092],"length":1,"stats":{"Line":2}},{"line":4964,"address":[52922701,52921251],"length":1,"stats":{"Line":1}},{"line":4965,"address":[55614775,55613532],"length":1,"stats":{"Line":1}},{"line":4966,"address":[53570145,53571238],"length":1,"stats":{"Line":1}},{"line":4967,"address":[55613902,55614731],"length":1,"stats":{"Line":1}},{"line":4968,"address":[55614709,55614087],"length":1,"stats":{"Line":1}},{"line":4969,"address":[55614420],"length":1,"stats":{"Line":1}},{"line":4970,"address":[52922176],"length":1,"stats":{"Line":1}},{"line":4971,"address":[52922220,52922276],"length":1,"stats":{"Line":2}},{"line":4973,"address":[54402467],"length":1,"stats":{"Line":1}},{"line":4978,"address":[54483578,54483868],"length":1,"stats":{"Line":50}},{"line":4979,"address":[53641125],"length":1,"stats":{"Line":31}},{"line":4980,"address":[53641164,53641242],"length":1,"stats":{"Line":38}},{"line":4982,"address":[54299915,54299995,54300797,54299782],"length":1,"stats":{"Line":0}},{"line":4983,"address":[52897639],"length":1,"stats":{"Line":0}},{"line":4984,"address":[55498445,55498370],"length":1,"stats":{"Line":0}},{"line":4985,"address":[52897807],"length":1,"stats":{"Line":0}},{"line":4986,"address":[52897850],"length":1,"stats":{"Line":0}},{"line":4987,"address":[52898486,52897885],"length":1,"stats":{"Line":0}},{"line":4989,"address":[55498767,55498826],"length":1,"stats":{"Line":0}},{"line":4990,"address":[53468656],"length":1,"stats":{"Line":0}},{"line":4991,"address":[55498709],"length":1,"stats":{"Line":0}},{"line":4992,"address":[52898012,52898090],"length":1,"stats":{"Line":0}},{"line":4993,"address":[53468924,53469046],"length":1,"stats":{"Line":0}},{"line":4998,"address":[55316048,55316338],"length":1,"stats":{"Line":50}},{"line":4999,"address":[54997704],"length":1,"stats":{"Line":31}},{"line":5000,"address":[52944911,52945018,52944016],"length":1,"stats":{"Line":38}},{"line":5002,"address":[54300854,54300927],"length":1,"stats":{"Line":0}},{"line":5003,"address":[54300941],"length":1,"stats":{"Line":0}},{"line":5004,"address":[52944168,52944980],"length":1,"stats":{"Line":0}},{"line":5006,"address":[54301086,54301012],"length":1,"stats":{"Line":0}},{"line":5007,"address":[52944288],"length":1,"stats":{"Line":0}},{"line":5008,"address":[54301138,54301747],"length":1,"stats":{"Line":0}},{"line":5010,"address":[52944454,52944365,52944554,52944635],"length":1,"stats":{"Line":0}},{"line":5011,"address":[54438640,54301423,54301322,54438670],"length":1,"stats":{"Line":0}},{"line":5012,"address":[54301544],"length":1,"stats":{"Line":0}},{"line":5017,"address":[53641672,53641935],"length":1,"stats":{"Line":42}},{"line":5018,"address":[53641771],"length":1,"stats":{"Line":31}},{"line":5019,"address":[53641810,53641888],"length":1,"stats":{"Line":46}},{"line":5021,"address":[54386356,54386274,54388312],"length":1,"stats":{"Line":0}},{"line":5022,"address":[53555078,53556806],"length":1,"stats":{"Line":0}},{"line":5023,"address":[53555343],"length":1,"stats":{"Line":0}},{"line":5024,"address":[53555399],"length":1,"stats":{"Line":0}},{"line":5025,"address":[54388269,54386941],"length":1,"stats":{"Line":0}},{"line":5027,"address":[52895541,52895603,52896606],"length":1,"stats":{"Line":0}},{"line":5028,"address":[53555479],"length":1,"stats":{"Line":0}},{"line":5029,"address":[54387051],"length":1,"stats":{"Line":0}},{"line":5030,"address":[55616610,55616691],"length":1,"stats":{"Line":0}},{"line":5031,"address":[53555740],"length":1,"stats":{"Line":0}},{"line":5032,"address":[55616887,55617583,55616813],"length":1,"stats":{"Line":0}},{"line":5033,"address":[53555832,53555886,53555933,53556525],"length":1,"stats":{"Line":0}},{"line":5034,"address":[54387507,54387460,54387406,54387972],"length":1,"stats":{"Line":0}},{"line":5035,"address":[52896310,52895977,52895876,52895930],"length":1,"stats":{"Line":0}},{"line":5036,"address":[54387600,54387641,54387546,54387838],"length":1,"stats":{"Line":0}},{"line":5037,"address":[54387660,54387606],"length":1,"stats":{"Line":0}},{"line":5039,"address":[55617639,55617407],"length":1,"stats":{"Line":0}},{"line":5044,"address":[54484652,54484942],"length":1,"stats":{"Line":50}},{"line":5045,"address":[54484767],"length":1,"stats":{"Line":23}},{"line":5046,"address":[55647205,55645376,55647137],"length":1,"stats":{"Line":55}},{"line":5047,"address":[53581890,53580139,53580060],"length":1,"stats":{"Line":2}},{"line":5048,"address":[55647195,55645683],"length":1,"stats":{"Line":1}},{"line":5049,"address":[53580588],"length":1,"stats":{"Line":1}},{"line":5050,"address":[52993067],"length":1,"stats":{"Line":1}},{"line":5051,"address":[54412177,54413345],"length":1,"stats":{"Line":0}},{"line":5053,"address":[53580768,53580717],"length":1,"stats":{"Line":1}},{"line":5054,"address":[54412255,54412346],"length":1,"stats":{"Line":2}},{"line":5055,"address":[54412362,54412433],"length":1,"stats":{"Line":2}},{"line":5056,"address":[52993378,52993417,52994160,52993333],"length":1,"stats":{"Line":4}},{"line":5057,"address":[53580994,53581033,53580962,53581653],"length":1,"stats":{"Line":4}},{"line":5058,"address":[55646393,55646322,55646888,55646354],"length":1,"stats":{"Line":0}},{"line":5059,"address":[53581129,53581090,53581501,53581058],"length":1,"stats":{"Line":0}},{"line":5060,"address":[53581171,53581106,53581138,53581351],"length":1,"stats":{"Line":0}},{"line":5061,"address":[55646456,55646488],"length":1,"stats":{"Line":0}},{"line":5063,"address":[55646738],"length":1,"stats":{"Line":1}},{"line":5068,"address":[55317122,55317409],"length":1,"stats":{"Line":50}},{"line":5069,"address":[55317237],"length":1,"stats":{"Line":23}},{"line":5070,"address":[55543424,55543713],"length":1,"stats":{"Line":55}},{"line":5072,"address":[53427710,53427855,53427780,53427894],"length":1,"stats":{"Line":4}},{"line":5073,"address":[53017017],"length":1,"stats":{"Line":1}},{"line":5074,"address":[55543554],"length":1,"stats":{"Line":1}},{"line":5075,"address":[53427869],"length":1,"stats":{"Line":1}},{"line":5076,"address":[53017126],"length":1,"stats":{"Line":1}},{"line":5081,"address":[53642640,53642902],"length":1,"stats":{"Line":50}},{"line":5082,"address":[55317592],"length":1,"stats":{"Line":23}},{"line":5083,"address":[53642778,53642855],"length":1,"stats":{"Line":54}},{"line":5086,"address":[53470695,53470368],"length":1,"stats":{"Line":1}},{"line":5088,"address":[52920094,52920285,52920160,52920234],"length":1,"stats":{"Line":4}},{"line":5089,"address":[52920172],"length":1,"stats":{"Line":1}},{"line":5090,"address":[52920197],"length":1,"stats":{"Line":1}},{"line":5091,"address":[53470560],"length":1,"stats":{"Line":1}},{"line":5092,"address":[54302117],"length":1,"stats":{"Line":1}},{"line":5102,"address":[53642962,53643225],"length":1,"stats":{"Line":50}},{"line":5103,"address":[55317947],"length":1,"stats":{"Line":23}},{"line":5104,"address":[55317986,55318063],"length":1,"stats":{"Line":55}},{"line":5106,"address":[53009606,53009671],"length":1,"stats":{"Line":2}},{"line":5107,"address":[53528717],"length":1,"stats":{"Line":1}},{"line":5108,"address":[55535640,55536467],"length":1,"stats":{"Line":0}},{"line":5110,"address":[55535676,55535746],"length":1,"stats":{"Line":2}},{"line":5111,"address":[53009840],"length":1,"stats":{"Line":1}},{"line":5112,"address":[53010489,53009878],"length":1,"stats":{"Line":0}},{"line":5114,"address":[53529176,53528956,53529081,53529027],"length":1,"stats":{"Line":3}},{"line":5115,"address":[55536020,55535954,55726016,55726045],"length":1,"stats":{"Line":1}},{"line":5116,"address":[55536225,55536146],"length":1,"stats":{"Line":2}},{"line":5121,"address":[54999804,54999541],"length":1,"stats":{"Line":50}},{"line":5122,"address":[55318305],"length":1,"stats":{"Line":23}},{"line":5123,"address":[52885485,52885750,52883664],"length":1,"stats":{"Line":55}},{"line":5125,"address":[53491958,53492063],"length":1,"stats":{"Line":2}},{"line":5126,"address":[55544933],"length":1,"stats":{"Line":1}},{"line":5127,"address":[53494031,53492112],"length":1,"stats":{"Line":0}},{"line":5129,"address":[52883957,52883887],"length":1,"stats":{"Line":2}},{"line":5130,"address":[55545091],"length":1,"stats":{"Line":1}},{"line":5131,"address":[52885651,52884009],"length":1,"stats":{"Line":0}},{"line":5133,"address":[52884122,52884188,52884263,52884051],"length":1,"stats":{"Line":3}},{"line":5134,"address":[52884165,53073552,53073581,52884231],"length":1,"stats":{"Line":1}},{"line":5135,"address":[55545564,55545709,55545477],"length":1,"stats":{"Line":3}},{"line":5136,"address":[52884522],"length":1,"stats":{"Line":1}},{"line":5137,"address":[52884594,52884674,52885513],"length":1,"stats":{"Line":2}},{"line":5138,"address":[52884884,52885491],"length":1,"stats":{"Line":1}},{"line":5139,"address":[54325283,54324879],"length":1,"stats":{"Line":1}},{"line":5140,"address":[52885266],"length":1,"stats":{"Line":1}},{"line":5142,"address":[54324322],"length":1,"stats":{"Line":1}},{"line":5148,"address":[55318548,55318838],"length":1,"stats":{"Line":50}},{"line":5149,"address":[53643707],"length":1,"stats":{"Line":23}},{"line":5150,"address":[53643824,53643746],"length":1,"stats":{"Line":55}},{"line":5152,"address":[52936487,52936422],"length":1,"stats":{"Line":2}},{"line":5153,"address":[55675941],"length":1,"stats":{"Line":1}},{"line":5154,"address":[54270263,54269312],"length":1,"stats":{"Line":0}},{"line":5156,"address":[53437918,53437844],"length":1,"stats":{"Line":2}},{"line":5157,"address":[55676096],"length":1,"stats":{"Line":1}},{"line":5158,"address":[55676835,55676134],"length":1,"stats":{"Line":0}},{"line":5160,"address":[53438012,53438232,53438083,53438137],"length":1,"stats":{"Line":3}},{"line":5161,"address":[53083357,53083328,52936850,52936916],"length":1,"stats":{"Line":1}},{"line":5163,"address":[54269834,54269921],"length":1,"stats":{"Line":2}},{"line":5164,"address":[53611088,53612044,53438424,53611994],"length":1,"stats":{"Line":2}},{"line":5165,"address":[54442622],"length":1,"stats":{"Line":1}},{"line":5166,"address":[55721869,55721792,55722610],"length":1,"stats":{"Line":2}},{"line":5167,"address":[54443504,54442954],"length":1,"stats":{"Line":1}},{"line":5168,"address":[53611972,53611643],"length":1,"stats":{"Line":1}},{"line":5169,"address":[54443340],"length":1,"stats":{"Line":1}},{"line":5171,"address":[52937175],"length":1,"stats":{"Line":1}},{"line":5172,"address":[52937198],"length":1,"stats":{"Line":1}},{"line":5177,"address":[53643931,53644194],"length":1,"stats":{"Line":50}},{"line":5178,"address":[55000286],"length":1,"stats":{"Line":23}},{"line":5179,"address":[55634368,55635755,55635968],"length":1,"stats":{"Line":55}},{"line":5181,"address":[54414639,54414566],"length":1,"stats":{"Line":2}},{"line":5182,"address":[54414653],"length":1,"stats":{"Line":1}},{"line":5183,"address":[52874648,52876055],"length":1,"stats":{"Line":0}},{"line":5185,"address":[54414801,54414727],"length":1,"stats":{"Line":2}},{"line":5186,"address":[55634643],"length":1,"stats":{"Line":1}},{"line":5187,"address":[54414853,54416059],"length":1,"stats":{"Line":0}},{"line":5189,"address":[55634793,55634720],"length":1,"stats":{"Line":2}},{"line":5190,"address":[55634807],"length":1,"stats":{"Line":1}},{"line":5191,"address":[54415021,54415997],"length":1,"stats":{"Line":0}},{"line":5193,"address":[53583559,53583779,53583630,53583684],"length":1,"stats":{"Line":3}},{"line":5194,"address":[55635067,55721133,55635001,55721104],"length":1,"stats":{"Line":1}},{"line":5195,"address":[53584101],"length":1,"stats":{"Line":1}},{"line":5196,"address":[53583965,53583877],"length":1,"stats":{"Line":2}},{"line":5202,"address":[55319554,55319264],"length":1,"stats":{"Line":50}},{"line":5203,"address":[53644353],"length":1,"stats":{"Line":23}},{"line":5204,"address":[55319418,55319495],"length":1,"stats":{"Line":54}},{"line":5207,"address":[54428914,54428697,54427248],"length":1,"stats":{"Line":1}},{"line":5209,"address":[54427286,54427359],"length":1,"stats":{"Line":2}},{"line":5210,"address":[53017349],"length":1,"stats":{"Line":1}},{"line":5211,"address":[53017387,53018823],"length":1,"stats":{"Line":0}},{"line":5213,"address":[54427527,54427450],"length":1,"stats":{"Line":2}},{"line":5214,"address":[54427541],"length":1,"stats":{"Line":1}},{"line":5215,"address":[54428811,54427579],"length":1,"stats":{"Line":0}},{"line":5217,"address":[54427618,54427695],"length":1,"stats":{"Line":2}},{"line":5218,"address":[54427709],"length":1,"stats":{"Line":1}},{"line":5220,"address":[53018697],"length":1,"stats":{"Line":0}},{"line":5221,"address":[53596243],"length":1,"stats":{"Line":0}},{"line":5225,"address":[53596356,53596410,53596505,53596285],"length":1,"stats":{"Line":3}},{"line":5226,"address":[54452733,54427977,54427879,54452704],"length":1,"stats":{"Line":1}},{"line":5227,"address":[53018300],"length":1,"stats":{"Line":1}},{"line":5228,"address":[55687106,55687195],"length":1,"stats":{"Line":2}},{"line":5235,"address":[53644577,53644840],"length":1,"stats":{"Line":50}},{"line":5236,"address":[55319737],"length":1,"stats":{"Line":23}},{"line":5237,"address":[53644715,53644793],"length":1,"stats":{"Line":55}},{"line":5239,"address":[54322367,54322294],"length":1,"stats":{"Line":2}},{"line":5240,"address":[55707637],"length":1,"stats":{"Line":1}},{"line":5241,"address":[55708589,55707672],"length":1,"stats":{"Line":0}},{"line":5243,"address":[53490948,53491022],"length":1,"stats":{"Line":2}},{"line":5244,"address":[54322540],"length":1,"stats":{"Line":1}},{"line":5245,"address":[52907190,52907891],"length":1,"stats":{"Line":0}},{"line":5247,"address":[52907232,52907369,52907303,52907444],"length":1,"stats":{"Line":3}},{"line":5248,"address":[54445053,54322710,54322808,54445024],"length":1,"stats":{"Line":1}},{"line":5250,"address":[54322938,54323025],"length":1,"stats":{"Line":2}},{"line":5251,"address":[53620103,53620048,53491528],"length":1,"stats":{"Line":3}},{"line":5252,"address":[53491555],"length":1,"stats":{"Line":1}},{"line":5253,"address":[54323086],"length":1,"stats":{"Line":1}},{"line":5262,"address":[55319980,55320270],"length":1,"stats":{"Line":50}},{"line":5263,"address":[55001255],"length":1,"stats":{"Line":23}},{"line":5264,"address":[55001294,55001372],"length":1,"stats":{"Line":55}},{"line":5265,"address":[54260148,54260220],"length":1,"stats":{"Line":2}},{"line":5266,"address":[54260234],"length":1,"stats":{"Line":1}},{"line":5267,"address":[54260269,54260709],"length":1,"stats":{"Line":0}},{"line":5269,"address":[55697518,55697470],"length":1,"stats":{"Line":2}},{"line":5270,"address":[52936063],"length":1,"stats":{"Line":1}},{"line":5271,"address":[55697534],"length":1,"stats":{"Line":1}},{"line":5277,"address":[55001742,55001479],"length":1,"stats":{"Line":46}},{"line":5278,"address":[55320453],"length":1,"stats":{"Line":23}},{"line":5279,"address":[54488380,54488457],"length":1,"stats":{"Line":55}},{"line":5280,"address":[53441094,53441167],"length":1,"stats":{"Line":2}},{"line":5281,"address":[54272685],"length":1,"stats":{"Line":1}},{"line":5282,"address":[53009508,53009064],"length":1,"stats":{"Line":0}},{"line":5284,"address":[53009100,53009168],"length":1,"stats":{"Line":2}},{"line":5285,"address":[54272841,54272909],"length":1,"stats":{"Line":2}},{"line":5286,"address":[55621252,55621299],"length":1,"stats":{"Line":0}},{"line":5288,"address":[54272911],"length":1,"stats":{"Line":1}},{"line":5289,"address":[53441570],"length":1,"stats":{"Line":1}},{"line":5294,"address":[54488865,54488584],"length":1,"stats":{"Line":50}},{"line":5295,"address":[55001901],"length":1,"stats":{"Line":24}},{"line":5296,"address":[55002017,55001940],"length":1,"stats":{"Line":52}},{"line":5297,"address":[52904638],"length":1,"stats":{"Line":0}},{"line":5298,"address":[55657645,55729000,55728992],"length":1,"stats":{"Line":0}},{"line":5299,"address":[55657662],"length":1,"stats":{"Line":0}},{"line":5300,"address":[55657682],"length":1,"stats":{"Line":0}},{"line":5305,"address":[55002369,55002118],"length":1,"stats":{"Line":50}},{"line":5306,"address":[55002214],"length":1,"stats":{"Line":24}},{"line":5307,"address":[55321196,55321273],"length":1,"stats":{"Line":53}},{"line":5309,"address":[52916550,52916631],"length":1,"stats":{"Line":2}},{"line":5310,"address":[53444317],"length":1,"stats":{"Line":1}},{"line":5311,"address":[54277360,54275856],"length":1,"stats":{"Line":0}},{"line":5316,"address":[53444460,53444528,53444383],"length":1,"stats":{"Line":3}},{"line":5318,"address":[55501226],"length":1,"stats":{"Line":1}},{"line":5319,"address":[54276233],"length":1,"stats":{"Line":1}},{"line":5320,"address":[55501373,55501456],"length":1,"stats":{"Line":2}},{"line":5321,"address":[54276535],"length":1,"stats":{"Line":1}},{"line":5322,"address":[54276743,54276883,54276820],"length":1,"stats":{"Line":3}},{"line":5323,"address":[54276822],"length":1,"stats":{"Line":0}},{"line":5325,"address":[52917584],"length":1,"stats":{"Line":1}},{"line":5328,"address":[52917007,52917948],"length":1,"stats":{"Line":0}},{"line":5334,"address":[53646173,53646424],"length":1,"stats":{"Line":50}},{"line":5335,"address":[55321503],"length":1,"stats":{"Line":24}},{"line":5336,"address":[52990032,52990906,52990959],"length":1,"stats":{"Line":53}},{"line":5338,"address":[53457183,53457110],"length":1,"stats":{"Line":2}},{"line":5339,"address":[55586661],"length":1,"stats":{"Line":1}},{"line":5340,"address":[55586696,55587434],"length":1,"stats":{"Line":0}},{"line":5345,"address":[53457408,53457263,53457340],"length":1,"stats":{"Line":3}},{"line":5347,"address":[52990471],"length":1,"stats":{"Line":1}},{"line":5348,"address":[52990529],"length":1,"stats":{"Line":1}},{"line":5349,"address":[54289241,54289039],"length":1,"stats":{"Line":0}},{"line":5355,"address":[55002991,55002740],"length":1,"stats":{"Line":51}},{"line":5356,"address":[55321849],"length":1,"stats":{"Line":24}},{"line":5357,"address":[52933920,52934067],"length":1,"stats":{"Line":50}},{"line":5358,"address":[54214550,54214614],"length":1,"stats":{"Line":0}},{"line":5359,"address":[55670070],"length":1,"stats":{"Line":0}},{"line":5364,"address":[55322083,55322358],"length":1,"stats":{"Line":48}},{"line":5365,"address":[55322195],"length":1,"stats":{"Line":25}},{"line":5366,"address":[55655728,55655981],"length":1,"stats":{"Line":53}},{"line":5367,"address":[53033662,53033725],"length":1,"stats":{"Line":2}},{"line":5368,"address":[53033762],"length":1,"stats":{"Line":1}},{"line":5373,"address":[55322426,55322701],"length":1,"stats":{"Line":50}},{"line":5374,"address":[54490426],"length":1,"stats":{"Line":23}},{"line":5375,"address":[55003496,55003573],"length":1,"stats":{"Line":55}},{"line":5376,"address":[54334711,54334654],"length":1,"stats":{"Line":2}},{"line":5377,"address":[52951952],"length":1,"stats":{"Line":1}},{"line":5378,"address":[54335074,54334745],"length":1,"stats":{"Line":0}},{"line":5384,"address":[53647415,53647666],"length":1,"stats":{"Line":50}},{"line":5385,"address":[53647511],"length":1,"stats":{"Line":23}},{"line":5386,"address":[55617824,55618337,55618294],"length":1,"stats":{"Line":54}},{"line":5387,"address":[55617862,55617927],"length":1,"stats":{"Line":0}},{"line":5388,"address":[53427245],"length":1,"stats":{"Line":0}},{"line":5389,"address":[53427280,53427627],"length":1,"stats":{"Line":0}},{"line":5391,"address":[52862849,52862921,52862764],"length":1,"stats":{"Line":0}},{"line":5392,"address":[55726288,55726317,55618080,55618143],"length":1,"stats":{"Line":0}},{"line":5393,"address":[53427516],"length":1,"stats":{"Line":0}},{"line":5398,"address":[54491003,54491281],"length":1,"stats":{"Line":50}},{"line":5399,"address":[55323227],"length":1,"stats":{"Line":23}},{"line":5400,"address":[55323266,55323343],"length":1,"stats":{"Line":54}},{"line":5403,"address":[54224720,54224752],"length":1,"stats":{"Line":0}},{"line":5409,"address":[53778067,53777392,53778061],"length":1,"stats":{"Line":23}},{"line":5410,"address":[55133715],"length":1,"stats":{"Line":27}},{"line":5411,"address":[55133784,55133720,55134313],"length":1,"stats":{"Line":54}},{"line":5412,"address":[53777746,53777910,53777601],"length":1,"stats":{"Line":27}},{"line":5414,"address":[55133885],"length":1,"stats":{"Line":3}},{"line":5419,"address":[53546000],"length":1,"stats":{"Line":3}},{"line":5420,"address":[55211493],"length":1,"stats":{"Line":3}},{"line":5425,"address":[54385984],"length":1,"stats":{"Line":0}},{"line":5426,"address":[54908549],"length":1,"stats":{"Line":0}},{"line":5430,"address":[54384633,54379488,54383115],"length":1,"stats":{"Line":0}},{"line":5437,"address":[54379629],"length":1,"stats":{"Line":0}},{"line":5440,"address":[53546595,53546518],"length":1,"stats":{"Line":0}},{"line":5442,"address":[54380021],"length":1,"stats":{"Line":0}},{"line":5446,"address":[55495042,55495097,55495103,55494960],"length":1,"stats":{"Line":0}},{"line":5448,"address":[54205725],"length":1,"stats":{"Line":0}},{"line":5452,"address":[54380501,54384610,54380690,54380418],"length":1,"stats":{"Line":0}},{"line":5453,"address":[52846349,52846266],"length":1,"stats":{"Line":0}},{"line":5454,"address":[55495367],"length":1,"stats":{"Line":0}},{"line":5458,"address":[54380791,54380878],"length":1,"stats":{"Line":0}},{"line":5461,"address":[53547483],"length":1,"stats":{"Line":0}},{"line":5462,"address":[54381333,54380940,54381020],"length":1,"stats":{"Line":0}},{"line":5463,"address":[54381203,54381226,54381142],"length":1,"stats":{"Line":0}},{"line":5467,"address":[54904168],"length":1,"stats":{"Line":0}},{"line":5468,"address":[54903987],"length":1,"stats":{"Line":0}},{"line":5470,"address":[54904245,54904312],"length":1,"stats":{"Line":0}},{"line":5471,"address":[54904336,54904397,54904424],"length":1,"stats":{"Line":0}},{"line":5474,"address":[55213798],"length":1,"stats":{"Line":0}},{"line":5475,"address":[53548397,53550622],"length":1,"stats":{"Line":0}},{"line":5479,"address":[53548415,53548466],"length":1,"stats":{"Line":0}},{"line":5480,"address":[55214158,55214095],"length":1,"stats":{"Line":0}},{"line":5484,"address":[55214265,55215851],"length":1,"stats":{"Line":0}},{"line":5486,"address":[54382232,54382294],"length":1,"stats":{"Line":0}},{"line":5487,"address":[53549014],"length":1,"stats":{"Line":0}},{"line":5488,"address":[54382652,54382756],"length":1,"stats":{"Line":0}},{"line":5490,"address":[54382796],"length":1,"stats":{"Line":0}},{"line":5493,"address":[55215282,55214371],"length":1,"stats":{"Line":0}},{"line":5494,"address":[54383384,54383564,54384133],"length":1,"stats":{"Line":0}},{"line":5495,"address":[53550119,53550284],"length":1,"stats":{"Line":0}},{"line":5499,"address":[55215102],"length":1,"stats":{"Line":0}},{"line":5503,"address":[55038872,55038240,55038904],"length":1,"stats":{"Line":0}},{"line":5504,"address":[55358952],"length":1,"stats":{"Line":0}},{"line":5507,"address":[53682175,53682095],"length":1,"stats":{"Line":0}},{"line":5508,"address":[54527068],"length":1,"stats":{"Line":0}},{"line":5512,"address":[55359429,55359163,55359223],"length":1,"stats":{"Line":0}},{"line":5513,"address":[53682369],"length":1,"stats":{"Line":0}},{"line":5517,"address":[53682344],"length":1,"stats":{"Line":0}},{"line":5519,"address":[53621753,53621759,53621616,53621698],"length":1,"stats":{"Line":0}},{"line":5520,"address":[53084381],"length":1,"stats":{"Line":0}},{"line":5524,"address":[55218112],"length":1,"stats":{"Line":27}},{"line":5525,"address":[54908598,54908701],"length":1,"stats":{"Line":27}},{"line":5526,"address":[53552571],"length":1,"stats":{"Line":4}},{"line":5527,"address":[55218514],"length":1,"stats":{"Line":0}},{"line":5528,"address":[54386542],"length":1,"stats":{"Line":0}},{"line":5529,"address":[54386531],"length":1,"stats":{"Line":0}},{"line":5531,"address":[53552917],"length":1,"stats":{"Line":0}},{"line":5532,"address":[53552907],"length":1,"stats":{"Line":0}},{"line":5537,"address":[55051265,55051271,55044944],"length":1,"stats":{"Line":27}},{"line":5541,"address":[55366019],"length":1,"stats":{"Line":23}},{"line":5542,"address":[55045406],"length":1,"stats":{"Line":8}},{"line":5547,"address":[54534304,54539143],"length":1,"stats":{"Line":4}},{"line":5548,"address":[55371352,55372395],"length":1,"stats":{"Line":9}},{"line":5549,"address":[53694417,53694484,53694169],"length":1,"stats":{"Line":7}},{"line":5550,"address":[54539685,54539772],"length":1,"stats":{"Line":6}},{"line":5551,"address":[53694903],"length":1,"stats":{"Line":3}},{"line":5553,"address":[53694240,53695040],"length":1,"stats":{"Line":1}},{"line":5554,"address":[53695126],"length":1,"stats":{"Line":1}},{"line":5556,"address":[54540120,54540337],"length":1,"stats":{"Line":6}},{"line":5557,"address":[54540610],"length":1,"stats":{"Line":4}},{"line":5560,"address":[54534554],"length":1,"stats":{"Line":16}},{"line":5561,"address":[53695601,53689485],"length":1,"stats":{"Line":16}},{"line":5562,"address":[55372983],"length":1,"stats":{"Line":16}},{"line":5563,"address":[55373241,55373170],"length":1,"stats":{"Line":6}},{"line":5564,"address":[55373474],"length":1,"stats":{"Line":3}},{"line":5567,"address":[55045918],"length":1,"stats":{"Line":3}},{"line":5568,"address":[54541544,54534809],"length":1,"stats":{"Line":3}},{"line":5569,"address":[55052869,55052726],"length":1,"stats":{"Line":3}},{"line":5570,"address":[54541699],"length":1,"stats":{"Line":3}},{"line":5571,"address":[55052946,55052842],"length":1,"stats":{"Line":6}},{"line":5572,"address":[55373988],"length":1,"stats":{"Line":3}},{"line":5573,"address":[55374240],"length":1,"stats":{"Line":3}},{"line":5576,"address":[55367144],"length":1,"stats":{"Line":3}},{"line":5582,"address":[55046227,55053228],"length":1,"stats":{"Line":3}},{"line":5583,"address":[53697073],"length":1,"stats":{"Line":3}},{"line":5584,"address":[53697321,53697274],"length":1,"stats":{"Line":6}},{"line":5585,"address":[53697554],"length":1,"stats":{"Line":3}},{"line":5586,"address":[55375732,55374934,55375533],"length":1,"stats":{"Line":9}},{"line":5590,"address":[53698456],"length":1,"stats":{"Line":3}},{"line":5591,"address":[55053849,55053923,55054478],"length":1,"stats":{"Line":9}},{"line":5592,"address":[55053931,55054179,55053980],"length":1,"stats":{"Line":9}},{"line":5596,"address":[55054213],"length":1,"stats":{"Line":3}},{"line":5598,"address":[54542895],"length":1,"stats":{"Line":3}},{"line":5599,"address":[55054357],"length":1,"stats":{"Line":3}},{"line":5603,"address":[55367387],"length":1,"stats":{"Line":3}},{"line":5608,"address":[54543843,54535318],"length":1,"stats":{"Line":6}},{"line":5612,"address":[53698666],"length":1,"stats":{"Line":3}},{"line":5613,"address":[54543891],"length":1,"stats":{"Line":3}},{"line":5614,"address":[55376303,55376590,55376771],"length":1,"stats":{"Line":6}},{"line":5615,"address":[53699462,53699275],"length":1,"stats":{"Line":3}},{"line":5616,"address":[55055819],"length":1,"stats":{"Line":3}},{"line":5619,"address":[53700234,53700343,53700542],"length":1,"stats":{"Line":9}},{"line":5626,"address":[53700261],"length":1,"stats":{"Line":3}},{"line":5629,"address":[53699965],"length":1,"stats":{"Line":1}},{"line":5632,"address":[55376341,55377999],"length":1,"stats":{"Line":6}},{"line":5636,"address":[55378028],"length":1,"stats":{"Line":3}},{"line":5639,"address":[55367622],"length":1,"stats":{"Line":3}},{"line":5645,"address":[53690472,53700949],"length":1,"stats":{"Line":6}},{"line":5649,"address":[55378318],"length":1,"stats":{"Line":3}},{"line":5651,"address":[55057447],"length":1,"stats":{"Line":3}},{"line":5652,"address":[53702026,53701409],"length":1,"stats":{"Line":6}},{"line":5653,"address":[55057619,55058034],"length":1,"stats":{"Line":3}},{"line":5654,"address":[55057727,55057545],"length":1,"stats":{"Line":9}},{"line":5656,"address":[53705458],"length":1,"stats":{"Line":0}},{"line":5657,"address":[55057519,55061556],"length":1,"stats":{"Line":0}},{"line":5658,"address":[55061715],"length":1,"stats":{"Line":0}},{"line":5663,"address":[53701748,53702118],"length":1,"stats":{"Line":6}},{"line":5664,"address":[53702378],"length":1,"stats":{"Line":3}},{"line":5665,"address":[55381334,55379783,55379985],"length":1,"stats":{"Line":9}},{"line":5666,"address":[54548024,54548106,54547972],"length":1,"stats":{"Line":6}},{"line":5667,"address":[55380151,55380564,55380279],"length":1,"stats":{"Line":9}},{"line":5671,"address":[55380598],"length":1,"stats":{"Line":3}},{"line":5672,"address":[55059724,55061420],"length":1,"stats":{"Line":3}},{"line":5675,"address":[53704181,53704313,53704512],"length":1,"stats":{"Line":6}},{"line":5682,"address":[55381658],"length":1,"stats":{"Line":2}},{"line":5685,"address":[55381366],"length":1,"stats":{"Line":0}},{"line":5688,"address":[54550223,54549938],"length":1,"stats":{"Line":11}},{"line":5692,"address":[54550257],"length":1,"stats":{"Line":8}},{"line":5695,"address":[55046978],"length":1,"stats":{"Line":5}},{"line":5701,"address":[55061999,55047083],"length":1,"stats":{"Line":12}},{"line":5705,"address":[54535907],"length":1,"stats":{"Line":5}},{"line":5708,"address":[55383301,55383259],"length":1,"stats":{"Line":12}},{"line":5710,"address":[54551177],"length":1,"stats":{"Line":16}},{"line":5711,"address":[55733959],"length":1,"stats":{"Line":5}},{"line":5712,"address":[53084577],"length":1,"stats":{"Line":5}},{"line":5717,"address":[53705822,53705905],"length":1,"stats":{"Line":10}},{"line":5718,"address":[54551305],"length":1,"stats":{"Line":5}},{"line":5719,"address":[54551353,54551428],"length":1,"stats":{"Line":12}},{"line":5720,"address":[55383548],"length":1,"stats":{"Line":7}},{"line":5722,"address":[53706627,53706322,53706208],"length":1,"stats":{"Line":23}},{"line":5724,"address":[55384375,55383889,55383933,55384090,55384171],"length":1,"stats":{"Line":16}},{"line":5725,"address":[54552121],"length":1,"stats":{"Line":6}},{"line":5728,"address":[55368363],"length":1,"stats":{"Line":3}},{"line":5729,"address":[53706975,53708124,53691189],"length":1,"stats":{"Line":13}},{"line":5730,"address":[55063243,55063491],"length":1,"stats":{"Line":8}},{"line":5731,"address":[55063622,55063721],"length":1,"stats":{"Line":18}},{"line":5732,"address":[55063969],"length":1,"stats":{"Line":6}},{"line":5734,"address":[53707062,53708027],"length":1,"stats":{"Line":0}},{"line":5735,"address":[55385686],"length":1,"stats":{"Line":0}},{"line":5737,"address":[55385351],"length":1,"stats":{"Line":9}},{"line":5740,"address":[54536355],"length":1,"stats":{"Line":3}},{"line":5741,"address":[53691282,53708129],"length":1,"stats":{"Line":3}},{"line":5742,"address":[53708260,53708359],"length":1,"stats":{"Line":6}},{"line":5743,"address":[53708623],"length":1,"stats":{"Line":3}},{"line":5744,"address":[55386389,55386321],"length":1,"stats":{"Line":6}},{"line":5745,"address":[55065143],"length":1,"stats":{"Line":3}},{"line":5746,"address":[53708957],"length":1,"stats":{"Line":3}},{"line":5749,"address":[55368582],"length":1,"stats":{"Line":3}},{"line":5750,"address":[54536482,54554598],"length":1,"stats":{"Line":3}},{"line":5751,"address":[54554695],"length":1,"stats":{"Line":3}},{"line":5754,"address":[55047806],"length":1,"stats":{"Line":3}},{"line":5755,"address":[54536671,54554821],"length":1,"stats":{"Line":3}},{"line":5756,"address":[53709446],"length":1,"stats":{"Line":3}},{"line":5759,"address":[53691754],"length":1,"stats":{"Line":3}},{"line":5765,"address":[54536929,54555112],"length":1,"stats":{"Line":6}},{"line":5769,"address":[54555292,54555141,54555855],"length":1,"stats":{"Line":11}},{"line":5770,"address":[53709725,53709853,53710085],"length":1,"stats":{"Line":10}},{"line":5771,"address":[55734625],"length":1,"stats":{"Line":0}},{"line":5772,"address":[53621837],"length":1,"stats":{"Line":0}},{"line":5773,"address":[53621870],"length":1,"stats":{"Line":0}},{"line":5776,"address":[54555750],"length":1,"stats":{"Line":5}},{"line":5777,"address":[55387876],"length":1,"stats":{"Line":5}},{"line":5779,"address":[53710520],"length":1,"stats":{"Line":2}},{"line":5780,"address":[53710401,53710312],"length":1,"stats":{"Line":4}},{"line":5781,"address":[54556026],"length":1,"stats":{"Line":2}},{"line":5786,"address":[53709788],"length":1,"stats":{"Line":3}},{"line":5789,"address":[54556282,54555873],"length":1,"stats":{"Line":6}},{"line":5791,"address":[55067078,55067158],"length":1,"stats":{"Line":6}},{"line":5792,"address":[54556539],"length":1,"stats":{"Line":11}},{"line":5793,"address":[53711684],"length":1,"stats":{"Line":3}},{"line":5794,"address":[55389378],"length":1,"stats":{"Line":3}},{"line":5795,"address":[55067982],"length":1,"stats":{"Line":3}},{"line":5800,"address":[55389413],"length":1,"stats":{"Line":7}},{"line":5802,"address":[53711820],"length":1,"stats":{"Line":18}},{"line":5803,"address":[54453687],"length":1,"stats":{"Line":5}},{"line":5804,"address":[53622209],"length":1,"stats":{"Line":6}},{"line":5809,"address":[55389577,55389652],"length":1,"stats":{"Line":10}},{"line":5810,"address":[55389660],"length":1,"stats":{"Line":6}},{"line":5811,"address":[54557596,54557671],"length":1,"stats":{"Line":12}},{"line":5812,"address":[54557679],"length":1,"stats":{"Line":7}},{"line":5814,"address":[54558217,54557855,54558061,54557938],"length":1,"stats":{"Line":15}},{"line":5818,"address":[55067332,55067405,55067710],"length":1,"stats":{"Line":26}},{"line":5820,"address":[53711654,53711474,53711377,53711192,53711224],"length":1,"stats":{"Line":14}},{"line":5821,"address":[55067772],"length":1,"stats":{"Line":9}},{"line":5824,"address":[55369291],"length":1,"stats":{"Line":5}},{"line":5825,"address":[54537265,54558473],"length":1,"stats":{"Line":10}},{"line":5829,"address":[55048384],"length":1,"stats":{"Line":5}},{"line":5831,"address":[55390609,55390683,55391446],"length":1,"stats":{"Line":5}},{"line":5832,"address":[53713439,53713052,53713166],"length":1,"stats":{"Line":19}},{"line":5834,"address":[53713635,53713245,53713213,53713366,53713463],"length":1,"stats":{"Line":10}},{"line":5835,"address":[55069761],"length":1,"stats":{"Line":7}},{"line":5838,"address":[55369693],"length":1,"stats":{"Line":0}},{"line":5841,"address":[55369763],"length":1,"stats":{"Line":0}},{"line":5843,"address":[54559400,54537725,54559685],"length":1,"stats":{"Line":0}},{"line":5847,"address":[54559711],"length":1,"stats":{"Line":0}},{"line":5850,"address":[55049003],"length":1,"stats":{"Line":11}},{"line":5856,"address":[54537884,54559908],"length":1,"stats":{"Line":11}},{"line":5857,"address":[54560005],"length":1,"stats":{"Line":11}},{"line":5858,"address":[54560278],"length":1,"stats":{"Line":2}},{"line":5859,"address":[53714726,53714667,53714925],"length":1,"stats":{"Line":6}},{"line":5863,"address":[55392726],"length":1,"stats":{"Line":2}},{"line":5865,"address":[55392272],"length":1,"stats":{"Line":9}},{"line":5866,"address":[55071343,55070825,55071565],"length":1,"stats":{"Line":27}},{"line":5871,"address":[55071672,55071599,55071902],"length":1,"stats":{"Line":21}},{"line":5873,"address":[53715666,53715838,53715459,53715556],"length":1,"stats":{"Line":9}},{"line":5874,"address":[54561406],"length":1,"stats":{"Line":9}},{"line":5879,"address":[53692940],"length":1,"stats":{"Line":6}},{"line":5880,"address":[53693006,53715860],"length":1,"stats":{"Line":4}},{"line":5881,"address":[54561668],"length":1,"stats":{"Line":7}},{"line":5882,"address":[54561926,54561855],"length":1,"stats":{"Line":12}},{"line":5884,"address":[54562159],"length":1,"stats":{"Line":8}},{"line":5885,"address":[55073036,55074550,55073560],"length":1,"stats":{"Line":11}},{"line":5886,"address":[55073728],"length":1,"stats":{"Line":3}},{"line":5888,"address":[53717852],"length":1,"stats":{"Line":3}},{"line":5889,"address":[53718191,53717894,53718005],"length":1,"stats":{"Line":6}},{"line":5891,"address":[54563802,54563911,54563961],"length":1,"stats":{"Line":2}},{"line":5893,"address":[53717937,53718270],"length":1,"stats":{"Line":6}},{"line":5898,"address":[55073054],"length":1,"stats":{"Line":2}},{"line":5899,"address":[54562917],"length":1,"stats":{"Line":2}},{"line":5900,"address":[55073314],"length":1,"stats":{"Line":2}},{"line":5901,"address":[55073437],"length":1,"stats":{"Line":2}},{"line":5905,"address":[54538335],"length":1,"stats":{"Line":3}},{"line":5910,"address":[55396175,55370467],"length":1,"stats":{"Line":3}},{"line":5911,"address":[54564168],"length":1,"stats":{"Line":3}},{"line":5912,"address":[53718645,53718598],"length":1,"stats":{"Line":6}},{"line":5913,"address":[53718878],"length":1,"stats":{"Line":2}},{"line":5914,"address":[54564778,54564698],"length":1,"stats":{"Line":5}},{"line":5915,"address":[55397308,55396906,55396947],"length":1,"stats":{"Line":4}},{"line":5916,"address":[53719278],"length":1,"stats":{"Line":2}},{"line":5918,"address":[55075276,55075671],"length":1,"stats":{"Line":4}},{"line":5920,"address":[53719348,53719457],"length":1,"stats":{"Line":4}},{"line":5921,"address":[55397710],"length":1,"stats":{"Line":3}},{"line":5922,"address":[55397659],"length":1,"stats":{"Line":3}},{"line":5923,"address":[54565595],"length":1,"stats":{"Line":3}},{"line":5926,"address":[53718955],"length":1,"stats":{"Line":2}},{"line":5927,"address":[55397809],"length":1,"stats":{"Line":2}},{"line":5930,"address":[55370690],"length":1,"stats":{"Line":3}},{"line":5935,"address":[55398017,55370735],"length":1,"stats":{"Line":6}},{"line":5938,"address":[55049737],"length":1,"stats":{"Line":3}},{"line":5940,"address":[55398054],"length":1,"stats":{"Line":3}},{"line":5941,"address":[54566200,54566129],"length":1,"stats":{"Line":6}},{"line":5944,"address":[53720608],"length":1,"stats":{"Line":4}},{"line":5945,"address":[53720721,53720908],"length":1,"stats":{"Line":4}},{"line":5946,"address":[55398615],"length":1,"stats":{"Line":2}},{"line":5948,"address":[53085264,53085286],"length":1,"stats":{"Line":8}},{"line":5951,"address":[54570715],"length":1,"stats":{"Line":0}},{"line":5952,"address":[54570569],"length":1,"stats":{"Line":0}},{"line":5954,"address":[54566465,54570553],"length":1,"stats":{"Line":0}},{"line":5956,"address":[54570712],"length":1,"stats":{"Line":0}},{"line":5962,"address":[54567041,54567116,54566707],"length":1,"stats":{"Line":7}},{"line":5964,"address":[55734224,55734234],"length":1,"stats":{"Line":10}},{"line":5967,"address":[53721263],"length":1,"stats":{"Line":5}},{"line":5968,"address":[55077670,55077775,55077597],"length":1,"stats":{"Line":7}},{"line":5969,"address":[55077688,55077643,55077777],"length":1,"stats":{"Line":4}},{"line":5971,"address":[55399387],"length":1,"stats":{"Line":5}},{"line":5975,"address":[54567490,54567423],"length":1,"stats":{"Line":5}},{"line":5976,"address":[54567519,54567463],"length":1,"stats":{"Line":8}},{"line":5977,"address":[54570400],"length":1,"stats":{"Line":2}},{"line":5978,"address":[55402307],"length":1,"stats":{"Line":2}},{"line":5981,"address":[54570179,54567576],"length":1,"stats":{"Line":4}},{"line":5983,"address":[55402509],"length":1,"stats":{"Line":2}},{"line":5988,"address":[53721656],"length":1,"stats":{"Line":4}},{"line":5989,"address":[55077928,55077993],"length":1,"stats":{"Line":9}},{"line":5990,"address":[55078260],"length":1,"stats":{"Line":8}},{"line":5991,"address":[54568117],"length":1,"stats":{"Line":2}},{"line":5992,"address":[54568137,54569384],"length":1,"stats":{"Line":16}},{"line":5994,"address":[54569041,54569284,54568267],"length":1,"stats":{"Line":20}},{"line":5996,"address":[55079598,55079692,55079390,55079502],"length":1,"stats":{"Line":9}},{"line":5997,"address":[55079628,55079671],"length":1,"stats":{"Line":6}},{"line":6000,"address":[55400352,55400421,55400535],"length":1,"stats":{"Line":0}},{"line":6001,"address":[53722482,53722648,53722534],"length":1,"stats":{"Line":0}},{"line":6002,"address":[55401008,55400667,55400769],"length":1,"stats":{"Line":0}},{"line":6004,"address":[54568904,54568828,54568700],"length":1,"stats":{"Line":0}},{"line":6007,"address":[55078502],"length":1,"stats":{"Line":3}},{"line":6009,"address":[55079799,55078530,55079722],"length":1,"stats":{"Line":6}},{"line":6010,"address":[54569552,54569477],"length":1,"stats":{"Line":6}},{"line":6011,"address":[54569587,54569653,54569975],"length":1,"stats":{"Line":9}},{"line":6012,"address":[53723781],"length":1,"stats":{"Line":3}},{"line":6013,"address":[53723927,53723815],"length":1,"stats":{"Line":6}},{"line":6015,"address":[53724024],"length":1,"stats":{"Line":3}},{"line":6018,"address":[55400330,55402257],"length":1,"stats":{"Line":4}},{"line":6019,"address":[55402219,55402262],"length":1,"stats":{"Line":2}},{"line":6026,"address":[54567960],"length":1,"stats":{"Line":4}},{"line":6029,"address":[53693765],"length":1,"stats":{"Line":0}},{"line":6034,"address":[53724779,53693823],"length":1,"stats":{"Line":0}},{"line":6035,"address":[53724910,53724979],"length":1,"stats":{"Line":0}},{"line":6036,"address":[54571254],"length":1,"stats":{"Line":0}},{"line":6039,"address":[55050170],"length":1,"stats":{"Line":1}},{"line":6040,"address":[55050205,55081617,55081692],"length":1,"stats":{"Line":2}},{"line":6041,"address":[54571614],"length":1,"stats":{"Line":1}},{"line":6042,"address":[55081850],"length":1,"stats":{"Line":1}},{"line":6043,"address":[55082210,55081956],"length":1,"stats":{"Line":0}},{"line":6045,"address":[54571879],"length":1,"stats":{"Line":1}},{"line":6046,"address":[55403940],"length":1,"stats":{"Line":1}},{"line":6047,"address":[55403988],"length":1,"stats":{"Line":1}},{"line":6053,"address":[55222256,55223723,55223789],"length":1,"stats":{"Line":3}},{"line":6058,"address":[53556459,53556373],"length":1,"stats":{"Line":6}},{"line":6059,"address":[53374640],"length":1,"stats":{"Line":9}},{"line":6060,"address":[54206159],"length":1,"stats":{"Line":3}},{"line":6062,"address":[55222525,55222550],"length":1,"stats":{"Line":3}},{"line":6064,"address":[54912894],"length":1,"stats":{"Line":3}},{"line":6065,"address":[55223453,55222648,55222720],"length":1,"stats":{"Line":9}},{"line":6066,"address":[54913981,54913113,54913311],"length":1,"stats":{"Line":15}},{"line":6067,"address":[54913640,54913552],"length":1,"stats":{"Line":3}},{"line":6068,"address":[55223221],"length":1,"stats":{"Line":3}},{"line":6069,"address":[54913785,54913727,54913521],"length":1,"stats":{"Line":6}},{"line":6070,"address":[54391421],"length":1,"stats":{"Line":3}},{"line":6075,"address":[55222848,55222891],"length":1,"stats":{"Line":3}},{"line":6076,"address":[54913212],"length":1,"stats":{"Line":3}},{"line":6079,"address":[55011696,55011702,55011040],"length":1,"stats":{"Line":8}},{"line":6080,"address":[55330308],"length":1,"stats":{"Line":8}},{"line":6081,"address":[55011153],"length":1,"stats":{"Line":11}},{"line":6082,"address":[55330373],"length":1,"stats":{"Line":11}},{"line":6083,"address":[55330552],"length":1,"stats":{"Line":9}},{"line":6084,"address":[55011397],"length":1,"stats":{"Line":0}},{"line":6085,"address":[53655188],"length":1,"stats":{"Line":2}},{"line":6086,"address":[54498624],"length":1,"stats":{"Line":0}},{"line":6087,"address":[54498661],"length":1,"stats":{"Line":0}},{"line":6089,"address":[54498750,54498674],"length":1,"stats":{"Line":22}},{"line":6091,"address":[53654983],"length":1,"stats":{"Line":2}},{"line":6092,"address":[54498351],"length":1,"stats":{"Line":5}},{"line":6093,"address":[54498380],"length":1,"stats":{"Line":0}},{"line":6094,"address":[55011329,55011725,55011781],"length":1,"stats":{"Line":0}},{"line":6095,"address":[55330951,55330997],"length":1,"stats":{"Line":0}},{"line":6096,"address":[54499209,54499357],"length":1,"stats":{"Line":0}},{"line":6097,"address":[53656218,53656419,53656303],"length":1,"stats":{"Line":0}},{"line":6098,"address":[55331953],"length":1,"stats":{"Line":0}},{"line":6100,"address":[55012664],"length":1,"stats":{"Line":0}},{"line":6103,"address":[54498867],"length":1,"stats":{"Line":0}},{"line":6109,"address":[55409176,55409182,55405680],"length":1,"stats":{"Line":19}},{"line":6110,"address":[54573683],"length":1,"stats":{"Line":26}},{"line":6111,"address":[55084236,55086904],"length":1,"stats":{"Line":9}},{"line":6112,"address":[55408679],"length":1,"stats":{"Line":6}},{"line":6113,"address":[55408727],"length":1,"stats":{"Line":4}},{"line":6114,"address":[53730500],"length":1,"stats":{"Line":6}},{"line":6115,"address":[53730595],"length":1,"stats":{"Line":3}},{"line":6116,"address":[55086888],"length":1,"stats":{"Line":3}},{"line":6119,"address":[55406307,55406398],"length":1,"stats":{"Line":32}},{"line":6122,"address":[55409048],"length":1,"stats":{"Line":14}},{"line":6123,"address":[53730861],"length":1,"stats":{"Line":18}},{"line":6124,"address":[55742045],"length":1,"stats":{"Line":2}},{"line":6125,"address":[53630190],"length":1,"stats":{"Line":2}},{"line":6128,"address":[53728200],"length":1,"stats":{"Line":3}},{"line":6129,"address":[54574385,54577091],"length":1,"stats":{"Line":6}},{"line":6130,"address":[53731247,53731180],"length":1,"stats":{"Line":6}},{"line":6131,"address":[55087859],"length":1,"stats":{"Line":0}},{"line":6132,"address":[54577770],"length":1,"stats":{"Line":0}},{"line":6133,"address":[53731600],"length":1,"stats":{"Line":0}},{"line":6136,"address":[55087971],"length":1,"stats":{"Line":4}},{"line":6139,"address":[55084594],"length":1,"stats":{"Line":6}},{"line":6145,"address":[54574508,54578060],"length":1,"stats":{"Line":10}},{"line":6146,"address":[54578393,54578553,54580216],"length":1,"stats":{"Line":10}},{"line":6149,"address":[55410957],"length":1,"stats":{"Line":4}},{"line":6150,"address":[54578907],"length":1,"stats":{"Line":0}},{"line":6151,"address":[54579092,54579237,54579024],"length":1,"stats":{"Line":0}},{"line":6153,"address":[53733594],"length":1,"stats":{"Line":0}},{"line":6154,"address":[53733162,53733248],"length":1,"stats":{"Line":0}},{"line":6155,"address":[55089520],"length":1,"stats":{"Line":0}},{"line":6156,"address":[55411669,55411733],"length":1,"stats":{"Line":0}},{"line":6157,"address":[55089847],"length":1,"stats":{"Line":0}},{"line":6162,"address":[55411058],"length":1,"stats":{"Line":6}},{"line":6165,"address":[55406659],"length":1,"stats":{"Line":6}},{"line":6170,"address":[55084740,55090196],"length":1,"stats":{"Line":14}},{"line":6171,"address":[55090527],"length":1,"stats":{"Line":7}},{"line":6172,"address":[54580606],"length":1,"stats":{"Line":7}},{"line":6173,"address":[55090640,55090827],"length":1,"stats":{"Line":10}},{"line":6174,"address":[54580736],"length":1,"stats":{"Line":5}},{"line":6175,"address":[55413321],"length":1,"stats":{"Line":0}},{"line":6176,"address":[55412757,55413159],"length":1,"stats":{"Line":0}},{"line":6177,"address":[54581206],"length":1,"stats":{"Line":0}},{"line":6180,"address":[55090550,55091267],"length":1,"stats":{"Line":6}},{"line":6184,"address":[54574662],"length":1,"stats":{"Line":3}},{"line":6190,"address":[53728584,53735311,53735100],"length":1,"stats":{"Line":9}},{"line":6191,"address":[53735447],"length":1,"stats":{"Line":3}},{"line":6193,"address":[54581797,54581874,54582019],"length":1,"stats":{"Line":9}},{"line":6194,"address":[53735574],"length":1,"stats":{"Line":3}},{"line":6196,"address":[55092017,55091967],"length":1,"stats":{"Line":6}},{"line":6200,"address":[55091726,55092292,55092113],"length":1,"stats":{"Line":9}},{"line":6201,"address":[53735909],"length":1,"stats":{"Line":3}},{"line":6203,"address":[55414301,55414479],"length":1,"stats":{"Line":6}},{"line":6209,"address":[55406882],"length":1,"stats":{"Line":16}},{"line":6215,"address":[54582496,54574813],"length":1,"stats":{"Line":21}},{"line":6216,"address":[53736215,53736285],"length":1,"stats":{"Line":6}},{"line":6217,"address":[53736608],"length":1,"stats":{"Line":3}},{"line":6221,"address":[55415169,55415079],"length":1,"stats":{"Line":6}},{"line":6222,"address":[55415314,55415235],"length":1,"stats":{"Line":6}},{"line":6224,"address":[55093232],"length":1,"stats":{"Line":3}},{"line":6225,"address":[54583385,54583518,54584782],"length":1,"stats":{"Line":14}},{"line":6226,"address":[55093892],"length":1,"stats":{"Line":7}},{"line":6227,"address":[54584738,54583840,54583764,54583918],"length":1,"stats":{"Line":14}},{"line":6229,"address":[55416303,55416576,55416227],"length":1,"stats":{"Line":14}},{"line":6230,"address":[55094512,55094134,55094322,55094228],"length":1,"stats":{"Line":3}},{"line":6231,"address":[55416638],"length":1,"stats":{"Line":3}},{"line":6235,"address":[55415532,55416923],"length":1,"stats":{"Line":0}},{"line":6236,"address":[55417076,55416989],"length":1,"stats":{"Line":0}},{"line":6238,"address":[55417145],"length":1,"stats":{"Line":0}},{"line":6239,"address":[53738766,53739211,53738633],"length":1,"stats":{"Line":0}},{"line":6240,"address":[55095284,55095427],"length":1,"stats":{"Line":0}},{"line":6242,"address":[53739278],"length":1,"stats":{"Line":0}},{"line":6243,"address":[53738664],"length":1,"stats":{"Line":0}},{"line":6244,"address":[55095531],"length":1,"stats":{"Line":0}},{"line":6249,"address":[53739377,53736247],"length":1,"stats":{"Line":34}},{"line":6250,"address":[53739748,53739652],"length":1,"stats":{"Line":32}},{"line":6251,"address":[53740010],"length":1,"stats":{"Line":10}},{"line":6254,"address":[55407018],"length":1,"stats":{"Line":3}},{"line":6259,"address":[53740252,53740463,53728819],"length":1,"stats":{"Line":14}},{"line":6260,"address":[55419179],"length":1,"stats":{"Line":6}},{"line":6261,"address":[55097484,55096920],"length":1,"stats":{"Line":15}},{"line":6263,"address":[53741307],"length":1,"stats":{"Line":8}},{"line":6264,"address":[55097649],"length":1,"stats":{"Line":5}},{"line":6265,"address":[54461773],"length":1,"stats":{"Line":0}},{"line":6266,"address":[53092350],"length":1,"stats":{"Line":0}},{"line":6268,"address":[55419464,55419559,55419257],"length":1,"stats":{"Line":14}},{"line":6270,"address":[54587455],"length":1,"stats":{"Line":4}},{"line":6272,"address":[53092752,53092817],"length":1,"stats":{"Line":6}},{"line":6273,"address":[54461085],"length":1,"stats":{"Line":0}},{"line":6274,"address":[54461118],"length":1,"stats":{"Line":0}},{"line":6276,"address":[55420410],"length":1,"stats":{"Line":2}},{"line":6277,"address":[55097745],"length":1,"stats":{"Line":2}},{"line":6280,"address":[53741465,53740591],"length":1,"stats":{"Line":4}},{"line":6282,"address":[53741691],"length":1,"stats":{"Line":2}},{"line":6287,"address":[55085114],"length":1,"stats":{"Line":3}},{"line":6293,"address":[55098167,55085183],"length":1,"stats":{"Line":11}},{"line":6294,"address":[53742258,53742463],"length":1,"stats":{"Line":14}},{"line":6295,"address":[55098923],"length":1,"stats":{"Line":8}},{"line":6296,"address":[55421535],"length":1,"stats":{"Line":6}},{"line":6297,"address":[55099076,55100063,55099676,55099866],"length":1,"stats":{"Line":12}},{"line":6298,"address":[55099974],"length":1,"stats":{"Line":8}},{"line":6300,"address":[55421484],"length":1,"stats":{"Line":2}},{"line":6301,"address":[55099332,55099029,55099609,55099142],"length":1,"stats":{"Line":4}},{"line":6302,"address":[53743207],"length":1,"stats":{"Line":2}},{"line":6304,"address":[55422885],"length":1,"stats":{"Line":2}},{"line":6305,"address":[53743869],"length":1,"stats":{"Line":2}},{"line":6308,"address":[53743845,53742715],"length":1,"stats":{"Line":4}},{"line":6310,"address":[53744071],"length":1,"stats":{"Line":2}},{"line":6315,"address":[55407203],"length":1,"stats":{"Line":5}},{"line":6320,"address":[53744414,53729027],"length":1,"stats":{"Line":11}},{"line":6321,"address":[55101001,55101173],"length":1,"stats":{"Line":11}},{"line":6322,"address":[55423960,55424054],"length":1,"stats":{"Line":8}},{"line":6323,"address":[54592635],"length":1,"stats":{"Line":5}},{"line":6324,"address":[55424787],"length":1,"stats":{"Line":6}},{"line":6325,"address":[55102452,55102265,55102290],"length":1,"stats":{"Line":14}},{"line":6326,"address":[55425096,55424915,55425024],"length":1,"stats":{"Line":7}},{"line":6328,"address":[55424902],"length":1,"stats":{"Line":6}},{"line":6330,"address":[55424942,55425125],"length":1,"stats":{"Line":11}},{"line":6332,"address":[53630352,53630431],"length":1,"stats":{"Line":10}},{"line":6333,"address":[53093219],"length":1,"stats":{"Line":2}},{"line":6334,"address":[55742158],"length":1,"stats":{"Line":2}},{"line":6335,"address":[53093270],"length":1,"stats":{"Line":2}},{"line":6338,"address":[55424110],"length":1,"stats":{"Line":2}},{"line":6339,"address":[55424196,55424166,55424344],"length":1,"stats":{"Line":6}},{"line":6340,"address":[53745457,53745355,53745491],"length":1,"stats":{"Line":4}},{"line":6342,"address":[53745334],"length":1,"stats":{"Line":2}},{"line":6344,"address":[55424229,55424383,55424660],"length":1,"stats":{"Line":6}},{"line":6345,"address":[55424438],"length":1,"stats":{"Line":2}},{"line":6346,"address":[55424479],"length":1,"stats":{"Line":6}},{"line":6347,"address":[54592512,54592556],"length":1,"stats":{"Line":4}},{"line":6348,"address":[55424522],"length":1,"stats":{"Line":2}},{"line":6349,"address":[55424533],"length":1,"stats":{"Line":2}},{"line":6350,"address":[54592509],"length":1,"stats":{"Line":2}},{"line":6353,"address":[54593215,54593332],"length":1,"stats":{"Line":6}},{"line":6355,"address":[53746612],"length":1,"stats":{"Line":4}},{"line":6357,"address":[54461505,54461440],"length":1,"stats":{"Line":3}},{"line":6358,"address":[53092429],"length":1,"stats":{"Line":0}},{"line":6359,"address":[55741822],"length":1,"stats":{"Line":0}},{"line":6361,"address":[53747015],"length":1,"stats":{"Line":0}},{"line":6362,"address":[55425765],"length":1,"stats":{"Line":0}},{"line":6364,"address":[54591904,54593562],"length":1,"stats":{"Line":0}},{"line":6365,"address":[55103007],"length":1,"stats":{"Line":0}},{"line":6367,"address":[55425967],"length":1,"stats":{"Line":0}},{"line":6372,"address":[54575252],"length":1,"stats":{"Line":4}},{"line":6378,"address":[54593995,54575275],"length":1,"stats":{"Line":7}},{"line":6379,"address":[53747481,53747653,53751356],"length":1,"stats":{"Line":11}},{"line":6380,"address":[55426892,55427052],"length":1,"stats":{"Line":8}},{"line":6382,"address":[55427280,55427358],"length":1,"stats":{"Line":10}},{"line":6383,"address":[55427397],"length":1,"stats":{"Line":6}},{"line":6384,"address":[54595393,54595325],"length":1,"stats":{"Line":12}},{"line":6385,"address":[54595492,54595660,54595467],"length":1,"stats":{"Line":12}},{"line":6386,"address":[55104962,55104879,55105030],"length":1,"stats":{"Line":4}},{"line":6388,"address":[55427593],"length":1,"stats":{"Line":5}},{"line":6390,"address":[54595521,54595786,54595686],"length":1,"stats":{"Line":18}},{"line":6391,"address":[53749393],"length":1,"stats":{"Line":0}},{"line":6392,"address":[55427849],"length":1,"stats":{"Line":0}},{"line":6393,"address":[55105117,55105603],"length":1,"stats":{"Line":0}},{"line":6394,"address":[55105650],"length":1,"stats":{"Line":0}},{"line":6397,"address":[53748973,53749075,53748935,53749325],"length":1,"stats":{"Line":7}},{"line":6398,"address":[54596131],"length":1,"stats":{"Line":7}},{"line":6400,"address":[54596491],"length":1,"stats":{"Line":2}},{"line":6401,"address":[55428942,55428643,55429217,55428740],"length":1,"stats":{"Line":5}},{"line":6402,"address":[53749997],"length":1,"stats":{"Line":2}},{"line":6404,"address":[53749602],"length":1,"stats":{"Line":2}},{"line":6406,"address":[53750151,53749658],"length":1,"stats":{"Line":4}},{"line":6407,"address":[55429423,55429355,55429631,55429917],"length":1,"stats":{"Line":4}},{"line":6408,"address":[54597665],"length":1,"stats":{"Line":2}},{"line":6410,"address":[54598161],"length":1,"stats":{"Line":0}},{"line":6411,"address":[54597956],"length":1,"stats":{"Line":0}},{"line":6413,"address":[54595208,54597865],"length":1,"stats":{"Line":0}},{"line":6414,"address":[55429993],"length":1,"stats":{"Line":0}},{"line":6416,"address":[55430270],"length":1,"stats":{"Line":0}},{"line":6421,"address":[54575314],"length":1,"stats":{"Line":2}},{"line":6428,"address":[55085552,55107626],"length":1,"stats":{"Line":7}},{"line":6431,"address":[53751713,53751790],"length":1,"stats":{"Line":7}},{"line":6432,"address":[53751979,53751803,53751755,53752569],"length":1,"stats":{"Line":12}},{"line":6433,"address":[54599278],"length":1,"stats":{"Line":4}},{"line":6434,"address":[54599292],"length":1,"stats":{"Line":4}},{"line":6436,"address":[53752437],"length":1,"stats":{"Line":0}},{"line":6437,"address":[55431459],"length":1,"stats":{"Line":0}},{"line":6438,"address":[55108694],"length":1,"stats":{"Line":0}},{"line":6443,"address":[54598809],"length":1,"stats":{"Line":3}},{"line":6447,"address":[54599386,54599631,54599674],"length":1,"stats":{"Line":12}},{"line":6448,"address":[55432497,55431751,55431799],"length":1,"stats":{"Line":10}},{"line":6449,"address":[53752998],"length":1,"stats":{"Line":4}},{"line":6450,"address":[55432184],"length":1,"stats":{"Line":4}},{"line":6452,"address":[55432376],"length":1,"stats":{"Line":0}},{"line":6453,"address":[54600127],"length":1,"stats":{"Line":0}},{"line":6454,"address":[55109453],"length":1,"stats":{"Line":0}},{"line":6459,"address":[53752610],"length":1,"stats":{"Line":3}},{"line":6463,"address":[54600398,54600441,54600166],"length":1,"stats":{"Line":10}},{"line":6464,"address":[53754214,53753382,53753334],"length":1,"stats":{"Line":4}},{"line":6465,"address":[54600825],"length":1,"stats":{"Line":2}},{"line":6466,"address":[53753759],"length":1,"stats":{"Line":2}},{"line":6467,"address":[53753783],"length":1,"stats":{"Line":2}},{"line":6468,"address":[53753949],"length":1,"stats":{"Line":2}},{"line":6469,"address":[55433017],"length":1,"stats":{"Line":2}},{"line":6470,"address":[55433146],"length":1,"stats":{"Line":2}},{"line":6473,"address":[53753864],"length":1,"stats":{"Line":2}},{"line":6476,"address":[55433327],"length":1,"stats":{"Line":0}},{"line":6477,"address":[54600871],"length":1,"stats":{"Line":0}},{"line":6478,"address":[55110380],"length":1,"stats":{"Line":0}},{"line":6483,"address":[55432541],"length":1,"stats":{"Line":4}},{"line":6486,"address":[55110313],"length":1,"stats":{"Line":4}},{"line":6487,"address":[53754345],"length":1,"stats":{"Line":5}},{"line":6488,"address":[55433577,55435499],"length":1,"stats":{"Line":8}},{"line":6489,"address":[55435644,55435565],"length":1,"stats":{"Line":8}},{"line":6492,"address":[53756731,53756411,53756890],"length":1,"stats":{"Line":9}},{"line":6493,"address":[55435732,55436075],"length":1,"stats":{"Line":9}},{"line":6494,"address":[53756815],"length":1,"stats":{"Line":5}},{"line":6495,"address":[55436142],"length":1,"stats":{"Line":4}},{"line":6498,"address":[55112790,55112690],"length":1,"stats":{"Line":4}},{"line":6499,"address":[54603686],"length":1,"stats":{"Line":2}},{"line":6500,"address":[54603871],"length":1,"stats":{"Line":2}},{"line":6504,"address":[53757106,53756779],"length":1,"stats":{"Line":7}},{"line":6505,"address":[54604214,54604094],"length":1,"stats":{"Line":4}},{"line":6507,"address":[55436232,55436163],"length":1,"stats":{"Line":6}},{"line":6510,"address":[53757034],"length":1,"stats":{"Line":2}},{"line":6511,"address":[55113534,55113419],"length":1,"stats":{"Line":4}},{"line":6513,"address":[55436388,55436461],"length":1,"stats":{"Line":6}},{"line":6516,"address":[54604419],"length":1,"stats":{"Line":4}},{"line":6517,"address":[55113599],"length":1,"stats":{"Line":2}},{"line":6518,"address":[53757360],"length":1,"stats":{"Line":3}},{"line":6519,"address":[55114430,55113652,55114072],"length":1,"stats":{"Line":11}},{"line":6520,"address":[53757840],"length":1,"stats":{"Line":4}},{"line":6521,"address":[55114303],"length":1,"stats":{"Line":5}},{"line":6523,"address":[55437516,55437326,55437503],"length":1,"stats":{"Line":9}},{"line":6527,"address":[54604530],"length":1,"stats":{"Line":2}},{"line":6528,"address":[54604546,54604657,54604985,54604569],"length":1,"stats":{"Line":8}},{"line":6529,"address":[55113752,55113840],"length":1,"stats":{"Line":4}},{"line":6530,"address":[53757643],"length":1,"stats":{"Line":2}},{"line":6532,"address":[55114051,55113876,55114038],"length":1,"stats":{"Line":4}},{"line":6535,"address":[53757865,53757399],"length":1,"stats":{"Line":7}},{"line":6537,"address":[55433482],"length":1,"stats":{"Line":3}},{"line":6538,"address":[55110582,55110715],"length":1,"stats":{"Line":4}},{"line":6539,"address":[55433804,55433725],"length":1,"stats":{"Line":4}},{"line":6542,"address":[55434132,55433812,55434291],"length":1,"stats":{"Line":6}},{"line":6543,"address":[55434208,55433865],"length":1,"stats":{"Line":4}},{"line":6544,"address":[53754996],"length":1,"stats":{"Line":2}},{"line":6545,"address":[54602163],"length":1,"stats":{"Line":2}},{"line":6548,"address":[55110863,55110963],"length":1,"stats":{"Line":4}},{"line":6549,"address":[54601819],"length":1,"stats":{"Line":2}},{"line":6550,"address":[54602004],"length":1,"stats":{"Line":2}},{"line":6554,"address":[55111528,55111220],"length":1,"stats":{"Line":4}},{"line":6555,"address":[55111375,55111468],"length":1,"stats":{"Line":4}},{"line":6557,"address":[53755149,53755084],"length":1,"stats":{"Line":4}},{"line":6560,"address":[53755192],"length":1,"stats":{"Line":3}},{"line":6561,"address":[55111569,55111661],"length":1,"stats":{"Line":4}},{"line":6563,"address":[53755274,53755339],"length":1,"stats":{"Line":8}},{"line":6566,"address":[55434614],"length":1,"stats":{"Line":2}},{"line":6567,"address":[55434694],"length":1,"stats":{"Line":5}},{"line":6568,"address":[53755487],"length":1,"stats":{"Line":2}},{"line":6569,"address":[54603059,54603309,54602627],"length":1,"stats":{"Line":17}},{"line":6570,"address":[53755971],"length":1,"stats":{"Line":6}},{"line":6571,"address":[54603217],"length":1,"stats":{"Line":6}},{"line":6573,"address":[53756054,53756165,53756178],"length":1,"stats":{"Line":8}},{"line":6577,"address":[53755469],"length":1,"stats":{"Line":2}},{"line":6578,"address":[53755901,53755663,53755508,53755485],"length":1,"stats":{"Line":8}},{"line":6579,"address":[53755678,53755777],"length":1,"stats":{"Line":4}},{"line":6580,"address":[55112081],"length":1,"stats":{"Line":2}},{"line":6582,"address":[53755782,53755893,53755906],"length":1,"stats":{"Line":4}},{"line":6585,"address":[55434774],"length":1,"stats":{"Line":6}},{"line":6587,"address":[55437737],"length":1,"stats":{"Line":0}},{"line":6588,"address":[55433444,55437575],"length":1,"stats":{"Line":0}},{"line":6589,"address":[53758373],"length":1,"stats":{"Line":0}},{"line":6594,"address":[55085591],"length":1,"stats":{"Line":4}},{"line":6595,"address":[55407592],"length":1,"stats":{"Line":4}},{"line":6596,"address":[55085640,55114922],"length":1,"stats":{"Line":8}},{"line":6598,"address":[54607725,54606276,54606018],"length":1,"stats":{"Line":17}},{"line":6599,"address":[54608021,54606380,54606314],"length":1,"stats":{"Line":18}},{"line":6600,"address":[55115701],"length":1,"stats":{"Line":9}},{"line":6601,"address":[54606848],"length":1,"stats":{"Line":7}},{"line":6602,"address":[55115878,55116430],"length":1,"stats":{"Line":14}},{"line":6604,"address":[55115775],"length":1,"stats":{"Line":2}},{"line":6606,"address":[55438937,55439074],"length":1,"stats":{"Line":4}},{"line":6607,"address":[55116134,55116307],"length":1,"stats":{"Line":4}},{"line":6611,"address":[55439861],"length":1,"stats":{"Line":0}},{"line":6612,"address":[55115741],"length":1,"stats":{"Line":0}},{"line":6613,"address":[55116700],"length":1,"stats":{"Line":0}},{"line":6618,"address":[55115368,55117007],"length":1,"stats":{"Line":8}},{"line":6621,"address":[55438186],"length":1,"stats":{"Line":4}},{"line":6624,"address":[54575551],"length":1,"stats":{"Line":3}},{"line":6625,"address":[55085694],"length":1,"stats":{"Line":3}},{"line":6626,"address":[55085723,55117283,55118672],"length":1,"stats":{"Line":9}},{"line":6627,"address":[55442066,55440620,55440840],"length":1,"stats":{"Line":6}},{"line":6628,"address":[55117885,55117953],"length":1,"stats":{"Line":6}},{"line":6629,"address":[55441436],"length":1,"stats":{"Line":3}},{"line":6630,"address":[55118235],"length":1,"stats":{"Line":3}},{"line":6631,"address":[55441556,55441745],"length":1,"stats":{"Line":0}},{"line":6633,"address":[53762091,53762359],"length":1,"stats":{"Line":6}},{"line":6635,"address":[53761163],"length":1,"stats":{"Line":3}},{"line":6638,"address":[55085757],"length":1,"stats":{"Line":3}},{"line":6644,"address":[55085818,55118850],"length":1,"stats":{"Line":6}},{"line":6645,"address":[55442431,55442591],"length":1,"stats":{"Line":6}},{"line":6646,"address":[55119660,55119557],"length":1,"stats":{"Line":6}},{"line":6647,"address":[55119817],"length":1,"stats":{"Line":3}},{"line":6648,"address":[55120087],"length":1,"stats":{"Line":0}},{"line":6649,"address":[54610937],"length":1,"stats":{"Line":0}},{"line":6650,"address":[55120012],"length":1,"stats":{"Line":0}},{"line":6655,"address":[55443510,55407854],"length":1,"stats":{"Line":6}},{"line":6657,"address":[55085949],"length":1,"stats":{"Line":3}},{"line":6663,"address":[54575896,54575854],"length":1,"stats":{"Line":6}},{"line":6665,"address":[55407996],"length":1,"stats":{"Line":9}},{"line":6666,"address":[53092659],"length":1,"stats":{"Line":3}},{"line":6667,"address":[53092682],"length":1,"stats":{"Line":3}},{"line":6673,"address":[53764077,53729772],"length":1,"stats":{"Line":7}},{"line":6674,"address":[53764085],"length":1,"stats":{"Line":3}},{"line":6675,"address":[55443707,55443895,55443779,55443996,55444632],"length":1,"stats":{"Line":10}},{"line":6676,"address":[53764371,53764223],"length":1,"stats":{"Line":7}},{"line":6677,"address":[53764405],"length":1,"stats":{"Line":4}},{"line":6679,"address":[54612208],"length":1,"stats":{"Line":3}},{"line":6681,"address":[53764911],"length":1,"stats":{"Line":3}},{"line":6684,"address":[55086078],"length":1,"stats":{"Line":8}},{"line":6685,"address":[54575991,54576039],"length":1,"stats":{"Line":14}},{"line":6688,"address":[54612702],"length":1,"stats":{"Line":6}},{"line":6689,"address":[53629687],"length":1,"stats":{"Line":0}},{"line":6690,"address":[53093068],"length":1,"stats":{"Line":0}},{"line":6694,"address":[55408189],"length":1,"stats":{"Line":0}},{"line":6695,"address":[53765251,53729931],"length":1,"stats":{"Line":0}},{"line":6696,"address":[55121802,55121849],"length":1,"stats":{"Line":0}},{"line":6697,"address":[54613149],"length":1,"stats":{"Line":0}},{"line":6699,"address":[54613245],"length":1,"stats":{"Line":0}},{"line":6700,"address":[55122293,55122088,55122017,55122186],"length":1,"stats":{"Line":0}},{"line":6701,"address":[55122096],"length":1,"stats":{"Line":0}},{"line":6702,"address":[53765953,53765887],"length":1,"stats":{"Line":0}},{"line":6704,"address":[55122342],"length":1,"stats":{"Line":0}},{"line":6707,"address":[53729970],"length":1,"stats":{"Line":3}},{"line":6708,"address":[55086254],"length":1,"stats":{"Line":3}},{"line":6709,"address":[55122628,55086267],"length":1,"stats":{"Line":9}},{"line":6710,"address":[55446094],"length":1,"stats":{"Line":5}},{"line":6711,"address":[55122988],"length":1,"stats":{"Line":6}},{"line":6712,"address":[55122947],"length":1,"stats":{"Line":5}},{"line":6713,"address":[53766686,53766779],"length":1,"stats":{"Line":11}},{"line":6714,"address":[54614609,54614688],"length":1,"stats":{"Line":11}},{"line":6718,"address":[55122778],"length":1,"stats":{"Line":5}},{"line":6723,"address":[54576268,54576210],"length":1,"stats":{"Line":0}},{"line":6724,"address":[55086313],"length":1,"stats":{"Line":0}},{"line":6725,"address":[55086355],"length":1,"stats":{"Line":0}},{"line":6729,"address":[54576367],"length":1,"stats":{"Line":3}},{"line":6730,"address":[54576428,54614846],"length":1,"stats":{"Line":5}},{"line":6731,"address":[55447299,55447444],"length":1,"stats":{"Line":5}},{"line":6733,"address":[55448082,55447672,55447742],"length":1,"stats":{"Line":2}},{"line":6736,"address":[54576467],"length":1,"stats":{"Line":3}},{"line":6743,"address":[54616076,54576528],"length":1,"stats":{"Line":6}},{"line":6744,"address":[55448520,55448449],"length":1,"stats":{"Line":6}},{"line":6745,"address":[53768993,53768864],"length":1,"stats":{"Line":6}},{"line":6747,"address":[54616477,54616422],"length":1,"stats":{"Line":10}},{"line":6753,"address":[54616672,54620550,54620544],"length":1,"stats":{"Line":4}},{"line":6760,"address":[55448863],"length":1,"stats":{"Line":6}},{"line":6761,"address":[54616796,54617574,54619831],"length":1,"stats":{"Line":9}},{"line":6762,"address":[54617761],"length":1,"stats":{"Line":3}},{"line":6763,"address":[53770617],"length":1,"stats":{"Line":3}},{"line":6764,"address":[54617900],"length":1,"stats":{"Line":2}},{"line":6765,"address":[53770471],"length":1,"stats":{"Line":0}},{"line":6766,"address":[55127026],"length":1,"stats":{"Line":4}},{"line":6767,"address":[55450828],"length":1,"stats":{"Line":0}},{"line":6768,"address":[55128150],"length":1,"stats":{"Line":0}},{"line":6769,"address":[55128542],"length":1,"stats":{"Line":3}},{"line":6770,"address":[54619892],"length":1,"stats":{"Line":3}},{"line":6771,"address":[53772503],"length":1,"stats":{"Line":3}},{"line":6772,"address":[53772714],"length":1,"stats":{"Line":3}},{"line":6774,"address":[53771771],"length":1,"stats":{"Line":0}},{"line":6775,"address":[55127757],"length":1,"stats":{"Line":0}},{"line":6780,"address":[55453081,55449005],"length":1,"stats":{"Line":6}},{"line":6781,"address":[55129683],"length":1,"stats":{"Line":3}},{"line":6782,"address":[53773842],"length":1,"stats":{"Line":3}},{"line":6783,"address":[53773550],"length":1,"stats":{"Line":0}},{"line":6784,"address":[54621352],"length":1,"stats":{"Line":0}},{"line":6785,"address":[55129486],"length":1,"stats":{"Line":0}},{"line":6786,"address":[53772986],"length":1,"stats":{"Line":0}},{"line":6788,"address":[54620582],"length":1,"stats":{"Line":0}},{"line":6789,"address":[54620612],"length":1,"stats":{"Line":0}},{"line":6795,"address":[54622006,54622943,54616970],"length":1,"stats":{"Line":9}},{"line":6796,"address":[55130761],"length":1,"stats":{"Line":3}},{"line":6797,"address":[53775124],"length":1,"stats":{"Line":3}},{"line":6798,"address":[55454398],"length":1,"stats":{"Line":0}},{"line":6799,"address":[55454748],"length":1,"stats":{"Line":0}},{"line":6800,"address":[55131533,55131046],"length":1,"stats":{"Line":5}},{"line":6801,"address":[53774798],"length":1,"stats":{"Line":3}},{"line":6803,"address":[53774249],"length":1,"stats":{"Line":0}},{"line":6804,"address":[53774021],"length":1,"stats":{"Line":0}},{"line":6806,"address":[53773963],"length":1,"stats":{"Line":0}},{"line":6807,"address":[55130264],"length":1,"stats":{"Line":0}},{"line":6815,"address":[53775355,53769483],"length":1,"stats":{"Line":6}},{"line":6816,"address":[55455227],"length":1,"stats":{"Line":2}},{"line":6817,"address":[55131644],"length":1,"stats":{"Line":3}},{"line":6818,"address":[55455286],"length":1,"stats":{"Line":2}},{"line":6822,"address":[55455060,55455713],"length":1,"stats":{"Line":6}},{"line":6823,"address":[55455802],"length":1,"stats":{"Line":3}},{"line":6824,"address":[55456215],"length":1,"stats":{"Line":4}},{"line":6825,"address":[55132435],"length":1,"stats":{"Line":0}},{"line":6826,"address":[55456075],"length":1,"stats":{"Line":2}},{"line":6827,"address":[54623505],"length":1,"stats":{"Line":0}},{"line":6828,"address":[55455389],"length":1,"stats":{"Line":0}},{"line":6830,"address":[53775559],"length":1,"stats":{"Line":0}},{"line":6831,"address":[54623247],"length":1,"stats":{"Line":0}},{"line":6839,"address":[54617120,54624224],"length":1,"stats":{"Line":6}},{"line":6840,"address":[53776657],"length":1,"stats":{"Line":2}},{"line":6842,"address":[55132851,55133354],"length":1,"stats":{"Line":6}},{"line":6843,"address":[55456903],"length":1,"stats":{"Line":3}},{"line":6844,"address":[54624924],"length":1,"stats":{"Line":3}},{"line":6845,"address":[55456760],"length":1,"stats":{"Line":0}},{"line":6846,"address":[54624420],"length":1,"stats":{"Line":0}},{"line":6848,"address":[53776700],"length":1,"stats":{"Line":0}},{"line":6849,"address":[55133001],"length":1,"stats":{"Line":0}},{"line":6856,"address":[54617146],"length":1,"stats":{"Line":3}},{"line":6857,"address":[55125943],"length":1,"stats":{"Line":3}},{"line":6859,"address":[55126076],"length":1,"stats":{"Line":14}},{"line":6860,"address":[53630748,53630897,53630880,53630720],"length":1,"stats":{"Line":12}},{"line":6861,"address":[53630609,53630656,53630684,53630592],"length":1,"stats":{"Line":12}},{"line":6862,"address":[55742929,55742912,55743008,55743036],"length":1,"stats":{"Line":9}},{"line":6866,"address":[54461038,54459374,54456064,54457728,54454400,54456046,54457710,54459392],"length":1,"stats":{"Line":14}},{"line":6878,"address":[54456140,54459558,54454476,54457894,54454566,54457804,54459468,54456230],"length":1,"stats":{"Line":28}},{"line":6879,"address":[53623180,53624844,53628172,53626508,53628348,53626684,53623356,53625020],"length":1,"stats":{"Line":28}},{"line":6880,"address":[55740778,55740617,55737450,55735625,55735786,55739114,55738953,55737289],"length":1,"stats":{"Line":6}},{"line":6881,"address":[],"length":0,"stats":{"Line":0}},{"line":6882,"address":[],"length":0,"stats":{"Line":0}},{"line":6883,"address":[],"length":0,"stats":{"Line":3}},{"line":6884,"address":[53087163,53090491,53088827,53092155],"length":1,"stats":{"Line":0}},{"line":6885,"address":[],"length":0,"stats":{"Line":0}},{"line":6886,"address":[],"length":0,"stats":{"Line":0}},{"line":6887,"address":[],"length":0,"stats":{"Line":0}},{"line":6888,"address":[54459015,54455687,54457351,54460679],"length":1,"stats":{"Line":0}},{"line":6890,"address":[],"length":0,"stats":{"Line":0}},{"line":6908,"address":[55038912],"length":1,"stats":{"Line":0}},{"line":6909,"address":[55359591],"length":1,"stats":{"Line":0}},{"line":6910,"address":[55038970],"length":1,"stats":{"Line":0}},{"line":6911,"address":[55038997],"length":1,"stats":{"Line":0}},{"line":6912,"address":[55039024],"length":1,"stats":{"Line":0}},{"line":6913,"address":[55039051],"length":1,"stats":{"Line":0}},{"line":6914,"address":[54527622],"length":1,"stats":{"Line":0}},{"line":6915,"address":[55039105],"length":1,"stats":{"Line":0}},{"line":6916,"address":[55359785],"length":1,"stats":{"Line":0}},{"line":6917,"address":[53682897],"length":1,"stats":{"Line":0}},{"line":6918,"address":[54527721],"length":1,"stats":{"Line":0}},{"line":6919,"address":[53682945],"length":1,"stats":{"Line":0}},{"line":6920,"address":[54527769],"length":1,"stats":{"Line":0}},{"line":6925,"address":[55362832,55365399,55365859],"length":1,"stats":{"Line":0}},{"line":6933,"address":[55042255,55042127],"length":1,"stats":{"Line":0}},{"line":6934,"address":[55365632],"length":1,"stats":{"Line":0}},{"line":6935,"address":[55044529,55042349],"length":1,"stats":{"Line":0}},{"line":6936,"address":[54533444,54533371],"length":1,"stats":{"Line":0}},{"line":6937,"address":[55044648],"length":1,"stats":{"Line":0}},{"line":6943,"address":[55042326,55042375],"length":1,"stats":{"Line":0}},{"line":6944,"address":[54531125,54531183],"length":1,"stats":{"Line":0}},{"line":6946,"address":[53686347,53686200],"length":1,"stats":{"Line":0}},{"line":6948,"address":[54531204,54531324],"length":1,"stats":{"Line":0}},{"line":6951,"address":[55042667,55042777],"length":1,"stats":{"Line":0}},{"line":6953,"address":[54531544],"length":1,"stats":{"Line":0}},{"line":6956,"address":[53688218,53686972,53686717],"length":1,"stats":{"Line":0}},{"line":6957,"address":[54532084,54533030],"length":1,"stats":{"Line":0}},{"line":6961,"address":[53687106],"length":1,"stats":{"Line":0}},{"line":6963,"address":[53687286,53687201],"length":1,"stats":{"Line":0}},{"line":6964,"address":[55043630],"length":1,"stats":{"Line":0}},{"line":6965,"address":[54532580],"length":1,"stats":{"Line":0}},{"line":6966,"address":[55364824],"length":1,"stats":{"Line":0}},{"line":6967,"address":[55044004],"length":1,"stats":{"Line":0}},{"line":6968,"address":[53687229],"length":1,"stats":{"Line":0}},{"line":6973,"address":[53678832,53680130,53680559],"length":1,"stats":{"Line":18}},{"line":6974,"address":[55035152],"length":1,"stats":{"Line":14}},{"line":6975,"address":[55035250,55035183],"length":1,"stats":{"Line":32}},{"line":6976,"address":[55355997,55356890,55355831],"length":1,"stats":{"Line":22}},{"line":6977,"address":[55357121,55356032,55356086],"length":1,"stats":{"Line":4}},{"line":6978,"address":[53679709],"length":1,"stats":{"Line":2}},{"line":6979,"address":[54524355],"length":1,"stats":{"Line":2}},{"line":6980,"address":[53679755,53679846],"length":1,"stats":{"Line":4}},{"line":6983,"address":[55036405],"length":1,"stats":{"Line":0}},{"line":6984,"address":[55356515],"length":1,"stats":{"Line":0}},{"line":6985,"address":[53680146],"length":1,"stats":{"Line":0}},{"line":6990,"address":[53679335,53680361],"length":1,"stats":{"Line":19}},{"line":6993,"address":[53679152],"length":1,"stats":{"Line":8}},{"line":6996,"address":[53541232,53545973,53542077],"length":1,"stats":{"Line":8}},{"line":6997,"address":[55206503],"length":1,"stats":{"Line":10}},{"line":6998,"address":[53541941,53541508],"length":1,"stats":{"Line":3}},{"line":6999,"address":[55206770],"length":1,"stats":{"Line":8}},{"line":7000,"address":[54374670,54375243],"length":1,"stats":{"Line":24}},{"line":7001,"address":[53542540],"length":1,"stats":{"Line":0}},{"line":7002,"address":[54898439,54898612],"length":1,"stats":{"Line":0}},{"line":7003,"address":[55207741,55207654],"length":1,"stats":{"Line":0}},{"line":7004,"address":[53542493],"length":1,"stats":{"Line":0}},{"line":7008,"address":[55207477,55207404],"length":1,"stats":{"Line":31}},{"line":7011,"address":[55206961,55206642],"length":1,"stats":{"Line":6}},{"line":7012,"address":[55207007],"length":1,"stats":{"Line":3}},{"line":7014,"address":[54374700],"length":1,"stats":{"Line":5}},{"line":7016,"address":[53541620,53542745],"length":1,"stats":{"Line":10}},{"line":7019,"address":[54376065,54375986],"length":1,"stats":{"Line":14}},{"line":7020,"address":[54899541],"length":1,"stats":{"Line":4}},{"line":7021,"address":[54376326,54377513,54376159],"length":1,"stats":{"Line":8}},{"line":7023,"address":[53543707,53543450,53543386],"length":1,"stats":{"Line":12}},{"line":7024,"address":[55209581,55209070,55208882],"length":1,"stats":{"Line":5}},{"line":7025,"address":[55209124],"length":1,"stats":{"Line":5}},{"line":7028,"address":[54899246],"length":1,"stats":{"Line":3}},{"line":7030,"address":[55206870],"length":1,"stats":{"Line":5}},{"line":7032,"address":[53544292,53541666],"length":1,"stats":{"Line":12}},{"line":7033,"address":[53545361],"length":1,"stats":{"Line":0}},{"line":7034,"address":[54378559,54377665],"length":1,"stats":{"Line":0}},{"line":7035,"address":[54378585,54378658],"length":1,"stats":{"Line":0}},{"line":7036,"address":[54378686],"length":1,"stats":{"Line":0}},{"line":7041,"address":[55209758],"length":1,"stats":{"Line":7}},{"line":7042,"address":[55210138,55209804,55209882,55210617],"length":1,"stats":{"Line":24}},{"line":7043,"address":[55210221,55210507],"length":1,"stats":{"Line":12}},{"line":7047,"address":[54901066],"length":1,"stats":{"Line":5}},{"line":7049,"address":[53545769],"length":1,"stats":{"Line":0}},{"line":7050,"address":[54379029,54374500],"length":1,"stats":{"Line":0}},{"line":7057,"address":[53659493,53678642,53656592],"length":1,"stats":{"Line":3}},{"line":7063,"address":[55012995],"length":1,"stats":{"Line":3}},{"line":7065,"address":[54500387,54500464],"length":1,"stats":{"Line":6}},{"line":7066,"address":[55013396,55032715],"length":1,"stats":{"Line":6}},{"line":7067,"address":[55034787],"length":1,"stats":{"Line":0}},{"line":7068,"address":[55032752],"length":1,"stats":{"Line":0}},{"line":7070,"address":[55355151],"length":1,"stats":{"Line":0}},{"line":7074,"address":[55353115,55353049],"length":1,"stats":{"Line":6}},{"line":7075,"address":[54521017,54521084],"length":1,"stats":{"Line":6}},{"line":7077,"address":[55034613],"length":1,"stats":{"Line":0}},{"line":7078,"address":[53676573],"length":1,"stats":{"Line":0}},{"line":7083,"address":[55033036,55033114],"length":1,"stats":{"Line":6}},{"line":7084,"address":[53676873],"length":1,"stats":{"Line":3}},{"line":7085,"address":[54521537,54521421,54521672,54522715],"length":1,"stats":{"Line":12}},{"line":7086,"address":[55354144,55354948,55353867],"length":1,"stats":{"Line":6}},{"line":7087,"address":[53678041],"length":1,"stats":{"Line":3}},{"line":7089,"address":[54521784],"length":1,"stats":{"Line":3}},{"line":7093,"address":[55013362,55013421],"length":1,"stats":{"Line":6}},{"line":7094,"address":[55013477,55030439],"length":1,"stats":{"Line":6}},{"line":7095,"address":[55032596],"length":1,"stats":{"Line":0}},{"line":7096,"address":[55350660],"length":1,"stats":{"Line":0}},{"line":7098,"address":[55032519],"length":1,"stats":{"Line":0}},{"line":7102,"address":[54518518,54518590],"length":1,"stats":{"Line":6}},{"line":7103,"address":[55030538,55030607],"length":1,"stats":{"Line":6}},{"line":7105,"address":[55352736],"length":1,"stats":{"Line":0}},{"line":7106,"address":[55350750],"length":1,"stats":{"Line":0}},{"line":7111,"address":[53674609,53674531],"length":1,"stats":{"Line":6}},{"line":7112,"address":[55030880],"length":1,"stats":{"Line":3}},{"line":7113,"address":[55030924,55031033,55031160,55032218],"length":1,"stats":{"Line":12}},{"line":7114,"address":[55031488,55031243,55032327],"length":1,"stats":{"Line":6}},{"line":7115,"address":[54520267,54520196],"length":1,"stats":{"Line":6}},{"line":7116,"address":[55352404],"length":1,"stats":{"Line":3}},{"line":7119,"address":[55031268],"length":1,"stats":{"Line":3}},{"line":7123,"address":[55013443,55013502],"length":1,"stats":{"Line":6}},{"line":7124,"address":[55013558,55028216],"length":1,"stats":{"Line":6}},{"line":7125,"address":[55350497],"length":1,"stats":{"Line":0}},{"line":7126,"address":[53672000],"length":1,"stats":{"Line":0}},{"line":7128,"address":[55350410],"length":1,"stats":{"Line":0}},{"line":7132,"address":[54516267,54516195],"length":1,"stats":{"Line":6}},{"line":7133,"address":[54516284,54516357],"length":1,"stats":{"Line":6}},{"line":7135,"address":[55030138],"length":1,"stats":{"Line":0}},{"line":7136,"address":[55028342],"length":1,"stats":{"Line":0}},{"line":7141,"address":[53672314,53672398],"length":1,"stats":{"Line":6}},{"line":7142,"address":[55028677,55028758],"length":1,"stats":{"Line":6}},{"line":7143,"address":[54516766,54518023,54517012,54516877],"length":1,"stats":{"Line":12}},{"line":7144,"address":[55030058,55029078,55029259],"length":1,"stats":{"Line":6}},{"line":7146,"address":[53672855],"length":1,"stats":{"Line":3}},{"line":7150,"address":[55332768,55332831],"length":1,"stats":{"Line":4}},{"line":7151,"address":[55346300,55332887],"length":1,"stats":{"Line":0}},{"line":7152,"address":[55028097],"length":1,"stats":{"Line":0}},{"line":7153,"address":[54514232],"length":1,"stats":{"Line":0}},{"line":7155,"address":[55028014],"length":1,"stats":{"Line":0}},{"line":7159,"address":[55026401,55026333],"length":1,"stats":{"Line":0}},{"line":7160,"address":[53670162,53670231],"length":1,"stats":{"Line":0}},{"line":7162,"address":[53671659],"length":1,"stats":{"Line":0}},{"line":7163,"address":[55346434],"length":1,"stats":{"Line":0}},{"line":7168,"address":[55026673,55026757],"length":1,"stats":{"Line":0}},{"line":7169,"address":[55026764,55026867,55027789,55026994],"length":1,"stats":{"Line":0}},{"line":7170,"address":[55347255,55347906,55347106],"length":1,"stats":{"Line":0}},{"line":7172,"address":[54515031],"length":1,"stats":{"Line":0}},{"line":7176,"address":[55332853,55332916],"length":1,"stats":{"Line":4}},{"line":7177,"address":[53657464,53667922],"length":1,"stats":{"Line":4}},{"line":7178,"address":[55026200],"length":1,"stats":{"Line":0}},{"line":7179,"address":[53667962],"length":1,"stats":{"Line":0}},{"line":7181,"address":[53669861],"length":1,"stats":{"Line":0}},{"line":7185,"address":[54512013,54511941],"length":1,"stats":{"Line":4}},{"line":7186,"address":[53668090,53668021],"length":1,"stats":{"Line":4}},{"line":7188,"address":[53669762],"length":1,"stats":{"Line":0}},{"line":7189,"address":[54512061],"length":1,"stats":{"Line":0}},{"line":7194,"address":[55024616,55024532],"length":1,"stats":{"Line":4}},{"line":7195,"address":[55344762,55345811,55344516,55344627],"length":1,"stats":{"Line":8}},{"line":7196,"address":[54512882,54512733,54513716,54513796],"length":1,"stats":{"Line":4}},{"line":7197,"address":[53669403,53669464],"length":1,"stats":{"Line":4}},{"line":7198,"address":[54513582],"length":1,"stats":{"Line":2}},{"line":7201,"address":[54512770],"length":1,"stats":{"Line":2}},{"line":7205,"address":[53657430,53657489],"length":1,"stats":{"Line":4}},{"line":7206,"address":[55341876,55333057],"length":1,"stats":{"Line":4}},{"line":7207,"address":[54511808],"length":1,"stats":{"Line":0}},{"line":7208,"address":[55022163],"length":1,"stats":{"Line":0}},{"line":7210,"address":[55343833],"length":1,"stats":{"Line":0}},{"line":7214,"address":[53665881,53665949],"length":1,"stats":{"Line":4}},{"line":7215,"address":[53666035,53665966],"length":1,"stats":{"Line":4}},{"line":7217,"address":[55023877],"length":1,"stats":{"Line":0}},{"line":7218,"address":[54509898],"length":1,"stats":{"Line":0}},{"line":7223,"address":[54510234,54510146],"length":1,"stats":{"Line":4}},{"line":7224,"address":[53667493,53666415,53666312,53666542],"length":1,"stats":{"Line":8}},{"line":7225,"address":[55023815,55023030,55023777,55022881],"length":1,"stats":{"Line":4}},{"line":7226,"address":[53667333,53667394],"length":1,"stats":{"Line":4}},{"line":7227,"address":[54511400],"length":1,"stats":{"Line":2}},{"line":7230,"address":[53666658],"length":1,"stats":{"Line":2}},{"line":7234,"address":[55013826,55013767],"length":1,"stats":{"Line":4}},{"line":7235,"address":[54501030,54507601],"length":1,"stats":{"Line":4}},{"line":7236,"address":[54509645],"length":1,"stats":{"Line":0}},{"line":7237,"address":[55020108],"length":1,"stats":{"Line":0}},{"line":7239,"address":[55021921],"length":1,"stats":{"Line":0}},{"line":7243,"address":[55339799,55339727],"length":1,"stats":{"Line":4}},{"line":7244,"address":[55020236,55020167],"length":1,"stats":{"Line":4}},{"line":7246,"address":[54509459],"length":1,"stats":{"Line":0}},{"line":7247,"address":[55339847],"length":1,"stats":{"Line":0}},{"line":7252,"address":[55020422,55020506],"length":1,"stats":{"Line":4}},{"line":7253,"address":[55340301,55341450,55340190,55340436],"length":1,"stats":{"Line":8}},{"line":7254,"address":[53664719,53665466,53664570,53665504],"length":1,"stats":{"Line":4}},{"line":7255,"address":[54509127,54509204],"length":1,"stats":{"Line":4}},{"line":7256,"address":[55341330],"length":1,"stats":{"Line":2}},{"line":7259,"address":[54508444],"length":1,"stats":{"Line":2}},{"line":7263,"address":[54500996,54501059],"length":1,"stats":{"Line":0}},{"line":7264,"address":[55336621,55333227],"length":1,"stats":{"Line":0}},{"line":7265,"address":[55019949],"length":1,"stats":{"Line":0}},{"line":7266,"address":[53660948],"length":1,"stats":{"Line":0}},{"line":7268,"address":[55339507],"length":1,"stats":{"Line":0}},{"line":7272,"address":[55017246,55017178],"length":1,"stats":{"Line":0}},{"line":7273,"address":[53661007,53661076],"length":1,"stats":{"Line":0}},{"line":7275,"address":[53663511],"length":1,"stats":{"Line":0}},{"line":7276,"address":[55017290],"length":1,"stats":{"Line":0}},{"line":7281,"address":[55337003,55337091],"length":1,"stats":{"Line":0}},{"line":7283,"address":[55337098,55337158],"length":1,"stats":{"Line":0}},{"line":7284,"address":[54505227,54507066,54505116,54505362],"length":1,"stats":{"Line":0}},{"line":7285,"address":[53661937,53661780,53663436],"length":1,"stats":{"Line":0}},{"line":7286,"address":[54506271,54506200],"length":1,"stats":{"Line":0}},{"line":7287,"address":[55338567,55338491],"length":1,"stats":{"Line":0}},{"line":7288,"address":[54506702,54506521],"length":1,"stats":{"Line":0}},{"line":7289,"address":[55338712],"length":1,"stats":{"Line":0}},{"line":7290,"address":[55019214],"length":1,"stats":{"Line":0}},{"line":7291,"address":[53662989],"length":1,"stats":{"Line":0}},{"line":7292,"address":[54506739,54506788],"length":1,"stats":{"Line":0}},{"line":7295,"address":[55337594],"length":1,"stats":{"Line":0}},{"line":7299,"address":[55333256,55333193],"length":1,"stats":{"Line":0}},{"line":7300,"address":[55014180,55014037],"length":1,"stats":{"Line":0}},{"line":7301,"address":[55336502],"length":1,"stats":{"Line":0}},{"line":7302,"address":[53657964],"length":1,"stats":{"Line":0}},{"line":7304,"address":[55336415],"length":1,"stats":{"Line":0}},{"line":7308,"address":[54501427,54501355],"length":1,"stats":{"Line":0}},{"line":7309,"address":[55014279,55014348],"length":1,"stats":{"Line":0}},{"line":7311,"address":[54504185],"length":1,"stats":{"Line":0}},{"line":7312,"address":[54501475],"length":1,"stats":{"Line":0}},{"line":7317,"address":[55014534,55014618],"length":1,"stats":{"Line":0}},{"line":7318,"address":[55014633],"length":1,"stats":{"Line":0}},{"line":7319,"address":[55014677],"length":1,"stats":{"Line":0}},{"line":7320,"address":[55334171,55336029,55334306,55334055],"length":1,"stats":{"Line":0}},{"line":7321,"address":[55335177,55334389,55336166],"length":1,"stats":{"Line":0}},{"line":7322,"address":[55016383,55016444],"length":1,"stats":{"Line":0}},{"line":7323,"address":[53660351,53660264],"length":1,"stats":{"Line":0}},{"line":7325,"address":[55335850,55335998],"length":1,"stats":{"Line":0}},{"line":7328,"address":[54502576,54503019,54502671,54502316,54502414],"length":1,"stats":{"Line":0}},{"line":7329,"address":[53658867,53658978],"length":1,"stats":{"Line":0}},{"line":7330,"address":[55334621,55334732],"length":1,"stats":{"Line":0}},{"line":7334,"address":[53657812],"length":1,"stats":{"Line":0}},{"line":7335,"address":[54501166],"length":1,"stats":{"Line":0}},{"line":7341,"address":[53556268,53555581,53554976],"length":1,"stats":{"Line":3}},{"line":7347,"address":[54911388,54911301],"length":1,"stats":{"Line":6}},{"line":7348,"address":[55221048],"length":1,"stats":{"Line":3}},{"line":7351,"address":[54389054,54388970],"length":1,"stats":{"Line":6}},{"line":7352,"address":[54911470],"length":1,"stats":{"Line":0}},{"line":7353,"address":[53556153],"length":1,"stats":{"Line":0}},{"line":7354,"address":[54389449],"length":1,"stats":{"Line":0}},{"line":7356,"address":[55222037],"length":1,"stats":{"Line":0}},{"line":7360,"address":[54912234],"length":1,"stats":{"Line":0}},{"line":7361,"address":[54389496],"length":1,"stats":{"Line":0}},{"line":7366,"address":[54911848,54911904],"length":1,"stats":{"Line":0}},{"line":7373,"address":[54389226],"length":1,"stats":{"Line":3}},{"line":7374,"address":[55221181,55221507],"length":1,"stats":{"Line":3}},{"line":7377,"address":[54389334],"length":1,"stats":{"Line":3}},{"line":7380,"address":[54529650,54530693,54527808],"length":1,"stats":{"Line":3}},{"line":7388,"address":[55360018,55360138],"length":1,"stats":{"Line":8}},{"line":7391,"address":[55039497],"length":1,"stats":{"Line":16}},{"line":7392,"address":[54528168,54528092],"length":1,"stats":{"Line":6}},{"line":7395,"address":[55041964,55039695],"length":1,"stats":{"Line":21}},{"line":7396,"address":[55361799,55362433,55360681],"length":1,"stats":{"Line":22}},{"line":7397,"address":[54529757,54530306],"length":1,"stats":{"Line":16}},{"line":7398,"address":[54529796,54529835,54529697],"length":1,"stats":{"Line":6}},{"line":7400,"address":[54529812,54529840],"length":1,"stats":{"Line":6}},{"line":7403,"address":[53684950],"length":1,"stats":{"Line":0}},{"line":7405,"address":[55362244,55362484],"length":1,"stats":{"Line":23}},{"line":7409,"address":[55040012],"length":1,"stats":{"Line":4}},{"line":7411,"address":[54528701],"length":1,"stats":{"Line":5}},{"line":7412,"address":[55361153],"length":1,"stats":{"Line":3}},{"line":7413,"address":[54529206],"length":1,"stats":{"Line":10}},{"line":7414,"address":[53684495],"length":1,"stats":{"Line":0}},{"line":7415,"address":[55040840],"length":1,"stats":{"Line":0}},{"line":7419,"address":[53684675],"length":1,"stats":{"Line":4}},{"line":7421,"address":[53684730],"length":1,"stats":{"Line":20}},{"line":7426,"address":[54374288],"length":1,"stats":{"Line":2}},{"line":7427,"address":[55206408],"length":1,"stats":{"Line":2}},{"line":7436,"address":[55465260,55464928,55465266],"length":1,"stats":{"Line":6}},{"line":7437,"address":[53784971],"length":1,"stats":{"Line":4}},{"line":7438,"address":[55141280],"length":1,"stats":{"Line":5}},{"line":7439,"address":[55465108],"length":1,"stats":{"Line":0}},{"line":7442,"address":[55141299],"length":1,"stats":{"Line":5}},{"line":7443,"address":[55141327],"length":1,"stats":{"Line":5}},{"line":7444,"address":[53785067,53785205],"length":1,"stats":{"Line":9}},{"line":7447,"address":[55150528],"length":1,"stats":{"Line":6}},{"line":7448,"address":[54642464,54642562,54642444],"length":1,"stats":{"Line":15}},{"line":7449,"address":[54642529,54642567],"length":1,"stats":{"Line":5}},{"line":7453,"address":[55140416],"length":1,"stats":{"Line":6}},{"line":7454,"address":[55464240],"length":1,"stats":{"Line":4}},{"line":7455,"address":[54632143],"length":1,"stats":{"Line":4}},{"line":7456,"address":[54632176],"length":1,"stats":{"Line":0}},{"line":7459,"address":[55140617,55140526],"length":1,"stats":{"Line":10}},{"line":7460,"address":[55464543],"length":1,"stats":{"Line":5}},{"line":7461,"address":[55464573],"length":1,"stats":{"Line":3}},{"line":7462,"address":[54632488],"length":1,"stats":{"Line":3}},{"line":7463,"address":[55464627],"length":1,"stats":{"Line":3}},{"line":7464,"address":[54632542],"length":1,"stats":{"Line":3}},{"line":7465,"address":[54632569],"length":1,"stats":{"Line":3}},{"line":7466,"address":[55464483,55464724],"length":1,"stats":{"Line":6}},{"line":7467,"address":[55464764],"length":1,"stats":{"Line":0}},{"line":7471,"address":[54635248,54637998,54638429],"length":1,"stats":{"Line":5}},{"line":7472,"address":[54635310,54635482],"length":1,"stats":{"Line":5}},{"line":7473,"address":[55467503],"length":1,"stats":{"Line":5}},{"line":7475,"address":[55467508],"length":1,"stats":{"Line":5}},{"line":7476,"address":[55143681],"length":1,"stats":{"Line":5}},{"line":7478,"address":[54635475,54635530],"length":1,"stats":{"Line":10}},{"line":7479,"address":[55144027,55143905],"length":1,"stats":{"Line":0}},{"line":7480,"address":[55143946],"length":1,"stats":{"Line":0}},{"line":7483,"address":[55145925],"length":1,"stats":{"Line":3}},{"line":7484,"address":[55143779],"length":1,"stats":{"Line":5}},{"line":7487,"address":[54635812,54635886],"length":1,"stats":{"Line":10}},{"line":7488,"address":[53790277,53787835],"length":1,"stats":{"Line":0}},{"line":7490,"address":[54638346,54635948],"length":1,"stats":{"Line":5}},{"line":7491,"address":[54636214],"length":1,"stats":{"Line":5}},{"line":7492,"address":[53788268],"length":1,"stats":{"Line":5}},{"line":7494,"address":[55468442,55470323],"length":1,"stats":{"Line":0}},{"line":7497,"address":[55144580],"length":1,"stats":{"Line":5}},{"line":7500,"address":[55144746,55144672],"length":1,"stats":{"Line":10}},{"line":7501,"address":[55468557,55470160],"length":1,"stats":{"Line":0}},{"line":7503,"address":[55144848,55144790],"length":1,"stats":{"Line":5}},{"line":7506,"address":[54636612,54638026,54636584],"length":1,"stats":{"Line":8}},{"line":7507,"address":[55468919,55468989],"length":1,"stats":{"Line":10}},{"line":7509,"address":[55145393],"length":1,"stats":{"Line":5}},{"line":7511,"address":[54637189],"length":1,"stats":{"Line":5}},{"line":7512,"address":[55146158,55145440],"length":1,"stats":{"Line":0}},{"line":7515,"address":[53789212,53789153],"length":1,"stats":{"Line":10}},{"line":7517,"address":[55145695,55145595,55145660],"length":1,"stats":{"Line":6}},{"line":7521,"address":[53789624,53789350,53789589],"length":1,"stats":{"Line":6}},{"line":7523,"address":[55145945,55145550],"length":1,"stats":{"Line":0}},{"line":7527,"address":[55145732],"length":1,"stats":{"Line":3}},{"line":7530,"address":[54629712,54631402,54631461],"length":1,"stats":{"Line":3}},{"line":7531,"address":[53782075,53781928],"length":1,"stats":{"Line":3}},{"line":7532,"address":[55138259],"length":1,"stats":{"Line":3}},{"line":7534,"address":[53781992],"length":1,"stats":{"Line":3}},{"line":7535,"address":[55138277],"length":1,"stats":{"Line":3}},{"line":7537,"address":[53782131,53782068],"length":1,"stats":{"Line":6}},{"line":7538,"address":[53782356,53782237],"length":1,"stats":{"Line":0}},{"line":7539,"address":[55462234],"length":1,"stats":{"Line":0}},{"line":7542,"address":[55139555],"length":1,"stats":{"Line":3}},{"line":7543,"address":[55462355,55463542,55462066],"length":1,"stats":{"Line":6}},{"line":7544,"address":[53782588,53782646],"length":1,"stats":{"Line":6}},{"line":7546,"address":[55462844],"length":1,"stats":{"Line":3}},{"line":7548,"address":[55139142],"length":1,"stats":{"Line":3}},{"line":7549,"address":[54630779,54631350],"length":1,"stats":{"Line":0}},{"line":7552,"address":[53782944,53782885],"length":1,"stats":{"Line":6}},{"line":7554,"address":[53783229,53783129,53783055],"length":1,"stats":{"Line":6}},{"line":7558,"address":[55463077,55463279,55463263],"length":1,"stats":{"Line":6}},{"line":7560,"address":[55139282,55139581],"length":1,"stats":{"Line":0}},{"line":7564,"address":[55463131],"length":1,"stats":{"Line":3}},{"line":7567,"address":[55472558,55470560,55472749],"length":1,"stats":{"Line":5}},{"line":7568,"address":[53790512,53790439],"length":1,"stats":{"Line":5}},{"line":7569,"address":[55146761],"length":1,"stats":{"Line":5}},{"line":7571,"address":[53790541,53792519],"length":1,"stats":{"Line":10}},{"line":7572,"address":[53790803,53790593,53790763],"length":1,"stats":{"Line":10}},{"line":7573,"address":[55470972],"length":1,"stats":{"Line":5}},{"line":7574,"address":[54638985,54639149,54638911],"length":1,"stats":{"Line":10}},{"line":7575,"address":[54638988],"length":1,"stats":{"Line":5}},{"line":7577,"address":[55471059],"length":1,"stats":{"Line":5}},{"line":7578,"address":[55147470,55147389,55147480],"length":1,"stats":{"Line":0}},{"line":7579,"address":[55147473],"length":1,"stats":{"Line":0}},{"line":7580,"address":[55147535,55148697],"length":1,"stats":{"Line":0}},{"line":7582,"address":[55147702,55147517,55147582],"length":1,"stats":{"Line":0}},{"line":7583,"address":[54639404],"length":1,"stats":{"Line":0}},{"line":7584,"address":[53791681,53791480],"length":1,"stats":{"Line":0}},{"line":7585,"address":[55147992,55147782],"length":1,"stats":{"Line":0}},{"line":7586,"address":[55147812,55147994],"length":1,"stats":{"Line":0}},{"line":7587,"address":[54639650,54639804],"length":1,"stats":{"Line":0}},{"line":7588,"address":[55471918,55471789],"length":1,"stats":{"Line":0}},{"line":7589,"address":[55147896,55148000],"length":1,"stats":{"Line":0}},{"line":7592,"address":[53791659,53791743],"length":1,"stats":{"Line":0}},{"line":7593,"address":[54640460,54639881],"length":1,"stats":{"Line":0}},{"line":7595,"address":[54639923,54639859],"length":1,"stats":{"Line":0}},{"line":7596,"address":[55148460,55148365,55148289],"length":1,"stats":{"Line":0}},{"line":7597,"address":[53792202],"length":1,"stats":{"Line":0}},{"line":7598,"address":[55148540],"length":1,"stats":{"Line":0}},{"line":7601,"address":[55472537,55472512,55472366],"length":1,"stats":{"Line":0}},{"line":7603,"address":[55471647,55472616],"length":1,"stats":{"Line":0}},{"line":7606,"address":[54639229,54640590],"length":1,"stats":{"Line":10}},{"line":7608,"address":[55471883,55472720,55472728],"length":1,"stats":{"Line":10}},{"line":7611,"address":[54638626,54638750],"length":1,"stats":{"Line":0}},{"line":7614,"address":[54635191,54634016,54635185],"length":1,"stats":{"Line":3}},{"line":7615,"address":[53786110],"length":1,"stats":{"Line":3}},{"line":7616,"address":[55142401],"length":1,"stats":{"Line":3}},{"line":7617,"address":[54634105],"length":1,"stats":{"Line":3}},{"line":7619,"address":[55142417,55142453,55142545],"length":1,"stats":{"Line":6}},{"line":7620,"address":[54634208,54634243],"length":1,"stats":{"Line":0}},{"line":7623,"address":[55466240],"length":1,"stats":{"Line":3}},{"line":7624,"address":[55466527,55466465],"length":1,"stats":{"Line":3}},{"line":7625,"address":[53787226,53786415],"length":1,"stats":{"Line":8}},{"line":7626,"address":[54634445,54635214,54635222],"length":1,"stats":{"Line":8}},{"line":7627,"address":[53786503,53786457,53786525,53786581],"length":1,"stats":{"Line":12}},{"line":7628,"address":[54634511],"length":1,"stats":{"Line":3}},{"line":7629,"address":[53786548,53786586],"length":1,"stats":{"Line":3}},{"line":7630,"address":[55466596,55466682],"length":1,"stats":{"Line":3}},{"line":7631,"address":[55466718],"length":1,"stats":{"Line":0}},{"line":7632,"address":[54634662,54634614],"length":1,"stats":{"Line":0}},{"line":7633,"address":[53786714,53786681,53786875,53786805],"length":1,"stats":{"Line":0}},{"line":7634,"address":[54634744,54634843,54634851],"length":1,"stats":{"Line":0}},{"line":7641,"address":[55142583],"length":1,"stats":{"Line":3}},{"line":7643,"address":[55143165,55142625],"length":1,"stats":{"Line":8}},{"line":7644,"address":[53787192,53786911],"length":1,"stats":{"Line":6}},{"line":7646,"address":[55467233],"length":1,"stats":{"Line":3}},{"line":7647,"address":[54463264,54463232],"length":1,"stats":{"Line":3}},{"line":7649,"address":[53786939,53787077],"length":1,"stats":{"Line":10}},{"line":7651,"address":[53787039],"length":1,"stats":{"Line":5}},{"line":7652,"address":[54463406,54463376],"length":1,"stats":{"Line":5}},{"line":7656,"address":[55461536,55461542,55461008],"length":1,"stats":{"Line":3}},{"line":7657,"address":[55137552,55137877,55137432],"length":1,"stats":{"Line":6}},{"line":7658,"address":[55461523,55461414,55461464],"length":1,"stats":{"Line":6}},{"line":7659,"address":[55137823],"length":1,"stats":{"Line":3}},{"line":7661,"address":[55461114],"length":1,"stats":{"Line":0}},{"line":7665,"address":[54632016,54631488,54632022],"length":1,"stats":{"Line":3}},{"line":7666,"address":[54631544,54631664,54632001],"length":1,"stats":{"Line":6}},{"line":7667,"address":[55464115,55464006,55464056],"length":1,"stats":{"Line":6}},{"line":7668,"address":[53784047],"length":1,"stats":{"Line":3}},{"line":7670,"address":[53783706],"length":1,"stats":{"Line":0}},{"line":7674,"address":[53780560,53781077,53781071],"length":1,"stats":{"Line":3}},{"line":7675,"address":[55460640,55460520,55460972],"length":1,"stats":{"Line":6}},{"line":7676,"address":[53780954,53781004,53781058],"length":1,"stats":{"Line":6}},{"line":7677,"address":[53781007],"length":1,"stats":{"Line":3}},{"line":7679,"address":[53780666],"length":1,"stats":{"Line":0}},{"line":7684,"address":[55457888,55459147,55459153],"length":1,"stats":{"Line":4}},{"line":7685,"address":[53778111,53778450],"length":1,"stats":{"Line":7}},{"line":7686,"address":[54626182],"length":1,"stats":{"Line":1}},{"line":7687,"address":[55135055],"length":1,"stats":{"Line":3}},{"line":7688,"address":[55135027],"length":1,"stats":{"Line":1}},{"line":7689,"address":[55134595],"length":1,"stats":{"Line":3}},{"line":7690,"address":[55134626],"length":1,"stats":{"Line":1}},{"line":7691,"address":[55134654,55134956],"length":1,"stats":{"Line":2}},{"line":7692,"address":[54626431],"length":1,"stats":{"Line":0}},{"line":7694,"address":[53778739],"length":1,"stats":{"Line":1}},{"line":7697,"address":[53778404],"length":1,"stats":{"Line":1}},{"line":7698,"address":[55458317],"length":1,"stats":{"Line":3}},{"line":7699,"address":[55458643,55458337],"length":1,"stats":{"Line":3}},{"line":7700,"address":[55135278],"length":1,"stats":{"Line":3}},{"line":7702,"address":[53778583],"length":1,"stats":{"Line":3}},{"line":7703,"address":[55134876,55134920],"length":1,"stats":{"Line":6}},{"line":7706,"address":[55459231],"length":1,"stats":{"Line":9}},{"line":7708,"address":[54627236],"length":1,"stats":{"Line":3}},{"line":7710,"address":[55134448,55136017],"length":1,"stats":{"Line":0}},{"line":7715,"address":[55474704,55477542,55476349],"length":1,"stats":{"Line":3}},{"line":7716,"address":[55150759],"length":1,"stats":{"Line":3}},{"line":7717,"address":[55474776],"length":1,"stats":{"Line":3}},{"line":7719,"address":[54642791,54643011],"length":1,"stats":{"Line":3}},{"line":7720,"address":[54643042,54643448],"length":1,"stats":{"Line":0}},{"line":7721,"address":[54643415,54643443],"length":1,"stats":{"Line":0}},{"line":7722,"address":[54643384,54643438],"length":1,"stats":{"Line":0}},{"line":7723,"address":[54642878,54643196],"length":1,"stats":{"Line":6}},{"line":7724,"address":[53794760],"length":1,"stats":{"Line":0}},{"line":7725,"address":[53794791,53795067,53795137],"length":1,"stats":{"Line":0}},{"line":7726,"address":[55151383,55151447],"length":1,"stats":{"Line":0}},{"line":7728,"address":[53795159],"length":1,"stats":{"Line":0}},{"line":7731,"address":[53794813,53795200],"length":1,"stats":{"Line":2}},{"line":7732,"address":[54643068],"length":1,"stats":{"Line":1}},{"line":7733,"address":[55151573,55151212],"length":1,"stats":{"Line":2}},{"line":7734,"address":[55475639,55475718],"length":1,"stats":{"Line":2}},{"line":7735,"address":[53796039,53795485],"length":1,"stats":{"Line":0}},{"line":7737,"address":[53795465,53795516],"length":1,"stats":{"Line":2}},{"line":7739,"address":[53095584,53095622],"length":1,"stats":{"Line":3}},{"line":7741,"address":[53795707,53795624],"length":1,"stats":{"Line":2}},{"line":7744,"address":[55475222],"length":1,"stats":{"Line":3}},{"line":7745,"address":[53796049,53794974],"length":1,"stats":{"Line":6}},{"line":7746,"address":[54644380,54644307],"length":1,"stats":{"Line":6}},{"line":7747,"address":[54644437,54644970],"length":1,"stats":{"Line":0}},{"line":7749,"address":[55152469],"length":1,"stats":{"Line":3}},{"line":7751,"address":[55152567],"length":1,"stats":{"Line":9}},{"line":7752,"address":[55744736,55744837,55744888],"length":1,"stats":{"Line":6}},{"line":7755,"address":[55744744],"length":1,"stats":{"Line":3}},{"line":7756,"address":[53095122],"length":1,"stats":{"Line":3}},{"line":7760,"address":[54644640,54644557],"length":1,"stats":{"Line":6}},{"line":7763,"address":[55474952,55477084],"length":1,"stats":{"Line":0}},{"line":7768,"address":[55474298,55473344,55474304],"length":1,"stats":{"Line":3}},{"line":7769,"address":[53793131],"length":1,"stats":{"Line":3}},{"line":7770,"address":[54641307,54641375],"length":1,"stats":{"Line":6}},{"line":7771,"address":[53793352],"length":1,"stats":{"Line":3}},{"line":7772,"address":[55149965,55149810],"length":1,"stats":{"Line":0}},{"line":7773,"address":[53793569,53793698],"length":1,"stats":{"Line":0}},{"line":7774,"address":[55473959,55473856],"length":1,"stats":{"Line":0}},{"line":7775,"address":[54641852,54641775],"length":1,"stats":{"Line":0}},{"line":7776,"address":[53793662,53793713],"length":1,"stats":{"Line":0}},{"line":7777,"address":[54641866,54641653],"length":1,"stats":{"Line":6}},{"line":7778,"address":[55150072,55150026],"length":1,"stats":{"Line":0}},{"line":7780,"address":[55150067,55150000],"length":1,"stats":{"Line":7}},{"line":7783,"address":[53793430],"length":1,"stats":{"Line":4}},{"line":7784,"address":[53793464],"length":1,"stats":{"Line":4}}],"covered":3077,"coverable":4259},{"path":["/","home","md","language","mdhavers","src","lexer.rs"],"content":"use logos::Logos;\n\nuse crate::error::{HaversError, HaversResult};\nuse crate::token::{Token, TokenKind};\n\n/// The lexer - turns source code intae tokens\npub struct Lexer<'source> {\n    source: &'source str,\n    logos: logos::Lexer<'source, TokenKind>,\n    line: usize,\n    column: usize,\n    last_newline_pos: usize,\n}\n\nimpl<'source> Lexer<'source> {\n    pub fn new(source: &'source str) -> Self {\n        Lexer {\n            source,\n            logos: TokenKind::lexer(source),\n            line: 1,\n            column: 1,\n            last_newline_pos: 0,\n        }\n    }\n\n    /// Tokenize the whole source intae a vector\n    pub fn tokenize(&mut self) -> HaversResult<Vec<Token>> {\n        let mut tokens = Vec::new();\n\n        while let Some(result) = self.logos.next() {\n            let span = self.logos.span();\n\n            // Update line and column tracking\n            let slice_before = &self.source[self.last_newline_pos..span.start];\n            for ch in slice_before.chars() {\n                if ch == '\\n' {\n                    self.line += 1;\n                    self.column = 1;\n                    self.last_newline_pos = span.start;\n                } else {\n                    self.column += 1;\n                }\n            }\n\n            let lexeme = self.logos.slice().to_string();\n            let column = span.start - self.last_newline_pos + 1;\n\n            match result {\n                Ok(kind) => {\n                    // Track newlines for line counting\n                    if kind == TokenKind::Newline {\n                        tokens.push(Token::new(kind, lexeme, self.line, column));\n                        self.line += 1;\n                        self.column = 1;\n                        self.last_newline_pos = span.end;\n                    } else {\n                        tokens.push(Token::new(kind, lexeme, self.line, column));\n                    }\n                }\n                Err(_) => {\n                    return Err(HaversError::UnkentToken {\n                        lexeme,\n                        line: self.line,\n                        column,\n                    });\n                }\n            }\n        }\n\n        // Add EOF token\n        tokens.push(Token::eof(self.line));\n\n        Ok(tokens)\n    }\n}\n\n/// Convenience function tae lex a string\npub fn lex(source: &str) -> HaversResult<Vec<Token>> {\n    let mut lexer = Lexer::new(source);\n    lexer.tokenize()\n}\n\n#[cfg(test)]\n#[allow(clippy::approx_constant)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_keywords() {\n        let source = \"ken gin ither whiles fer gie blether\";\n        let tokens = lex(source).unwrap();\n\n        assert!(matches!(tokens[0].kind, TokenKind::Ken));\n        assert!(matches!(tokens[1].kind, TokenKind::Gin));\n        assert!(matches!(tokens[2].kind, TokenKind::Ither));\n        assert!(matches!(tokens[3].kind, TokenKind::Whiles));\n        assert!(matches!(tokens[4].kind, TokenKind::Fer));\n        assert!(matches!(tokens[5].kind, TokenKind::Gie));\n        assert!(matches!(tokens[6].kind, TokenKind::Blether));\n    }\n\n    #[test]\n    fn test_numbers() {\n        let source = \"42 3.14\";\n        let tokens = lex(source).unwrap();\n\n        assert_eq!(tokens[0].kind, TokenKind::Integer(42));\n        assert_eq!(tokens[1].kind, TokenKind::Float(3.14));\n    }\n\n    #[test]\n    fn test_strings() {\n        let source = r#\"\"Hello, Scotland!\"\"#;\n        let tokens = lex(source).unwrap();\n\n        assert_eq!(\n            tokens[0].kind,\n            TokenKind::String(\"Hello, Scotland!\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_operators() {\n        let source = \"+ - * / == != < > <= >=\";\n        let tokens = lex(source).unwrap();\n\n        assert!(matches!(tokens[0].kind, TokenKind::Plus));\n        assert!(matches!(tokens[1].kind, TokenKind::Minus));\n        assert!(matches!(tokens[2].kind, TokenKind::Star));\n        assert!(matches!(tokens[3].kind, TokenKind::Slash));\n        assert!(matches!(tokens[4].kind, TokenKind::EqualsEquals));\n        assert!(matches!(tokens[5].kind, TokenKind::BangEquals));\n        assert!(matches!(tokens[6].kind, TokenKind::Less));\n        assert!(matches!(tokens[7].kind, TokenKind::Greater));\n        assert!(matches!(tokens[8].kind, TokenKind::LessEquals));\n        assert!(matches!(tokens[9].kind, TokenKind::GreaterEquals));\n    }\n\n    #[test]\n    fn test_identifiers() {\n        let source = \"foo bar_baz _private\";\n        let tokens = lex(source).unwrap();\n\n        assert_eq!(tokens[0].kind, TokenKind::Identifier(\"foo\".to_string()));\n        assert_eq!(tokens[1].kind, TokenKind::Identifier(\"bar_baz\".to_string()));\n        assert_eq!(\n            tokens[2].kind,\n            TokenKind::Identifier(\"_private\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_comments_are_skipped() {\n        let source = \"ken x = 5 # this is a comment\\nken y = 10\";\n        let tokens = lex(source).unwrap();\n\n        // Should have: ken, x, =, 5, newline, ken, y, =, 10, eof\n        assert_eq!(tokens.len(), 10);\n    }\n\n    #[test]\n    fn test_multiline() {\n        let source = \"ken x = 5\\nken y = 10\";\n        let tokens = lex(source).unwrap();\n\n        assert_eq!(tokens[0].line, 1);\n        assert_eq!(tokens[5].line, 2); // second ken\n    }\n\n    #[test]\n    fn test_braw_program() {\n        let source = r#\"\n# A wee program\ndae greet(name) {\n    blether \"Hullo, \" + name + \"!\"\n}\n\nken message = \"Scotland\"\ngreet(message)\n\"#;\n        let tokens = lex(source).unwrap();\n        assert!(tokens.len() > 10);\n        // Just check it parses without error\n    }\n}\n","traces":[{"line":16,"address":[54118688],"length":1,"stats":{"Line":40}},{"line":19,"address":[54473138],"length":1,"stats":{"Line":25}},{"line":27,"address":[54120515,54118816,54120898],"length":1,"stats":{"Line":50}},{"line":28,"address":[54473271],"length":1,"stats":{"Line":51}},{"line":30,"address":[],"length":0,"stats":{"Line":164}},{"line":31,"address":[54473447,54473581],"length":1,"stats":{"Line":112}},{"line":34,"address":[54334381],"length":1,"stats":{"Line":61}},{"line":35,"address":[53220524],"length":1,"stats":{"Line":61}},{"line":36,"address":[],"length":0,"stats":{"Line":118}},{"line":37,"address":[53221871,53221892,53221799],"length":1,"stats":{"Line":4}},{"line":38,"address":[54120643],"length":1,"stats":{"Line":2}},{"line":39,"address":[54120651],"length":1,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":96}},{"line":45,"address":[],"length":0,"stats":{"Line":60}},{"line":46,"address":[53220765,53220875,53220916],"length":1,"stats":{"Line":124}},{"line":48,"address":[53220883],"length":1,"stats":{"Line":62}},{"line":49,"address":[53221144],"length":1,"stats":{"Line":63}},{"line":51,"address":[53221263,53221702,53221192],"length":1,"stats":{"Line":153}},{"line":52,"address":[54474755,54474579],"length":1,"stats":{"Line":52}},{"line":53,"address":[54120472,54120415],"length":1,"stats":{"Line":26}},{"line":54,"address":[],"length":0,"stats":{"Line":27}},{"line":55,"address":[],"length":0,"stats":{"Line":27}},{"line":57,"address":[54335216,54335462],"length":1,"stats":{"Line":116}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[54474178],"length":1,"stats":{"Line":0}},{"line":62,"address":[53220955],"length":1,"stats":{"Line":0}},{"line":63,"address":[53221011],"length":1,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[54119075,54120760],"length":1,"stats":{"Line":46}},{"line":73,"address":[],"length":0,"stats":{"Line":66}},{"line":78,"address":[54333792],"length":1,"stats":{"Line":38}},{"line":79,"address":[54473053],"length":1,"stats":{"Line":38}},{"line":80,"address":[54473067],"length":1,"stats":{"Line":43}}],"covered":28,"coverable":33},{"path":["/","home","md","language","mdhavers","src","lib.rs"],"content":"//! mdhavers - A Scots Programming Language\n//!\n//! Pure havers, but working havers!\n//!\n//! This crate provides the core functionality for the mdhavers programming language,\n//! including lexing, parsing, interpretation, and compilation.\n\npub mod ast;\npub mod compiler;\npub mod error;\npub mod formatter;\npub mod graphics;\npub mod interpreter;\npub mod lexer;\npub mod parser;\npub mod token;\npub mod value;\npub mod wasm_compiler;\n\n// LLVM backend (optional, requires llvm feature)\n#[cfg(feature = \"llvm\")]\npub mod llvm;\n\n// Re-export commonly used types\npub use error::{HaversError, HaversResult};\npub use interpreter::Interpreter;\npub use parser::parse;\npub use value::Value;\n\n// LLVM compiler re-export\n#[cfg(feature = \"llvm\")]\npub use llvm::LLVMCompiler;\n\n/// Run mdhavers source code and return the result\n///\n/// This is a convenience function that handles the full pipeline:\n/// lexing, parsing, and interpretation.\n///\n/// # Example\n/// ```\n/// use mdhavers::run;\n///\n/// let code = r#\"\n///     ken x = 42\n///     x * 2\n/// \"#;\n/// let result = run(code);\n/// ```\npub fn run(source: &str) -> HaversResult<Value> {\n    let program = parse(source)?;\n    let mut interpreter = Interpreter::new();\n    interpreter.interpret(&program)\n}\n\n/// Run mdhavers source code and capture output\n///\n/// Returns a tuple of (result, output_lines) where output_lines\n/// contains all lines printed with `blether`.\npub fn run_with_output(source: &str) -> HaversResult<(Value, Vec<String>)> {\n    let program = parse(source)?;\n    let mut interpreter = Interpreter::new();\n    let result = interpreter.interpret(&program)?;\n    let output = interpreter.get_output().to_vec();\n    Ok((result, output))\n}\n\n/// Compile mdhavers source code to JavaScript\npub fn compile_to_js(source: &str) -> HaversResult<String> {\n    compiler::compile(source)\n}\n\n/// Compile mdhavers source code to WebAssembly Text format\npub fn compile_to_wat(source: &str) -> HaversResult<String> {\n    wasm_compiler::compile_to_wat(source)\n}\n\n/// Compile mdhavers source code to LLVM IR\n#[cfg(feature = \"llvm\")]\npub fn compile_to_llvm_ir(source: &str) -> HaversResult<String> {\n    let program = parse(source)?;\n    let compiler = llvm::LLVMCompiler::new();\n    compiler.compile_to_ir(&program)\n}\n\n/// Format mdhavers source code\npub fn format_source(source: &str) -> HaversResult<String> {\n    formatter::format_source(source)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_run_simple() {\n        let result = run(\"ken x = 42\\nx\").unwrap();\n        assert_eq!(result, Value::Integer(42));\n    }\n\n    #[test]\n    fn test_run_arithmetic() {\n        let result = run(\"10 + 5 * 2\").unwrap();\n        assert_eq!(result, Value::Integer(20));\n    }\n\n    #[test]\n    fn test_run_function() {\n        let result = run(r#\"\n            dae add(a, b) {\n                gie a + b\n            }\n            add(3, 4)\n        \"#)\n        .unwrap();\n        assert_eq!(result, Value::Integer(7));\n    }\n\n    #[test]\n    fn test_run_error() {\n        let result = run(\"undefined_var\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_run_with_output_simple() {\n        let (result, output) = run_with_output(\n            r#\"\n            blether \"Hello\"\n            blether \"World\"\n            42\n        \"#,\n        )\n        .unwrap();\n        assert_eq!(result, Value::Integer(42));\n        assert_eq!(output.len(), 2);\n        assert_eq!(output[0], \"Hello\");\n        assert_eq!(output[1], \"World\");\n    }\n\n    #[test]\n    fn test_run_with_output_no_output() {\n        let (result, output) = run_with_output(\"5 + 5\").unwrap();\n        assert_eq!(result, Value::Integer(10));\n        assert!(output.is_empty());\n    }\n\n    #[test]\n    fn test_compile_to_js_simple() {\n        let js = compile_to_js(\"ken x = 42\").unwrap();\n        assert!(js.contains(\"let x\"));\n        assert!(js.contains(\"42\"));\n    }\n\n    #[test]\n    fn test_compile_to_js_function() {\n        let js = compile_to_js(\n            r#\"\n            dae greet(name) {\n                gie \"Hello \" + name\n            }\n        \"#,\n        )\n        .unwrap();\n        assert!(js.contains(\"function greet\"));\n    }\n\n    #[test]\n    fn test_compile_to_js_error() {\n        // Invalid syntax\n        let result = compile_to_js(\"ken = \");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_compile_to_wat_simple() {\n        let wat = compile_to_wat(\"ken x = 42\").unwrap();\n        assert!(wat.contains(\"(module\"));\n    }\n\n    #[test]\n    fn test_compile_to_wat_function() {\n        let wat = compile_to_wat(\n            r#\"\n            dae add(a, b) {\n                gie a + b\n            }\n        \"#,\n        )\n        .unwrap();\n        assert!(wat.contains(\"(func\"));\n    }\n\n    #[test]\n    fn test_format_source_simple() {\n        let formatted = format_source(\"ken x=42\").unwrap();\n        assert!(formatted.contains(\"ken x = 42\"));\n    }\n\n    #[test]\n    fn test_format_source_function() {\n        let formatted = format_source(\"dae foo(){gie 1}\").unwrap();\n        assert!(formatted.contains(\"dae foo()\"));\n    }\n\n    #[test]\n    fn test_format_source_error() {\n        let result = format_source(\"ken = invalid\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_run_boolean_operations() {\n        assert_eq!(run(\"aye\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"nae\").unwrap(), Value::Bool(false));\n        assert_eq!(run(\"aye an aye\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"aye an nae\").unwrap(), Value::Bool(false));\n        assert_eq!(run(\"aye or nae\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"nae or nae\").unwrap(), Value::Bool(false));\n    }\n\n    #[test]\n    fn test_run_comparison_operations() {\n        assert_eq!(run(\"5 > 3\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"5 < 3\").unwrap(), Value::Bool(false));\n        assert_eq!(run(\"5 == 5\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"5 != 3\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"5 >= 5\").unwrap(), Value::Bool(true));\n        assert_eq!(run(\"5 <= 5\").unwrap(), Value::Bool(true));\n    }\n\n    #[test]\n    fn test_run_list_operations() {\n        let result = run(\"[1, 2, 3]\").unwrap();\n        if let Value::List(items) = result {\n            assert_eq!(items.borrow().len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n\n    #[test]\n    fn test_run_string_operations() {\n        let result = run(r#\"\"Hello\" + \" \" + \"World\"\"#).unwrap();\n        assert_eq!(result, Value::String(\"Hello World\".to_string()));\n    }\n}\n","traces":[{"line":49,"address":[53237552,53237886,53237892],"length":1,"stats":{"Line":1}},{"line":50,"address":[53237584],"length":1,"stats":{"Line":1}},{"line":51,"address":[53283965],"length":1,"stats":{"Line":1}},{"line":52,"address":[3588833],"length":1,"stats":{"Line":1}},{"line":59,"address":[3589004],"length":1,"stats":{"Line":3}},{"line":60,"address":[115593389],"length":1,"stats":{"Line":3}},{"line":61,"address":[57652199],"length":1,"stats":{"Line":3}},{"line":62,"address":[115593406,115593449,115593460],"length":1,"stats":{"Line":6}},{"line":63,"address":[57652344],"length":1,"stats":{"Line":6}},{"line":64,"address":[115731668],"length":1,"stats":{"Line":3}},{"line":68,"address":[57652155],"length":1,"stats":{"Line":1}},{"line":69,"address":[53282405],"length":1,"stats":{"Line":1}},{"line":73,"address":[4358924,4358938,4358649],"length":1,"stats":{"Line":1}},{"line":74,"address":[3967924,3967894,3951461,3951491,3967864],"length":1,"stats":{"Line":1}},{"line":79,"address":[53237536,53237232,53237530],"length":1,"stats":{"Line":0}},{"line":80,"address":[5296721],"length":1,"stats":{"Line":0}},{"line":81,"address":[115736056],"length":1,"stats":{"Line":0}},{"line":82,"address":[53283706],"length":1,"stats":{"Line":0}},{"line":86,"address":[3776628,3775060,3777247,3782285,3782056,3778850,3780682,3733620,3777705,3781598,3780911,3782514,3779766,3779079,3780224,3778163,3778392,3779995,3775871,3777934,3781369,3775263,3779308,3781140,3733823,3778621,3734052,3777476,3779537,3777044,3781827,3780453,3775668],"length":1,"stats":{"Line":1}},{"line":87,"address":[53282453],"length":1,"stats":{"Line":2}}],"covered":16,"coverable":20},{"path":["/","home","md","language","mdhavers","src","llvm","builtins.rs"],"content":"//! Built-in functions for LLVM codegen\n//!\n//! Maps mdhavers built-in functions to runtime calls.\n\nuse std::collections::HashMap;\n\n/// Information about a built-in function\n#[derive(Debug, Clone)]\npub struct BuiltinInfo {\n    /// Name in mdhavers\n    pub name: &'static str,\n    /// Corresponding runtime function name\n    pub runtime_name: &'static str,\n    /// Minimum number of arguments\n    pub min_arity: usize,\n    /// Maximum number of arguments (None = variadic)\n    pub max_arity: Option<usize>,\n}\n\nimpl BuiltinInfo {\n    const fn new(\n        name: &'static str,\n        runtime_name: &'static str,\n        min_arity: usize,\n        max_arity: Option<usize>,\n    ) -> Self {\n        BuiltinInfo {\n            name,\n            runtime_name,\n            min_arity,\n            max_arity,\n        }\n    }\n\n    const fn fixed(name: &'static str, runtime_name: &'static str, arity: usize) -> Self {\n        BuiltinInfo::new(name, runtime_name, arity, Some(arity))\n    }\n}\n\n/// All built-in functions\npub static BUILTINS: &[BuiltinInfo] = &[\n    // I/O\n    BuiltinInfo::fixed(\"blether\", \"__mdh_blether\", 1),\n    BuiltinInfo::fixed(\"speir\", \"__mdh_speir\", 1),\n    BuiltinInfo::fixed(\"get_key\", \"__mdh_get_key\", 0),\n    // Type conversion\n    BuiltinInfo::fixed(\"tae_string\", \"__mdh_to_string\", 1),\n    BuiltinInfo::fixed(\"tae_int\", \"__mdh_to_int\", 1),\n    BuiltinInfo::fixed(\"tae_float\", \"__mdh_to_float\", 1),\n    // Type checking\n    BuiltinInfo::fixed(\"whit_kind\", \"__mdh_type_of\", 1),\n    // List operations\n    BuiltinInfo::fixed(\"len\", \"__mdh_len\", 1),\n    BuiltinInfo::fixed(\"shove\", \"__mdh_list_push\", 2),\n    BuiltinInfo::fixed(\"yank\", \"__mdh_list_pop\", 1),\n    // Math\n    BuiltinInfo::fixed(\"abs\", \"__mdh_abs\", 1),\n    BuiltinInfo::new(\"jammy\", \"__mdh_random\", 0, Some(2)),\n    BuiltinInfo::fixed(\"floor\", \"__mdh_floor\", 1),\n    BuiltinInfo::fixed(\"ceil\", \"__mdh_ceil\", 1),\n    BuiltinInfo::fixed(\"round\", \"__mdh_round\", 1),\n];\n\n/// Lookup table for quick builtin resolution\npub fn get_builtin_map() -> HashMap<&'static str, &'static BuiltinInfo> {\n    BUILTINS.iter().map(|b| (b.name, b)).collect()\n}\n\n/// Check if a name is a built-in function\npub fn is_builtin(name: &str) -> bool {\n    BUILTINS.iter().any(|b| b.name == name)\n}\n\n/// Get builtin info by name\npub fn get_builtin(name: &str) -> Option<&'static BuiltinInfo> {\n    BUILTINS.iter().find(|b| b.name == name)\n}\n","traces":[{"line":21,"address":[54827680],"length":1,"stats":{"Line":0}},{"line":35,"address":[55595520],"length":1,"stats":{"Line":0}},{"line":36,"address":[55595560],"length":1,"stats":{"Line":0}},{"line":65,"address":[55595664],"length":1,"stats":{"Line":0}},{"line":66,"address":[55954814],"length":1,"stats":{"Line":0}},{"line":70,"address":[55595344],"length":1,"stats":{"Line":0}},{"line":71,"address":[54827614],"length":1,"stats":{"Line":0}},{"line":75,"address":[55122608],"length":1,"stats":{"Line":0}},{"line":76,"address":[54460129,54460112],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","home","md","language","mdhavers","src","llvm","codegen.rs"],"content":"//! LLVM Code Generation\n//!\n//! Compiles mdhavers AST to LLVM IR with fully inlined runtime.\n//! Produces standalone executables that only depend on libc.\n\n// Allow duplicate pattern aliases - many Scots/English synonyms are handled in multiple places\n#![allow(unreachable_patterns)]\n// Allow unused code - some functions are prepared for future use\n#![allow(dead_code)]\n// Allow unused variables - some are prepared for future implementation\n#![allow(unused_variables)]\n// Allow clippy warnings for this complex generated-style code\n#![allow(clippy::collapsible_match)]\n#![allow(clippy::unnecessary_map_or)]\n#![allow(clippy::only_used_in_recursion)]\n#![allow(clippy::borrowed_box)]\n\nuse std::collections::{HashMap, HashSet};\nuse std::path::{Path, PathBuf};\n\nuse inkwell::basic_block::BasicBlock;\nuse inkwell::builder::Builder;\nuse inkwell::context::Context;\nuse inkwell::module::{Linkage, Module};\nuse inkwell::types::BasicMetadataTypeEnum;\nuse inkwell::values::{\n    BasicMetadataValueEnum, BasicValueEnum, FunctionValue, IntValue, PointerValue,\n};\nuse inkwell::AddressSpace;\nuse inkwell::IntPredicate;\n\nuse crate::ast::{\n    BinaryOp, DestructPattern, Expr, FStringPart, Literal, LogicalOp, MatchArm, Pattern, Program,\n    Stmt, UnaryOp,\n};\nuse crate::error::HaversError;\n\nuse super::types::{MdhTypes, ValueTag};\n\n/// Loop context for break/continue\nstruct LoopContext<'ctx> {\n    break_block: BasicBlock<'ctx>,\n    continue_block: BasicBlock<'ctx>,\n}\n\n/// Libc functions we use\n#[allow(dead_code)]\nstruct LibcFunctions<'ctx> {\n    printf: FunctionValue<'ctx>,\n    malloc: FunctionValue<'ctx>,\n    realloc: FunctionValue<'ctx>,\n    strlen: FunctionValue<'ctx>,\n    strcpy: FunctionValue<'ctx>,\n    strcat: FunctionValue<'ctx>,\n    snprintf: FunctionValue<'ctx>,\n    exit: FunctionValue<'ctx>,\n    strstr: FunctionValue<'ctx>,\n    strcmp: FunctionValue<'ctx>,\n    memcpy: FunctionValue<'ctx>,\n    toupper: FunctionValue<'ctx>,\n    tolower: FunctionValue<'ctx>,\n    isspace: FunctionValue<'ctx>,\n    // Phase 5: Timing functions\n    clock_gettime: FunctionValue<'ctx>,\n    nanosleep: FunctionValue<'ctx>,\n    // Phase 7: I/O functions\n    fgets: FunctionValue<'ctx>,\n    // Extra: string operations\n    strdup: FunctionValue<'ctx>,\n    // Extra: random/time\n    rand: FunctionValue<'ctx>,\n    srand: FunctionValue<'ctx>,\n    time: FunctionValue<'ctx>,\n    qsort: FunctionValue<'ctx>,\n    // Runtime functions\n    get_key: FunctionValue<'ctx>,\n    random: FunctionValue<'ctx>,\n    term_width: FunctionValue<'ctx>,\n    term_height: FunctionValue<'ctx>,\n    // Dict/Creel runtime functions\n    empty_creel: FunctionValue<'ctx>,\n    dict_contains: FunctionValue<'ctx>,\n    toss_in: FunctionValue<'ctx>,\n    heave_oot: FunctionValue<'ctx>,\n    creel_tae_list: FunctionValue<'ctx>,\n    // File I/O runtime functions\n    file_exists: FunctionValue<'ctx>,\n    slurp: FunctionValue<'ctx>,\n    scrieve: FunctionValue<'ctx>,\n    lines: FunctionValue<'ctx>,\n    words: FunctionValue<'ctx>,\n    // Logging/Debug runtime functions\n    get_log_level: FunctionValue<'ctx>,\n    set_log_level: FunctionValue<'ctx>,\n    // Scots builtin runtime functions\n    slainte: FunctionValue<'ctx>,\n    och: FunctionValue<'ctx>,\n    wee: FunctionValue<'ctx>,\n    tak: FunctionValue<'ctx>,\n    pair_up: FunctionValue<'ctx>,\n    tae_binary: FunctionValue<'ctx>,\n    average: FunctionValue<'ctx>,\n    chynge: FunctionValue<'ctx>,\n    // Testing runtime functions\n    assert_fn: FunctionValue<'ctx>,\n    skip: FunctionValue<'ctx>,\n    stacktrace: FunctionValue<'ctx>,\n    // Additional Scots runtime functions\n    muckle: FunctionValue<'ctx>,\n    median: FunctionValue<'ctx>,\n    is_space: FunctionValue<'ctx>,\n    is_digit: FunctionValue<'ctx>,\n    wheesht_aw: FunctionValue<'ctx>,\n    bonnie: FunctionValue<'ctx>,\n    shuffle: FunctionValue<'ctx>,\n    bit_and: FunctionValue<'ctx>,\n    bit_or: FunctionValue<'ctx>,\n    bit_xor: FunctionValue<'ctx>,\n    // I/O runtime functions\n    speir: FunctionValue<'ctx>,\n}\n\n/// Inferred type for optimization\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum VarType {\n    Unknown,\n    Int,\n    Float,\n    String,\n    Bool,\n    List,\n}\n\n/// Main code generator with inlined runtime\npub struct CodeGen<'ctx> {\n    context: &'ctx Context,\n    module: Module<'ctx>,\n    builder: Builder<'ctx>,\n    types: MdhTypes<'ctx>,\n    libc: LibcFunctions<'ctx>,\n\n    /// Current function being compiled\n    current_function: Option<FunctionValue<'ctx>>,\n\n    /// Variable storage (name -> alloca pointer)\n    variables: HashMap<String, PointerValue<'ctx>>,\n\n    /// Global variable storage (name -> global pointer) - accessible from all functions\n    globals: HashMap<String, PointerValue<'ctx>>,\n\n    /// Shadow i64 storage for integer variables (optimization)\n    /// When a variable is known to be Int, we keep an unboxed i64 version\n    int_shadows: HashMap<String, PointerValue<'ctx>>,\n\n    /// Shadow length storage for string variables (optimization)\n    /// Stores the string length so we can skip strlen calls\n    string_len_shadows: HashMap<String, PointerValue<'ctx>>,\n\n    /// Shadow capacity storage for string variables (optimization)\n    /// Stores the allocated buffer capacity for in-place appending\n    string_cap_shadows: HashMap<String, PointerValue<'ctx>>,\n\n    /// Shadow pointer storage for list variables (optimization)\n    /// Stores the raw list pointer as i64 so we don't need to extract from MdhValue\n    list_ptr_shadows: HashMap<String, PointerValue<'ctx>>,\n\n    /// Inferred types for variables (for optimization)\n    var_types: HashMap<String, VarType>,\n\n    /// Track which class a variable holds (for method dispatch)\n    variable_class_types: HashMap<String, String>,\n\n    /// User-defined functions\n    functions: HashMap<String, FunctionValue<'ctx>>,\n\n    /// Default parameter values for functions (name -> vec of optional exprs)\n    function_defaults: HashMap<String, Vec<Option<Expr>>>,\n\n    /// Captured variables for closures/nested functions (func_name -> [var_name])\n    function_captures: HashMap<String, Vec<String>>,\n\n    /// Loop context stack for break/continue\n    loop_stack: Vec<LoopContext<'ctx>>,\n\n    /// Track if we're in a hot loop body (skip MdhValue stores)\n    in_loop_body: bool,\n\n    /// Track if we're inside a user-defined function (not main)\n    in_user_function: bool,\n\n    /// Counter for generating unique lambda names\n    lambda_counter: u32,\n\n    /// Class definitions: name -> global variable holding class data pointer\n    classes: HashMap<String, inkwell::values::GlobalValue<'ctx>>,\n\n    /// Class method tables: class_name -> [(method_name, function)]\n    class_methods: HashMap<String, Vec<(String, FunctionValue<'ctx>)>>,\n\n    /// Current 'masel' value (set during method execution)\n    current_masel: Option<PointerValue<'ctx>>,\n\n    /// Current class name being compiled (for method naming)\n    current_class: Option<String>,\n\n    /// Source file path for resolving imports\n    source_path: Option<PathBuf>,\n\n    /// Imported modules (to avoid duplicate imports)\n    imported_modules: HashSet<PathBuf>,\n\n    /// Format strings for printf\n    fmt_int: inkwell::values::GlobalValue<'ctx>,\n    fmt_float: inkwell::values::GlobalValue<'ctx>,\n    fmt_string: inkwell::values::GlobalValue<'ctx>,\n    fmt_true: inkwell::values::GlobalValue<'ctx>,\n    fmt_false: inkwell::values::GlobalValue<'ctx>,\n    fmt_nil: inkwell::values::GlobalValue<'ctx>,\n    fmt_newline: inkwell::values::GlobalValue<'ctx>,\n}\n\nimpl<'ctx> CodeGen<'ctx> {\n    pub fn new(context: &'ctx Context, module_name: &str) -> Self {\n        let module = context.create_module(module_name);\n\n        // Set target triple and data layout for x86_64 Linux\n        // This ensures proper struct alignment (i64 aligned to 8 bytes)\n        use inkwell::targets::{InitializationConfig, Target, TargetTriple};\n        Target::initialize_native(&InitializationConfig::default()).unwrap();\n        let triple = TargetTriple::create(\"x86_64-unknown-linux-gnu\");\n        module.set_triple(&triple);\n\n        // Standard x86_64 data layout - i64 aligned to 8 bytes\n        let data_layout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\";\n        module\n            .set_data_layout(&inkwell::targets::TargetData::create(data_layout).get_data_layout());\n\n        let builder = context.create_builder();\n        let types = MdhTypes::new(context);\n\n        // Declare libc functions\n        let libc = Self::declare_libc_functions(&module, context, &types);\n\n        // Create format strings\n        let fmt_int = Self::create_global_string(&module, context, \"%lld\", \"fmt_int\");\n        let fmt_float = Self::create_global_string(&module, context, \"%g\", \"fmt_float\");\n        let fmt_string = Self::create_global_string(&module, context, \"%s\", \"fmt_string\");\n        let fmt_true = Self::create_global_string(&module, context, \"aye\", \"fmt_true\");\n        let fmt_false = Self::create_global_string(&module, context, \"nae\", \"fmt_false\");\n        let fmt_nil = Self::create_global_string(&module, context, \"naething\", \"fmt_nil\");\n        let fmt_newline = Self::create_global_string(&module, context, \"\\n\", \"fmt_newline\");\n\n        CodeGen {\n            context,\n            module,\n            builder,\n            types,\n            libc,\n            current_function: None,\n            variables: HashMap::new(),\n            globals: HashMap::new(),\n            int_shadows: HashMap::new(),\n            string_len_shadows: HashMap::new(),\n            string_cap_shadows: HashMap::new(),\n            list_ptr_shadows: HashMap::new(),\n            var_types: HashMap::new(),\n            variable_class_types: HashMap::new(),\n            functions: HashMap::new(),\n            function_defaults: HashMap::new(),\n            function_captures: HashMap::new(),\n            loop_stack: Vec::new(),\n            in_loop_body: false,\n            in_user_function: false,\n            lambda_counter: 0,\n            classes: HashMap::new(),\n            class_methods: HashMap::new(),\n            current_masel: None,\n            current_class: None,\n            source_path: None,\n            imported_modules: HashSet::new(),\n            fmt_int,\n            fmt_float,\n            fmt_string,\n            fmt_true,\n            fmt_false,\n            fmt_nil,\n            fmt_newline,\n        }\n    }\n\n    /// Set the source file path for resolving imports\n    pub fn set_source_path(&mut self, path: &Path) {\n        self.source_path = Some(path.to_path_buf());\n    }\n\n    fn declare_libc_functions(\n        module: &Module<'ctx>,\n        context: &'ctx Context,\n        types: &MdhTypes<'ctx>,\n    ) -> LibcFunctions<'ctx> {\n        let i8_ptr = context.i8_type().ptr_type(AddressSpace::default());\n        let i32_type = context.i32_type();\n        let i64_type = context.i64_type();\n        let void_type = context.void_type();\n\n        // printf(const char* fmt, ...) -> int\n        let printf_type = i32_type.fn_type(&[i8_ptr.into()], true);\n        let printf = module.add_function(\"printf\", printf_type, Some(Linkage::External));\n\n        // malloc(size_t) -> void*\n        let malloc_type = i8_ptr.fn_type(&[i64_type.into()], false);\n        let malloc = module.add_function(\"malloc\", malloc_type, Some(Linkage::External));\n\n        // realloc(void*, size_t) -> void*\n        let realloc_type = i8_ptr.fn_type(&[i8_ptr.into(), i64_type.into()], false);\n        let realloc = module.add_function(\"realloc\", realloc_type, Some(Linkage::External));\n\n        // strlen(const char*) -> size_t\n        let strlen_type = i64_type.fn_type(&[i8_ptr.into()], false);\n        let strlen = module.add_function(\"strlen\", strlen_type, Some(Linkage::External));\n\n        // strcpy(char* dest, const char* src) -> char*\n        let strcpy_type = i8_ptr.fn_type(&[i8_ptr.into(), i8_ptr.into()], false);\n        let strcpy = module.add_function(\"strcpy\", strcpy_type, Some(Linkage::External));\n\n        // strcat(char* dest, const char* src) -> char*\n        let strcat_type = i8_ptr.fn_type(&[i8_ptr.into(), i8_ptr.into()], false);\n        let strcat = module.add_function(\"strcat\", strcat_type, Some(Linkage::External));\n\n        // snprintf(char* str, size_t size, const char* format, ...) -> int\n        let snprintf_type =\n            i32_type.fn_type(&[i8_ptr.into(), i64_type.into(), i8_ptr.into()], true);\n        let snprintf = module.add_function(\"snprintf\", snprintf_type, Some(Linkage::External));\n\n        // exit(int) -> void\n        let exit_type = void_type.fn_type(&[i32_type.into()], false);\n        let exit = module.add_function(\"exit\", exit_type, Some(Linkage::External));\n\n        // strstr(const char*, const char*) -> char*\n        let strstr_type = i8_ptr.fn_type(&[i8_ptr.into(), i8_ptr.into()], false);\n        let strstr = module.add_function(\"strstr\", strstr_type, Some(Linkage::External));\n\n        // strcmp(const char*, const char*) -> int\n        let strcmp_type = i32_type.fn_type(&[i8_ptr.into(), i8_ptr.into()], false);\n        let strcmp = module.add_function(\"strcmp\", strcmp_type, Some(Linkage::External));\n\n        // memcpy(void* dest, const void* src, size_t n) -> void*\n        let memcpy_type = i8_ptr.fn_type(&[i8_ptr.into(), i8_ptr.into(), i64_type.into()], false);\n        let memcpy = module.add_function(\"memcpy\", memcpy_type, Some(Linkage::External));\n\n        // toupper(int) -> int\n        let toupper_type = i32_type.fn_type(&[i32_type.into()], false);\n        let toupper = module.add_function(\"toupper\", toupper_type, Some(Linkage::External));\n\n        // tolower(int) -> int\n        let tolower_type = i32_type.fn_type(&[i32_type.into()], false);\n        let tolower = module.add_function(\"tolower\", tolower_type, Some(Linkage::External));\n\n        // isspace(int) -> int\n        let isspace_type = i32_type.fn_type(&[i32_type.into()], false);\n        let isspace = module.add_function(\"isspace\", isspace_type, Some(Linkage::External));\n\n        // clock_gettime(clockid_t, struct timespec*) -> int\n        // struct timespec is {i64 tv_sec, i64 tv_nsec}\n        let clock_gettime_type = i32_type.fn_type(&[i32_type.into(), i8_ptr.into()], false);\n        let clock_gettime =\n            module.add_function(\"clock_gettime\", clock_gettime_type, Some(Linkage::External));\n\n        // nanosleep(const struct timespec*, struct timespec*) -> int\n        let nanosleep_type = i32_type.fn_type(&[i8_ptr.into(), i8_ptr.into()], false);\n        let nanosleep = module.add_function(\"nanosleep\", nanosleep_type, Some(Linkage::External));\n\n        // fgets(char* buf, int size, FILE* stream) -> char*\n        let fgets_type = i8_ptr.fn_type(&[i8_ptr.into(), i32_type.into(), i8_ptr.into()], false);\n        let fgets = module.add_function(\"fgets\", fgets_type, Some(Linkage::External));\n\n        // strdup(const char*) -> char* (allocates a copy)\n        let strdup_type = i8_ptr.fn_type(&[i8_ptr.into()], false);\n        let strdup = module.add_function(\"strdup\", strdup_type, Some(Linkage::External));\n\n        // rand() -> int\n        let rand_type = i32_type.fn_type(&[], false);\n        let rand = module.add_function(\"rand\", rand_type, Some(Linkage::External));\n\n        // srand(unsigned int) -> void\n        let srand_type = void_type.fn_type(&[i32_type.into()], false);\n        let srand = module.add_function(\"srand\", srand_type, Some(Linkage::External));\n\n        // time(time_t*) -> time_t (pass NULL to get current time)\n        let time_type = i64_type.fn_type(&[i8_ptr.into()], false);\n        let time = module.add_function(\"time\", time_type, Some(Linkage::External));\n\n        // qsort(void*, size_t, size_t, comparator) - we won't use this directly\n        let qsort_type = void_type.fn_type(\n            &[\n                i8_ptr.into(),\n                i64_type.into(),\n                i64_type.into(),\n                i8_ptr.into(),\n            ],\n            false,\n        );\n        let qsort = module.add_function(\"qsort\", qsort_type, Some(Linkage::External));\n\n        // __mdh_get_key() -> MdhValue\n        let get_key_type = types.value_type.fn_type(&[], false);\n        let get_key = module.add_function(\"__mdh_get_key\", get_key_type, Some(Linkage::External));\n\n        // __mdh_random(i64 min, i64 max) -> MdhValue\n        let random_type = types\n            .value_type\n            .fn_type(&[i64_type.into(), i64_type.into()], false);\n        let random = module.add_function(\"__mdh_random\", random_type, Some(Linkage::External));\n\n        // __mdh_term_width() -> MdhValue\n        let term_size_type = types.value_type.fn_type(&[], false);\n        let term_width =\n            module.add_function(\"__mdh_term_width\", term_size_type, Some(Linkage::External));\n\n        // __mdh_term_height() -> MdhValue\n        let term_height =\n            module.add_function(\"__mdh_term_height\", term_size_type, Some(Linkage::External));\n\n        // __mdh_empty_creel() -> MdhValue\n        let empty_creel_type = types.value_type.fn_type(&[], false);\n        let empty_creel = module.add_function(\n            \"__mdh_empty_creel\",\n            empty_creel_type,\n            Some(Linkage::External),\n        );\n\n        // __mdh_dict_contains(dict, key) -> MdhValue (bool)\n        let dict_contains_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let dict_contains = module.add_function(\n            \"__mdh_dict_contains\",\n            dict_contains_type,\n            Some(Linkage::External),\n        );\n\n        // __mdh_toss_in(dict, item) -> MdhValue (new dict)\n        let toss_in_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let toss_in = module.add_function(\"__mdh_toss_in\", toss_in_type, Some(Linkage::External));\n\n        // __mdh_heave_oot(dict, item) -> MdhValue (new dict)\n        let heave_oot_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let heave_oot =\n            module.add_function(\"__mdh_heave_oot\", heave_oot_type, Some(Linkage::External));\n\n        // __mdh_creel_tae_list(dict) -> MdhValue (list)\n        let creel_tae_list_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let creel_tae_list = module.add_function(\n            \"__mdh_creel_tae_list\",\n            creel_tae_list_type,\n            Some(Linkage::External),\n        );\n\n        // File I/O functions\n        // __mdh_file_exists(path) -> MdhValue (bool)\n        let file_exists_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let file_exists = module.add_function(\n            \"__mdh_file_exists\",\n            file_exists_type,\n            Some(Linkage::External),\n        );\n\n        // __mdh_slurp(path) -> MdhValue (string)\n        let slurp_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let slurp = module.add_function(\"__mdh_slurp\", slurp_type, Some(Linkage::External));\n\n        // __mdh_scrieve(path, content) -> MdhValue (bool)\n        let scrieve_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let scrieve = module.add_function(\"__mdh_scrieve\", scrieve_type, Some(Linkage::External));\n\n        // __mdh_lines(path) -> MdhValue (list)\n        let lines_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let lines = module.add_function(\"__mdh_lines\", lines_type, Some(Linkage::External));\n\n        // __mdh_words(str) -> MdhValue (list)\n        let words_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let words = module.add_function(\"__mdh_words\", words_type, Some(Linkage::External));\n\n        // Logging/Debug functions\n        // __mdh_get_log_level() -> MdhValue (int)\n        let get_log_level_type = types.value_type.fn_type(&[], false);\n        let get_log_level = module.add_function(\n            \"__mdh_get_log_level\",\n            get_log_level_type,\n            Some(Linkage::External),\n        );\n\n        // __mdh_set_log_level(level) -> MdhValue (nil)\n        let set_log_level_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let set_log_level = module.add_function(\n            \"__mdh_set_log_level\",\n            set_log_level_type,\n            Some(Linkage::External),\n        );\n\n        // Scots builtin functions\n        // __mdh_slainte() -> MdhValue (nil)\n        let slainte_type = types.value_type.fn_type(&[], false);\n        let slainte = module.add_function(\"__mdh_slainte\", slainte_type, Some(Linkage::External));\n\n        // __mdh_och(msg) -> MdhValue (nil)\n        let och_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let och = module.add_function(\"__mdh_och\", och_type, Some(Linkage::External));\n\n        // __mdh_wee(a, b) -> MdhValue (smaller)\n        let wee_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let wee = module.add_function(\"__mdh_wee\", wee_type, Some(Linkage::External));\n\n        // __mdh_tak(list, n) -> MdhValue (list)\n        let tak_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let tak = module.add_function(\"__mdh_tak\", tak_type, Some(Linkage::External));\n\n        // __mdh_pair_up(list1, list2) -> MdhValue (list of pairs)\n        let pair_up_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let pair_up = module.add_function(\"__mdh_pair_up\", pair_up_type, Some(Linkage::External));\n\n        // __mdh_tae_binary(n) -> MdhValue (string)\n        let tae_binary_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let tae_binary =\n            module.add_function(\"__mdh_tae_binary\", tae_binary_type, Some(Linkage::External));\n\n        // __mdh_average(list) -> MdhValue (float)\n        let average_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let average = module.add_function(\"__mdh_average\", average_type, Some(Linkage::External));\n\n        // __mdh_chynge(str, old, new) -> MdhValue (string)\n        let chynge_type = types.value_type.fn_type(\n            &[\n                types.value_type.into(),\n                types.value_type.into(),\n                types.value_type.into(),\n            ],\n            false,\n        );\n        let chynge = module.add_function(\"__mdh_chynge\", chynge_type, Some(Linkage::External));\n\n        // Testing functions\n        // __mdh_assert(condition, msg) -> MdhValue (nil)\n        let assert_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let assert_fn = module.add_function(\"__mdh_assert\", assert_type, Some(Linkage::External));\n\n        // __mdh_skip(reason) -> MdhValue (nil)\n        let skip_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let skip = module.add_function(\"__mdh_skip\", skip_type, Some(Linkage::External));\n\n        // __mdh_stacktrace() -> MdhValue (string)\n        let stacktrace_type = types.value_type.fn_type(&[], false);\n        let stacktrace =\n            module.add_function(\"__mdh_stacktrace\", stacktrace_type, Some(Linkage::External));\n\n        // Additional Scots runtime functions\n        // __mdh_muckle(a, b) -> MdhValue (larger)\n        let muckle_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let muckle = module.add_function(\"__mdh_muckle\", muckle_type, Some(Linkage::External));\n\n        // __mdh_median(list) -> MdhValue (float)\n        let median_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let median = module.add_function(\"__mdh_median\", median_type, Some(Linkage::External));\n\n        // __mdh_is_space(str) -> MdhValue (bool)\n        let is_space_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let is_space =\n            module.add_function(\"__mdh_is_space\", is_space_type, Some(Linkage::External));\n\n        // __mdh_is_digit(str) -> MdhValue (bool)\n        let is_digit_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let is_digit =\n            module.add_function(\"__mdh_is_digit\", is_digit_type, Some(Linkage::External));\n\n        // __mdh_wheesht_aw(str) -> MdhValue (string)\n        let wheesht_aw_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let wheesht_aw =\n            module.add_function(\"__mdh_wheesht_aw\", wheesht_aw_type, Some(Linkage::External));\n\n        // __mdh_bonnie(val) -> MdhValue (string)\n        let bonnie_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let bonnie = module.add_function(\"__mdh_bonnie\", bonnie_type, Some(Linkage::External));\n\n        // __mdh_shuffle(list) -> MdhValue (list)\n        let shuffle_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let shuffle = module.add_function(\"__mdh_shuffle\", shuffle_type, Some(Linkage::External));\n\n        // __mdh_bit_and(a, b) -> MdhValue (int)\n        let bit_and_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let bit_and = module.add_function(\"__mdh_bit_and\", bit_and_type, Some(Linkage::External));\n\n        // __mdh_bit_or(a, b) -> MdhValue (int)\n        let bit_or_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let bit_or = module.add_function(\"__mdh_bit_or\", bit_or_type, Some(Linkage::External));\n\n        // __mdh_bit_xor(a, b) -> MdhValue (int)\n        let bit_xor_type = types\n            .value_type\n            .fn_type(&[types.value_type.into(), types.value_type.into()], false);\n        let bit_xor = module.add_function(\"__mdh_bit_xor\", bit_xor_type, Some(Linkage::External));\n\n        // __mdh_speir(prompt) -> MdhValue (string)\n        let speir_type = types.value_type.fn_type(&[types.value_type.into()], false);\n        let speir = module.add_function(\"__mdh_speir\", speir_type, Some(Linkage::External));\n\n        LibcFunctions {\n            printf,\n            malloc,\n            realloc,\n            strlen,\n            strcpy,\n            strcat,\n            snprintf,\n            exit,\n            strstr,\n            strcmp,\n            memcpy,\n            toupper,\n            tolower,\n            isspace,\n            clock_gettime,\n            nanosleep,\n            fgets,\n            strdup,\n            rand,\n            srand,\n            time,\n            qsort,\n            get_key,\n            random,\n            term_width,\n            term_height,\n            empty_creel,\n            dict_contains,\n            toss_in,\n            heave_oot,\n            creel_tae_list,\n            file_exists,\n            slurp,\n            scrieve,\n            lines,\n            words,\n            get_log_level,\n            set_log_level,\n            slainte,\n            och,\n            wee,\n            tak,\n            pair_up,\n            tae_binary,\n            average,\n            chynge,\n            assert_fn,\n            skip,\n            stacktrace,\n            muckle,\n            median,\n            is_space,\n            is_digit,\n            wheesht_aw,\n            bonnie,\n            shuffle,\n            bit_and,\n            bit_or,\n            bit_xor,\n            speir,\n        }\n    }\n\n    fn create_global_string(\n        module: &Module<'ctx>,\n        context: &'ctx Context,\n        s: &str,\n        name: &str,\n    ) -> inkwell::values::GlobalValue<'ctx> {\n        let bytes: Vec<u8> = s.bytes().chain(std::iter::once(0)).collect();\n        let arr_type = context.i8_type().array_type(bytes.len() as u32);\n        let global = module.add_global(arr_type, Some(AddressSpace::default()), name);\n        global.set_linkage(Linkage::Private);\n        global.set_constant(true);\n        let values: Vec<_> = bytes\n            .iter()\n            .map(|b| context.i8_type().const_int(*b as u64, false))\n            .collect();\n        global.set_initializer(&context.i8_type().const_array(&values));\n        global\n    }\n\n    fn get_string_ptr(&self, global: inkwell::values::GlobalValue<'ctx>) -> PointerValue<'ctx> {\n        self.builder\n            .build_pointer_cast(\n                global.as_pointer_value(),\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"str_ptr\",\n            )\n            .unwrap()\n    }\n\n    /// Get the compiled module\n    pub fn get_module(&self) -> &Module<'ctx> {\n        &self.module\n    }\n\n    /// Compile a complete program\n    pub fn compile(&mut self, program: &Program) -> Result<(), HaversError> {\n        // First pass: declare all functions and store default parameter values\n        for stmt in &program.statements {\n            if let Stmt::Function { name, params, .. } = stmt {\n                self.declare_function(name, params.len())?;\n                // Store default parameter values for call-site substitution\n                let defaults: Vec<Option<Expr>> =\n                    params.iter().map(|p| p.default.clone()).collect();\n                if defaults.iter().any(|d| d.is_some()) {\n                    self.function_defaults.insert(name.clone(), defaults);\n                }\n            }\n        }\n\n        // Create main function\n        let main_fn_type = self.types.i32_type.fn_type(&[], false);\n        let main_fn = self.module.add_function(\"main\", main_fn_type, None);\n        let entry = self.context.append_basic_block(main_fn, \"entry\");\n        self.builder.position_at_end(entry);\n        self.current_function = Some(main_fn);\n\n        // Pre-register all classes and their methods (allows cross-class method calls)\n        // Must happen after main function is created so builder position is set\n        for stmt in &program.statements {\n            if let Stmt::Class { name, methods, .. } = stmt {\n                self.preregister_class(name, methods)?;\n            }\n        }\n\n        // Compile all statements\n        for stmt in &program.statements {\n            self.compile_stmt(stmt)?;\n        }\n\n        // Return 0 from main\n        self.builder\n            .build_return(Some(&self.types.i32_type.const_int(0, false)))\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to build return: {}\", e)))?;\n\n        Ok(())\n    }\n\n    /// Declare a function (first pass)\n    fn declare_function(&mut self, name: &str, param_count: usize) -> Result<(), HaversError> {\n        self.declare_function_with_captures(name, param_count, &[])\n    }\n\n    /// Declare a function with captured variables as additional parameters\n    fn declare_function_with_captures(\n        &mut self,\n        name: &str,\n        param_count: usize,\n        captures: &[String],\n    ) -> Result<(), HaversError> {\n        // Total params = declared params + captured variables\n        let total_params = param_count + captures.len();\n        let param_types: Vec<BasicMetadataTypeEnum> = (0..total_params)\n            .map(|_| self.types.value_type.into())\n            .collect();\n\n        let fn_type = self.types.value_type.fn_type(&param_types, false);\n        let function = self.module.add_function(name, fn_type, None);\n        self.functions.insert(name.to_string(), function);\n\n        // Track captured variables for this function\n        if !captures.is_empty() {\n            self.function_captures\n                .insert(name.to_string(), captures.to_vec());\n        }\n        Ok(())\n    }\n\n    /// Pre-register a class and its methods (allows cross-class method calls)\n    fn preregister_class(&mut self, name: &str, methods: &[Stmt]) -> Result<(), HaversError> {\n        // Skip if already registered\n        if self.classes.contains_key(name) {\n            return Ok(());\n        }\n\n        // Declare all methods (create function signatures)\n        let mut method_list: Vec<(String, FunctionValue<'ctx>)> = Vec::new();\n        for method in methods {\n            if let Stmt::Function {\n                name: method_name,\n                params,\n                ..\n            } = method\n            {\n                let func_name = format!(\"{}_{}\", name, method_name);\n                // Skip if already declared\n                if self.functions.contains_key(&func_name) {\n                    continue;\n                }\n                let param_types: Vec<BasicMetadataTypeEnum> =\n                    std::iter::once(self.types.value_type.into())\n                        .chain(params.iter().map(|_| self.types.value_type.into()))\n                        .collect();\n                let fn_type = self.types.value_type.fn_type(&param_types, false);\n                let function = self.module.add_function(&func_name, fn_type, None);\n                self.functions.insert(func_name.clone(), function);\n                method_list.push((method_name.clone(), function));\n\n                // Store default parameter values for methods\n                let defaults: Vec<Option<Expr>> =\n                    params.iter().map(|p| p.default.clone()).collect();\n                if defaults.iter().any(|d| d.is_some()) {\n                    self.function_defaults.insert(func_name, defaults);\n                }\n            }\n        }\n\n        // Store class and method table\n        self.class_methods.insert(name.to_string(), method_list);\n        let class_name_global = self\n            .builder\n            .build_global_string_ptr(name, &format!(\"class_{}\", name))\n            .unwrap();\n        self.classes.insert(name.to_string(), class_name_global);\n\n        Ok(())\n    }\n\n    // ========== Inline Value Creation ==========\n\n    /// Create a nil value: {tag=0, data=0}\n    fn make_nil(&self) -> BasicValueEnum<'ctx> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Nil.as_u8() as u64, false);\n        let data = self.types.i64_type.const_int(0, false);\n        self.types\n            .value_type\n            .const_named_struct(&[tag.into(), data.into()])\n            .into()\n    }\n\n    /// Create a bool value: {tag=1, data=0|1}\n    fn make_bool(&self, val: IntValue<'ctx>) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n\n        // Fast path: if val is a constant, build a constant struct directly\n        if val.is_const() {\n            let bool_val = val.get_zero_extended_constant().unwrap_or(0);\n            let data = self.types.i64_type.const_int(bool_val, false);\n            return Ok(self\n                .types\n                .value_type\n                .const_named_struct(&[tag.into(), data.into()])\n                .into());\n        }\n\n        // Non-constant path\n        let data = self\n            .builder\n            .build_int_z_extend(val, self.types.i64_type, \"bool_ext\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to extend bool: {}\", e)))?;\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, data, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create an int value: {tag=2, data=i64}\n    fn make_int(&self, val: IntValue<'ctx>) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n\n        // Fast path: if val is a constant, build a constant struct directly\n        if val.is_const() {\n            return Ok(self\n                .types\n                .value_type\n                .const_named_struct(&[tag.into(), val.into()])\n                .into());\n        }\n\n        // Non-constant path\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, val, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create a float value: {tag=3, data=bitcast(f64)}\n    fn make_float(\n        &self,\n        val: inkwell::values::FloatValue<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n        let data = self\n            .builder\n            .build_bitcast(val, self.types.i64_type, \"float_bits\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast float: {}\", e)))?;\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, data, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create a string value: {tag=4, data=ptr as i64}\n    fn make_string(&self, ptr: PointerValue<'ctx>) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::String.as_u8() as u64, false);\n        let data = self\n            .builder\n            .build_ptr_to_int(ptr, self.types.i64_type, \"str_ptr_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert ptr: {}\", e)))?;\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, data, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create a list value: {tag=5, data=ptr as i64}\n    /// List memory layout: [i64 length, {i8,i64} element0, {i8,i64} element1, ...]\n    fn make_list(&self, ptr: PointerValue<'ctx>) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let data = self\n            .builder\n            .build_ptr_to_int(ptr, self.types.i64_type, \"list_ptr_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert ptr: {}\", e)))?;\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, data, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create a dict value: {tag=6, data=ptr as i64}\n    /// Dict memory layout: [i64 count][entry0][entry1]... where entry = [{i8,i64} key][{i8,i64} val]\n    fn make_dict(&self, ptr: PointerValue<'ctx>) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Dict.as_u8() as u64, false);\n        let data = self\n            .builder\n            .build_ptr_to_int(ptr, self.types.i64_type, \"dict_ptr_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert ptr: {}\", e)))?;\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, data, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create an instance value: {tag=9, data=ptr as i64}\n    /// Instance memory layout: [i64 class_name_ptr][i64 field_count][field_entry0][field_entry1]...\n    /// where field_entry = [{i8,i64} key (string)][{i8,i64} value]\n    fn make_instance(&self, ptr: PointerValue<'ctx>) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Instance.as_u8() as u64, false);\n        let data = self\n            .builder\n            .build_ptr_to_int(ptr, self.types.i64_type, \"instance_ptr_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert ptr: {}\", e)))?;\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, data, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Create a function value: {tag=7, data=func_ptr as i64}\n    fn make_function(\n        &self,\n        func_ptr_int: IntValue<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Function.as_u8() as u64, false);\n\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"v1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert tag: {}\", e)))?;\n        let v2 = self\n            .builder\n            .build_insert_value(v1, func_ptr_int, 1, \"v2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to insert data: {}\", e)))?;\n\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Extract data as list pointer\n    #[allow(dead_code)]\n    fn extract_list_ptr(\n        &self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<PointerValue<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let ptr = self\n            .builder\n            .build_int_to_ptr(\n                data,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"as_list\",\n            )\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert to ptr: {}\", e)))?;\n        Ok(ptr)\n    }\n\n    /// Extract tag from value\n    fn extract_tag(&self, val: BasicValueEnum<'ctx>) -> Result<IntValue<'ctx>, HaversError> {\n        let struct_val = val.into_struct_value();\n        let tag = self\n            .builder\n            .build_extract_value(struct_val, 0, \"tag\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to extract tag: {}\", e)))?;\n        Ok(tag.into_int_value())\n    }\n\n    /// Extract data from value as i64\n    fn extract_data(&self, val: BasicValueEnum<'ctx>) -> Result<IntValue<'ctx>, HaversError> {\n        let struct_val = val.into_struct_value();\n        let data = self\n            .builder\n            .build_extract_value(struct_val, 1, \"data\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to extract data: {}\", e)))?;\n        Ok(data.into_int_value())\n    }\n\n    /// Extract data as f64 (for float values)\n    #[allow(dead_code)]\n    fn extract_float(\n        &self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<inkwell::values::FloatValue<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"as_float\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast to float: {}\", e)))?;\n        Ok(float_val.into_float_value())\n    }\n\n    /// Extract data as string pointer\n    #[allow(dead_code)]\n    fn extract_string_ptr(\n        &self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<PointerValue<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let ptr = self\n            .builder\n            .build_int_to_ptr(\n                data,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"as_str\",\n            )\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert to ptr: {}\", e)))?;\n        Ok(ptr)\n    }\n\n    /// Check if value is truthy\n    fn is_truthy(&self, val: BasicValueEnum<'ctx>) -> Result<IntValue<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let function = self.current_function.unwrap();\n        let is_nil = self.context.append_basic_block(function, \"is_nil\");\n        let is_bool = self.context.append_basic_block(function, \"is_bool\");\n        let is_int = self.context.append_basic_block(function, \"is_int\");\n        let is_other = self.context.append_basic_block(function, \"is_other\");\n        let merge = self.context.append_basic_block(function, \"truthy_merge\");\n\n        // Switch on tag\n        let nil_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Nil.as_u8() as u64, false);\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n\n        self.builder\n            .build_switch(\n                tag,\n                is_other,\n                &[(nil_tag, is_nil), (bool_tag, is_bool), (int_tag, is_int)],\n            )\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to build switch: {}\", e)))?;\n\n        // nil -> false\n        self.builder.position_at_end(is_nil);\n        let nil_result = self.types.bool_type.const_int(0, false);\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let nil_block = self.builder.get_insert_block().unwrap();\n\n        // bool -> value\n        self.builder.position_at_end(is_bool);\n        let bool_result = self\n            .builder\n            .build_int_truncate(data, self.types.bool_type, \"bool_val\")\n            .unwrap();\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let bool_block = self.builder.get_insert_block().unwrap();\n\n        // int -> value != 0\n        self.builder.position_at_end(is_int);\n        let zero = self.types.i64_type.const_int(0, false);\n        let int_result = self\n            .builder\n            .build_int_compare(IntPredicate::NE, data, zero, \"int_truthy\")\n            .unwrap();\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // other -> true\n        self.builder.position_at_end(is_other);\n        let other_result = self.types.bool_type.const_int(1, false);\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let other_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.bool_type, \"truthy\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&nil_result, nil_block),\n            (&bool_result, bool_block),\n            (&int_result, int_block),\n            (&other_result, other_block),\n        ]);\n\n        Ok(phi.as_basic_value().into_int_value())\n    }\n\n    /// Compile a condition expression directly to i1 boolean, bypassing MdhValue boxing.\n    /// This is an optimization for loop conditions and if statements.\n    /// Returns None if the expression can't be optimized (falls back to is_truthy).\n    fn compile_condition_direct(\n        &mut self,\n        expr: &Expr,\n    ) -> Result<Option<IntValue<'ctx>>, HaversError> {\n        match expr {\n            // Comparison operations can return i1 directly\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                match operator {\n                    // For equality comparisons, check if either operand could be a string\n                    // If so, fall back to full compilation which uses strcmp\n                    BinaryOp::Equal | BinaryOp::NotEqual => {\n                        let left_type = self.infer_expr_type(left);\n                        let right_type = self.infer_expr_type(right);\n                        // Only use fast path if both are known to be non-string types\n                        if left_type == VarType::String\n                            || right_type == VarType::String\n                            || left_type == VarType::Unknown\n                            || right_type == VarType::Unknown\n                        {\n                            // Fall back to full compilation with strcmp support\n                            return Ok(None);\n                        }\n                        // Both are known non-string types, safe to compare data directly\n                        let get_int_data =\n                            |s: &mut Self, expr: &Expr| -> Result<IntValue<'ctx>, HaversError> {\n                                if let Some(int_val) = s.compile_int_expr(expr)? {\n                                    return Ok(int_val);\n                                }\n                                let val = s.compile_expr(expr)?;\n                                s.extract_data(val)\n                            };\n                        let left_data = get_int_data(self, left)?;\n                        let right_data = get_int_data(self, right)?;\n                        let pred = match operator {\n                            BinaryOp::Equal => IntPredicate::EQ,\n                            BinaryOp::NotEqual => IntPredicate::NE,\n                            _ => unreachable!(),\n                        };\n                        let result = self\n                            .builder\n                            .build_int_compare(pred, left_data, right_data, \"cmp_direct\")\n                            .unwrap();\n                        Ok(Some(result))\n                    }\n                    BinaryOp::Less\n                    | BinaryOp::LessEqual\n                    | BinaryOp::Greater\n                    | BinaryOp::GreaterEqual => {\n                        // Helper to get i64 value from expression (shadow or extract)\n                        let get_int_data =\n                            |s: &mut Self, expr: &Expr| -> Result<IntValue<'ctx>, HaversError> {\n                                // First try int shadow path\n                                if let Some(int_val) = s.compile_int_expr(expr)? {\n                                    return Ok(int_val);\n                                }\n                                // Fall back to MdhValue extraction\n                                let val = s.compile_expr(expr)?;\n                                s.extract_data(val)\n                            };\n\n                        let left_data = get_int_data(self, left)?;\n                        let right_data = get_int_data(self, right)?;\n\n                        let pred = match operator {\n                            BinaryOp::Less => IntPredicate::SLT,\n                            BinaryOp::LessEqual => IntPredicate::SLE,\n                            BinaryOp::Greater => IntPredicate::SGT,\n                            BinaryOp::GreaterEqual => IntPredicate::SGE,\n                            _ => unreachable!(),\n                        };\n\n                        let result = self\n                            .builder\n                            .build_int_compare(pred, left_data, right_data, \"cmp_direct\")\n                            .unwrap();\n                        Ok(Some(result))\n                    }\n                    _ => Ok(None), // Other binary ops need full compilation\n                }\n            }\n            // Boolean literals\n            Expr::Literal {\n                value: Literal::Bool(b),\n                ..\n            } => {\n                let result = self\n                    .types\n                    .bool_type\n                    .const_int(if *b { 1 } else { 0 }, false);\n                Ok(Some(result))\n            }\n            // Boolean variable - extract and compare to 0\n            Expr::Variable { name, .. } => {\n                if self.var_types.get(name) == Some(&VarType::Bool) {\n                    let val = self.compile_expr(expr)?;\n                    let data = self.extract_data(val)?;\n                    let zero = self.types.i64_type.const_int(0, false);\n                    let result = self\n                        .builder\n                        .build_int_compare(IntPredicate::NE, data, zero, \"bool_truthy\")\n                        .unwrap();\n                    Ok(Some(result))\n                } else {\n                    Ok(None)\n                }\n            }\n            // Index expression - optimize to only load data field (skip tag)\n            Expr::Index { object, index, .. } => {\n                // Check if we can use the fast path\n                let obj_type = self.infer_expr_type(object);\n                let idx_type = self.infer_expr_type(index);\n\n                if obj_type == VarType::List && idx_type == VarType::Int {\n                    // Ultra-fast path: directly load only the data field (8 bytes instead of 16)\n                    let list_data = if let Expr::Variable { name, .. } = object.as_ref() {\n                        if let Some(&shadow) = self.list_ptr_shadows.get(name) {\n                            self.builder\n                                .build_load(self.types.i64_type, shadow, \"list_ptr_cond\")\n                                .unwrap()\n                                .into_int_value()\n                        } else {\n                            let obj_val = self.compile_expr(object)?;\n                            self.extract_data(obj_val)?\n                        }\n                    } else {\n                        let obj_val = self.compile_expr(object)?;\n                        self.extract_data(obj_val)?\n                    };\n\n                    let idx_i64 = if let Some(i) = self.compile_int_expr(index)? {\n                        i\n                    } else {\n                        let idx_val = self.compile_expr(index)?;\n                        self.extract_data(idx_val)?\n                    };\n\n                    // List layout: [cap:i64][len:i64][elem0:{i8,i64}][elem1:{i8,i64}]...\n                    // Element layout: {tag:i8, data:i64} - data is at offset 8 from element start\n                    let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n                    let list_ptr = self\n                        .builder\n                        .build_int_to_ptr(list_data, i64_ptr_type, \"lp_cond\")\n                        .unwrap();\n\n                    // Skip header (16 bytes = 2 i64s) to reach elements\n                    let two = self.types.i64_type.const_int(2, false);\n                    let elements_base = unsafe {\n                        self.builder\n                            .build_gep(self.types.i64_type, list_ptr, &[two], \"eb_cond\")\n                            .unwrap()\n                    };\n\n                    // Each element is 16 bytes. To reach element[idx].data, we need:\n                    // base + idx*16 + 8 (for data offset within element)\n                    // In i64 terms: base + idx*2 + 1\n                    let idx_times_2 = self\n                        .builder\n                        .build_int_mul(idx_i64, two, \"idx2_cond\")\n                        .unwrap();\n                    let one = self.types.i64_type.const_int(1, false);\n                    let data_offset = self\n                        .builder\n                        .build_int_add(idx_times_2, one, \"do_cond\")\n                        .unwrap();\n                    let data_ptr = unsafe {\n                        self.builder\n                            .build_gep(\n                                self.types.i64_type,\n                                elements_base,\n                                &[data_offset],\n                                \"dp_cond\",\n                            )\n                            .unwrap()\n                    };\n\n                    // Load just the data field (8 bytes instead of 16)\n                    let data = self\n                        .builder\n                        .build_load(self.types.i64_type, data_ptr, \"data_cond\")\n                        .unwrap()\n                        .into_int_value();\n                    let zero = self.types.i64_type.const_int(0, false);\n                    let result = self\n                        .builder\n                        .build_int_compare(IntPredicate::NE, data, zero, \"truthy_cond\")\n                        .unwrap();\n                    return Ok(Some(result));\n                }\n\n                // Fallback: full compile\n                let val = self.compile_expr(expr)?;\n                let data = self.extract_data(val)?;\n                let zero = self.types.i64_type.const_int(0, false);\n                let result = self\n                    .builder\n                    .build_int_compare(IntPredicate::NE, data, zero, \"index_truthy\")\n                    .unwrap();\n                Ok(Some(result))\n            }\n            _ => Ok(None),\n        }\n    }\n\n    /// Infer the type of an expression for optimization purposes\n    fn infer_expr_type(&self, expr: &Expr) -> VarType {\n        match expr {\n            Expr::Literal { value, .. } => match value {\n                Literal::Integer(_) => VarType::Int,\n                Literal::Float(_) => VarType::Float,\n                Literal::String(_) => VarType::String,\n                Literal::Bool(_) => VarType::Bool,\n                Literal::Nil => VarType::Unknown,\n            },\n            Expr::Variable { name, .. } => self\n                .var_types\n                .get(name)\n                .copied()\n                .unwrap_or(VarType::Unknown),\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => match operator {\n                BinaryOp::Add => {\n                    let lt = self.infer_expr_type(left);\n                    let rt = self.infer_expr_type(right);\n                    if lt == VarType::Int && rt == VarType::Int {\n                        VarType::Int\n                    } else if lt == VarType::Float || rt == VarType::Float {\n                        VarType::Float\n                    } else if lt == VarType::String && rt == VarType::String {\n                        VarType::String\n                    } else {\n                        VarType::Unknown\n                    }\n                }\n                BinaryOp::Subtract | BinaryOp::Multiply | BinaryOp::Divide | BinaryOp::Modulo => {\n                    let lt = self.infer_expr_type(left);\n                    let rt = self.infer_expr_type(right);\n                    if lt == VarType::Int && rt == VarType::Int {\n                        VarType::Int\n                    } else if lt == VarType::Float || rt == VarType::Float {\n                        VarType::Float\n                    } else {\n                        VarType::Unknown\n                    }\n                }\n                BinaryOp::Less\n                | BinaryOp::LessEqual\n                | BinaryOp::Greater\n                | BinaryOp::GreaterEqual\n                | BinaryOp::Equal\n                | BinaryOp::NotEqual => VarType::Bool,\n            },\n            Expr::List { .. } => VarType::List,\n            Expr::Unary { operand, .. } => self.infer_expr_type(operand),\n            _ => VarType::Unknown,\n        }\n    }\n\n    /// Compile an integer expression directly to i64, bypassing MdhValue boxing.\n    /// Returns None if the expression can't be compiled as pure integer.\n    fn compile_int_expr(&mut self, expr: &Expr) -> Result<Option<IntValue<'ctx>>, HaversError> {\n        match expr {\n            // Integer literal\n            Expr::Literal {\n                value: Literal::Integer(n),\n                ..\n            } => Ok(Some(self.types.i64_type.const_int(*n as u64, true))),\n\n            // Variable with int shadow\n            Expr::Variable { name, .. } => {\n                if let Some(&shadow) = self.int_shadows.get(name) {\n                    let val = self\n                        .builder\n                        .build_load(self.types.i64_type, shadow, &format!(\"{}_i64\", name))\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to load shadow: {}\", e))\n                        })?;\n                    Ok(Some(val.into_int_value()))\n                } else if self.var_types.get(name) == Some(&VarType::Int) {\n                    // Known int but no shadow - extract from MdhValue\n                    if let Some(&alloca) = self.variables.get(name) {\n                        let val = self\n                            .builder\n                            .build_load(self.types.value_type, alloca, name)\n                            .map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to load: {}\", e))\n                            })?;\n                        let data = self.extract_data(val)?;\n                        Ok(Some(data))\n                    } else {\n                        Ok(None)\n                    }\n                } else {\n                    Ok(None)\n                }\n            }\n\n            // Binary operations on integers\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                let lt = self.infer_expr_type(left);\n                let rt = self.infer_expr_type(right);\n\n                if lt == VarType::Int && rt == VarType::Int {\n                    match operator {\n                        BinaryOp::Add\n                        | BinaryOp::Subtract\n                        | BinaryOp::Multiply\n                        | BinaryOp::Divide\n                        | BinaryOp::Modulo => {\n                            let left_i64 = self.compile_int_expr(left)?;\n                            let right_i64 = self.compile_int_expr(right)?;\n\n                            if let (Some(l), Some(r)) = (left_i64, right_i64) {\n                                let result = match operator {\n                                    BinaryOp::Add => {\n                                        self.builder.build_int_add(l, r, \"add_i64\").unwrap()\n                                    }\n                                    BinaryOp::Subtract => {\n                                        self.builder.build_int_sub(l, r, \"sub_i64\").unwrap()\n                                    }\n                                    BinaryOp::Multiply => {\n                                        self.builder.build_int_mul(l, r, \"mul_i64\").unwrap()\n                                    }\n                                    BinaryOp::Divide => {\n                                        self.builder.build_int_signed_div(l, r, \"div_i64\").unwrap()\n                                    }\n                                    BinaryOp::Modulo => {\n                                        self.builder.build_int_signed_rem(l, r, \"mod_i64\").unwrap()\n                                    }\n                                    _ => unreachable!(),\n                                };\n                                return Ok(Some(result));\n                            }\n                        }\n                        _ => {}\n                    }\n                }\n                Ok(None)\n            }\n\n            _ => Ok(None),\n        }\n    }\n\n    /// Sync all int shadows back to their MdhValue counterparts\n    /// Called at loop exit to ensure variables are up-to-date\n    fn sync_all_shadows(&mut self) -> Result<(), HaversError> {\n        // Collect names first to avoid borrow issues\n        let shadow_names: Vec<String> = self.int_shadows.keys().cloned().collect();\n\n        for name in shadow_names {\n            if let (Some(&shadow), Some(&alloca)) =\n                (self.int_shadows.get(&name), self.variables.get(&name))\n            {\n                // Load from shadow\n                let int_val = self\n                    .builder\n                    .build_load(self.types.i64_type, shadow, &format!(\"{}_sync\", name))\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to load shadow: {}\", e))\n                    })?\n                    .into_int_value();\n                // Box to MdhValue\n                let boxed = self.make_int(int_val)?;\n                // Store to MdhValue\n                self.builder\n                    .build_store(alloca, boxed)\n                    .map_err(|e| HaversError::CompileError(format!(\"Failed to store: {}\", e)))?;\n            }\n        }\n        Ok(())\n    }\n\n    // ========== Inline Arithmetic ==========\n\n    /// Add two values with type checking\n    fn inline_add(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_tag = self.extract_tag(left)?;\n        let right_tag = self.extract_tag(right)?;\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n\n        let function = self.current_function.unwrap();\n        let int_int = self.context.append_basic_block(function, \"add_int_int\");\n        let float_case = self.context.append_basic_block(function, \"add_float\");\n        let string_case = self.context.append_basic_block(function, \"add_string\");\n        let error_case = self.context.append_basic_block(function, \"add_error\");\n        let merge = self.context.append_basic_block(function, \"add_merge\");\n\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n        let string_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::String.as_u8() as u64, false);\n\n        // Check if both are ints\n        let left_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, int_tag, \"l_int\")\n            .unwrap();\n        let right_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, int_tag, \"r_int\")\n            .unwrap();\n        let both_int = self\n            .builder\n            .build_and(left_is_int, right_is_int, \"both_int\")\n            .unwrap();\n\n        // Check if either is float\n        let left_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, float_tag, \"l_float\")\n            .unwrap();\n        let right_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, float_tag, \"r_float\")\n            .unwrap();\n        let either_float = self\n            .builder\n            .build_or(left_is_float, right_is_float, \"either_float\")\n            .unwrap();\n\n        // Check if both are strings\n        let left_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, string_tag, \"l_str\")\n            .unwrap();\n        let right_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, string_tag, \"r_str\")\n            .unwrap();\n        let both_string = self\n            .builder\n            .build_and(left_is_string, right_is_string, \"both_str\")\n            .unwrap();\n\n        // Branch based on types\n        let check_float = self.context.append_basic_block(function, \"check_float\");\n        let check_string = self.context.append_basic_block(function, \"check_string\");\n\n        self.builder\n            .build_conditional_branch(both_int, int_int, check_float)\n            .unwrap();\n\n        self.builder.position_at_end(check_float);\n        self.builder\n            .build_conditional_branch(either_float, float_case, check_string)\n            .unwrap();\n\n        self.builder.position_at_end(check_string);\n        self.builder\n            .build_conditional_branch(both_string, string_case, error_case)\n            .unwrap();\n\n        // int + int\n        self.builder.position_at_end(int_int);\n        let int_sum = self\n            .builder\n            .build_int_add(left_data, right_data, \"sum\")\n            .unwrap();\n        let int_result = self.make_int(int_sum)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float + float (or int+float)\n        self.builder.position_at_end(float_case);\n        // Convert both to float\n        let left_f = self\n            .builder\n            .build_select(\n                left_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(left_data, self.types.f64_type, \"lf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(left_data, self.types.f64_type, \"li2f\")\n                        .unwrap(),\n                ),\n                \"left_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let right_f = self\n            .builder\n            .build_select(\n                right_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(right_data, self.types.f64_type, \"rf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(right_data, self.types.f64_type, \"ri2f\")\n                        .unwrap(),\n                ),\n                \"right_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let float_sum = self\n            .builder\n            .build_float_add(left_f, right_f, \"fsum\")\n            .unwrap();\n        let float_result = self.make_float(float_sum)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // string + string (concatenation)\n        self.builder.position_at_end(string_case);\n        let left_ptr = self\n            .builder\n            .build_int_to_ptr(\n                left_data,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"lstr\",\n            )\n            .unwrap();\n        let right_ptr = self\n            .builder\n            .build_int_to_ptr(\n                right_data,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"rstr\",\n            )\n            .unwrap();\n\n        // Get lengths\n        let left_len = self\n            .builder\n            .build_call(self.libc.strlen, &[left_ptr.into()], \"llen\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let right_len = self\n            .builder\n            .build_call(self.libc.strlen, &[right_ptr.into()], \"rlen\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Allocate new string (len1 + len2 + 1)\n        let total_len = self\n            .builder\n            .build_int_add(left_len, right_len, \"total\")\n            .unwrap();\n        let one = self.types.i64_type.const_int(1, false);\n        let alloc_size = self\n            .builder\n            .build_int_add(total_len, one, \"alloc_size\")\n            .unwrap();\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[alloc_size.into()], \"new_str\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy strings using memcpy (faster than strcpy/strcat since we know lengths)\n        // memcpy(new_str, left_ptr, left_len)\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[new_str.into(), left_ptr.into(), left_len.into()],\n                \"\",\n            )\n            .unwrap();\n        // memcpy(new_str + left_len, right_ptr, right_len + 1) - +1 for null terminator\n        let dest_offset = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_str, &[left_len], \"dest_offset\")\n                .unwrap()\n        };\n        let right_len_plus_one = self\n            .builder\n            .build_int_add(right_len, one, \"rlen_plus_one\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[\n                    dest_offset.into(),\n                    right_ptr.into(),\n                    right_len_plus_one.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n\n        let string_result = self.make_string(new_str)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let string_block = self.builder.get_insert_block().unwrap();\n\n        // Error case - just return nil for now (should be runtime error)\n        self.builder.position_at_end(error_case);\n        let error_result = self.make_nil();\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let error_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"add_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&int_result, int_block),\n            (&float_result, float_block),\n            (&string_result, string_block),\n            (&error_result, error_block),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Subtract two values\n    fn inline_sub(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_tag = self.extract_tag(left)?;\n        let right_tag = self.extract_tag(right)?;\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n\n        let function = self.current_function.unwrap();\n        let int_int = self.context.append_basic_block(function, \"sub_int\");\n        let float_case = self.context.append_basic_block(function, \"sub_float\");\n        let merge = self.context.append_basic_block(function, \"sub_merge\");\n\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n\n        let left_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, int_tag, \"l_int\")\n            .unwrap();\n        let right_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, int_tag, \"r_int\")\n            .unwrap();\n        let both_int = self\n            .builder\n            .build_and(left_is_int, right_is_int, \"both_int\")\n            .unwrap();\n\n        self.builder\n            .build_conditional_branch(both_int, int_int, float_case)\n            .unwrap();\n\n        // int - int\n        self.builder.position_at_end(int_int);\n        let int_diff = self\n            .builder\n            .build_int_sub(left_data, right_data, \"diff\")\n            .unwrap();\n        let int_result = self.make_int(int_diff)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float case\n        self.builder.position_at_end(float_case);\n        let left_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, float_tag, \"lf\")\n            .unwrap();\n        let right_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, float_tag, \"rf\")\n            .unwrap();\n        let left_f = self\n            .builder\n            .build_select(\n                left_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(left_data, self.types.f64_type, \"lf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(left_data, self.types.f64_type, \"li2f\")\n                        .unwrap(),\n                ),\n                \"left_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let right_f = self\n            .builder\n            .build_select(\n                right_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(right_data, self.types.f64_type, \"rf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(right_data, self.types.f64_type, \"ri2f\")\n                        .unwrap(),\n                ),\n                \"right_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let float_diff = self\n            .builder\n            .build_float_sub(left_f, right_f, \"fdiff\")\n            .unwrap();\n        let float_result = self.make_float(float_diff)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"sub_result\")\n            .unwrap();\n        phi.add_incoming(&[(&int_result, int_block), (&float_result, float_block)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Multiply two values\n    fn inline_mul(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_tag = self.extract_tag(left)?;\n        let right_tag = self.extract_tag(right)?;\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n\n        let function = self.current_function.unwrap();\n        let int_int = self.context.append_basic_block(function, \"mul_int\");\n        let float_case = self.context.append_basic_block(function, \"mul_float\");\n        let merge = self.context.append_basic_block(function, \"mul_merge\");\n\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n\n        let left_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, int_tag, \"l_int\")\n            .unwrap();\n        let right_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, int_tag, \"r_int\")\n            .unwrap();\n        let both_int = self\n            .builder\n            .build_and(left_is_int, right_is_int, \"both_int\")\n            .unwrap();\n\n        self.builder\n            .build_conditional_branch(both_int, int_int, float_case)\n            .unwrap();\n\n        // int * int\n        self.builder.position_at_end(int_int);\n        let int_prod = self\n            .builder\n            .build_int_mul(left_data, right_data, \"prod\")\n            .unwrap();\n        let int_result = self.make_int(int_prod)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float case\n        self.builder.position_at_end(float_case);\n        let left_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, float_tag, \"lf\")\n            .unwrap();\n        let right_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, float_tag, \"rf\")\n            .unwrap();\n        let left_f = self\n            .builder\n            .build_select(\n                left_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(left_data, self.types.f64_type, \"lf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(left_data, self.types.f64_type, \"li2f\")\n                        .unwrap(),\n                ),\n                \"left_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let right_f = self\n            .builder\n            .build_select(\n                right_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(right_data, self.types.f64_type, \"rf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(right_data, self.types.f64_type, \"ri2f\")\n                        .unwrap(),\n                ),\n                \"right_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let float_prod = self\n            .builder\n            .build_float_mul(left_f, right_f, \"fprod\")\n            .unwrap();\n        let float_result = self.make_float(float_prod)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"mul_result\")\n            .unwrap();\n        phi.add_incoming(&[(&int_result, int_block), (&float_result, float_block)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Divide two values\n    fn inline_div(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_tag = self.extract_tag(left)?;\n        let right_tag = self.extract_tag(right)?;\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n\n        let function = self.current_function.unwrap();\n        let int_int = self.context.append_basic_block(function, \"div_int\");\n        let float_case = self.context.append_basic_block(function, \"div_float\");\n        let merge = self.context.append_basic_block(function, \"div_merge\");\n\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n\n        let left_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, int_tag, \"l_int\")\n            .unwrap();\n        let right_is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, int_tag, \"r_int\")\n            .unwrap();\n        let both_int = self\n            .builder\n            .build_and(left_is_int, right_is_int, \"both_int\")\n            .unwrap();\n\n        self.builder\n            .build_conditional_branch(both_int, int_int, float_case)\n            .unwrap();\n\n        // int / int\n        self.builder.position_at_end(int_int);\n        let int_quot = self\n            .builder\n            .build_int_signed_div(left_data, right_data, \"quot\")\n            .unwrap();\n        let int_result = self.make_int(int_quot)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float case\n        self.builder.position_at_end(float_case);\n        let left_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, float_tag, \"lf\")\n            .unwrap();\n        let right_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, float_tag, \"rf\")\n            .unwrap();\n        let left_f = self\n            .builder\n            .build_select(\n                left_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(left_data, self.types.f64_type, \"lf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(left_data, self.types.f64_type, \"li2f\")\n                        .unwrap(),\n                ),\n                \"left_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let right_f = self\n            .builder\n            .build_select(\n                right_is_float,\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_bitcast(right_data, self.types.f64_type, \"rf\")\n                        .unwrap()\n                        .into_float_value(),\n                ),\n                BasicValueEnum::FloatValue(\n                    self.builder\n                        .build_signed_int_to_float(right_data, self.types.f64_type, \"ri2f\")\n                        .unwrap(),\n                ),\n                \"right_as_float\",\n            )\n            .unwrap()\n            .into_float_value();\n        let float_quot = self\n            .builder\n            .build_float_div(left_f, right_f, \"fquot\")\n            .unwrap();\n        let float_result = self.make_float(float_quot)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"div_result\")\n            .unwrap();\n        phi.add_incoming(&[(&int_result, int_block), (&float_result, float_block)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Modulo two values\n    fn inline_mod(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        let rem = self\n            .builder\n            .build_int_signed_rem(left_data, right_data, \"rem\")\n            .unwrap();\n        self.make_int(rem)\n    }\n\n    /// Compare two values for equality\n    fn inline_eq(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_tag = self.extract_tag(left)?;\n        let right_tag = self.extract_tag(right)?;\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n\n        // Tags must match first\n        let tags_equal = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, right_tag, \"tags_eq\")\n            .unwrap();\n\n        // Check if both are strings (tag == 4)\n        let string_tag = self.types.i8_type.const_int(4, false);\n        let left_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, string_tag, \"left_is_str\")\n            .unwrap();\n        let right_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, string_tag, \"right_is_str\")\n            .unwrap();\n        let both_strings = self\n            .builder\n            .build_and(left_is_string, right_is_string, \"both_str\")\n            .unwrap();\n\n        // Create basic blocks for string vs non-string comparison\n        let function = self.current_function.unwrap();\n        let cmp_string = self.context.append_basic_block(function, \"cmp_string\");\n        let cmp_other = self.context.append_basic_block(function, \"cmp_other\");\n        let cmp_merge = self.context.append_basic_block(function, \"cmp_merge\");\n\n        self.builder\n            .build_conditional_branch(both_strings, cmp_string, cmp_other)\n            .unwrap();\n\n        // String comparison: use strcmp\n        self.builder.position_at_end(cmp_string);\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let left_str = self\n            .builder\n            .build_int_to_ptr(left_data, i8_ptr_type, \"left_str\")\n            .unwrap();\n        let right_str = self\n            .builder\n            .build_int_to_ptr(right_data, i8_ptr_type, \"right_str\")\n            .unwrap();\n        let strcmp_result = self\n            .builder\n            .build_call(\n                self.libc.strcmp,\n                &[left_str.into(), right_str.into()],\n                \"strcmp_res\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let zero = self.types.i32_type.const_int(0, false);\n        let str_equal = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, strcmp_result, zero, \"str_eq\")\n            .unwrap();\n        self.builder.build_unconditional_branch(cmp_merge).unwrap();\n        let string_block = self.builder.get_insert_block().unwrap();\n\n        // Non-string comparison: compare data directly\n        self.builder.position_at_end(cmp_other);\n        let data_equal = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_data, right_data, \"data_eq\")\n            .unwrap();\n        // Both tags and data must match for non-strings\n        let other_equal = self\n            .builder\n            .build_and(tags_equal, data_equal, \"other_eq\")\n            .unwrap();\n        self.builder.build_unconditional_branch(cmp_merge).unwrap();\n        let other_block = self.builder.get_insert_block().unwrap();\n\n        // Merge results\n        self.builder.position_at_end(cmp_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.bool_type, \"eq_result\")\n            .unwrap();\n        phi.add_incoming(&[(&str_equal, string_block), (&other_equal, other_block)]);\n        let result = phi.as_basic_value().into_int_value();\n\n        self.make_bool(result)\n    }\n\n    /// Compare two values for inequality\n    fn inline_ne(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Use inline_eq and invert the result\n        let eq_result = self.inline_eq(left, right)?;\n        // Extract the bool data (0 or 1) and truncate to i1\n        let eq_data = self.extract_data(eq_result)?;\n        let eq_bool = self\n            .builder\n            .build_int_truncate(eq_data, self.types.bool_type, \"eq_as_bool\")\n            .unwrap();\n        let result = self.builder.build_not(eq_bool, \"ne\").unwrap();\n        self.make_bool(result)\n    }\n\n    /// Compare two values: less than\n    fn inline_lt(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        let result = self\n            .builder\n            .build_int_compare(IntPredicate::SLT, left_data, right_data, \"lt\")\n            .unwrap();\n        self.make_bool(result)\n    }\n\n    /// Compare two values: less than or equal\n    fn inline_le(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        let result = self\n            .builder\n            .build_int_compare(IntPredicate::SLE, left_data, right_data, \"le\")\n            .unwrap();\n        self.make_bool(result)\n    }\n\n    /// Compare two values: greater than\n    fn inline_gt(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        let result = self\n            .builder\n            .build_int_compare(IntPredicate::SGT, left_data, right_data, \"gt\")\n            .unwrap();\n        self.make_bool(result)\n    }\n\n    /// Compare two values: greater than or equal\n    fn inline_ge(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        let result = self\n            .builder\n            .build_int_compare(IntPredicate::SGE, left_data, right_data, \"ge\")\n            .unwrap();\n        self.make_bool(result)\n    }\n\n    /// Check if a value is truthy (returns raw i1 bool for conditionals)\n    fn inline_is_truthy(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<IntValue<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        // Value is truthy if:\n        // - Bool: data != 0\n        // - Int: data != 0\n        // - Float: data != 0 (bit pattern)\n        // - String: len > 0\n        // - List: len > 0\n        // - Nil: false\n        // For simplicity, we check if data != 0 (works for most cases)\n        let nil_tag = self.types.i8_type.const_int(0, false);\n        let is_nil = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, tag, nil_tag, \"is_nil\")\n            .unwrap();\n\n        let zero = self.types.i64_type.const_int(0, false);\n        let data_nonzero = self\n            .builder\n            .build_int_compare(IntPredicate::NE, data, zero, \"data_nonzero\")\n            .unwrap();\n\n        // Truthy if not nil AND data is non-zero\n        let not_nil = self.builder.build_not(is_nil, \"not_nil\").unwrap();\n        let is_truthy = self\n            .builder\n            .build_and(not_nil, data_nonzero, \"is_truthy\")\n            .unwrap();\n\n        Ok(is_truthy)\n    }\n\n    /// Compare two values for equality (returns raw i1 bool for conditionals)\n    fn inline_eq_raw(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<IntValue<'ctx>, HaversError> {\n        let left_tag = self.extract_tag(left)?;\n        let right_tag = self.extract_tag(right)?;\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n\n        // Tags must match first\n        let tags_equal = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, right_tag, \"tags_eq\")\n            .unwrap();\n\n        // Check if both are strings (tag == 4)\n        let string_tag = self.types.i8_type.const_int(4, false);\n        let left_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_tag, string_tag, \"left_is_str\")\n            .unwrap();\n        let right_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, right_tag, string_tag, \"right_is_str\")\n            .unwrap();\n        let both_strings = self\n            .builder\n            .build_and(left_is_string, right_is_string, \"both_str\")\n            .unwrap();\n\n        // Create basic blocks for string vs non-string comparison\n        let function = self.current_function.unwrap();\n        let cmp_string = self.context.append_basic_block(function, \"cmp_string_raw\");\n        let cmp_other = self.context.append_basic_block(function, \"cmp_other_raw\");\n        let cmp_merge = self.context.append_basic_block(function, \"cmp_merge_raw\");\n\n        self.builder\n            .build_conditional_branch(both_strings, cmp_string, cmp_other)\n            .unwrap();\n\n        // String comparison: use strcmp\n        self.builder.position_at_end(cmp_string);\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let left_str = self\n            .builder\n            .build_int_to_ptr(left_data, i8_ptr_type, \"left_str\")\n            .unwrap();\n        let right_str = self\n            .builder\n            .build_int_to_ptr(right_data, i8_ptr_type, \"right_str\")\n            .unwrap();\n        let strcmp_result = self\n            .builder\n            .build_call(\n                self.libc.strcmp,\n                &[left_str.into(), right_str.into()],\n                \"strcmp_res\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let zero = self.types.i32_type.const_int(0, false);\n        let str_equal = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, strcmp_result, zero, \"str_eq\")\n            .unwrap();\n        self.builder.build_unconditional_branch(cmp_merge).unwrap();\n        let string_block = self.builder.get_insert_block().unwrap();\n\n        // Non-string comparison: compare data directly\n        self.builder.position_at_end(cmp_other);\n        let data_equal = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, left_data, right_data, \"data_eq\")\n            .unwrap();\n        // Both tags and data must match for non-strings\n        let other_equal = self\n            .builder\n            .build_and(tags_equal, data_equal, \"other_eq\")\n            .unwrap();\n        self.builder.build_unconditional_branch(cmp_merge).unwrap();\n        let other_block = self.builder.get_insert_block().unwrap();\n\n        // Merge results\n        self.builder.position_at_end(cmp_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.bool_type, \"eq_result_raw\")\n            .unwrap();\n        phi.add_incoming(&[(&str_equal, string_block), (&other_equal, other_block)]);\n\n        Ok(phi.as_basic_value().into_int_value())\n    }\n\n    /// Compare two values: greater than or equal (returns raw i1 bool)\n    fn inline_ge_raw(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<IntValue<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        Ok(self\n            .builder\n            .build_int_compare(IntPredicate::SGE, left_data, right_data, \"ge_raw\")\n            .unwrap())\n    }\n\n    /// Compare two values: less than (returns raw i1 bool)\n    fn inline_lt_raw(\n        &mut self,\n        left: BasicValueEnum<'ctx>,\n        right: BasicValueEnum<'ctx>,\n    ) -> Result<IntValue<'ctx>, HaversError> {\n        let left_data = self.extract_data(left)?;\n        let right_data = self.extract_data(right)?;\n        Ok(self\n            .builder\n            .build_int_compare(IntPredicate::SLT, left_data, right_data, \"lt_raw\")\n            .unwrap())\n    }\n\n    /// Negate a value\n    fn inline_neg(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n\n        let is_int = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, tag, int_tag, \"is_int\")\n            .unwrap();\n\n        let function = self.current_function.unwrap();\n        let neg_int = self.context.append_basic_block(function, \"neg_int\");\n        let neg_float = self.context.append_basic_block(function, \"neg_float\");\n        let merge = self.context.append_basic_block(function, \"neg_merge\");\n\n        self.builder\n            .build_conditional_branch(is_int, neg_int, neg_float)\n            .unwrap();\n\n        // Negate int\n        self.builder.position_at_end(neg_int);\n        let neg_data = self.builder.build_int_neg(data, \"neg\").unwrap();\n        let int_result = self.make_int(neg_data)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // Negate float (treat anything non-int as float for simplicity)\n        self.builder.position_at_end(neg_float);\n        let is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, tag, float_tag, \"is_float\")\n            .unwrap();\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"f\")\n            .unwrap()\n            .into_float_value();\n        let neg_float_val = self.builder.build_float_neg(float_val, \"fneg\").unwrap();\n        // For non-float, just return 0\n        let zero_float = self.types.f64_type.const_float(0.0);\n        let selected_float = self\n            .builder\n            .build_select(is_float, neg_float_val, zero_float, \"sel_float\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_float_value();\n        let float_result = self.make_float(selected_float)?;\n        self.builder.build_unconditional_branch(merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"neg_result\")\n            .unwrap();\n        phi.add_incoming(&[(&int_result, int_block), (&float_result, float_block)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Logical not\n    fn inline_not(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let truthy = self.is_truthy(val)?;\n        let result = self.builder.build_not(truthy, \"not\").unwrap();\n        self.make_bool(result)\n    }\n\n    // ========== Inline Print (blether) ==========\n\n    /// Print a value using printf\n    fn inline_blether(&mut self, val: BasicValueEnum<'ctx>) -> Result<(), HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let function = self.current_function.unwrap();\n        let print_nil = self.context.append_basic_block(function, \"print_nil\");\n        let print_bool = self.context.append_basic_block(function, \"print_bool\");\n        let print_int = self.context.append_basic_block(function, \"print_int\");\n        let print_float = self.context.append_basic_block(function, \"print_float\");\n        let print_string = self.context.append_basic_block(function, \"print_string\");\n        let print_default = self.context.append_basic_block(function, \"print_default\");\n        let print_done = self.context.append_basic_block(function, \"print_done\");\n\n        let nil_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Nil.as_u8() as u64, false);\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n        let string_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::String.as_u8() as u64, false);\n\n        self.builder\n            .build_switch(\n                tag,\n                print_default,\n                &[\n                    (nil_tag, print_nil),\n                    (bool_tag, print_bool),\n                    (int_tag, print_int),\n                    (float_tag, print_float),\n                    (string_tag, print_string),\n                ],\n            )\n            .unwrap();\n\n        // Print nil\n        self.builder.position_at_end(print_nil);\n        let nil_str = self.get_string_ptr(self.fmt_nil);\n        self.builder\n            .build_call(self.libc.printf, &[nil_str.into()], \"\")\n            .unwrap();\n        self.builder.build_unconditional_branch(print_done).unwrap();\n\n        // Print bool\n        self.builder.position_at_end(print_bool);\n        let true_str = self.get_string_ptr(self.fmt_true);\n        let false_str = self.get_string_ptr(self.fmt_false);\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_true = self\n            .builder\n            .build_int_compare(IntPredicate::NE, data, zero, \"is_true\")\n            .unwrap();\n        let bool_str = self\n            .builder\n            .build_select(is_true, true_str, false_str, \"bool_str\")\n            .unwrap();\n        self.builder\n            .build_call(self.libc.printf, &[bool_str.into()], \"\")\n            .unwrap();\n        self.builder.build_unconditional_branch(print_done).unwrap();\n\n        // Print int\n        self.builder.position_at_end(print_int);\n        let int_fmt = self.get_string_ptr(self.fmt_int);\n        self.builder\n            .build_call(self.libc.printf, &[int_fmt.into(), data.into()], \"\")\n            .unwrap();\n        self.builder.build_unconditional_branch(print_done).unwrap();\n\n        // Print float\n        self.builder.position_at_end(print_float);\n        let float_fmt = self.get_string_ptr(self.fmt_float);\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"f\")\n            .unwrap();\n        self.builder\n            .build_call(self.libc.printf, &[float_fmt.into(), float_val.into()], \"\")\n            .unwrap();\n        self.builder.build_unconditional_branch(print_done).unwrap();\n\n        // Print string\n        self.builder.position_at_end(print_string);\n        let str_fmt = self.get_string_ptr(self.fmt_string);\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(\n                data,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"str\",\n            )\n            .unwrap();\n        self.builder\n            .build_call(self.libc.printf, &[str_fmt.into(), str_ptr.into()], \"\")\n            .unwrap();\n        self.builder.build_unconditional_branch(print_done).unwrap();\n\n        // Print default (unknown type)\n        self.builder.position_at_end(print_default);\n        self.builder.build_unconditional_branch(print_done).unwrap();\n\n        // Done - print newline\n        self.builder.position_at_end(print_done);\n        let newline = self.get_string_ptr(self.fmt_newline);\n        self.builder\n            .build_call(self.libc.printf, &[newline.into()], \"\")\n            .unwrap();\n\n        Ok(())\n    }\n\n    // ========== Inline Type Conversion Functions ==========\n\n    /// Convert any value to string (tae_string)\n    fn inline_tae_string(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let function = self.current_function.unwrap();\n        let str_nil = self.context.append_basic_block(function, \"str_nil\");\n        let str_bool = self.context.append_basic_block(function, \"str_bool\");\n        let str_int = self.context.append_basic_block(function, \"str_int\");\n        let str_float = self.context.append_basic_block(function, \"str_float\");\n        let str_string = self.context.append_basic_block(function, \"str_string\");\n        let str_default = self.context.append_basic_block(function, \"str_default\");\n        let str_merge = self.context.append_basic_block(function, \"str_merge\");\n\n        let nil_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Nil.as_u8() as u64, false);\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n        let string_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::String.as_u8() as u64, false);\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n\n        let str_list = self.context.append_basic_block(function, \"str_list\");\n\n        self.builder\n            .build_switch(\n                tag,\n                str_default,\n                &[\n                    (nil_tag, str_nil),\n                    (bool_tag, str_bool),\n                    (int_tag, str_int),\n                    (float_tag, str_float),\n                    (string_tag, str_string),\n                    (list_tag, str_list),\n                ],\n            )\n            .unwrap();\n\n        // nil -> \"naething\"\n        self.builder.position_at_end(str_nil);\n        let nil_str = self\n            .builder\n            .build_global_string_ptr(\"naething\", \"nil_str\")\n            .unwrap();\n        let nil_result = self.make_string(nil_str.as_pointer_value())?;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let nil_block = self.builder.get_insert_block().unwrap();\n\n        // bool -> \"aye\" or \"nae\"\n        self.builder.position_at_end(str_bool);\n        let true_str = self\n            .builder\n            .build_global_string_ptr(\"aye\", \"true_str\")\n            .unwrap();\n        let false_str = self\n            .builder\n            .build_global_string_ptr(\"nae\", \"false_str\")\n            .unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_true = self\n            .builder\n            .build_int_compare(IntPredicate::NE, data, zero, \"is_true\")\n            .unwrap();\n        let bool_ptr = self\n            .builder\n            .build_select(\n                is_true,\n                true_str.as_pointer_value(),\n                false_str.as_pointer_value(),\n                \"bool_ptr\",\n            )\n            .unwrap();\n        let bool_result = self.make_string(bool_ptr.into_pointer_value())?;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let bool_block = self.builder.get_insert_block().unwrap();\n\n        // int -> format with snprintf\n        self.builder.position_at_end(str_int);\n        // Allocate buffer for int (max 21 chars for i64 + sign + null)\n        let buf_size = self.types.i64_type.const_int(32, false);\n        let int_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[buf_size.into()], \"int_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let int_fmt = self\n            .builder\n            .build_global_string_ptr(\"%lld\", \"int_fmt\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.snprintf,\n                &[\n                    int_buf.into(),\n                    buf_size.into(),\n                    int_fmt.as_pointer_value().into(),\n                    data.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n        let int_result = self.make_string(int_buf)?;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float -> format with snprintf\n        self.builder.position_at_end(str_float);\n        let float_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[buf_size.into()], \"float_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let float_fmt = self\n            .builder\n            .build_global_string_ptr(\"%g\", \"float_fmt\")\n            .unwrap();\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"f\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.snprintf,\n                &[\n                    float_buf.into(),\n                    buf_size.into(),\n                    float_fmt.as_pointer_value().into(),\n                    float_val.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n        let float_result = self.make_string(float_buf)?;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // string -> already a string, just return it\n        self.builder.position_at_end(str_string);\n        let string_result = val;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let string_block = self.builder.get_insert_block().unwrap();\n\n        // list -> format as \"[elem, elem, ...]\"\n        self.builder.position_at_end(str_list);\n        // Get list pointer and length\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate buffer: \"[\" + up to 20 chars per element * count + \", \" separators + \"]\" + null\n        // Estimate: 25 bytes per element should be plenty\n        let const_25 = self.types.i64_type.const_int(25, false);\n        let const_3 = self.types.i64_type.const_int(3, false);\n        let buf_size_mul = self\n            .builder\n            .build_int_mul(list_len, const_25, \"buf_size_mul\")\n            .unwrap();\n        let list_buf_size = self\n            .builder\n            .build_int_add(buf_size_mul, const_3, \"list_buf_size\")\n            .unwrap();\n        let list_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[list_buf_size.into()], \"list_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Start with \"[\"\n        let open_bracket = self\n            .builder\n            .build_global_string_ptr(\"[\", \"open_bracket\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.snprintf,\n                &[\n                    list_buf.into(),\n                    list_buf_size.into(),\n                    open_bracket.as_pointer_value().into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n\n        // Loop through elements\n        let list_loop_header = self\n            .context\n            .append_basic_block(function, \"list_loop_header\");\n        let list_loop_body = self.context.append_basic_block(function, \"list_loop_body\");\n        let list_loop_end = self.context.append_basic_block(function, \"list_loop_end\");\n\n        // Index starts at 0\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx_ptr\")\n            .unwrap();\n        let zero_64 = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(idx_ptr, zero_64).unwrap();\n        self.builder\n            .build_unconditional_branch(list_loop_header)\n            .unwrap();\n\n        // Loop header: check idx < len\n        self.builder.position_at_end(list_loop_header);\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx\")\n            .unwrap()\n            .into_int_value();\n        let loop_cond = self\n            .builder\n            .build_int_compare(IntPredicate::ULT, idx, list_len, \"loop_cond\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(loop_cond, list_loop_body, list_loop_end)\n            .unwrap();\n\n        // Loop body: append element\n        self.builder.position_at_end(list_loop_body);\n\n        // If not first element, add \", \"\n        let is_first = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, idx, zero_64, \"is_first\")\n            .unwrap();\n        let sep_block = self.context.append_basic_block(function, \"sep_block\");\n        let elem_block = self.context.append_basic_block(function, \"elem_block\");\n        self.builder\n            .build_conditional_branch(is_first, elem_block, sep_block)\n            .unwrap();\n\n        self.builder.position_at_end(sep_block);\n        let comma_sep = self\n            .builder\n            .build_global_string_ptr(\", \", \"comma_sep\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.strcat,\n                &[list_buf.into(), comma_sep.as_pointer_value().into()],\n                \"\",\n            )\n            .unwrap();\n        self.builder.build_unconditional_branch(elem_block).unwrap();\n\n        self.builder.position_at_end(elem_block);\n        // Reload idx since we may have come from sep_block\n        let idx_in_elem = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_in_elem\")\n            .unwrap()\n            .into_int_value();\n        // Get element from list\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let one_64 = self.types.i64_type.const_int(1, false);\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, len_ptr, &[one_64], \"elements_base\")\n                .unwrap()\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    elements_ptr,\n                    &[idx_in_elem],\n                    \"elem_ptr\",\n                )\n                .unwrap()\n        };\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"elem_val\")\n            .unwrap();\n\n        // Extract element tag and data\n        let elem_tag = self\n            .builder\n            .build_extract_value(elem_val.into_struct_value(), 0, \"elem_tag\")\n            .unwrap()\n            .into_int_value();\n        let elem_data = self\n            .builder\n            .build_extract_value(elem_val.into_struct_value(), 1, \"elem_data\")\n            .unwrap()\n            .into_int_value();\n\n        // Store elem_data for use in blocks\n        let elem_data_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"elem_data_ptr\")\n            .unwrap();\n        self.builder.build_store(elem_data_ptr, elem_data).unwrap();\n\n        // Format based on type (float, string, or int/default)\n        let elem_is_float = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, elem_tag, float_tag, \"elem_is_float\")\n            .unwrap();\n        let elem_is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, elem_tag, string_tag, \"elem_is_string\")\n            .unwrap();\n        let elem_float_block = self\n            .context\n            .append_basic_block(function, \"elem_float_block\");\n        let elem_string_check = self\n            .context\n            .append_basic_block(function, \"elem_string_check\");\n        let elem_string_print = self\n            .context\n            .append_basic_block(function, \"elem_string_print\");\n        let elem_int_block = self.context.append_basic_block(function, \"elem_int_block\");\n        let elem_done = self.context.append_basic_block(function, \"elem_done\");\n        self.builder\n            .build_conditional_branch(elem_is_float, elem_float_block, elem_string_check)\n            .unwrap();\n\n        // Check for string\n        self.builder.position_at_end(elem_string_check);\n        self.builder\n            .build_conditional_branch(elem_is_string, elem_string_print, elem_int_block)\n            .unwrap();\n\n        // Format as string\n        self.builder.position_at_end(elem_string_print);\n        let elem_data_str = self\n            .builder\n            .build_load(self.types.i64_type, elem_data_ptr, \"elem_data_str\")\n            .unwrap()\n            .into_int_value();\n        let elem_str_ptr = self\n            .builder\n            .build_int_to_ptr(elem_data_str, i8_ptr_type, \"elem_str_ptr\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.strcat,\n                &[list_buf.into(), elem_str_ptr.into()],\n                \"\",\n            )\n            .unwrap();\n        self.builder.build_unconditional_branch(elem_done).unwrap();\n\n        // Format as float\n        self.builder.position_at_end(elem_float_block);\n        let elem_data_float = self\n            .builder\n            .build_load(self.types.i64_type, elem_data_ptr, \"elem_data_float\")\n            .unwrap()\n            .into_int_value();\n        let elem_float_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[const_25.into()], \"elem_float_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let float_fmt2 = self\n            .builder\n            .build_global_string_ptr(\"%g\", \"float_fmt2\")\n            .unwrap();\n        let elem_as_float = self\n            .builder\n            .build_bitcast(elem_data_float, self.types.f64_type, \"elem_as_float\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.snprintf,\n                &[\n                    elem_float_buf.into(),\n                    const_25.into(),\n                    float_fmt2.as_pointer_value().into(),\n                    elem_as_float.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.strcat,\n                &[list_buf.into(), elem_float_buf.into()],\n                \"\",\n            )\n            .unwrap();\n        self.builder.build_unconditional_branch(elem_done).unwrap();\n\n        // Format as int (default)\n        self.builder.position_at_end(elem_int_block);\n        let elem_data_int = self\n            .builder\n            .build_load(self.types.i64_type, elem_data_ptr, \"elem_data_int\")\n            .unwrap()\n            .into_int_value();\n        let elem_int_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[const_25.into()], \"elem_int_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let int_fmt2 = self\n            .builder\n            .build_global_string_ptr(\"%lld\", \"int_fmt2\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.snprintf,\n                &[\n                    elem_int_buf.into(),\n                    const_25.into(),\n                    int_fmt2.as_pointer_value().into(),\n                    elem_data_int.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.strcat,\n                &[list_buf.into(), elem_int_buf.into()],\n                \"\",\n            )\n            .unwrap();\n        self.builder.build_unconditional_branch(elem_done).unwrap();\n\n        // Increment and loop\n        self.builder.position_at_end(elem_done);\n        let idx_for_incr = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_for_incr\")\n            .unwrap()\n            .into_int_value();\n        let next_idx = self\n            .builder\n            .build_int_add(idx_for_incr, one_64, \"next_idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder\n            .build_unconditional_branch(list_loop_header)\n            .unwrap();\n\n        // Loop end: close bracket\n        self.builder.position_at_end(list_loop_end);\n        let close_bracket = self\n            .builder\n            .build_global_string_ptr(\"]\", \"close_bracket\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.strcat,\n                &[list_buf.into(), close_bracket.as_pointer_value().into()],\n                \"\",\n            )\n            .unwrap();\n        let list_result = self.make_string(list_buf)?;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let list_block = self.builder.get_insert_block().unwrap();\n\n        // default -> empty string\n        self.builder.position_at_end(str_default);\n        let empty_str = self\n            .builder\n            .build_global_string_ptr(\"\", \"empty_str\")\n            .unwrap();\n        let default_result = self.make_string(empty_str.as_pointer_value())?;\n        self.builder.build_unconditional_branch(str_merge).unwrap();\n        let default_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(str_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"str_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&nil_result, nil_block),\n            (&bool_result, bool_block),\n            (&int_result, int_block),\n            (&float_result, float_block),\n            (&string_result, string_block),\n            (&list_result, list_block),\n            (&default_result, default_block),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Convert any value to int (tae_int)\n    fn inline_tae_int(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let function = self.current_function.unwrap();\n        let int_nil = self.context.append_basic_block(function, \"int_nil\");\n        let int_bool = self.context.append_basic_block(function, \"int_bool\");\n        let int_int = self.context.append_basic_block(function, \"int_int\");\n        let int_float = self.context.append_basic_block(function, \"int_float\");\n        let int_default = self.context.append_basic_block(function, \"int_default\");\n        let int_merge = self.context.append_basic_block(function, \"int_merge\");\n\n        let nil_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Nil.as_u8() as u64, false);\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n\n        self.builder\n            .build_switch(\n                tag,\n                int_default,\n                &[\n                    (nil_tag, int_nil),\n                    (bool_tag, int_bool),\n                    (int_tag, int_int),\n                    (float_tag, int_float),\n                ],\n            )\n            .unwrap();\n\n        // nil -> 0\n        self.builder.position_at_end(int_nil);\n        let zero = self.types.i64_type.const_int(0, false);\n        let nil_result = self.make_int(zero)?;\n        self.builder.build_unconditional_branch(int_merge).unwrap();\n        let nil_block = self.builder.get_insert_block().unwrap();\n\n        // bool -> 0 or 1\n        self.builder.position_at_end(int_bool);\n        let bool_result = self.make_int(data)?;\n        self.builder.build_unconditional_branch(int_merge).unwrap();\n        let bool_block = self.builder.get_insert_block().unwrap();\n\n        // int -> already an int\n        self.builder.position_at_end(int_int);\n        let int_result = val;\n        self.builder.build_unconditional_branch(int_merge).unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float -> truncate to int\n        self.builder.position_at_end(int_float);\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"f\")\n            .unwrap()\n            .into_float_value();\n        let truncated = self\n            .builder\n            .build_float_to_signed_int(float_val, self.types.i64_type, \"trunc\")\n            .unwrap();\n        let float_result = self.make_int(truncated)?;\n        self.builder.build_unconditional_branch(int_merge).unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // default -> 0\n        self.builder.position_at_end(int_default);\n        let default_result = self.make_int(zero)?;\n        self.builder.build_unconditional_branch(int_merge).unwrap();\n        let default_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(int_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"int_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&nil_result, nil_block),\n            (&bool_result, bool_block),\n            (&int_result, int_block),\n            (&float_result, float_block),\n            (&default_result, default_block),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Convert any value to float (tae_float)\n    fn inline_tae_float(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let function = self.current_function.unwrap();\n        let float_nil = self.context.append_basic_block(function, \"float_nil\");\n        let float_bool = self.context.append_basic_block(function, \"float_bool\");\n        let float_int = self.context.append_basic_block(function, \"float_int\");\n        let float_float = self.context.append_basic_block(function, \"float_float\");\n        let float_default = self.context.append_basic_block(function, \"float_default\");\n        let float_merge = self.context.append_basic_block(function, \"float_merge\");\n\n        let nil_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Nil.as_u8() as u64, false);\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n        let int_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Int.as_u8() as u64, false);\n        let float_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Float.as_u8() as u64, false);\n\n        self.builder\n            .build_switch(\n                tag,\n                float_default,\n                &[\n                    (nil_tag, float_nil),\n                    (bool_tag, float_bool),\n                    (int_tag, float_int),\n                    (float_tag, float_float),\n                ],\n            )\n            .unwrap();\n\n        // nil -> 0.0\n        self.builder.position_at_end(float_nil);\n        let zero_f = self.types.f64_type.const_float(0.0);\n        let nil_result = self.make_float(zero_f)?;\n        self.builder\n            .build_unconditional_branch(float_merge)\n            .unwrap();\n        let nil_block = self.builder.get_insert_block().unwrap();\n\n        // bool -> 0.0 or 1.0\n        self.builder.position_at_end(float_bool);\n        let bool_f = self\n            .builder\n            .build_signed_int_to_float(data, self.types.f64_type, \"bool_f\")\n            .unwrap();\n        let bool_result = self.make_float(bool_f)?;\n        self.builder\n            .build_unconditional_branch(float_merge)\n            .unwrap();\n        let bool_block = self.builder.get_insert_block().unwrap();\n\n        // int -> convert to float\n        self.builder.position_at_end(float_int);\n        let int_f = self\n            .builder\n            .build_signed_int_to_float(data, self.types.f64_type, \"int_f\")\n            .unwrap();\n        let int_result = self.make_float(int_f)?;\n        self.builder\n            .build_unconditional_branch(float_merge)\n            .unwrap();\n        let int_block = self.builder.get_insert_block().unwrap();\n\n        // float -> already a float\n        self.builder.position_at_end(float_float);\n        let float_result = val;\n        self.builder\n            .build_unconditional_branch(float_merge)\n            .unwrap();\n        let float_block = self.builder.get_insert_block().unwrap();\n\n        // default -> 0.0\n        self.builder.position_at_end(float_default);\n        let default_result = self.make_float(zero_f)?;\n        self.builder\n            .build_unconditional_branch(float_merge)\n            .unwrap();\n        let default_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(float_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"float_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&nil_result, nil_block),\n            (&bool_result, bool_block),\n            (&int_result, int_block),\n            (&float_result, float_block),\n            (&default_result, default_block),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Get length of a string (len)\n    fn inline_len(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n        let data = self.extract_data(val)?;\n\n        let function = self.current_function.unwrap();\n        let len_string = self.context.append_basic_block(function, \"len_string\");\n        let len_check_list = self.context.append_basic_block(function, \"len_check_list\");\n        let len_list = self.context.append_basic_block(function, \"len_list\");\n        let len_default = self.context.append_basic_block(function, \"len_default\");\n        let len_merge = self.context.append_basic_block(function, \"len_merge\");\n\n        // Check if string (tag == 4)\n        let string_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::String.as_u8() as u64, false);\n        let is_string = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, tag, string_tag, \"is_str\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(is_string, len_string, len_check_list)\n            .unwrap();\n\n        // String -> strlen\n        self.builder.position_at_end(len_string);\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(\n                data,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"str\",\n            )\n            .unwrap();\n        let len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let string_result = self.make_int(len)?;\n        self.builder.build_unconditional_branch(len_merge).unwrap();\n        let string_block = self.builder.get_insert_block().unwrap();\n\n        // Check if list (tag == 5)\n        self.builder.position_at_end(len_check_list);\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let is_list = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, tag, list_tag, \"is_list\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(is_list, len_list, len_default)\n            .unwrap();\n\n        // List -> read length from offset 1 (after capacity)\n        // Layout: [capacity: i64][length: i64][elements...]\n        self.builder.position_at_end(len_list);\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(data, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n        let list_result = self.make_int(list_len)?;\n        self.builder.build_unconditional_branch(len_merge).unwrap();\n        let list_block = self.builder.get_insert_block().unwrap();\n\n        // Default -> 0\n        self.builder.position_at_end(len_default);\n        let zero = self.types.i64_type.const_int(0, false);\n        let default_result = self.make_int(zero)?;\n        self.builder.build_unconditional_branch(len_merge).unwrap();\n        let default_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(len_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"len_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&string_result, string_block),\n            (&list_result, list_block),\n            (&default_result, default_block),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    fn inline_shove(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        elem_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List layout: [capacity: i64][length: i64][elements...]\n        let tag = self.extract_tag(list_val)?;\n        let data = self.extract_data(list_val)?;\n\n        let function = self.current_function.unwrap();\n        let shove_list = self.context.append_basic_block(function, \"shove_list\");\n        let shove_default = self.context.append_basic_block(function, \"shove_default\");\n        let shove_merge = self.context.append_basic_block(function, \"shove_merge\");\n\n        // Check if it's a list (tag == 5)\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let is_list = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, tag, list_tag, \"is_list\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(is_list, shove_list, shove_default)\n            .unwrap();\n\n        // Handle list case with capacity-based growth\n        self.builder.position_at_end(shove_list);\n\n        // Convert data to pointer\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(data, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n\n        // Load capacity from offset 0\n        let old_capacity = self\n            .builder\n            .build_load(self.types.i64_type, header_ptr, \"old_capacity\")\n            .unwrap()\n            .into_int_value();\n\n        // Get length pointer at offset 1\n        let one = self.types.i64_type.const_int(1, false);\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[one], \"len_ptr\")\n                .unwrap()\n        };\n\n        // Load current length\n        let old_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"old_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate new length\n        let new_len = self.builder.build_int_add(old_len, one, \"new_len\").unwrap();\n\n        // Check if we need to grow: new_len > capacity?\n        let needs_grow = self\n            .builder\n            .build_int_compare(IntPredicate::UGT, new_len, old_capacity, \"needs_grow\")\n            .unwrap();\n\n        // Create blocks for grow vs no-grow paths\n        let grow_block = self.context.append_basic_block(function, \"shove_grow\");\n        let no_grow_block = self.context.append_basic_block(function, \"shove_no_grow\");\n        let store_block = self.context.append_basic_block(function, \"shove_store\");\n\n        self.builder\n            .build_conditional_branch(needs_grow, grow_block, no_grow_block)\n            .unwrap();\n\n        // GROW PATH: double capacity and realloc\n        self.builder.position_at_end(grow_block);\n        let two = self.types.i64_type.const_int(2, false);\n        let doubled_capacity = self\n            .builder\n            .build_int_mul(old_capacity, two, \"doubled_capacity\")\n            .unwrap();\n        // Ensure new_capacity is at least 8 (in case old_capacity was 0 or very small)\n        let eight = self.types.i64_type.const_int(8, false);\n        let cap_ok = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, doubled_capacity, eight, \"cap_ok\")\n            .unwrap();\n        let new_capacity = self\n            .builder\n            .build_select(cap_ok, doubled_capacity, eight, \"safe_cap\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate new allocation size: 16 (header) + new_capacity * 16 (elements)\n        let header_size = self.types.i64_type.const_int(16, false);\n        let value_size = self.types.i64_type.const_int(16, false);\n        let elements_size = self\n            .builder\n            .build_int_mul(new_capacity, value_size, \"elements_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elements_size, \"total_size\")\n            .unwrap();\n\n        // Realloc\n        let old_ptr_i8 = self\n            .builder\n            .build_pointer_cast(header_ptr, i8_ptr_type, \"old_ptr_i8\")\n            .unwrap();\n        let new_ptr = self\n            .builder\n            .build_call(\n                self.libc.realloc,\n                &[old_ptr_i8.into(), total_size.into()],\n                \"new_list_alloc\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let new_header_ptr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr_type, \"new_header_ptr\")\n            .unwrap();\n\n        // Store new capacity\n        self.builder\n            .build_store(new_header_ptr, new_capacity)\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(store_block)\n            .unwrap();\n        let grow_end_block = self.builder.get_insert_block().unwrap();\n\n        // NO-GROW PATH: just use existing buffer\n        self.builder.position_at_end(no_grow_block);\n        self.builder\n            .build_unconditional_branch(store_block)\n            .unwrap();\n        let no_grow_end_block = self.builder.get_insert_block().unwrap();\n\n        // STORE BLOCK: use PHI to get final header pointer, then store element\n        self.builder.position_at_end(store_block);\n        let final_header_ptr = self\n            .builder\n            .build_phi(i64_ptr_type, \"final_header_ptr\")\n            .unwrap();\n        final_header_ptr.add_incoming(&[\n            (&new_header_ptr, grow_end_block),\n            (&header_ptr, no_grow_end_block),\n        ]);\n        let final_header_ptr = final_header_ptr.as_basic_value().into_pointer_value();\n\n        // Get length pointer in final buffer (at offset 1)\n        let final_len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    final_header_ptr,\n                    &[one],\n                    \"final_len_ptr\",\n                )\n                .unwrap()\n        };\n\n        // Store new length\n        self.builder.build_store(final_len_ptr, new_len).unwrap();\n\n        // Get pointer to elements array (at offset 2)\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    final_header_ptr,\n                    &[two],\n                    \"elements_base\",\n                )\n                .unwrap()\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .unwrap();\n\n        // Store new element at index old_len\n        let new_elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, elements_ptr, &[old_len], \"new_elem\")\n                .unwrap()\n        };\n        self.builder.build_store(new_elem_ptr, elem_val).unwrap();\n\n        // Create result list value\n        let list_result = self.make_list(\n            self.builder\n                .build_pointer_cast(final_header_ptr, i8_ptr_type, \"list_ptr\")\n                .unwrap(),\n        )?;\n        self.builder\n            .build_unconditional_branch(shove_merge)\n            .unwrap();\n        let list_block = self.builder.get_insert_block().unwrap();\n\n        // Default case - return nil for non-lists\n        self.builder.position_at_end(shove_default);\n        let default_result = self.make_nil();\n        self.builder\n            .build_unconditional_branch(shove_merge)\n            .unwrap();\n        let default_block = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(shove_merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"shove_result\")\n            .unwrap();\n        phi.add_incoming(&[(&list_result, list_block), (&default_result, default_block)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Fast path for shove when we know the argument is already a list\n    /// Skips the tag check and goes directly to list push logic\n    fn inline_shove_fast(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        elem_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List layout: [capacity: i64][length: i64][elements...]\n        let data = self.extract_data(list_val)?;\n\n        let function = self.current_function.unwrap();\n\n        // Convert data to pointer\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(data, i64_ptr_type, \"header_ptr_fast\")\n            .unwrap();\n\n        // Load capacity from offset 0\n        let old_capacity = self\n            .builder\n            .build_load(self.types.i64_type, header_ptr, \"old_capacity_fast\")\n            .unwrap()\n            .into_int_value();\n\n        // Get length pointer at offset 1\n        let one = self.types.i64_type.const_int(1, false);\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[one], \"len_ptr_fast\")\n                .unwrap()\n        };\n\n        // Load current length\n        let old_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"old_len_fast\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate new length\n        let new_len = self\n            .builder\n            .build_int_add(old_len, one, \"new_len_fast\")\n            .unwrap();\n\n        // Check if we need to grow: new_len > capacity?\n        let needs_grow = self\n            .builder\n            .build_int_compare(IntPredicate::UGT, new_len, old_capacity, \"needs_grow_fast\")\n            .unwrap();\n\n        // Create blocks for grow vs no-grow paths\n        let grow_block = self.context.append_basic_block(function, \"shove_grow_fast\");\n        let no_grow_block = self\n            .context\n            .append_basic_block(function, \"shove_no_grow_fast\");\n        let merge_block = self\n            .context\n            .append_basic_block(function, \"shove_merge_fast\");\n\n        self.builder\n            .build_conditional_branch(needs_grow, grow_block, no_grow_block)\n            .unwrap();\n\n        // GROW PATH: double capacity and realloc\n        self.builder.position_at_end(grow_block);\n        let two = self.types.i64_type.const_int(2, false);\n        let doubled_capacity = self\n            .builder\n            .build_int_mul(old_capacity, two, \"doubled_cap_fast\")\n            .unwrap();\n        // Ensure new_capacity is at least 32 to reduce future reallocations\n        let min_cap = self.types.i64_type.const_int(32, false);\n        let cap_ok = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, doubled_capacity, min_cap, \"cap_ok_fast\")\n            .unwrap();\n        let new_capacity = self\n            .builder\n            .build_select(cap_ok, doubled_capacity, min_cap, \"safe_cap_fast\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate new allocation size: 16 (header) + new_capacity * 16 (elements)\n        let header_size = self.types.i64_type.const_int(16, false);\n        let value_size = self.types.i64_type.const_int(16, false);\n        let elements_size = self\n            .builder\n            .build_int_mul(new_capacity, value_size, \"elements_size_fast\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elements_size, \"total_size_fast\")\n            .unwrap();\n\n        // Realloc\n        let old_ptr_i8 = self\n            .builder\n            .build_pointer_cast(header_ptr, i8_ptr_type, \"old_ptr_i8_fast\")\n            .unwrap();\n        let new_ptr = self\n            .builder\n            .build_call(\n                self.libc.realloc,\n                &[old_ptr_i8.into(), total_size.into()],\n                \"new_list_alloc_fast\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let new_header_ptr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr_type, \"new_header_ptr_fast\")\n            .unwrap();\n\n        // Store new capacity\n        self.builder\n            .build_store(new_header_ptr, new_capacity)\n            .unwrap();\n\n        // Store new length (in grown buffer)\n        let grow_len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    new_header_ptr,\n                    &[one],\n                    \"grow_len_ptr_fast\",\n                )\n                .unwrap()\n        };\n        self.builder.build_store(grow_len_ptr, new_len).unwrap();\n\n        // Store element (in grown buffer)\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let grow_elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    new_header_ptr,\n                    &[two],\n                    \"grow_elements_base_fast\",\n                )\n                .unwrap()\n        };\n        let grow_elements_ptr = self\n            .builder\n            .build_pointer_cast(grow_elements_base, value_ptr_type, \"grow_elements_ptr_fast\")\n            .unwrap();\n        let grow_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    grow_elements_ptr,\n                    &[old_len],\n                    \"grow_new_elem_fast\",\n                )\n                .unwrap()\n        };\n        self.builder.build_store(grow_elem_ptr, elem_val).unwrap();\n\n        // Create new MdhValue for grow path (pointer changed)\n        let grow_result = self.make_list(\n            self.builder\n                .build_pointer_cast(new_header_ptr, i8_ptr_type, \"grow_list_ptr_fast\")\n                .unwrap(),\n        )?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let grow_end_block = self.builder.get_insert_block().unwrap();\n\n        // NO-GROW PATH: use existing buffer, no need to create new MdhValue\n        self.builder.position_at_end(no_grow_block);\n\n        // Store new length (in existing buffer)\n        self.builder.build_store(len_ptr, new_len).unwrap();\n\n        // Store element (in existing buffer)\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[two],\n                    \"elements_base_fast\",\n                )\n                .unwrap()\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr_fast\")\n            .unwrap();\n        let new_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    elements_ptr,\n                    &[old_len],\n                    \"new_elem_fast\",\n                )\n                .unwrap()\n        };\n        self.builder.build_store(new_elem_ptr, elem_val).unwrap();\n\n        // Return original MdhValue (pointer unchanged)\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let no_grow_end_block = self.builder.get_insert_block().unwrap();\n\n        // MERGE: PHI to select result\n        self.builder.position_at_end(merge_block);\n        let result_phi = self\n            .builder\n            .build_phi(self.types.value_type, \"shove_result_fast\")\n            .unwrap();\n        result_phi.add_incoming(&[\n            (&grow_result, grow_end_block),\n            (&list_val, no_grow_end_block), // Return original in no-grow case\n        ]);\n\n        Ok(result_phi.as_basic_value())\n    }\n\n    /// Ultra-optimized shove: Only updates the variable MdhValue when realloc happens\n    /// In the no-grow case (99%+ of calls), we just store length + element - no MdhValue work\n    fn inline_shove_fire_and_forget(\n        &mut self,\n        shadow: PointerValue<'ctx>,\n        elem_val: BasicValueEnum<'ctx>,\n        var_ptr: Option<PointerValue<'ctx>>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List layout: [capacity: i64][length: i64][elements...]\n        let data = self\n            .builder\n            .build_load(self.types.i64_type, shadow, \"list_ptr_upd\")\n            .unwrap()\n            .into_int_value();\n\n        let function = self.current_function.unwrap();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(data, i64_ptr_type, \"hdr_upd\")\n            .unwrap();\n\n        // Load capacity and length\n        let old_capacity = self\n            .builder\n            .build_load(self.types.i64_type, header_ptr, \"cap_upd\")\n            .unwrap()\n            .into_int_value();\n        let one = self.types.i64_type.const_int(1, false);\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[one], \"len_ptr_upd\")\n                .unwrap()\n        };\n        let old_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"len_upd\")\n            .unwrap()\n            .into_int_value();\n        let new_len = self\n            .builder\n            .build_int_add(old_len, one, \"new_len_upd\")\n            .unwrap();\n\n        // Check if grow needed\n        let needs_grow = self\n            .builder\n            .build_int_compare(IntPredicate::UGT, new_len, old_capacity, \"grow_upd\")\n            .unwrap();\n        let grow_block = self.context.append_basic_block(function, \"shove_grow_upd\");\n        let no_grow_block = self\n            .context\n            .append_basic_block(function, \"shove_no_grow_upd\");\n        let merge_block = self.context.append_basic_block(function, \"shove_merge_upd\");\n        self.builder\n            .build_conditional_branch(needs_grow, grow_block, no_grow_block)\n            .unwrap();\n\n        // GROW PATH\n        self.builder.position_at_end(grow_block);\n        let two = self.types.i64_type.const_int(2, false);\n        let doubled = self\n            .builder\n            .build_int_mul(old_capacity, two, \"dbl_upd\")\n            .unwrap();\n        let min_cap = self.types.i64_type.const_int(64, false);\n        let cap_ok = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, doubled, min_cap, \"cok_upd\")\n            .unwrap();\n        let new_cap = self\n            .builder\n            .build_select(cap_ok, doubled, min_cap, \"ncap_upd\")\n            .unwrap()\n            .into_int_value();\n        let header_size = self.types.i64_type.const_int(16, false);\n        let value_size = self.types.i64_type.const_int(16, false);\n        let elem_sz = self\n            .builder\n            .build_int_mul(new_cap, value_size, \"esz_upd\")\n            .unwrap();\n        let total = self\n            .builder\n            .build_int_add(header_size, elem_sz, \"tot_upd\")\n            .unwrap();\n        let old_i8 = self\n            .builder\n            .build_pointer_cast(header_ptr, i8_ptr_type, \"oi8_upd\")\n            .unwrap();\n        let new_ptr = self\n            .builder\n            .build_call(\n                self.libc.realloc,\n                &[old_i8.into(), total.into()],\n                \"realloc_upd\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let new_hdr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr_type, \"nhdr_upd\")\n            .unwrap();\n        self.builder.build_store(new_hdr, new_cap).unwrap();\n        let new_i64 = self\n            .builder\n            .build_ptr_to_int(new_ptr, self.types.i64_type, \"ni64_upd\")\n            .unwrap();\n        self.builder.build_store(shadow, new_i64).unwrap();\n        let g_len = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, new_hdr, &[one], \"gl_upd\")\n                .unwrap()\n        };\n        self.builder.build_store(g_len, new_len).unwrap();\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let g_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, new_hdr, &[two], \"gb_upd\")\n                .unwrap()\n        };\n        let g_elems = self\n            .builder\n            .build_pointer_cast(g_base, value_ptr_type, \"ge_upd\")\n            .unwrap();\n        let g_elem = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, g_elems, &[old_len], \"gep_upd\")\n                .unwrap()\n        };\n        self.builder.build_store(g_elem, elem_val).unwrap();\n        let tag = self\n            .types\n            .i8_type\n            .const_int(crate::llvm::codegen::ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let gv1 = self\n            .builder\n            .build_insert_value(undef, tag, 0, \"gv1_upd\")\n            .unwrap();\n        let grow_result = self\n            .builder\n            .build_insert_value(gv1, new_i64, 1, \"gv2_upd\")\n            .unwrap()\n            .into_struct_value();\n        if let Some(vp) = var_ptr {\n            self.builder.build_store(vp, grow_result).unwrap();\n        }\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // NO-GROW PATH - fast path: just store length + element, no MdhValue work\n        self.builder.position_at_end(no_grow_block);\n        self.builder.build_store(len_ptr, new_len).unwrap();\n        let n_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[two], \"nb_upd\")\n                .unwrap()\n        };\n        let n_elems = self\n            .builder\n            .build_pointer_cast(n_base, value_ptr_type, \"ne_upd\")\n            .unwrap();\n        let n_elem = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, n_elems, &[old_len], \"nep_upd\")\n                .unwrap()\n        };\n        self.builder.build_store(n_elem, elem_val).unwrap();\n        // Skip MdhValue creation - variable already has correct pointer\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // MERGE - return nil since shove result is rarely used\n        self.builder.position_at_end(merge_block);\n        Ok(self.make_nil())\n    }\n\n    /// Ultra-fast shove for constant boolean values - stores only 8-byte data field\n    /// This is the fastest possible shove path for homogeneous boolean lists\n    fn inline_shove_bool_fast(\n        &mut self,\n        shadow: PointerValue<'ctx>,\n        bool_val: bool,\n        var_ptr: Option<PointerValue<'ctx>>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List layout: [capacity: i64][length: i64][elements...]\n        let data = self\n            .builder\n            .build_load(self.types.i64_type, shadow, \"list_ptr_bf\")\n            .unwrap()\n            .into_int_value();\n\n        let function = self.current_function.unwrap();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(data, i64_ptr_type, \"hdr_bf\")\n            .unwrap();\n\n        // Load capacity and length\n        let old_capacity = self\n            .builder\n            .build_load(self.types.i64_type, header_ptr, \"cap_bf\")\n            .unwrap()\n            .into_int_value();\n        let one = self.types.i64_type.const_int(1, false);\n        let two = self.types.i64_type.const_int(2, false);\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[one], \"len_ptr_bf\")\n                .unwrap()\n        };\n        let old_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"len_bf\")\n            .unwrap()\n            .into_int_value();\n        let new_len = self\n            .builder\n            .build_int_add(old_len, one, \"new_len_bf\")\n            .unwrap();\n\n        // Check if grow needed\n        let needs_grow = self\n            .builder\n            .build_int_compare(IntPredicate::UGT, new_len, old_capacity, \"grow_bf\")\n            .unwrap();\n        let grow_block = self.context.append_basic_block(function, \"shove_grow_bf\");\n        let no_grow_block = self\n            .context\n            .append_basic_block(function, \"shove_no_grow_bf\");\n        let merge_block = self.context.append_basic_block(function, \"shove_merge_bf\");\n        self.builder\n            .build_conditional_branch(needs_grow, grow_block, no_grow_block)\n            .unwrap();\n\n        // Constant for the data value\n        let data_val = self\n            .types\n            .i64_type\n            .const_int(if bool_val { 1 } else { 0 }, false);\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n\n        // GROW PATH - need full MdhValue store after realloc\n        self.builder.position_at_end(grow_block);\n        let doubled = self\n            .builder\n            .build_int_mul(old_capacity, two, \"dbl_bf\")\n            .unwrap();\n        let min_cap = self.types.i64_type.const_int(64, false);\n        let cap_ok = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, doubled, min_cap, \"cok_bf\")\n            .unwrap();\n        let new_cap = self\n            .builder\n            .build_select(cap_ok, doubled, min_cap, \"ncap_bf\")\n            .unwrap()\n            .into_int_value();\n        let header_size = self.types.i64_type.const_int(16, false);\n        let value_size = self.types.i64_type.const_int(16, false);\n        let elem_sz = self\n            .builder\n            .build_int_mul(new_cap, value_size, \"esz_bf\")\n            .unwrap();\n        let total = self\n            .builder\n            .build_int_add(header_size, elem_sz, \"tot_bf\")\n            .unwrap();\n        let old_i8 = self\n            .builder\n            .build_pointer_cast(header_ptr, i8_ptr_type, \"oi8_bf\")\n            .unwrap();\n        let new_ptr = self\n            .builder\n            .build_call(\n                self.libc.realloc,\n                &[old_i8.into(), total.into()],\n                \"realloc_bf\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let new_hdr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr_type, \"nhdr_bf\")\n            .unwrap();\n        self.builder.build_store(new_hdr, new_cap).unwrap();\n        let new_i64 = self\n            .builder\n            .build_ptr_to_int(new_ptr, self.types.i64_type, \"ni64_bf\")\n            .unwrap();\n        self.builder.build_store(shadow, new_i64).unwrap();\n        let g_len = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, new_hdr, &[one], \"gl_bf\")\n                .unwrap()\n        };\n        self.builder.build_store(g_len, new_len).unwrap();\n        // Store full MdhValue in grow path (tag + data)\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let g_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, new_hdr, &[two], \"gb_bf\")\n                .unwrap()\n        };\n        let g_elems = self\n            .builder\n            .build_pointer_cast(g_base, value_ptr_type, \"ge_bf\")\n            .unwrap();\n        let g_elem = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, g_elems, &[old_len], \"gep_bf\")\n                .unwrap()\n        };\n        // Build constant bool MdhValue\n        let elem_val = self\n            .types\n            .value_type\n            .const_named_struct(&[bool_tag.into(), data_val.into()]);\n        self.builder.build_store(g_elem, elem_val).unwrap();\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let gv1 = self\n            .builder\n            .build_insert_value(undef, list_tag, 0, \"gv1_bf\")\n            .unwrap();\n        let grow_result = self\n            .builder\n            .build_insert_value(gv1, new_i64, 1, \"gv2_bf\")\n            .unwrap()\n            .into_struct_value();\n        if let Some(vp) = var_ptr {\n            self.builder.build_store(vp, grow_result).unwrap();\n        }\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // NO-GROW PATH - ultra-fast: store only length + data field (8 bytes instead of 16)\n        self.builder.position_at_end(no_grow_block);\n        self.builder.build_store(len_ptr, new_len).unwrap();\n        // Element layout: {i8 tag, i64 data} - for existing elements, tag is already set\n        // But for NEW elements, we need to set the tag too. So still use full struct here.\n        // However, we can optimize by using a constant struct store\n        let n_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[two], \"nb_bf\")\n                .unwrap()\n        };\n        let n_elems = self\n            .builder\n            .build_pointer_cast(n_base, value_ptr_type, \"ne_bf\")\n            .unwrap();\n        let n_elem = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, n_elems, &[old_len], \"nep_bf\")\n                .unwrap()\n        };\n        // Store constant bool MdhValue\n        self.builder.build_store(n_elem, elem_val).unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // MERGE - return nil since shove result is rarely used\n        self.builder.position_at_end(merge_block);\n        Ok(self.make_nil())\n    }\n\n    // ========== Phase 1: Math Functions ==========\n\n    /// Get or create an LLVM intrinsic function\n    fn get_or_create_intrinsic(\n        &self,\n        name: &str,\n        ret_type: inkwell::types::BasicTypeEnum<'ctx>,\n        arg_types: &[inkwell::types::BasicMetadataTypeEnum<'ctx>],\n    ) -> FunctionValue<'ctx> {\n        if let Some(func) = self.module.get_function(name) {\n            func\n        } else {\n            let fn_type = match ret_type {\n                inkwell::types::BasicTypeEnum::FloatType(ft) => ft.fn_type(arg_types, false),\n                inkwell::types::BasicTypeEnum::IntType(it) => it.fn_type(arg_types, false),\n                _ => panic!(\"Unsupported intrinsic return type\"),\n            };\n            self.module.add_function(name, fn_type, None)\n        }\n    }\n\n    /// abs(x) - absolute value (integers only for simplicity, uses select)\n    fn inline_abs(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n\n        // Integer abs: (x < 0) ? -x : x\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_negative = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, data, zero, \"is_negative\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n        let negated = self\n            .builder\n            .build_int_neg(data, \"negated\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to negate: {}\", e)))?;\n        let abs_val = self\n            .builder\n            .build_select(is_negative, negated, data, \"abs_val\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_int_value();\n\n        self.make_int(abs_val)\n    }\n\n    /// min(a, b) - minimum of two values\n    fn inline_min(\n        &mut self,\n        a: BasicValueEnum<'ctx>,\n        b: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let a_data = self.extract_data(a)?;\n        let b_data = self.extract_data(b)?;\n\n        // Compare as signed integers\n        let is_less = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, a_data, b_data, \"is_less\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let min_val = self\n            .builder\n            .build_select(is_less, a_data, b_data, \"min_val\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_int_value();\n\n        self.make_int(min_val)\n    }\n\n    /// max(a, b) - maximum of two values\n    fn inline_max(\n        &mut self,\n        a: BasicValueEnum<'ctx>,\n        b: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let a_data = self.extract_data(a)?;\n        let b_data = self.extract_data(b)?;\n\n        // Compare as signed integers\n        let is_greater = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SGT, a_data, b_data, \"is_greater\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let max_val = self\n            .builder\n            .build_select(is_greater, a_data, b_data, \"max_val\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_int_value();\n\n        self.make_int(max_val)\n    }\n\n    /// floor(x) - floor of float, returns int\n    fn inline_floor(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"as_float\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast: {}\", e)))?\n            .into_float_value();\n\n        let floor_fn = self.get_or_create_intrinsic(\n            \"llvm.floor.f64\",\n            self.types.f64_type.into(),\n            &[self.types.f64_type.into()],\n        );\n        let floored = self\n            .builder\n            .build_call(floor_fn, &[float_val.into()], \"floored\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call floor: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        let int_val = self\n            .builder\n            .build_float_to_signed_int(floored, self.types.i64_type, \"floor_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n\n        self.make_int(int_val)\n    }\n\n    /// ceil(x) - ceiling of float, returns int\n    fn inline_ceil(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"as_float\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast: {}\", e)))?\n            .into_float_value();\n\n        let ceil_fn = self.get_or_create_intrinsic(\n            \"llvm.ceil.f64\",\n            self.types.f64_type.into(),\n            &[self.types.f64_type.into()],\n        );\n        let ceiled = self\n            .builder\n            .build_call(ceil_fn, &[float_val.into()], \"ceiled\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call ceil: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        let int_val = self\n            .builder\n            .build_float_to_signed_int(ceiled, self.types.i64_type, \"ceil_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n\n        self.make_int(int_val)\n    }\n\n    /// round(x) - round float to nearest int\n    fn inline_round(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"as_float\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast: {}\", e)))?\n            .into_float_value();\n\n        let round_fn = self.get_or_create_intrinsic(\n            \"llvm.round.f64\",\n            self.types.f64_type.into(),\n            &[self.types.f64_type.into()],\n        );\n        let rounded = self\n            .builder\n            .build_call(round_fn, &[float_val.into()], \"rounded\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call round: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        let int_val = self\n            .builder\n            .build_float_to_signed_int(rounded, self.types.i64_type, \"round_int\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n\n        self.make_int(int_val)\n    }\n\n    /// sqrt(x) - square root, returns float\n    fn inline_sqrt(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.types.f64_type, \"as_float\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast: {}\", e)))?\n            .into_float_value();\n\n        let sqrt_fn = self.get_or_create_intrinsic(\n            \"llvm.sqrt.f64\",\n            self.types.f64_type.into(),\n            &[self.types.f64_type.into()],\n        );\n        let sqrt_result = self\n            .builder\n            .build_call(sqrt_fn, &[float_val.into()], \"sqrt_result\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call sqrt: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        self.make_float(sqrt_result)\n    }\n\n    // ========== Phase 2: List Operations ==========\n\n    /// Helper to get element pointer at index in a list\n    fn get_list_element_ptr(\n        &self,\n        list_data: IntValue<'ctx>,\n        index: IntValue<'ctx>,\n    ) -> Result<PointerValue<'ctx>, HaversError> {\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let raw_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"len_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast: {}\", e)))?;\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    len_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"elements_base\",\n                )\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to compute base: {}\", e)))?\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast: {}\", e)))?;\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, elements_ptr, &[index], \"elem_ptr\")\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute element ptr: {}\", e))\n                })?\n        };\n        Ok(elem_ptr)\n    }\n\n    /// Helper to get list length\n    fn get_list_length(&self, list_data: IntValue<'ctx>) -> Result<IntValue<'ctx>, HaversError> {\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let raw_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"len_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast: {}\", e)))?;\n        let length = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        Ok(length)\n    }\n\n    /// Helper to allocate a new list with given length\n    fn allocate_list(&self, length: IntValue<'ctx>) -> Result<PointerValue<'ctx>, HaversError> {\n        // Size = 8 (length) + 16 * num_elements (each element is {i8, i64} = 16 bytes with padding)\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elems_size = self\n            .builder\n            .build_int_mul(length, elem_size, \"elems_size\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to multiply: {}\", e)))?;\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_size, \"total_size\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n\n        let ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store the length\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(ptr, i64_ptr_type, \"len_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast: {}\", e)))?;\n        self.builder\n            .build_store(len_ptr, length)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store: {}\", e)))?;\n\n        Ok(ptr)\n    }\n\n    /// yank(list) - pop last element from list\n    fn inline_yank(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(val)?;\n        let length = self.get_list_length(list_data)?;\n\n        // Get last element\n        let one = self.types.i64_type.const_int(1, false);\n        let last_idx = self\n            .builder\n            .build_int_sub(length, one, \"last_idx\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n        let elem_ptr = self.get_list_element_ptr(list_data, last_idx)?;\n        let result = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"yanked\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n\n        // Decrement length in place\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let raw_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"len_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast: {}\", e)))?;\n        let new_len = self\n            .builder\n            .build_int_sub(length, one, \"new_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n        self.builder\n            .build_store(len_ptr, new_len)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store: {}\", e)))?;\n\n        Ok(result)\n    }\n\n    /// heid(list) - get first element (head)\n    fn inline_heid(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(val)?;\n        let zero = self.types.i64_type.const_int(0, false);\n        let elem_ptr = self.get_list_element_ptr(list_data, zero)?;\n        let result = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"heid\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n        Ok(result)\n    }\n\n    /// bum(list) - get last element\n    fn inline_bum(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(val)?;\n        let length = self.get_list_length(list_data)?;\n        let one = self.types.i64_type.const_int(1, false);\n        let last_idx = self\n            .builder\n            .build_int_sub(length, one, \"last_idx\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n        let elem_ptr = self.get_list_element_ptr(list_data, last_idx)?;\n        let result = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"bum\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n        Ok(result)\n    }\n\n    /// tail(list) - return new list without first element\n    fn inline_tail(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(val)?;\n        let length = self.get_list_length(list_data)?;\n\n        let one = self.types.i64_type.const_int(1, false);\n        let new_len = self\n            .builder\n            .build_int_sub(length, one, \"new_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n\n        // Allocate new list\n        let new_list_ptr = self.allocate_list(new_len)?;\n\n        // Copy elements 1..length to new list\n        let function = self\n            .current_function\n            .ok_or_else(|| HaversError::CompileError(\"No current function\".to_string()))?;\n        let loop_block = self.context.append_basic_block(function, \"tail_loop\");\n        let done_block = self.context.append_basic_block(function, \"tail_done\");\n\n        // i = 0\n        let i_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca: {}\", e)))?;\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, i, new_len, \"cond\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let body_block = self.context.append_basic_block(function, \"tail_body\");\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        // Copy element i+1 from source to i in dest\n        let src_idx = self\n            .builder\n            .build_int_add(i, one, \"src_idx\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        let src_ptr = self.get_list_element_ptr(list_data, src_idx)?;\n        let elem = self\n            .builder\n            .build_load(self.types.value_type, src_ptr, \"elem\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n\n        let new_list_data = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"new_data\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n        let dst_ptr = self.get_list_element_ptr(new_list_data, i)?;\n        self.builder.build_store(dst_ptr, elem).unwrap();\n\n        // i++\n        let next_i = self\n            .builder\n            .build_int_add(i, one, \"next_i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n\n        self.make_list(new_list_ptr)\n    }\n\n    /// scran(list, start, end) - slice list[start:end]\n    fn inline_scran(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        start_val: BasicValueEnum<'ctx>,\n        end_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(list_val)?;\n        let start = self.extract_data(start_val)?;\n        let end = self.extract_data(end_val)?;\n\n        // new_len = end - start\n        let new_len = self\n            .builder\n            .build_int_sub(end, start, \"new_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n\n        let new_list_ptr = self.allocate_list(new_len)?;\n\n        let function = self\n            .current_function\n            .ok_or_else(|| HaversError::CompileError(\"No current function\".to_string()))?;\n        let loop_block = self.context.append_basic_block(function, \"scran_loop\");\n        let done_block = self.context.append_basic_block(function, \"scran_done\");\n\n        let i_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca: {}\", e)))?;\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, i, new_len, \"cond\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let body_block = self.context.append_basic_block(function, \"scran_body\");\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        let src_idx = self\n            .builder\n            .build_int_add(start, i, \"src_idx\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        let src_ptr = self.get_list_element_ptr(list_data, src_idx)?;\n        let elem = self\n            .builder\n            .build_load(self.types.value_type, src_ptr, \"elem\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n\n        let new_list_data = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"new_data\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n        let dst_ptr = self.get_list_element_ptr(new_list_data, i)?;\n        self.builder.build_store(dst_ptr, elem).unwrap();\n\n        let one = self.types.i64_type.const_int(1, false);\n        let next_i = self\n            .builder\n            .build_int_add(i, one, \"next_i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n\n        self.make_list(new_list_ptr)\n    }\n\n    /// slap(a, b) - concatenate two lists\n    fn inline_slap(\n        &mut self,\n        a: BasicValueEnum<'ctx>,\n        b: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let a_data = self.extract_data(a)?;\n        let b_data = self.extract_data(b)?;\n        let a_len = self.get_list_length(a_data)?;\n        let b_len = self.get_list_length(b_data)?;\n\n        let new_len = self\n            .builder\n            .build_int_add(a_len, b_len, \"new_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n\n        let new_list_ptr = self.allocate_list(new_len)?;\n        let new_list_data = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"new_data\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n\n        let function = self\n            .current_function\n            .ok_or_else(|| HaversError::CompileError(\"No current function\".to_string()))?;\n\n        // Copy first list\n        let loop1 = self.context.append_basic_block(function, \"slap_loop1\");\n        let body1 = self.context.append_basic_block(function, \"slap_body1\");\n        let done1 = self.context.append_basic_block(function, \"slap_done1\");\n\n        let i_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca: {}\", e)))?;\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop1).unwrap();\n\n        self.builder.position_at_end(loop1);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let cond1 = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, i, a_len, \"cond1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n        self.builder\n            .build_conditional_branch(cond1, body1, done1)\n            .unwrap();\n\n        self.builder.position_at_end(body1);\n        let src_ptr = self.get_list_element_ptr(a_data, i)?;\n        let elem = self\n            .builder\n            .build_load(self.types.value_type, src_ptr, \"elem\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n        let dst_ptr = self.get_list_element_ptr(new_list_data, i)?;\n        self.builder.build_store(dst_ptr, elem).unwrap();\n        let next_i = self\n            .builder\n            .build_int_add(i, one, \"next_i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop1).unwrap();\n\n        // Copy second list\n        self.builder.position_at_end(done1);\n        let loop2 = self.context.append_basic_block(function, \"slap_loop2\");\n        let body2 = self.context.append_basic_block(function, \"slap_body2\");\n        let done2 = self.context.append_basic_block(function, \"slap_done2\");\n\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop2).unwrap();\n\n        self.builder.position_at_end(loop2);\n        let i2 = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let cond2 = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, i2, b_len, \"cond2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n        self.builder\n            .build_conditional_branch(cond2, body2, done2)\n            .unwrap();\n\n        self.builder.position_at_end(body2);\n        let src_ptr2 = self.get_list_element_ptr(b_data, i2)?;\n        let elem2 = self\n            .builder\n            .build_load(self.types.value_type, src_ptr2, \"elem2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n        let dst_idx = self\n            .builder\n            .build_int_add(a_len, i2, \"dst_idx\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        let dst_ptr2 = self.get_list_element_ptr(new_list_data, dst_idx)?;\n        self.builder.build_store(dst_ptr2, elem2).unwrap();\n        let next_i2 = self\n            .builder\n            .build_int_add(i2, one, \"next_i2\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(i_ptr, next_i2).unwrap();\n        self.builder.build_unconditional_branch(loop2).unwrap();\n\n        self.builder.position_at_end(done2);\n\n        self.make_list(new_list_ptr)\n    }\n\n    /// reverse(list) - return reversed copy\n    fn inline_reverse(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(val)?;\n        let length = self.get_list_length(list_data)?;\n\n        let new_list_ptr = self.allocate_list(length)?;\n        let new_list_data = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"new_data\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to convert: {}\", e)))?;\n\n        let function = self\n            .current_function\n            .ok_or_else(|| HaversError::CompileError(\"No current function\".to_string()))?;\n        let loop_block = self.context.append_basic_block(function, \"rev_loop\");\n        let body_block = self.context.append_basic_block(function, \"rev_body\");\n        let done_block = self.context.append_basic_block(function, \"rev_done\");\n\n        let i_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca: {}\", e)))?;\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, i, length, \"cond\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        let src_ptr = self.get_list_element_ptr(list_data, i)?;\n        let elem = self\n            .builder\n            .build_load(self.types.value_type, src_ptr, \"elem\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n        // dst_idx = length - 1 - i\n        let len_minus_1 = self\n            .builder\n            .build_int_sub(length, one, \"len_minus_1\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n        let dst_idx = self\n            .builder\n            .build_int_sub(len_minus_1, i, \"dst_idx\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to subtract: {}\", e)))?;\n        let dst_ptr = self.get_list_element_ptr(new_list_data, dst_idx)?;\n        self.builder.build_store(dst_ptr, elem).unwrap();\n\n        let next_i = self\n            .builder\n            .build_int_add(i, one, \"next_i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n\n        self.make_list(new_list_ptr)\n    }\n\n    /// sumaw(list) - sum all numeric elements\n    fn inline_sumaw(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(val)?;\n        let length = self.get_list_length(list_data)?;\n\n        let function = self\n            .current_function\n            .ok_or_else(|| HaversError::CompileError(\"No current function\".to_string()))?;\n        let loop_block = self.context.append_basic_block(function, \"sum_loop\");\n        let body_block = self.context.append_basic_block(function, \"sum_body\");\n        let done_block = self.context.append_basic_block(function, \"sum_done\");\n\n        let i_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca: {}\", e)))?;\n        let sum_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"sum\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca: {}\", e)))?;\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_store(sum_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, i, length, \"cond\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        let elem_ptr = self.get_list_element_ptr(list_data, i)?;\n        let elem = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"elem\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n        let elem_data = self.extract_data(elem)?;\n\n        let sum = self\n            .builder\n            .build_load(self.types.i64_type, sum_ptr, \"sum\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n        let new_sum = self\n            .builder\n            .build_int_add(sum, elem_data, \"new_sum\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(sum_ptr, new_sum).unwrap();\n\n        let next_i = self\n            .builder\n            .build_int_add(i, one, \"next_i\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        let final_sum = self\n            .builder\n            .build_load(self.types.i64_type, sum_ptr, \"final_sum\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?\n            .into_int_value();\n\n        self.make_int(final_sum)\n    }\n\n    // ========== Phase 3: String Operations ==========\n\n    /// contains(str, substr) -> bool - check if string contains substring\n    fn inline_contains(\n        &mut self,\n        container: BasicValueEnum<'ctx>,\n        substr: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let container_data = self.extract_data(container)?;\n        let substr_data = self.extract_data(substr)?;\n\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(container_data, i8_ptr_type, \"str_ptr\")\n            .unwrap();\n        let sub_ptr = self\n            .builder\n            .build_int_to_ptr(substr_data, i8_ptr_type, \"sub_ptr\")\n            .unwrap();\n\n        // Call strstr(str, substr) - returns NULL if not found\n        let result_ptr = self\n            .builder\n            .build_call(\n                self.libc.strstr,\n                &[str_ptr.into(), sub_ptr.into()],\n                \"strstr_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Compare with null\n        let null = i8_ptr_type.const_null();\n        let is_found = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::NE, result_ptr, null, \"is_found\")\n            .unwrap();\n\n        // Convert to i64 (0 or 1) for the bool tag's data\n        let found_i64 = self\n            .builder\n            .build_int_z_extend(is_found, self.types.i64_type, \"found_i64\")\n            .unwrap();\n\n        // Create bool tagged value\n        let bool_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Bool.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, bool_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, found_i64, 1, \"v2\")\n            .unwrap();\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// upper(str) -> string - convert to uppercase\n    fn inline_upper(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(val)?;\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr_type, \"str_ptr\")\n            .unwrap();\n\n        // Get length\n        let len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Allocate result buffer (len + 1)\n        let one = self.types.i64_type.const_int(1, false);\n        let buf_size = self.builder.build_int_add(len, one, \"buf_size\").unwrap();\n        let result_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[buf_size.into()], \"upper_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Loop through each character and uppercase\n        let function = self.current_function.unwrap();\n        let loop_block = self.context.append_basic_block(function, \"upper_loop\");\n        let body_block = self.context.append_basic_block(function, \"upper_body\");\n        let done_block = self.context.append_basic_block(function, \"upper_done\");\n\n        let i_ptr = self.builder.build_alloca(self.types.i64_type, \"i\").unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .unwrap()\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::ULT, i, len, \"cond\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        let src_char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[i], \"src_char_ptr\")\n                .unwrap()\n        };\n        let char_val = self\n            .builder\n            .build_load(self.context.i8_type(), src_char_ptr, \"char\")\n            .unwrap()\n            .into_int_value();\n\n        // Inline ASCII uppercase: if char >= 'a' && char <= 'z' then char - 32\n        let i8_type = self.context.i8_type();\n        let a_char = i8_type.const_int(97, false); // 'a'\n        let z_char = i8_type.const_int(122, false); // 'z'\n        let diff = i8_type.const_int(32, false); // 'a' - 'A'\n\n        let ge_a = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::UGE, char_val, a_char, \"ge_a\")\n            .unwrap();\n        let le_z = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::ULE, char_val, z_char, \"le_z\")\n            .unwrap();\n        let is_lower = self.builder.build_and(ge_a, le_z, \"is_lower\").unwrap();\n\n        let upper_char = self\n            .builder\n            .build_int_sub(char_val, diff, \"upper_char\")\n            .unwrap();\n        let upper_i8 = self\n            .builder\n            .build_select(is_lower, upper_char, char_val, \"result_char\")\n            .unwrap()\n            .into_int_value();\n\n        let dst_char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[i], \"dst_char_ptr\")\n                .unwrap()\n        };\n        self.builder.build_store(dst_char_ptr, upper_i8).unwrap();\n\n        let next_i = self.builder.build_int_add(i, one, \"next_i\").unwrap();\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        // Null-terminate\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[len], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        self.make_string(result_buf)\n    }\n\n    /// lower(str) -> string - convert to lowercase\n    fn inline_lower(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(val)?;\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr_type, \"str_ptr\")\n            .unwrap();\n\n        let len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        let one = self.types.i64_type.const_int(1, false);\n        let buf_size = self.builder.build_int_add(len, one, \"buf_size\").unwrap();\n        let result_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[buf_size.into()], \"lower_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        let function = self.current_function.unwrap();\n        let loop_block = self.context.append_basic_block(function, \"lower_loop\");\n        let body_block = self.context.append_basic_block(function, \"lower_body\");\n        let done_block = self.context.append_basic_block(function, \"lower_done\");\n\n        let i_ptr = self.builder.build_alloca(self.types.i64_type, \"i\").unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .unwrap()\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::ULT, i, len, \"cond\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        let src_char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[i], \"src_char_ptr\")\n                .unwrap()\n        };\n        let char_val = self\n            .builder\n            .build_load(self.context.i8_type(), src_char_ptr, \"char\")\n            .unwrap()\n            .into_int_value();\n\n        // Inline ASCII lowercase: if char >= 'A' && char <= 'Z' then char + 32\n        let i8_type = self.context.i8_type();\n        let a_upper = i8_type.const_int(65, false); // 'A'\n        let z_upper = i8_type.const_int(90, false); // 'Z'\n        let diff = i8_type.const_int(32, false); // 'a' - 'A'\n\n        let ge_a = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::UGE, char_val, a_upper, \"ge_a\")\n            .unwrap();\n        let le_z = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::ULE, char_val, z_upper, \"le_z\")\n            .unwrap();\n        let is_upper = self.builder.build_and(ge_a, le_z, \"is_upper\").unwrap();\n\n        let lower_char = self\n            .builder\n            .build_int_add(char_val, diff, \"lower_char\")\n            .unwrap();\n        let lower_i8 = self\n            .builder\n            .build_select(is_upper, lower_char, char_val, \"result_char\")\n            .unwrap()\n            .into_int_value();\n\n        let dst_char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[i], \"dst_char_ptr\")\n                .unwrap()\n        };\n        self.builder.build_store(dst_char_ptr, lower_i8).unwrap();\n\n        let next_i = self.builder.build_int_add(i, one, \"next_i\").unwrap();\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[len], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        self.make_string(result_buf)\n    }\n\n    /// wheesht(str) -> string - trim whitespace\n    fn inline_wheesht(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(val)?;\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr_type, \"str_ptr\")\n            .unwrap();\n\n        let len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        let function = self.current_function.unwrap();\n\n        // Find start (skip leading whitespace)\n        let find_start = self.context.append_basic_block(function, \"find_start\");\n        let find_start_body = self.context.append_basic_block(function, \"find_start_body\");\n        let find_end = self.context.append_basic_block(function, \"find_end\");\n        let find_end_body = self.context.append_basic_block(function, \"find_end_body\");\n        let copy = self.context.append_basic_block(function, \"copy\");\n\n        let start_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"start\")\n            .unwrap();\n        let end_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"end\")\n            .unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        self.builder.build_store(start_ptr, zero).unwrap();\n        self.builder.build_store(end_ptr, len).unwrap();\n        self.builder.build_unconditional_branch(find_start).unwrap();\n\n        // Find start loop\n        self.builder.position_at_end(find_start);\n        let start = self\n            .builder\n            .build_load(self.types.i64_type, start_ptr, \"start\")\n            .unwrap()\n            .into_int_value();\n        let cond1 = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::ULT, start, len, \"cond1\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond1, find_start_body, find_end)\n            .unwrap();\n\n        self.builder.position_at_end(find_start_body);\n        let char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[start], \"char_ptr\")\n                .unwrap()\n        };\n        let char_val = self\n            .builder\n            .build_load(self.context.i8_type(), char_ptr, \"char\")\n            .unwrap()\n            .into_int_value();\n        let char_i32 = self\n            .builder\n            .build_int_z_extend(char_val, self.types.i32_type, \"char_i32\")\n            .unwrap();\n        let is_space = self\n            .builder\n            .build_call(self.libc.isspace, &[char_i32.into()], \"is_space\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let is_ws = self\n            .builder\n            .build_int_compare(\n                inkwell::IntPredicate::NE,\n                is_space,\n                self.types.i32_type.const_int(0, false),\n                \"is_ws\",\n            )\n            .unwrap();\n\n        // Create a continue block for when we find whitespace\n        let start_continue = self.context.append_basic_block(function, \"start_continue\");\n\n        // If whitespace, increment and loop; otherwise go to find_end\n        self.builder\n            .build_conditional_branch(is_ws, start_continue, find_end)\n            .unwrap();\n\n        // Increment start and continue looping\n        self.builder.position_at_end(start_continue);\n        let next_start = self\n            .builder\n            .build_int_add(start, one, \"next_start\")\n            .unwrap();\n        self.builder.build_store(start_ptr, next_start).unwrap();\n        self.builder.build_unconditional_branch(find_start).unwrap();\n\n        // Find end loop (from end backwards)\n        self.builder.position_at_end(find_end);\n        let end = self\n            .builder\n            .build_load(self.types.i64_type, end_ptr, \"end\")\n            .unwrap()\n            .into_int_value();\n        let start_val = self\n            .builder\n            .build_load(self.types.i64_type, start_ptr, \"start_val\")\n            .unwrap()\n            .into_int_value();\n        let cond2 = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::UGT, end, start_val, \"cond2\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond2, find_end_body, copy)\n            .unwrap();\n\n        self.builder.position_at_end(find_end_body);\n        let prev_end = self.builder.build_int_sub(end, one, \"prev_end\").unwrap();\n        let char_ptr2 = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[prev_end], \"char_ptr2\")\n                .unwrap()\n        };\n        let char_val2 = self\n            .builder\n            .build_load(self.context.i8_type(), char_ptr2, \"char2\")\n            .unwrap()\n            .into_int_value();\n        let char_i32_2 = self\n            .builder\n            .build_int_z_extend(char_val2, self.types.i32_type, \"char_i32_2\")\n            .unwrap();\n        let is_space2 = self\n            .builder\n            .build_call(self.libc.isspace, &[char_i32_2.into()], \"is_space2\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let is_ws2 = self\n            .builder\n            .build_int_compare(\n                inkwell::IntPredicate::NE,\n                is_space2,\n                self.types.i32_type.const_int(0, false),\n                \"is_ws2\",\n            )\n            .unwrap();\n\n        // If whitespace at prev_end, store the new end and loop; otherwise go to copy\n        let end_continue = self.context.append_basic_block(function, \"end_continue\");\n        self.builder\n            .build_conditional_branch(is_ws2, end_continue, copy)\n            .unwrap();\n\n        self.builder.position_at_end(end_continue);\n        self.builder.build_store(end_ptr, prev_end).unwrap();\n        self.builder.build_unconditional_branch(find_end).unwrap();\n\n        // Copy substring\n        self.builder.position_at_end(copy);\n        let final_start = self\n            .builder\n            .build_load(self.types.i64_type, start_ptr, \"final_start\")\n            .unwrap()\n            .into_int_value();\n        let final_end = self\n            .builder\n            .build_load(self.types.i64_type, end_ptr, \"final_end\")\n            .unwrap()\n            .into_int_value();\n        let new_len = self\n            .builder\n            .build_int_sub(final_end, final_start, \"new_len\")\n            .unwrap();\n        let buf_size = self\n            .builder\n            .build_int_add(new_len, one, \"buf_size\")\n            .unwrap();\n\n        let result_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[buf_size.into()], \"trim_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        let src_start = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[final_start], \"src_start\")\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[result_buf.into(), src_start.into(), new_len.into()],\n                \"\",\n            )\n            .unwrap();\n\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[new_len], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        self.make_string(result_buf)\n    }\n\n    /// coont(str, substr) -> int - count occurrences\n    fn inline_coont(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        sub_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let sub_data = self.extract_data(sub_val)?;\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr_type, \"str_ptr\")\n            .unwrap();\n        let sub_ptr = self\n            .builder\n            .build_int_to_ptr(sub_data, i8_ptr_type, \"sub_ptr\")\n            .unwrap();\n\n        let sub_len = self\n            .builder\n            .build_call(self.libc.strlen, &[sub_ptr.into()], \"sub_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        let function = self.current_function.unwrap();\n        let loop_block = self.context.append_basic_block(function, \"coont_loop\");\n        let found_block = self.context.append_basic_block(function, \"coont_found\");\n        let done_block = self.context.append_basic_block(function, \"coont_done\");\n\n        let count_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"count\")\n            .unwrap();\n        let pos_ptr = self.builder.build_alloca(i8_ptr_type, \"pos\").unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(count_ptr, zero).unwrap();\n        self.builder.build_store(pos_ptr, str_ptr).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let pos = self\n            .builder\n            .build_load(i8_ptr_type, pos_ptr, \"pos\")\n            .unwrap()\n            .into_pointer_value();\n        let found = self\n            .builder\n            .build_call(self.libc.strstr, &[pos.into(), sub_ptr.into()], \"found\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let null = i8_ptr_type.const_null();\n        let is_found = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::NE, found, null, \"is_found\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(is_found, found_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(found_block);\n        let count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"count\")\n            .unwrap()\n            .into_int_value();\n        let one = self.types.i64_type.const_int(1, false);\n        let new_count = self.builder.build_int_add(count, one, \"new_count\").unwrap();\n        self.builder.build_store(count_ptr, new_count).unwrap();\n\n        // Move past this occurrence\n        let next_pos = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), found, &[sub_len], \"next_pos\")\n                .unwrap()\n        };\n        self.builder.build_store(pos_ptr, next_pos).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        let final_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"final_count\")\n            .unwrap()\n            .into_int_value();\n        self.make_int(final_count)\n    }\n\n    // ========== Phase 4: Type & Utility Functions ==========\n\n    /// whit_kind(x) -> string - return type name\n    fn inline_whit_kind(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let tag = self.extract_tag(val)?;\n\n        let function = self.current_function.unwrap();\n        let nil_block = self.context.append_basic_block(function, \"kind_nil\");\n        let bool_block = self.context.append_basic_block(function, \"kind_bool\");\n        let int_block = self.context.append_basic_block(function, \"kind_int\");\n        let float_block = self.context.append_basic_block(function, \"kind_float\");\n        let string_block = self.context.append_basic_block(function, \"kind_string\");\n        let list_block = self.context.append_basic_block(function, \"kind_list\");\n        let dict_block = self.context.append_basic_block(function, \"kind_dict\");\n        let default_block = self.context.append_basic_block(function, \"kind_default\");\n        let merge_block = self.context.append_basic_block(function, \"kind_merge\");\n\n        // Create type name strings\n        let nil_str = self\n            .builder\n            .build_global_string_ptr(\"naething\", \"nil_kind\")\n            .unwrap();\n        let bool_str = self\n            .builder\n            .build_global_string_ptr(\"boolean\", \"bool_kind\")\n            .unwrap();\n        let number_str = self\n            .builder\n            .build_global_string_ptr(\"number\", \"number_kind\")\n            .unwrap();\n        let string_str = self\n            .builder\n            .build_global_string_ptr(\"string\", \"string_kind\")\n            .unwrap();\n        let list_str = self\n            .builder\n            .build_global_string_ptr(\"list\", \"list_kind\")\n            .unwrap();\n        let dict_str = self\n            .builder\n            .build_global_string_ptr(\"dict\", \"dict_kind\")\n            .unwrap();\n\n        // Switch on tag\n        self.builder\n            .build_switch(\n                tag,\n                default_block,\n                &[\n                    (self.types.i8_type.const_int(0, false), nil_block),\n                    (self.types.i8_type.const_int(1, false), bool_block),\n                    (self.types.i8_type.const_int(2, false), int_block),\n                    (self.types.i8_type.const_int(3, false), float_block),\n                    (self.types.i8_type.const_int(4, false), string_block),\n                    (self.types.i8_type.const_int(5, false), list_block),\n                    (self.types.i8_type.const_int(6, false), dict_block),\n                ],\n            )\n            .unwrap();\n\n        self.builder.position_at_end(nil_block);\n        let nil_result = self.make_string(nil_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let nil_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(bool_block);\n        let bool_result = self.make_string(bool_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let bool_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(int_block);\n        let int_result = self.make_string(number_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let int_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(float_block);\n        let float_result = self.make_string(number_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let float_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(string_block);\n        let string_result = self.make_string(string_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let string_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(list_block);\n        let list_result = self.make_string(list_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let list_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(dict_block);\n        let dict_result = self.make_string(dict_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let dict_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(default_block);\n        let default_result = self.make_string(nil_str.as_pointer_value())?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let default_bb = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"kind_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&nil_result, nil_bb),\n            (&bool_result, bool_bb),\n            (&int_result, int_bb),\n            (&float_result, float_bb),\n            (&string_result, string_bb),\n            (&list_result, list_bb),\n            (&dict_result, dict_bb),\n            (&default_result, default_bb),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// range(start, end) -> list - create list [start, start+1, ..., end-1]\n    fn inline_range(\n        &mut self,\n        start_val: BasicValueEnum<'ctx>,\n        end_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let start = self.extract_data(start_val)?;\n        let end = self.extract_data(end_val)?;\n\n        let function = self.current_function.unwrap();\n\n        // Calculate length = max(0, end - start)\n        let diff = self.builder.build_int_sub(end, start, \"diff\").unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_positive = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SGT, diff, zero, \"is_pos\")\n            .unwrap();\n        let length = self\n            .builder\n            .build_select(is_positive, diff, zero, \"length\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate list: 8 bytes header + length * 16 bytes\n        let header_size = self.types.i64_type.const_int(16, false);\n        let value_size = self.types.i64_type.const_int(16, false);\n        let elements_size = self\n            .builder\n            .build_int_mul(length, value_size, \"elem_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elements_size, \"total\")\n            .unwrap();\n\n        let raw_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"range_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"len_ptr\")\n            .unwrap();\n        self.builder.build_store(len_ptr, length).unwrap();\n\n        // Get elements base\n        let one = self.types.i64_type.const_int(1, false);\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, len_ptr, &[one], \"elements_base\")\n                .unwrap()\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .unwrap();\n\n        // Loop to fill elements\n        let loop_block = self.context.append_basic_block(function, \"range_loop\");\n        let body_block = self.context.append_basic_block(function, \"range_body\");\n        let done_block = self.context.append_basic_block(function, \"range_done\");\n\n        let i_ptr = self.builder.build_alloca(self.types.i64_type, \"i\").unwrap();\n        self.builder.build_store(i_ptr, zero).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i\")\n            .unwrap()\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::ULT, i, length, \"cond\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond, body_block, done_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        let val = self.builder.build_int_add(start, i, \"val\").unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.value_type, elements_ptr, &[i], \"elem_ptr\")\n                .unwrap()\n        };\n        let elem = self.make_int(val)?;\n        self.builder.build_store(elem_ptr, elem).unwrap();\n\n        let next_i = self.builder.build_int_add(i, one, \"next_i\").unwrap();\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        self.make_list(raw_ptr)\n    }\n\n    // ========== Statement Compilation ==========\n\n    fn compile_stmt(&mut self, stmt: &Stmt) -> Result<(), HaversError> {\n        match stmt {\n            Stmt::VarDecl {\n                name, initializer, ..\n            } => {\n                // Track the inferred type for optimization\n                let var_type = if let Some(init) = initializer {\n                    self.infer_expr_type(init)\n                } else {\n                    VarType::Unknown\n                };\n                self.var_types.insert(name.clone(), var_type);\n\n                // Track class type if this is a class instantiation\n                if let Some(init) = initializer {\n                    if let Expr::Call { callee, .. } = init {\n                        if let Expr::Variable {\n                            name: class_name, ..\n                        } = callee.as_ref()\n                        {\n                            if self.classes.contains_key(class_name.as_str()) {\n                                self.variable_class_types\n                                    .insert(name.clone(), class_name.clone());\n                            }\n                        }\n                    }\n                }\n\n                // Check if this is a top-level declaration (needs LLVM global)\n                // Variables inside user functions are never top-level\n                let is_top_level = !self.in_user_function\n                    && self.current_class.is_none()\n                    && self.loop_stack.is_empty()\n                    && !self.variables.contains_key(name)\n                    && !self.globals.contains_key(name);\n\n                // For list variables, create a pointer shadow for fast access\n                // Note: we skip the optimization for top-level vars since they need LLVM globals\n                if var_type == VarType::List && !is_top_level {\n                    // Create shadow to cache the raw list pointer\n                    let shadow = if let Some(&existing) = self.list_ptr_shadows.get(name) {\n                        existing\n                    } else {\n                        let s = self.create_entry_block_alloca_i64(&format!(\"{}_list_ptr\", name));\n                        self.list_ptr_shadows.insert(name.clone(), s);\n                        s\n                    };\n\n                    // Compile the initializer and store shadow\n                    if let Some(init) = initializer {\n                        let value = self.compile_expr(init)?;\n                        let list_ptr = self.extract_data(value)?;\n                        self.builder.build_store(shadow, list_ptr).unwrap();\n\n                        // Also store the MdhValue\n                        let alloca = if let Some(&existing) = self.variables.get(name) {\n                            existing\n                        } else {\n                            let a = self.create_entry_block_alloca(name);\n                            self.variables.insert(name.clone(), a);\n                            a\n                        };\n                        self.builder.build_store(alloca, value).unwrap();\n                        return Ok(());\n                    }\n                }\n\n                // For int variables, try to use optimized path\n                // Note: we skip the optimization for top-level vars since they need LLVM globals\n                if var_type == VarType::Int && !is_top_level {\n                    // Check if shadow already exists (re-declaration in loop)\n                    let shadow = if let Some(&existing) = self.int_shadows.get(name) {\n                        existing\n                    } else {\n                        let s = self.create_entry_block_alloca_i64(&format!(\"{}_shadow\", name));\n                        self.int_shadows.insert(name.clone(), s);\n                        s\n                    };\n\n                    // Try to get the int value directly\n                    if let Some(init) = initializer {\n                        if let Some(int_val) = self.compile_int_expr(init)? {\n                            // Store to shadow\n                            self.builder.build_store(shadow, int_val).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store shadow: {}\", e))\n                            })?;\n\n                            // Skip MdhValue store in loop body\n                            if !self.in_loop_body {\n                                // Ensure MdhValue alloca exists\n                                let alloca = if let Some(&existing) = self.variables.get(name) {\n                                    existing\n                                } else {\n                                    let a = self.create_entry_block_alloca(name);\n                                    self.variables.insert(name.clone(), a);\n                                    a\n                                };\n                                let boxed = self.make_int(int_val)?;\n                                self.builder.build_store(alloca, boxed).map_err(|e| {\n                                    HaversError::CompileError(format!(\"Failed to store: {}\", e))\n                                })?;\n                            } else {\n                                // In loop: just ensure alloca exists\n                                if !self.variables.contains_key(name) {\n                                    let a = self.create_entry_block_alloca(name);\n                                    self.variables.insert(name.clone(), a);\n                                }\n                            }\n                            return Ok(());\n                        }\n                    }\n                }\n\n                // Fall back to standard path\n                let value = if let Some(init) = initializer {\n                    self.compile_expr(init)?\n                } else {\n                    self.make_nil()\n                };\n\n                // Check if we need to use a global variable (top-level declaration)\n                // Top-level vars need to be true LLVM globals to be accessible from methods\n                // Variables inside user functions are never top-level\n                let is_top_level = !self.in_user_function\n                    && self.current_class.is_none()\n                    && self.loop_stack.is_empty()\n                    && !self.variables.contains_key(name);\n\n                let alloca = if let Some(&existing) = self.variables.get(name) {\n                    existing\n                } else if let Some(&existing) = self.globals.get(name) {\n                    // Already exists as a global\n                    existing\n                } else if is_top_level {\n                    // Create an LLVM global variable\n                    let global = self.module.add_global(self.types.value_type, None, name);\n                    global.set_initializer(&self.types.value_type.const_zero());\n                    let global_ptr = global.as_pointer_value();\n                    self.globals.insert(name.clone(), global_ptr);\n                    // Also add to variables so main function can find it easily\n                    self.variables.insert(name.clone(), global_ptr);\n                    global_ptr\n                } else {\n                    let a = self.create_entry_block_alloca(name);\n                    self.variables.insert(name.clone(), a);\n                    a\n                };\n                self.builder\n                    .build_store(alloca, value)\n                    .map_err(|e| HaversError::CompileError(format!(\"Failed to store: {}\", e)))?;\n\n                // Create shadow if needed\n                if var_type == VarType::Int && !self.int_shadows.contains_key(name) {\n                    let shadow = self.create_entry_block_alloca_i64(&format!(\"{}_shadow\", name));\n                    let data = self.extract_data(value)?;\n                    self.builder.build_store(shadow, data).map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to store shadow: {}\", e))\n                    })?;\n                    self.int_shadows.insert(name.clone(), shadow);\n                }\n\n                // Create string length and capacity shadows if needed\n                if var_type == VarType::String && !self.string_len_shadows.contains_key(name) {\n                    let len_shadow =\n                        self.create_entry_block_alloca_i64(&format!(\"{}_strlen\", name));\n                    let cap_shadow =\n                        self.create_entry_block_alloca_i64(&format!(\"{}_strcap\", name));\n                    // Calculate initial string length and set initial capacity\n                    if let Some(init) = initializer {\n                        if let Expr::Literal {\n                            value: Literal::String(s),\n                            ..\n                        } = init\n                        {\n                            // Literal string - use compile-time length\n                            let len = s.len() as u64;\n                            let len_val = self.types.i64_type.const_int(len, false);\n                            self.builder.build_store(len_shadow, len_val).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store strlen: {}\", e))\n                            })?;\n                            // Set capacity to 0 to indicate it's a literal (not owned)\n                            // We'll reallocate on first append\n                            let zero = self.types.i64_type.const_int(0, false);\n                            self.builder.build_store(cap_shadow, zero).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store strcap: {}\", e))\n                            })?;\n                        } else {\n                            // Runtime string - compute with strlen\n                            let data = self.extract_data(value)?;\n                            let i8_ptr_type =\n                                self.context.i8_type().ptr_type(AddressSpace::default());\n                            let str_ptr = self\n                                .builder\n                                .build_int_to_ptr(data, i8_ptr_type, \"str_for_len\")\n                                .unwrap();\n                            let len = self\n                                .builder\n                                .build_call(self.libc.strlen, &[str_ptr.into()], \"init_strlen\")\n                                .unwrap()\n                                .try_as_basic_value()\n                                .left()\n                                .unwrap()\n                                .into_int_value();\n                            self.builder.build_store(len_shadow, len).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store strlen: {}\", e))\n                            })?;\n                            // Capacity is 0 for externally-owned strings\n                            let zero = self.types.i64_type.const_int(0, false);\n                            self.builder.build_store(cap_shadow, zero).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store strcap: {}\", e))\n                            })?;\n                        }\n                    } else {\n                        // No initializer - length and capacity are 0\n                        let zero = self.types.i64_type.const_int(0, false);\n                        self.builder.build_store(len_shadow, zero).map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to store strlen: {}\", e))\n                        })?;\n                        self.builder.build_store(cap_shadow, zero).map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to store strcap: {}\", e))\n                        })?;\n                    }\n                    self.string_len_shadows.insert(name.clone(), len_shadow);\n                    self.string_cap_shadows.insert(name.clone(), cap_shadow);\n                }\n                Ok(())\n            }\n\n            Stmt::Expression { expr, .. } => {\n                self.compile_expr(expr)?;\n                Ok(())\n            }\n\n            Stmt::Block { statements, .. } => {\n                for s in statements {\n                    self.compile_stmt(s)?;\n                }\n                Ok(())\n            }\n\n            Stmt::Print { value, .. } => {\n                let val = self.compile_expr(value)?;\n                self.inline_blether(val)?;\n                Ok(())\n            }\n\n            Stmt::If {\n                condition,\n                then_branch,\n                else_branch,\n                ..\n            } => self.compile_if(condition, then_branch, else_branch.as_deref()),\n\n            Stmt::While {\n                condition, body, ..\n            } => self.compile_while(condition, body),\n\n            Stmt::For {\n                variable,\n                iterable,\n                body,\n                ..\n            } => self.compile_for(variable, iterable, body),\n\n            Stmt::Function {\n                name, params, body, ..\n            } => {\n                // Ensure function is declared before compiling\n                if !self.functions.contains_key(name) {\n                    self.declare_function(name, params.len())?;\n                }\n                self.compile_function(name, params, body)\n            }\n\n            Stmt::Return { value, .. } => {\n                let ret_val = if let Some(v) = value {\n                    self.compile_expr(v)?\n                } else {\n                    self.make_nil()\n                };\n                self.builder.build_return(Some(&ret_val)).map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to build return: {}\", e))\n                })?;\n                Ok(())\n            }\n\n            Stmt::Break { .. } => {\n                if let Some(loop_ctx) = self.loop_stack.last() {\n                    self.builder\n                        .build_unconditional_branch(loop_ctx.break_block)\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to build break: {}\", e))\n                        })?;\n                    Ok(())\n                } else {\n                    Err(HaversError::CompileError(\"Break outside loop\".to_string()))\n                }\n            }\n\n            Stmt::Continue { .. } => {\n                if let Some(loop_ctx) = self.loop_stack.last() {\n                    self.builder\n                        .build_unconditional_branch(loop_ctx.continue_block)\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to build continue: {}\", e))\n                        })?;\n                    Ok(())\n                } else {\n                    Err(HaversError::CompileError(\n                        \"Continue outside loop\".to_string(),\n                    ))\n                }\n            }\n\n            Stmt::Class {\n                name,\n                superclass: _,\n                methods,\n                ..\n            } => self.compile_class(name, methods),\n\n            Stmt::Import { path, .. } => self.compile_import(path),\n\n            Stmt::Assert {\n                condition, message, ..\n            } => self.compile_assert(condition, message.as_ref()),\n\n            Stmt::Match { value, arms, .. } => self.compile_match(value, arms),\n\n            Stmt::Destructure {\n                patterns, value, ..\n            } => self.compile_destructure(patterns, value),\n\n            Stmt::TryCatch {\n                try_block,\n                error_name,\n                catch_block,\n                ..\n            } => self.compile_try_catch(try_block, error_name, catch_block),\n\n            Stmt::Log {\n                level: _, message, ..\n            } => {\n                // For now, just print the message like blether does\n                let val = self.compile_expr(message)?;\n                self.inline_blether(val)?;\n                Ok(())\n            }\n\n            // Not yet implemented\n            _ => Err(HaversError::CompileError(format!(\n                \"Statement not yet supported in LLVM backend: {:?}\",\n                stmt\n            ))),\n        }\n    }\n\n    // ========== Expression Compilation ==========\n\n    fn compile_expr(&mut self, expr: &Expr) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        match expr {\n            Expr::Literal { value, .. } => self.compile_literal(value),\n\n            Expr::Variable { name, .. } => {\n                if let Some(&alloca) = self.variables.get(name) {\n                    // If we're in a loop body and have a shadow, construct fresh MdhValue from shadow\n                    // This ensures function calls get the correct value even though we've been\n                    // skipping MdhValue stores for optimization\n                    if self.in_loop_body {\n                        if let Some(&shadow) = self.int_shadows.get(name) {\n                            let int_val = self\n                                .builder\n                                .build_load(\n                                    self.types.i64_type,\n                                    shadow,\n                                    &format!(\"{}_shadow_load\", name),\n                                )\n                                .map_err(|e| {\n                                    HaversError::CompileError(format!(\n                                        \"Failed to load shadow: {}\",\n                                        e\n                                    ))\n                                })?\n                                .into_int_value();\n                            return self.make_int(int_val);\n                        }\n                    }\n                    let val = self\n                        .builder\n                        .build_load(self.types.value_type, alloca, name)\n                        .map_err(|e| HaversError::CompileError(format!(\"Failed to load: {}\", e)))?;\n                    Ok(val)\n                } else if let Some(&global) = self.globals.get(name) {\n                    // Global variable\n                    let val = self\n                        .builder\n                        .build_load(self.types.value_type, global, &format!(\"{}_global\", name))\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to load global: {}\", e))\n                        })?;\n                    Ok(val)\n                } else if let Some(&func) = self.functions.get(name) {\n                    // User-defined function referenced as a value - return function pointer\n                    let func_ptr = func.as_global_value().as_pointer_value();\n                    let func_int = self\n                        .builder\n                        .build_ptr_to_int(func_ptr, self.types.i64_type, \"func_int\")\n                        .unwrap();\n                    self.make_function(func_int)\n                } else if name == \"PI\" {\n                    // Built-in constant: PI\n                    let pi_val = self.context.f64_type().const_float(std::f64::consts::PI);\n                    self.make_float(pi_val)\n                } else if name == \"E\" {\n                    // Built-in constant: E (Euler's number)\n                    let e_val = self.context.f64_type().const_float(std::f64::consts::E);\n                    self.make_float(e_val)\n                } else if name == \"TAU\" {\n                    // Built-in constant: TAU (2*PI)\n                    let tau_val = self.context.f64_type().const_float(std::f64::consts::TAU);\n                    self.make_float(tau_val)\n                } else {\n                    Err(HaversError::CompileError(format!(\n                        \"Undefined variable: {}\",\n                        name\n                    )))\n                }\n            }\n\n            Expr::Assign { name, value, .. } => {\n                // Try to use optimized int path if we have an int shadow\n                if let Some(&shadow) = self.int_shadows.get(name) {\n                    // Try to compile the value directly as i64\n                    if let Some(int_val) = self.compile_int_expr(value)? {\n                        // Update the shadow with the new i64 value\n                        self.builder.build_store(shadow, int_val).map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to store shadow: {}\", e))\n                        })?;\n\n                        // Skip MdhValue store in loop body (will sync at loop exit)\n                        if self.in_loop_body {\n                            // Still need to return a valid MdhValue\n                            let boxed = self.make_int(int_val)?;\n                            return Ok(boxed);\n                        }\n\n                        // Outside loop: also update the MdhValue\n                        let boxed = self.make_int(int_val)?;\n                        if let Some(&alloca) = self.variables.get(name) {\n                            self.builder.build_store(alloca, boxed).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store: {}\", e))\n                            })?;\n                        }\n                        return Ok(boxed);\n                    }\n                }\n\n                // Check for optimized self-concat pattern: s = s + \"literal\"\n                // This uses realloc for O(n) amortized instead of O(n)\n                if let Some(&len_shadow) = self.string_len_shadows.get(name) {\n                    if let Some(&cap_shadow) = self.string_cap_shadows.get(name) {\n                        if let Expr::Binary {\n                            left,\n                            operator: BinaryOp::Add,\n                            right,\n                            ..\n                        } = value.as_ref()\n                        {\n                            // Check if left is the same variable and right is a literal\n                            let is_self_concat =\n                                if let Expr::Variable { name: lname, .. } = left.as_ref() {\n                                    lname == name\n                                } else {\n                                    false\n                                };\n                            let right_literal_len = if let Expr::Literal {\n                                value: Literal::String(s),\n                                ..\n                            } = right.as_ref()\n                            {\n                                Some(s.len())\n                            } else {\n                                None\n                            };\n                            if is_self_concat {\n                                if let Some(rlen) = right_literal_len {\n                                    // OPTIMIZED PATH: s = s + \"literal\" with capacity-based growth\n                                    return self.compile_string_self_append(\n                                        name, len_shadow, cap_shadow, right, rlen,\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Check if assigning string to a variable with string length shadow\n                // Try to compute the new length efficiently\n                let new_str_len = if let Some(&len_shadow) = self.string_len_shadows.get(name) {\n                    // Check for common pattern: s = s + \"literal\" or s = s + var\n                    if let Expr::Binary {\n                        left,\n                        operator: BinaryOp::Add,\n                        right,\n                        ..\n                    } = value.as_ref()\n                    {\n                        // Check if left is the same variable\n                        let is_self_concat =\n                            if let Expr::Variable { name: lname, .. } = left.as_ref() {\n                                lname == name\n                            } else {\n                                false\n                            };\n                        if is_self_concat {\n                            // s = s + something - compute new length as old_len + right_len\n                            let old_len = self\n                                .builder\n                                .build_load(self.types.i64_type, len_shadow, \"old_len\")\n                                .unwrap()\n                                .into_int_value();\n                            let right_len = if let Expr::Literal {\n                                value: Literal::String(s),\n                                ..\n                            } = right.as_ref()\n                            {\n                                self.types.i64_type.const_int(s.len() as u64, false)\n                            } else if let Expr::Variable { name: rname, .. } = right.as_ref() {\n                                if let Some(&rshadow) = self.string_len_shadows.get(rname) {\n                                    self.builder\n                                        .build_load(self.types.i64_type, rshadow, \"rvar_len\")\n                                        .unwrap()\n                                        .into_int_value()\n                                } else {\n                                    // Don't have shadow - skip optimization\n                                    self.types.i64_type.const_int(0, false) // placeholder\n                                }\n                            } else {\n                                self.types.i64_type.const_int(0, false) // placeholder\n                            };\n                            // Check if we got a valid right_len (not placeholder 0)\n                            let is_literal_or_shadow = if let Expr::Literal {\n                                value: Literal::String(_),\n                                ..\n                            } = right.as_ref()\n                            {\n                                true\n                            } else if let Expr::Variable { name: rname, .. } = right.as_ref() {\n                                self.string_len_shadows.contains_key(rname)\n                            } else {\n                                false\n                            };\n                            if is_literal_or_shadow {\n                                Some(\n                                    self.builder\n                                        .build_int_add(old_len, right_len, \"new_len\")\n                                        .unwrap(),\n                                )\n                            } else {\n                                None\n                            }\n                        } else {\n                            None\n                        }\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                };\n\n                // Track class type if this is a class instantiation reassignment\n                if let Expr::Call { callee, .. } = value.as_ref() {\n                    if let Expr::Variable {\n                        name: class_name, ..\n                    } = callee.as_ref()\n                    {\n                        if self.classes.contains_key(class_name.as_str()) {\n                            self.variable_class_types\n                                .insert(name.clone(), class_name.clone());\n                        }\n                    }\n                }\n\n                // Fall back to standard path\n                let val = self.compile_expr(value)?;\n                // Look up variable location - check locals first, then globals\n                let alloca = self\n                    .variables\n                    .get(name)\n                    .copied()\n                    .or_else(|| self.globals.get(name).copied());\n                if let Some(alloca) = alloca {\n                    self.builder.build_store(alloca, val).map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to store: {}\", e))\n                    })?;\n                    // Update int shadow if we have one\n                    if let Some(&shadow) = self.int_shadows.get(name) {\n                        let data = self.extract_data(val)?;\n                        self.builder.build_store(shadow, data).map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to store shadow: {}\", e))\n                        })?;\n                    }\n                    // Update string length shadow if we have one\n                    if let Some(&len_shadow) = self.string_len_shadows.get(name) {\n                        if let Some(new_len) = new_str_len {\n                            // Use pre-computed length\n                            self.builder.build_store(len_shadow, new_len).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store strlen: {}\", e))\n                            })?;\n                        } else {\n                            // Compute length with strlen\n                            let data = self.extract_data(val)?;\n                            let i8_ptr_type =\n                                self.context.i8_type().ptr_type(AddressSpace::default());\n                            let str_ptr = self\n                                .builder\n                                .build_int_to_ptr(data, i8_ptr_type, \"str_for_len\")\n                                .unwrap();\n                            let len = self\n                                .builder\n                                .build_call(self.libc.strlen, &[str_ptr.into()], \"new_strlen\")\n                                .unwrap()\n                                .try_as_basic_value()\n                                .left()\n                                .unwrap()\n                                .into_int_value();\n                            self.builder.build_store(len_shadow, len).map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to store strlen: {}\", e))\n                            })?;\n                        }\n                    }\n                    Ok(val)\n                } else {\n                    Err(HaversError::CompileError(format!(\n                        \"Undefined variable: {}\",\n                        name\n                    )))\n                }\n            }\n\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => self.compile_binary(left, *operator, right),\n\n            Expr::Unary {\n                operator, operand, ..\n            } => self.compile_unary(*operator, operand),\n\n            Expr::Logical {\n                left,\n                operator,\n                right,\n                ..\n            } => self.compile_logical(left, *operator, right),\n\n            Expr::Call {\n                callee, arguments, ..\n            } => self.compile_call(callee, arguments),\n\n            Expr::Grouping { expr, .. } => self.compile_expr(expr),\n\n            Expr::Ternary {\n                condition,\n                then_expr,\n                else_expr,\n                ..\n            } => self.compile_ternary(condition, then_expr, else_expr),\n\n            Expr::Range { start, end, .. } => {\n                // For now, just compile as nil - ranges are handled in for loops\n                let _start_val = self.compile_expr(start)?;\n                let _end_val = self.compile_expr(end)?;\n                Ok(self.make_nil())\n            }\n\n            Expr::List { elements, .. } => self.compile_list(elements),\n\n            Expr::Dict { pairs, .. } => self.compile_dict(pairs),\n\n            Expr::Index { object, index, .. } => self.compile_index(object, index),\n\n            Expr::IndexSet {\n                object,\n                index,\n                value,\n                ..\n            } => self.compile_index_set(object, index, value),\n\n            Expr::Input { prompt, .. } => {\n                // Use runtime function for stdin handling\n                let prompt_val = self.compile_expr(prompt)?;\n                let result = self\n                    .builder\n                    .build_call(self.libc.speir, &[prompt_val.into()], \"input_result\")\n                    .map_err(|e| HaversError::CompileError(format!(\"Failed to call speir: {}\", e)))?\n                    .try_as_basic_value()\n                    .left()\n                    .ok_or_else(|| HaversError::CompileError(\"speir call failed\".to_string()))?;\n                Ok(result)\n            }\n\n            Expr::Lambda { params, body, .. } => self.compile_lambda(params, body),\n\n            Expr::Masel { .. } => self.compile_masel(),\n\n            Expr::Get {\n                object, property, ..\n            } => self.compile_get(object, property),\n\n            Expr::Set {\n                object,\n                property,\n                value,\n                ..\n            } => self.compile_set(object, property, value),\n\n            Expr::FString { parts, .. } => self.compile_fstring(parts),\n\n            Expr::Pipe { left, right, .. } => self.compile_pipe(left, right),\n\n            Expr::Spread { .. } => {\n                // Spread is handled specially in list literal compilation\n                // If we get here, it's an error - spread can only be used in list context\n                Err(HaversError::CompileError(\n                    \"Spread operator can only be used inside list literals\".to_string(),\n                ))\n            }\n\n            Expr::Slice {\n                object,\n                start,\n                end,\n                step,\n                ..\n            } => self.compile_slice_expr(object, start.as_ref(), end.as_ref(), step.as_ref()),\n\n            // Not yet implemented\n            _ => Err(HaversError::CompileError(format!(\n                \"Expression not yet supported in LLVM backend: {:?}\",\n                expr\n            ))),\n        }\n    }\n\n    fn compile_literal(&mut self, literal: &Literal) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        match literal {\n            Literal::Nil => Ok(self.make_nil()),\n\n            Literal::Bool(b) => {\n                let bool_val = self.types.bool_type.const_int(*b as u64, false);\n                self.make_bool(bool_val)\n            }\n\n            Literal::Integer(n) => {\n                let int_val = self.types.i64_type.const_int(*n as u64, true);\n                self.make_int(int_val)\n            }\n\n            Literal::Float(f) => {\n                let float_val = self.types.f64_type.const_float(*f);\n                self.make_float(float_val)\n            }\n\n            Literal::String(s) => {\n                let str_ptr = self\n                    .builder\n                    .build_global_string_ptr(s, \"str\")\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to create string: {}\", e))\n                    })?;\n                self.make_string(str_ptr.as_pointer_value())\n            }\n        }\n    }\n\n    fn compile_binary(\n        &mut self,\n        left: &Expr,\n        op: BinaryOp,\n        right: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Type-based optimization: if both operands are known to be Int, use fast path\n        let left_type = self.infer_expr_type(left);\n        let right_type = self.infer_expr_type(right);\n\n        // Integer fast path for arithmetic operations\n        if left_type == VarType::Int && right_type == VarType::Int {\n            match op {\n                BinaryOp::Add\n                | BinaryOp::Subtract\n                | BinaryOp::Multiply\n                | BinaryOp::Divide\n                | BinaryOp::Modulo => {\n                    return self.compile_binary_int_fast(left, op, right);\n                }\n                _ => {} // Comparisons already optimized via compile_condition_direct\n            }\n        }\n\n        // String fast path for concatenation - skip type checks\n        if left_type == VarType::String && right_type == VarType::String {\n            if let BinaryOp::Add = op {\n                return self.compile_string_concat_fast(left, right);\n            }\n        }\n\n        let left_val = self.compile_expr(left)?;\n        let right_val = self.compile_expr(right)?;\n\n        match op {\n            BinaryOp::Add => self.inline_add(left_val, right_val),\n            BinaryOp::Subtract => self.inline_sub(left_val, right_val),\n            BinaryOp::Multiply => self.inline_mul(left_val, right_val),\n            BinaryOp::Divide => self.inline_div(left_val, right_val),\n            BinaryOp::Modulo => self.inline_mod(left_val, right_val),\n            BinaryOp::Equal => self.inline_eq(left_val, right_val),\n            BinaryOp::NotEqual => self.inline_ne(left_val, right_val),\n            BinaryOp::Less => self.inline_lt(left_val, right_val),\n            BinaryOp::LessEqual => self.inline_le(left_val, right_val),\n            BinaryOp::Greater => self.inline_gt(left_val, right_val),\n            BinaryOp::GreaterEqual => self.inline_ge(left_val, right_val),\n        }\n    }\n\n    /// Fast path for integer arithmetic - uses shadows when available\n    fn compile_binary_int_fast(\n        &mut self,\n        left: &Expr,\n        op: BinaryOp,\n        right: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Try to use int shadows directly (avoids MdhValue load)\n        let left_data = if let Some(l) = self.compile_int_expr(left)? {\n            l\n        } else {\n            let left_val = self.compile_expr(left)?;\n            self.extract_data(left_val)?\n        };\n\n        let right_data = if let Some(r) = self.compile_int_expr(right)? {\n            r\n        } else {\n            let right_val = self.compile_expr(right)?;\n            self.extract_data(right_val)?\n        };\n\n        // Perform operation directly on i64\n        let result = match op {\n            BinaryOp::Add => self\n                .builder\n                .build_int_add(left_data, right_data, \"add_fast\")\n                .unwrap(),\n            BinaryOp::Subtract => self\n                .builder\n                .build_int_sub(left_data, right_data, \"sub_fast\")\n                .unwrap(),\n            BinaryOp::Multiply => self\n                .builder\n                .build_int_mul(left_data, right_data, \"mul_fast\")\n                .unwrap(),\n            BinaryOp::Divide => self\n                .builder\n                .build_int_signed_div(left_data, right_data, \"div_fast\")\n                .unwrap(),\n            BinaryOp::Modulo => self\n                .builder\n                .build_int_signed_rem(left_data, right_data, \"mod_fast\")\n                .unwrap(),\n            _ => unreachable!(),\n        };\n\n        // Box the result back to MdhValue\n        self.make_int(result)\n    }\n\n    /// Fast path for string concatenation - skips runtime type checks\n    fn compile_string_concat_fast(\n        &mut self,\n        left: &Expr,\n        right: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let left_val = self.compile_expr(left)?;\n        let right_val = self.compile_expr(right)?;\n\n        let left_data = self.extract_data(left_val)?;\n        let right_data = self.extract_data(right_val)?;\n\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let left_ptr = self\n            .builder\n            .build_int_to_ptr(left_data, i8_ptr_type, \"lstr_fast\")\n            .unwrap();\n        let right_ptr = self\n            .builder\n            .build_int_to_ptr(right_data, i8_ptr_type, \"rstr_fast\")\n            .unwrap();\n\n        // Get left length - use shadow if available, otherwise strlen\n        let left_len = if let Expr::Variable { name, .. } = left {\n            if let Some(&shadow) = self.string_len_shadows.get(name) {\n                self.builder\n                    .build_load(self.types.i64_type, shadow, \"cached_llen\")\n                    .unwrap()\n                    .into_int_value()\n            } else {\n                self.builder\n                    .build_call(self.libc.strlen, &[left_ptr.into()], \"llen_fast\")\n                    .unwrap()\n                    .try_as_basic_value()\n                    .left()\n                    .unwrap()\n                    .into_int_value()\n            }\n        } else if let Expr::Literal {\n            value: Literal::String(s),\n            ..\n        } = left\n        {\n            self.types.i64_type.const_int(s.len() as u64, false)\n        } else {\n            self.builder\n                .build_call(self.libc.strlen, &[left_ptr.into()], \"llen_fast\")\n                .unwrap()\n                .try_as_basic_value()\n                .left()\n                .unwrap()\n                .into_int_value()\n        };\n\n        // Get right length - use compile-time length for literals\n        let right_len = if let Expr::Literal {\n            value: Literal::String(s),\n            ..\n        } = right\n        {\n            self.types.i64_type.const_int(s.len() as u64, false)\n        } else if let Expr::Variable { name, .. } = right {\n            if let Some(&shadow) = self.string_len_shadows.get(name) {\n                self.builder\n                    .build_load(self.types.i64_type, shadow, \"cached_rlen\")\n                    .unwrap()\n                    .into_int_value()\n            } else {\n                self.builder\n                    .build_call(self.libc.strlen, &[right_ptr.into()], \"rlen_fast\")\n                    .unwrap()\n                    .try_as_basic_value()\n                    .left()\n                    .unwrap()\n                    .into_int_value()\n            }\n        } else {\n            self.builder\n                .build_call(self.libc.strlen, &[right_ptr.into()], \"rlen_fast\")\n                .unwrap()\n                .try_as_basic_value()\n                .left()\n                .unwrap()\n                .into_int_value()\n        };\n\n        // Allocate new string (len1 + len2 + 1)\n        let total_len = self\n            .builder\n            .build_int_add(left_len, right_len, \"total_fast\")\n            .unwrap();\n        let one = self.types.i64_type.const_int(1, false);\n        let alloc_size = self\n            .builder\n            .build_int_add(total_len, one, \"alloc_size_fast\")\n            .unwrap();\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[alloc_size.into()], \"new_str_fast\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy using memcpy\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[new_str.into(), left_ptr.into(), left_len.into()],\n                \"\",\n            )\n            .unwrap();\n        let dest_offset = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_str,\n                    &[left_len],\n                    \"dest_offset_fast\",\n                )\n                .unwrap()\n        };\n        let right_len_plus_one = self\n            .builder\n            .build_int_add(right_len, one, \"rlen_plus_one_fast\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[\n                    dest_offset.into(),\n                    right_ptr.into(),\n                    right_len_plus_one.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n\n        self.make_string(new_str)\n    }\n\n    /// Optimized string self-append: s = s + \"literal\"\n    /// Uses capacity-based growth with realloc for O(n) amortized instead of O(n)\n    fn compile_string_self_append(\n        &mut self,\n        var_name: &str,\n        len_shadow: PointerValue<'ctx>,\n        cap_shadow: PointerValue<'ctx>,\n        right_expr: &Expr,\n        right_len: usize,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let right_len_const = self.types.i64_type.const_int(right_len as u64, false);\n\n        // Compile the right side string (the literal)\n        let right_val = self.compile_expr(right_expr)?;\n        let right_data = self.extract_data(right_val)?;\n        let right_ptr = self\n            .builder\n            .build_int_to_ptr(right_data, i8_ptr_type, \"right_ptr\")\n            .unwrap();\n\n        // Load current string pointer, length, and capacity\n        let var_alloca = *self.variables.get(var_name).ok_or_else(|| {\n            HaversError::CompileError(format!(\"Variable not found: {}\", var_name))\n        })?;\n        let current_val = self\n            .builder\n            .build_load(self.types.value_type, var_alloca, \"current_str\")\n            .unwrap();\n        let current_data = self.extract_data(current_val)?;\n        let current_ptr = self\n            .builder\n            .build_int_to_ptr(current_data, i8_ptr_type, \"current_ptr\")\n            .unwrap();\n\n        let old_len = self\n            .builder\n            .build_load(self.types.i64_type, len_shadow, \"old_len\")\n            .unwrap()\n            .into_int_value();\n        let old_cap = self\n            .builder\n            .build_load(self.types.i64_type, cap_shadow, \"old_cap\")\n            .unwrap()\n            .into_int_value();\n\n        // Compute new length\n        let new_len = self\n            .builder\n            .build_int_add(old_len, right_len_const, \"new_len\")\n            .unwrap();\n        let one = self.types.i64_type.const_int(1, false);\n        let new_len_plus_one = self\n            .builder\n            .build_int_add(new_len, one, \"new_size\")\n            .unwrap();\n\n        // Use an alloca to store the working buffer pointer\n        let buf_ptr_alloca = self\n            .builder\n            .build_alloca(i8_ptr_type, \"buf_ptr_alloca\")\n            .unwrap();\n        self.builder\n            .build_store(buf_ptr_alloca, current_ptr)\n            .unwrap();\n\n        // Check if we need to grow: new_len + 1 > capacity?\n        let needs_grow = self\n            .builder\n            .build_int_compare(IntPredicate::UGT, new_len_plus_one, old_cap, \"needs_grow\")\n            .unwrap();\n\n        let grow_block = self.context.append_basic_block(function, \"str_grow\");\n        let append_block = self.context.append_basic_block(function, \"str_append\");\n\n        self.builder\n            .build_conditional_branch(needs_grow, grow_block, append_block)\n            .unwrap();\n\n        // GROW PATH: calculate new capacity and realloc/malloc\n        self.builder.position_at_end(grow_block);\n        // New capacity: max(old_cap * 2, new_len + 1, 32)\n        let two = self.types.i64_type.const_int(2, false);\n        let doubled = self.builder.build_int_mul(old_cap, two, \"doubled\").unwrap();\n        let min_cap = self.types.i64_type.const_int(32, false);\n\n        // cap1 = max(doubled, new_len_plus_one)\n        let double_ok = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, doubled, new_len_plus_one, \"double_ok\")\n            .unwrap();\n        let cap1 = self\n            .builder\n            .build_select(double_ok, doubled, new_len_plus_one, \"cap1\")\n            .unwrap()\n            .into_int_value();\n\n        // new_cap = max(cap1, min_cap)\n        let min_ok = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, cap1, min_cap, \"min_ok\")\n            .unwrap();\n        let new_cap = self\n            .builder\n            .build_select(min_ok, cap1, min_cap, \"new_cap\")\n            .unwrap()\n            .into_int_value();\n\n        // Check if this is first allocation (cap == 0) or realloc\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_first = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, old_cap, zero, \"is_first\")\n            .unwrap();\n\n        let malloc_block = self.context.append_basic_block(function, \"str_malloc\");\n        let realloc_block = self.context.append_basic_block(function, \"str_realloc\");\n        let after_grow = self.context.append_basic_block(function, \"after_grow\");\n\n        self.builder\n            .build_conditional_branch(is_first, malloc_block, realloc_block)\n            .unwrap();\n\n        // MALLOC PATH: allocate new buffer and copy existing content\n        self.builder.position_at_end(malloc_block);\n        let malloc_result = self\n            .builder\n            .build_call(self.libc.malloc, &[new_cap.into()], \"new_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        // Copy old content\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[malloc_result.into(), current_ptr.into(), old_len.into()],\n                \"\",\n            )\n            .unwrap();\n        self.builder\n            .build_store(buf_ptr_alloca, malloc_result)\n            .unwrap();\n        self.builder.build_unconditional_branch(after_grow).unwrap();\n\n        // REALLOC PATH: extend existing buffer\n        self.builder.position_at_end(realloc_block);\n        let realloc_result = self\n            .builder\n            .build_call(\n                self.libc.realloc,\n                &[current_ptr.into(), new_cap.into()],\n                \"grown_buf\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        self.builder\n            .build_store(buf_ptr_alloca, realloc_result)\n            .unwrap();\n        self.builder.build_unconditional_branch(after_grow).unwrap();\n\n        // AFTER GROW: update capacity and continue to append\n        self.builder.position_at_end(after_grow);\n        self.builder.build_store(cap_shadow, new_cap).unwrap();\n        self.builder\n            .build_unconditional_branch(append_block)\n            .unwrap();\n\n        // APPEND PATH: copy the right string to the buffer\n        self.builder.position_at_end(append_block);\n        let final_buf = self\n            .builder\n            .build_load(i8_ptr_type, buf_ptr_alloca, \"final_buf\")\n            .unwrap()\n            .into_pointer_value();\n\n        // Calculate destination offset\n        let dest_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), final_buf, &[old_len], \"dest_ptr\")\n                .unwrap()\n        };\n\n        // Copy right string (including null terminator)\n        let right_len_plus_one = self\n            .builder\n            .build_int_add(right_len_const, one, \"rlen_plus_one\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dest_ptr.into(), right_ptr.into(), right_len_plus_one.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Update length shadow\n        self.builder.build_store(len_shadow, new_len).unwrap();\n\n        // Create new MdhValue with the buffer pointer and store it back\n        let result = self.make_string(final_buf)?;\n        self.builder.build_store(var_alloca, result).unwrap();\n\n        Ok(result)\n    }\n\n    fn compile_unary(\n        &mut self,\n        op: UnaryOp,\n        operand: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let val = self.compile_expr(operand)?;\n        match op {\n            UnaryOp::Negate => self.inline_neg(val),\n            UnaryOp::Not => self.inline_not(val),\n        }\n    }\n\n    fn compile_logical(\n        &mut self,\n        left: &Expr,\n        op: LogicalOp,\n        right: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n        let left_val = self.compile_expr(left)?;\n        let left_truthy = self.is_truthy(left_val)?;\n\n        let eval_right = self.context.append_basic_block(function, \"eval_right\");\n        let merge = self.context.append_basic_block(function, \"merge\");\n\n        match op {\n            LogicalOp::And => {\n                self.builder\n                    .build_conditional_branch(left_truthy, eval_right, merge)\n                    .unwrap();\n            }\n            LogicalOp::Or => {\n                self.builder\n                    .build_conditional_branch(left_truthy, merge, eval_right)\n                    .unwrap();\n            }\n        }\n\n        let left_block = self.builder.get_insert_block().unwrap();\n        self.builder.position_at_end(eval_right);\n        let right_val = self.compile_expr(right)?;\n        let right_block = self.builder.get_insert_block().unwrap();\n        self.builder.build_unconditional_branch(merge).unwrap();\n\n        self.builder.position_at_end(merge);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"logical\")\n            .unwrap();\n        phi.add_incoming(&[(&left_val, left_block), (&right_val, right_block)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    fn compile_call(\n        &mut self,\n        callee: &Expr,\n        args: &[Expr],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Check for method call: obj.method(args)\n        if let Expr::Get {\n            object, property, ..\n        } = callee\n        {\n            return self.compile_method_call(object, property, args);\n        }\n\n        if let Expr::Variable { name, .. } = callee {\n            // Check for class instantiation: ClassName()\n            if self.classes.contains_key(name) {\n                return self.compile_class_instantiation(name, args);\n            }\n\n            // Check for user-defined functions FIRST to allow shadowing built-ins\n            if let Some(&func) = self.functions.get(name) {\n                let mut compiled_args: Vec<BasicMetadataValueEnum> = Vec::new();\n\n                // Check if any argument is a spread expression\n                let has_spread = args.iter().any(|a| matches!(a, Expr::Spread { .. }));\n\n                if has_spread {\n                    // Handle spread arguments - need to unpack list elements at runtime\n                    let expected_params = func.count_params() as usize;\n                    let capture_count = self.function_captures.get(name).map_or(0, |c| c.len());\n                    let user_param_count = expected_params.saturating_sub(capture_count);\n\n                    // Count non-spread args to know how many elements to extract from spread\n                    let non_spread_count = args.iter().filter(|a| !matches!(a, Expr::Spread { .. })).count();\n                    let spread_elements_needed = user_param_count.saturating_sub(non_spread_count);\n                    let mut spread_elements_used = 0;\n\n                    for arg in args {\n                        if let Expr::Spread { expr, .. } = arg {\n                            // Compile the spread expression to get the list\n                            let list_val = self.compile_expr(expr)?;\n                            let list_struct = list_val.into_struct_value();\n                            let list_data = self\n                                .builder\n                                .build_extract_value(list_struct, 1, \"spread_data\")\n                                .unwrap()\n                                .into_int_value();\n\n                            // Extract elements from the list\n                            let elements_to_extract = spread_elements_needed - spread_elements_used;\n                            for i in 0..elements_to_extract {\n                                let idx = self.types.i64_type.const_int(i as u64, false);\n                                let elem = self.compile_list_index(list_data, idx)?;\n                                compiled_args.push(elem.into());\n                            }\n                            spread_elements_used += elements_to_extract;\n                        } else {\n                            compiled_args.push(self.compile_expr(arg)?.into());\n                        }\n                    }\n                } else {\n                    // No spread - use simple path\n                    for arg in args {\n                        compiled_args.push(self.compile_expr(arg)?.into());\n                    }\n                }\n\n                // Add captured variables if this function has any\n                if let Some(captures) = self.function_captures.get(name).cloned() {\n                    for capture_name in captures {\n                        // Look up the captured variable in current scope and pass it\n                        if let Some(&alloca) = self.variables.get(&capture_name) {\n                            let val = self\n                                .builder\n                                .build_load(\n                                    self.types.value_type,\n                                    alloca,\n                                    &format!(\"{}_cap\", capture_name),\n                                )\n                                .unwrap();\n                            compiled_args.push(val.into());\n                        } else {\n                            return Err(HaversError::CompileError(format!(\n                                \"Captured variable '{}' not found in scope when calling '{}'\",\n                                capture_name, name\n                            )));\n                        }\n                    }\n                }\n\n                // Fill in default parameter values if fewer args provided than expected\n                let expected_param_count = func.count_params() as usize;\n                if compiled_args.len() < expected_param_count {\n                    if let Some(defaults) = self.function_defaults.get(name).cloned() {\n                        for i in compiled_args.len()..expected_param_count {\n                            if let Some(Some(ref default_expr)) = defaults.get(i) {\n                                compiled_args.push(self.compile_expr(default_expr)?.into());\n                            } else {\n                                // No default for this parameter - fill with nil\n                                compiled_args.push(self.make_nil().into());\n                            }\n                        }\n                    } else {\n                        // No defaults defined - fill remaining with nil\n                        for _ in compiled_args.len()..expected_param_count {\n                            compiled_args.push(self.make_nil().into());\n                        }\n                    }\n                }\n\n                let call_site = self\n                    .builder\n                    .build_call(func, &compiled_args, \"call\")\n                    .map_err(|e| HaversError::CompileError(format!(\"Failed to call: {}\", e)))?;\n\n                call_site.set_tail_call(true);\n\n                return Ok(call_site.try_as_basic_value().left().unwrap());\n            }\n\n            // Check for built-in functions\n            match name.as_str() {\n                \"tae_string\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tae_string expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_tae_string(arg);\n                }\n                \"tae_int\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tae_int expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_tae_int(arg);\n                }\n                \"tae_float\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tae_float expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_tae_float(arg);\n                }\n                \"len\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"len expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_len(arg);\n                }\n                \"shove\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"shove expects 2 arguments (list, element)\".to_string(),\n                        ));\n                    }\n\n                    // Check if we have a list pointer shadow for the variable - use optimized path\n                    if let Expr::Variable { name, .. } = &args[0] {\n                        if let Some(shadow) = self.list_ptr_shadows.get(name).copied() {\n                            // Check for constant boolean element - use ultra-fast data-only shove\n                            if let Expr::Literal {\n                                value: Literal::Bool(b),\n                                ..\n                            } = &args[1]\n                            {\n                                let var_ptr = self.variables.get(name).copied();\n                                return self.inline_shove_bool_fast(shadow, *b, var_ptr);\n                            }\n                            // Use fire-and-forget shove: skips MdhValue work in no-grow case\n                            let elem_arg = self.compile_expr(&args[1])?;\n                            let var_ptr = self.variables.get(name).copied();\n                            return self.inline_shove_fire_and_forget(shadow, elem_arg, var_ptr);\n                        }\n                    }\n\n                    // Compile element for standard path\n                    let elem_arg = self.compile_expr(&args[1])?;\n\n                    // Standard path - no shadow available\n                    let list_type = self.infer_expr_type(&args[0]);\n                    let result = if list_type == VarType::List {\n                        let list_arg = self.compile_expr(&args[0])?;\n                        self.inline_shove_fast(list_arg, elem_arg)?\n                    } else {\n                        let list_arg = self.compile_expr(&args[0])?;\n                        self.inline_shove(list_arg, elem_arg)?\n                    };\n\n                    // If first argument is a variable, update both MdhValue and shadow\n                    if let Expr::Variable { name, .. } = &args[0] {\n                        // Update shadow if exists (needed after realloc)\n                        if let Some(&shadow) = self.list_ptr_shadows.get(name) {\n                            let new_ptr = self.extract_data(result)?;\n                            self.builder.build_store(shadow, new_ptr).unwrap();\n                        }\n                        // Update variable\n                        if let Some(var_ptr) = self.variables.get(name).copied() {\n                            self.builder.build_store(var_ptr, result).unwrap();\n                        }\n                    }\n                    return Ok(result);\n                }\n                // Phase 1: Math functions\n                \"abs\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"abs expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_abs(arg);\n                }\n                \"min\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"min expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    return self.inline_min(a, b);\n                }\n                \"max\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"max expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    return self.inline_max(a, b);\n                }\n                \"clamp\" => {\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"clamp expects 3 arguments (value, min, max)\".to_string(),\n                        ));\n                    }\n                    let val = self.compile_expr(&args[0])?;\n                    let min_val = self.compile_expr(&args[1])?;\n                    let max_val = self.compile_expr(&args[2])?;\n                    // clamp(x, min, max) = min(max(x, min_val), max_val)\n                    let clamped_low = self.inline_max(val, min_val)?;\n                    return self.inline_min(clamped_low, max_val);\n                }\n                \"floor\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"floor expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_floor(arg);\n                }\n                \"ceil\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"ceil expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_ceil(arg);\n                }\n                \"round\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"round expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_round(arg);\n                }\n                \"sqrt\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sqrt expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_sqrt(arg);\n                }\n                // Phase 2: List operations\n                \"yank\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"yank expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let list = self.compile_expr(&args[0])?;\n                    return self.inline_yank(list);\n                }\n                \"heid\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"heid expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_heid(arg);\n                }\n                \"tail\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tail expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_tail(arg);\n                }\n                \"bum\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"bum expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_bum(arg);\n                }\n                \"scran\" => {\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"scran expects 3 arguments (list, start, end)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let start_arg = self.compile_expr(&args[1])?;\n                    let end_arg = self.compile_expr(&args[2])?;\n                    return self.inline_scran(list_arg, start_arg, end_arg);\n                }\n                \"slap\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"slap expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    return self.inline_slap(a, b);\n                }\n                \"reverse\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"reverse expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_reverse(arg);\n                }\n                \"sumaw\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sumaw expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_sumaw(arg);\n                }\n                // Phase 3: String/Set operations\n                \"contains\" | \"dict_has\" => {\n                    // String contains or dict has key\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"contains/dict_has expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let container = self.compile_expr(&args[0])?;\n                    let key = self.compile_expr(&args[1])?;\n                    return self.inline_contains(container, key);\n                }\n                \"is_in_creel\" => {\n                    // is_in_creel is Scots for \"is in set/basket\" - uses dict_contains runtime\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"is_in_creel expects 2 arguments (set, item)\".to_string(),\n                        ));\n                    }\n                    let set_val = self.compile_expr(&args[0])?;\n                    let item = self.compile_expr(&args[1])?;\n                    // Call runtime function: __mdh_dict_contains(dict, key) -> MdhValue (bool)\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.dict_contains,\n                            &[set_val.into(), item.into()],\n                            \"is_in_creel_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\n                                \"Failed to call dict_contains: {}\",\n                                e\n                            ))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"dict_contains returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"toss_in\" => {\n                    // toss_in(set, item) - add item to set (Scots: toss it in the creel!)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"toss_in expects 2 arguments (set, item)\".to_string(),\n                        ));\n                    }\n                    let set_val = self.compile_expr(&args[0])?;\n                    let item = self.compile_expr(&args[1])?;\n                    // Call runtime function: __mdh_toss_in(dict, item) -> MdhValue\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.toss_in,\n                            &[set_val.into(), item.into()],\n                            \"toss_in_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call toss_in: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"toss_in returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"heave_oot\" => {\n                    // heave_oot(set, item) - remove item from set (Scots: heave it out!)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"heave_oot expects 2 arguments (set, item)\".to_string(),\n                        ));\n                    }\n                    let set_val = self.compile_expr(&args[0])?;\n                    let item = self.compile_expr(&args[1])?;\n                    // Call runtime function: __mdh_heave_oot(dict, item) -> MdhValue\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.heave_oot,\n                            &[set_val.into(), item.into()],\n                            \"heave_oot_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call heave_oot: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"heave_oot returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"empty_creel\" => {\n                    // empty_creel() - create empty set (empty basket)\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"empty_creel expects no arguments\".to_string(),\n                        ));\n                    }\n                    // Call runtime function: __mdh_empty_creel() -> MdhValue\n                    let result = self\n                        .builder\n                        .build_call(self.libc.empty_creel, &[], \"empty_creel_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call empty_creel: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"empty_creel returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"make_creel\" => {\n                    // make_creel(list) - create set from list items\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"make_creel expects 1 argument (list)\".to_string(),\n                        ));\n                    }\n                    // For now, just return an empty creel - full implementation would iterate list\n                    // and add each item. This is a stub to allow files to compile.\n                    let result = self\n                        .builder\n                        .build_call(self.libc.empty_creel, &[], \"make_creel_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call empty_creel: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"empty_creel returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"creel_tae_list\" => {\n                    // Convert set/dict keys to list\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"creel_tae_list expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let dict_val = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.creel_tae_list,\n                            &[dict_val.into()],\n                            \"creel_to_list_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\n                                \"Failed to call creel_tae_list: {}\",\n                                e\n                            ))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"creel_tae_list returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"creels_thegither\" | \"set_union\" => {\n                    // Union of two sets (placeholder: return first)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"creels_thegither expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                // File I/O builtins\n                \"file_exists\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"file_exists expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.file_exists, &[path.into()], \"file_exists_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call file_exists: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"file_exists returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"slurp\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"slurp expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.slurp, &[path.into()], \"slurp_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call slurp: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"slurp returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"scrieve\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"scrieve expects 2 arguments (path, content)\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let content = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.scrieve,\n                            &[path.into(), content.into()],\n                            \"scrieve_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call scrieve: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"scrieve returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"lines\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"lines expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.lines, &[path.into()], \"lines_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call lines: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"lines returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"words\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"words expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let str_val = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.words, &[str_val.into()], \"words_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call words: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"words returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Logging builtins\n                \"get_log_level\" => {\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"get_log_level expects no arguments\".to_string(),\n                        ));\n                    }\n                    let result = self\n                        .builder\n                        .build_call(self.libc.get_log_level, &[], \"get_log_level_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\n                                \"Failed to call get_log_level: {}\",\n                                e\n                            ))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"get_log_level returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"set_log_level\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"set_log_level expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let level = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.set_log_level,\n                            &[level.into()],\n                            \"set_log_level_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\n                                \"Failed to call set_log_level: {}\",\n                                e\n                            ))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"set_log_level returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Scots builtins\n                \"slainte\" => {\n                    let result = self\n                        .builder\n                        .build_call(self.libc.slainte, &[], \"slainte_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call slainte: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"slainte returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"och\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"och expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let msg = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.och, &[msg.into()], \"och_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call och: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"och returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"wee\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"wee expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.wee, &[a.into(), b.into()], \"wee_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call wee: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"wee returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"tak\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"tak expects 2 arguments (list, n)\".to_string(),\n                        ));\n                    }\n                    let list = self.compile_expr(&args[0])?;\n                    let n = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.tak, &[list.into(), n.into()], \"tak_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call tak: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"tak returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"pair_up\" => {\n                    if args.len() == 2 {\n                        // pair_up(list1, list2) - zip two lists\n                        let list1 = self.compile_expr(&args[0])?;\n                        let list2 = self.compile_expr(&args[1])?;\n                        let result = self\n                            .builder\n                            .build_call(\n                                self.libc.pair_up,\n                                &[list1.into(), list2.into()],\n                                \"pair_up_result\",\n                            )\n                            .map_err(|e| {\n                                HaversError::CompileError(format!(\"Failed to call pair_up: {}\", e))\n                            })?\n                            .try_as_basic_value()\n                            .left()\n                            .ok_or_else(|| {\n                                HaversError::CompileError(\"pair_up returned void\".to_string())\n                            })?;\n                        return Ok(result);\n                    } else if args.len() == 1 {\n                        // pair_up(list) - pair adjacent elements (placeholder: return as-is)\n                        return self.compile_expr(&args[0]);\n                    } else {\n                        return Err(HaversError::CompileError(\n                            \"pair_up expects 1 or 2 arguments\".to_string(),\n                        ));\n                    }\n                }\n                \"tae_binary\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tae_binary expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let n = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.tae_binary, &[n.into()], \"tae_binary_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call tae_binary: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"tae_binary returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"average\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"average expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let list = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.average, &[list.into()], \"average_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call average: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"average returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"chynge\" | \"replace\" => {\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"chynge/replace expects 3 arguments (str, old, new)\".to_string(),\n                        ));\n                    }\n                    let str_val = self.compile_expr(&args[0])?;\n                    let old_val = self.compile_expr(&args[1])?;\n                    let new_val = self.compile_expr(&args[2])?;\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.chynge,\n                            &[str_val.into(), old_val.into(), new_val.into()],\n                            \"chynge_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call chynge: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"chynge returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Testing builtins\n                \"assert\" => {\n                    if args.is_empty() || args.len() > 2 {\n                        return Err(HaversError::CompileError(\n                            \"assert expects 1 or 2 arguments\".to_string(),\n                        ));\n                    }\n                    let cond = self.compile_expr(&args[0])?;\n                    let msg = if args.len() > 1 {\n                        self.compile_expr(&args[1])?\n                    } else {\n                        self.make_nil()\n                    };\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.assert_fn,\n                            &[cond.into(), msg.into()],\n                            \"assert_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call assert: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"assert returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"skip\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"skip expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let reason = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.skip, &[reason.into()], \"skip_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call skip: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"skip returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"stacktrace\" => {\n                    let result = self\n                        .builder\n                        .build_call(self.libc.stacktrace, &[], \"stacktrace_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call stacktrace: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"stacktrace returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Additional Scots aliases\n                \"scots_greetin\" | \"scunner\" => {\n                    // Return an error message string (Scots for \"complaint\")\n                    let global = Self::create_global_string(\n                        &self.module,\n                        self.context,\n                        \"Och, something went wrang!\",\n                        \"scots_err_msg\",\n                    );\n                    let str_ptr = self.get_string_ptr(global);\n                    return self.make_string(str_ptr);\n                }\n                \"poetry_seed\" | \"braw_time\" => {\n                    // Random seed / current time - return a random number for now\n                    let min = self.types.i64_type.const_int(0, false);\n                    let max = self.types.i64_type.const_int(i64::MAX as u64, false);\n                    let result = self\n                        .builder\n                        .build_call(self.libc.random, &[min.into(), max.into()], \"seed_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call random: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"random returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Additional builtins\n                \"read_file\" => {\n                    // Alias for slurp\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"read_file expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.slurp, &[path.into()], \"read_file_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call slurp: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"slurp returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"muckle\" | \"max\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"muckle/max expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.muckle, &[a.into(), b.into()], \"muckle_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call muckle: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"muckle returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"median\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"median expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let list = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.median, &[list.into()], \"median_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call median: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"median returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"is_space\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_space expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let str_val = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.is_space, &[str_val.into()], \"is_space_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call is_space: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"is_space returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"is_digit\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_digit expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let str_val = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.is_digit, &[str_val.into()], \"is_digit_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call is_digit: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"is_digit returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"wheesht_aw\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"wheesht_aw expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let str_val = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.wheesht_aw, &[str_val.into()], \"wheesht_aw_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call wheesht_aw: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"wheesht_aw returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"dicht\" | \"remove_at\" => {\n                    // dicht(list, index) - remove element at index (placeholder: return list)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"dicht expects 2 arguments (list, index)\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"bonnie\" | \"pretty\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"bonnie expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let val = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.bonnie, &[val.into()], \"bonnie_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call bonnie: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"bonnie returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"deck\" | \"shuffle\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"shuffle expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let list = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.shuffle, &[list.into()], \"shuffle_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call shuffle: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"shuffle returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"bit_an\" | \"bit_and\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"bit_and expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.bit_and, &[a.into(), b.into()], \"bit_and_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call bit_and: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"bit_and returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"bit_or\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"bit_or expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.bit_or, &[a.into(), b.into()], \"bit_or_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call bit_or: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"bit_or returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"bit_xor\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"bit_xor expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.bit_xor, &[a.into(), b.into()], \"bit_xor_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call bit_xor: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"bit_xor returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Misc Scots aliases\n                \"jings\" | \"scots_farewell\" | \"blether_format\" | \"stooshie\" | \"scots_exclaim\"\n                | \"crivvens\" | \"geggie\" => {\n                    // These just return nil - they're exclamations or placeholders\n                    return Ok(self.make_nil());\n                }\n                \"read_lines\" => {\n                    // Alias for lines\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"read_lines expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let result = self\n                        .builder\n                        .build_call(self.libc.lines, &[path.into()], \"read_lines_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call lines: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"lines returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"append_file\" => {\n                    // Append to file - for now just call scrieve (overwrites)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"append_file expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let path = self.compile_expr(&args[0])?;\n                    let content = self.compile_expr(&args[1])?;\n                    let result = self\n                        .builder\n                        .build_call(\n                            self.libc.scrieve,\n                            &[path.into(), content.into()],\n                            \"append_file_result\",\n                        )\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call scrieve: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"scrieve returned void\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                \"minaw\" => {\n                    // Minimum of list - return nil for now\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"minaw expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // Just compile the argument to avoid unused\n                    let _list = self.compile_expr(&args[0])?;\n                    return Ok(self.make_nil());\n                }\n                \"is_wee\" | \"is_alpha\" => {\n                    // Check if value is small or alphabetic - return true for now\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"predicate expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let _val = self.compile_expr(&args[0])?;\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"is_even\" => {\n                    // Check if number is even\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_even expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let n = self.compile_expr(&args[0])?;\n                    let data = self.extract_data(n)?;\n                    let two = self.types.i64_type.const_int(2, false);\n                    let rem = self\n                        .builder\n                        .build_int_signed_rem(data, two, \"is_even_rem\")\n                        .unwrap();\n                    let zero = self.types.i64_type.const_int(0, false);\n                    let is_even = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::EQ, rem, zero, \"is_even_cmp\")\n                        .unwrap();\n                    let is_even_i64 = self\n                        .builder\n                        .build_int_z_extend(is_even, self.types.i64_type, \"is_even_i64\")\n                        .unwrap();\n                    return self.make_bool(is_even_i64);\n                }\n                \"bit_nae\" | \"bit_not\" => {\n                    // Bitwise NOT\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"bit_not expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let n = self.compile_expr(&args[0])?;\n                    let data = self.extract_data(n)?;\n                    let not_val = self.builder.build_not(data, \"bit_not\").unwrap();\n                    return self.make_int(not_val);\n                }\n                // Global test variables - return reasonable defaults\n                \"__current_suite\" => {\n                    let global = Self::create_global_string(\n                        &self.module,\n                        self.context,\n                        \"\",\n                        \"current_suite_default\",\n                    );\n                    let str_ptr = self.get_string_ptr(global);\n                    return self.make_string(str_ptr);\n                }\n                \"_tick_counter\" | \"_msg_counter\" | \"_verbose\" | \"__prop_passed\" => {\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"_global_bus\" | \"_global_logger\" => {\n                    // Return nil for global objects\n                    return Ok(self.make_nil());\n                }\n                // More missing builtins\n                \"maxaw\" => {\n                    // Maximum of list - return nil for now\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"maxaw expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let _list = self.compile_expr(&args[0])?;\n                    return Ok(self.make_nil());\n                }\n                \"is_odd\" => {\n                    // Check if number is odd\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_odd expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let n = self.compile_expr(&args[0])?;\n                    let data = self.extract_data(n)?;\n                    let two = self.types.i64_type.const_int(2, false);\n                    let rem = self\n                        .builder\n                        .build_int_signed_rem(data, two, \"is_odd_rem\")\n                        .unwrap();\n                    let zero = self.types.i64_type.const_int(0, false);\n                    let is_odd = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::NE, rem, zero, \"is_odd_cmp\")\n                        .unwrap();\n                    let is_odd_i64 = self\n                        .builder\n                        .build_int_z_extend(is_odd, self.types.i64_type, \"is_odd_i64\")\n                        .unwrap();\n                    return self.make_bool(is_odd_i64);\n                }\n                \"is_muckle\" => {\n                    // Check if value is large\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_muckle expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let _val = self.compile_expr(&args[0])?;\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"capitalize\" => {\n                    // Capitalize string - for now just return the string\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"capitalize expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let s = self.compile_expr(&args[0])?;\n                    return Ok(s);\n                }\n                \"bit_shove_left\" | \"bit_shift_left\" => {\n                    // Bitwise left shift\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"bit_shift_left expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let data_a = self.extract_data(a)?;\n                    let data_b = self.extract_data(b)?;\n                    let shifted = self\n                        .builder\n                        .build_left_shift(data_a, data_b, \"bit_shl\")\n                        .unwrap();\n                    return self.make_int(shifted);\n                }\n                // Scots exclamations and misc\n                \"help_ma_boab\" | \"banter\" | \"clype\" | \"spy\" => {\n                    // Just return nil\n                    return Ok(self.make_nil());\n                }\n                \"upper\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"upper expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_upper(arg);\n                }\n                \"lower\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"lower expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_lower(arg);\n                }\n                \"wheesht\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"wheesht expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_wheesht(arg);\n                }\n                \"coont\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"coont expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let sub_arg = self.compile_expr(&args[1])?;\n                    return self.inline_coont(str_arg, sub_arg);\n                }\n                // Phase 4: Type & Utility functions\n                \"whit_kind\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"whit_kind expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_whit_kind(arg);\n                }\n                \"range\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"range expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let start = self.compile_expr(&args[0])?;\n                    let end = self.compile_expr(&args[1])?;\n                    return self.inline_range(start, end);\n                }\n                // Phase 5: Timing functions\n                \"noo\" => {\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"noo expects 0 arguments\".to_string(),\n                        ));\n                    }\n                    return self.inline_noo();\n                }\n                \"tick\" => {\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"tick expects 0 arguments\".to_string(),\n                        ));\n                    }\n                    return self.inline_tick();\n                }\n                \"bide\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"bide expects 1 argument (milliseconds)\".to_string(),\n                        ));\n                    }\n                    let ms = self.compile_expr(&args[0])?;\n                    return self.inline_bide(ms);\n                }\n                // Phase 7: I/O functions\n                \"speir\" => {\n                    // Use runtime function to handle stdin properly\n                    let prompt = if args.is_empty() {\n                        self.make_nil() // Pass nil for no prompt\n                    } else {\n                        self.compile_expr(&args[0])?\n                    };\n                    let result = self\n                        .builder\n                        .build_call(self.libc.speir, &[prompt.into()], \"speir_result\")\n                        .map_err(|e| {\n                            HaversError::CompileError(format!(\"Failed to call speir: {}\", e))\n                        })?\n                        .try_as_basic_value()\n                        .left()\n                        .ok_or_else(|| {\n                            HaversError::CompileError(\"speir call failed\".to_string())\n                        })?;\n                    return Ok(result);\n                }\n                // Extra: String operations\n                \"split\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"split expects 2 arguments (string, delimiter)\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let delim_arg = self.compile_expr(&args[1])?;\n                    return self.inline_split(str_arg, delim_arg);\n                }\n                \"join\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"join expects 2 arguments (list, delimiter)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let delim_arg = self.compile_expr(&args[1])?;\n                    return self.inline_join(list_arg, delim_arg);\n                }\n                \"sort\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sort expects 1 argument (list)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    return self.inline_sort(list_arg);\n                }\n                \"shuffle\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"shuffle expects 1 argument (list)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    return self.inline_shuffle(list_arg);\n                }\n                // Phase 6: Higher-order functions\n                \"gaun\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"gaun expects 2 arguments (list, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let func_arg = self.compile_expr(&args[1])?;\n                    return self.inline_gaun(list_arg, func_arg);\n                }\n                \"sieve\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"sieve expects 2 arguments (list, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let func_arg = self.compile_expr(&args[1])?;\n                    return self.inline_sieve(list_arg, func_arg);\n                }\n                \"tumble\" => {\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"tumble expects 3 arguments (list, initial, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let init_arg = self.compile_expr(&args[1])?;\n                    let func_arg = self.compile_expr(&args[2])?;\n                    return self.inline_tumble(list_arg, init_arg, func_arg);\n                }\n                \"aw\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"aw expects 2 arguments (list, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let func_arg = self.compile_expr(&args[1])?;\n                    return self.inline_aw(list_arg, func_arg);\n                }\n                \"ony\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"ony expects 2 arguments (list, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let func_arg = self.compile_expr(&args[1])?;\n                    return self.inline_ony(list_arg, func_arg);\n                }\n                \"hunt\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"hunt expects 2 arguments (list, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let func_arg = self.compile_expr(&args[1])?;\n                    return self.inline_hunt(list_arg, func_arg);\n                }\n                \"ilk\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"ilk expects 2 arguments (list, function)\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let func_arg = self.compile_expr(&args[1])?;\n                    return self.inline_ilk(list_arg, func_arg);\n                }\n                // Dict functions\n                \"keys\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"keys expects 1 argument (dict)\".to_string(),\n                        ));\n                    }\n                    let dict_arg = self.compile_expr(&args[0])?;\n                    return self.inline_keys(dict_arg);\n                }\n                \"values\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"values expects 1 argument (dict)\".to_string(),\n                        ));\n                    }\n                    let dict_arg = self.compile_expr(&args[0])?;\n                    return self.inline_values(dict_arg);\n                }\n                \"jammy\" => {\n                    // jammy(min, max) - random number between min and max (inclusive)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"jammy expects 2 arguments (min, max)\".to_string(),\n                        ));\n                    }\n                    let min_arg = self.compile_expr(&args[0])?;\n                    let max_arg = self.compile_expr(&args[1])?;\n                    return self.inline_jammy(min_arg, max_arg);\n                }\n                \"get_key\" => {\n                    // get_key() - read a single key press\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"get_key expects 0 arguments\".to_string(),\n                        ));\n                    }\n                    return self.inline_get_key();\n                }\n                \"term_width\" => {\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"term_width expects 0 arguments\".to_string(),\n                        ));\n                    }\n                    return self.inline_term_width();\n                }\n                \"term_height\" => {\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"term_height expects 0 arguments\".to_string(),\n                        ));\n                    }\n                    return self.inline_term_height();\n                }\n                // Phase 1: Quick wins - new builtins\n                \"PI\" => {\n                    // PI as a float constant\n                    let pi_val = self.context.f64_type().const_float(std::f64::consts::PI);\n                    return self.make_float(pi_val);\n                }\n                \"ord\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"ord expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_ord(arg);\n                }\n                \"chr\" => {\n                    // chr(n) - convert codepoint to single-character string\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"chr expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_chr(arg);\n                }\n                \"char_at\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"char_at expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let idx_arg = self.compile_expr(&args[1])?;\n                    return self.inline_char_at(str_arg, idx_arg);\n                }\n                \"chars\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"chars expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_chars(arg);\n                }\n                \"repeat\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"repeat expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let count_arg = self.compile_expr(&args[1])?;\n                    return self.inline_repeat(str_arg, count_arg);\n                }\n                \"index_of\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"index_of expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let substr_arg = self.compile_expr(&args[1])?;\n                    return self.inline_index_of(str_arg, substr_arg);\n                }\n                // Phase 2: String operations\n                \"replace\" => {\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"replace expects 3 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let old_arg = self.compile_expr(&args[1])?;\n                    let new_arg = self.compile_expr(&args[2])?;\n                    return self.inline_replace(str_arg, old_arg, new_arg);\n                }\n                \"starts_wi\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"starts_wi expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let prefix_arg = self.compile_expr(&args[1])?;\n                    return self.inline_starts_wi(str_arg, prefix_arg);\n                }\n                \"ends_wi\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"ends_wi expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let suffix_arg = self.compile_expr(&args[1])?;\n                    return self.inline_ends_wi(str_arg, suffix_arg);\n                }\n                // Math functions\n                \"sin\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sin expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"sin\");\n                }\n                \"cos\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"cos expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"cos\");\n                }\n                \"tan\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tan expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"tan\");\n                }\n                \"sqrt\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sqrt expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"sqrt\");\n                }\n                \"atan2\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"atan2 expects 2 arguments (y, x)\".to_string(),\n                        ));\n                    }\n                    let y_arg = self.compile_expr(&args[0])?;\n                    let x_arg = self.compile_expr(&args[1])?;\n                    return self.inline_atan2(y_arg, x_arg);\n                }\n                \"asin\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"asin expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"asin\");\n                }\n                \"acos\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"acos expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"acos\");\n                }\n                \"atan\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"atan expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"atan\");\n                }\n                \"log\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"log expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"log\");\n                }\n                \"log10\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"log10 expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"log10\");\n                }\n                \"exp\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"exp expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_math_func(arg, \"exp\");\n                }\n                \"pooer\" | \"pow\" => {\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"pooer expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let base_arg = self.compile_expr(&args[0])?;\n                    let exp_arg = self.compile_expr(&args[1])?;\n                    return self.inline_pow(base_arg, exp_arg);\n                }\n                \"snooze\" => {\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"snooze expects 1 argument (milliseconds)\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_snooze(arg);\n                }\n                \"creel\" => {\n                    // creel() - create empty list, or creel(list) - copy list (future: dedupe)\n                    if args.is_empty() {\n                        // Create empty list with capacity 8\n                        let initial_cap = 8u64;\n                        let header_size = 16u64;\n                        let elem_size = 16u64;\n                        let total_size = header_size + initial_cap * elem_size;\n                        let size_val = self.types.i64_type.const_int(total_size, false);\n                        let list_ptr = self\n                            .builder\n                            .build_call(self.libc.malloc, &[size_val.into()], \"creel_ptr\")\n                            .unwrap()\n                            .try_as_basic_value()\n                            .left()\n                            .unwrap()\n                            .into_pointer_value();\n\n                        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n                        let len_ptr = self\n                            .builder\n                            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n                            .unwrap();\n                        self.builder\n                            .build_store(len_ptr, self.types.i64_type.const_int(0, false))\n                            .unwrap();\n                        let cap_ptr = unsafe {\n                            self.builder\n                                .build_gep(\n                                    self.context.i8_type(),\n                                    list_ptr,\n                                    &[self.types.i64_type.const_int(8, false)],\n                                    \"cap_ptr\",\n                                )\n                                .unwrap()\n                        };\n                        let cap_ptr = self\n                            .builder\n                            .build_pointer_cast(cap_ptr, i64_ptr, \"cap_ptr_i64\")\n                            .unwrap();\n                        self.builder\n                            .build_store(cap_ptr, self.types.i64_type.const_int(initial_cap, false))\n                            .unwrap();\n\n                        return self.make_list(list_ptr);\n                    } else if args.len() == 1 {\n                        // creel(list) - copy the list (simplified: just copy, no dedup)\n                        let list_arg = self.compile_expr(&args[0])?;\n                        return self.inline_uniq(list_arg);\n                    } else {\n                        return Err(HaversError::CompileError(\n                            \"creel expects 0 or 1 argument\".to_string(),\n                        ));\n                    }\n                }\n                \"slice\" => {\n                    // slice(list, start, end) - return a sublist\n                    if args.len() < 2 || args.len() > 3 {\n                        return Err(HaversError::CompileError(\n                            \"slice expects 2-3 arguments (list, start, [end])\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let start_arg = self.compile_expr(&args[1])?;\n                    let end_arg = if args.len() == 3 {\n                        Some(self.compile_expr(&args[2])?)\n                    } else {\n                        None\n                    };\n                    return self.inline_slice(list_arg, start_arg, end_arg);\n                }\n                \"uniq\" => {\n                    // uniq(list) - remove duplicates (simple O(n^2) implementation)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"uniq expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    return self.inline_uniq(list_arg);\n                }\n                \"dram\" => {\n                    // dram(list) - pick a random element from the list\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"dram expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    return self.inline_dram(list_arg);\n                }\n                \"birl\" => {\n                    // birl(list, n) - rotate list by n positions\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"birl expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let list_arg = self.compile_expr(&args[0])?;\n                    let n_arg = self.compile_expr(&args[1])?;\n                    return self.inline_birl(list_arg, n_arg);\n                }\n                \"ceilidh\" => {\n                    // ceilidh(list1, list2) - interleave two lists\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"ceilidh expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let list1_arg = self.compile_expr(&args[0])?;\n                    let list2_arg = self.compile_expr(&args[1])?;\n                    return self.inline_ceilidh(list1_arg, list2_arg);\n                }\n                \"pad_left\" | \"pad_right\" => {\n                    // pad_left/right(str, width, char) - pad string to width\n                    if args.len() < 2 || args.len() > 3 {\n                        return Err(HaversError::CompileError(format!(\n                            \"{} expects 2-3 arguments\",\n                            name\n                        )));\n                    }\n                    let str_arg = self.compile_expr(&args[0])?;\n                    let width_arg = self.compile_expr(&args[1])?;\n                    let pad_char = if args.len() == 3 {\n                        Some(self.compile_expr(&args[2])?)\n                    } else {\n                        None\n                    };\n                    return self.inline_pad(str_arg, width_arg, pad_char, name == \"pad_left\");\n                }\n                \"radians\" => {\n                    // radians(degrees) - convert degrees to radians\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"radians expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_radians(arg);\n                }\n                \"degrees\" => {\n                    // degrees(radians) - convert radians to degrees\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"degrees expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_degrees(arg);\n                }\n                \"braw\" => {\n                    // braw(val) - return val (identity function for filtering)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"braw expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"haverin\" | \"haver\" => {\n                    // haverin() - return random nonsense/placeholder text\n                    // Return a simple placeholder string\n                    let placeholder = \"Och aye, havers!\";\n                    return self.compile_string_literal(placeholder);\n                }\n                // Additional missing builtins\n                \"atween\" | \"between\" => {\n                    // atween(val, min, max) - check if val is between min and max\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"atween expects 3 arguments (val, min, max)\".to_string(),\n                        ));\n                    }\n                    let val = self.compile_expr(&args[0])?;\n                    let min_val = self.compile_expr(&args[1])?;\n                    let max_val = self.compile_expr(&args[2])?;\n                    // Extract data values and compare\n                    let val_data = self.extract_data(val)?;\n                    let min_data = self.extract_data(min_val)?;\n                    let max_data = self.extract_data(max_val)?;\n                    let ge_min = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::SGE, val_data, min_data, \"ge_min\")\n                        .unwrap();\n                    let le_max = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::SLE, val_data, max_data, \"le_max\")\n                        .unwrap();\n                    let result = self.builder.build_and(ge_min, le_max, \"atween\").unwrap();\n                    let result_i64 = self\n                        .builder\n                        .build_int_z_extend(result, self.types.i64_type, \"atween_i64\")\n                        .unwrap();\n                    return self.make_bool(result_i64);\n                }\n                \"hauld_atween\" | \"clamp\" => {\n                    // hauld_atween(val, min, max) - clamp val to [min, max]\n                    if args.len() != 3 {\n                        return Err(HaversError::CompileError(\n                            \"hauld_atween expects 3 arguments (val, min, max)\".to_string(),\n                        ));\n                    }\n                    let val = self.compile_expr(&args[0])?;\n                    let min_val = self.compile_expr(&args[1])?;\n                    let max_val = self.compile_expr(&args[2])?;\n                    // Use min(max(val, min), max) pattern\n                    let val_data = self.extract_data(val)?;\n                    let min_data = self.extract_data(min_val)?;\n                    let max_data = self.extract_data(max_val)?;\n                    let ge_min = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::SGE, val_data, min_data, \"ge_min\")\n                        .unwrap();\n                    let clamped_low = self\n                        .builder\n                        .build_select(ge_min, val_data, min_data, \"clamped_low\")\n                        .unwrap()\n                        .into_int_value();\n                    let le_max = self\n                        .builder\n                        .build_int_compare(\n                            inkwell::IntPredicate::SLE,\n                            clamped_low,\n                            max_data,\n                            \"le_max\",\n                        )\n                        .unwrap();\n                    let result = self\n                        .builder\n                        .build_select(le_max, clamped_low, max_data, \"clamped\")\n                        .unwrap()\n                        .into_int_value();\n                    return self.make_int(result);\n                }\n                \"range_o\" => {\n                    // range_o(list) - return max - min of list\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"range_o expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // Return nil for now (placeholder)\n                    return Ok(self.make_nil());\n                }\n                \"sclaff\" | \"flatten\" => {\n                    // sclaff(list) - flatten nested list\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sclaff expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // Return the argument unchanged for now (shallow flatten placeholder)\n                    return self.compile_expr(&args[0]);\n                }\n                \"inspect\" | \"debug\" => {\n                    // inspect(val) - print debug info about value\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"inspect expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    // Call blether on it for now\n                    self.inline_blether(arg)?;\n                    return Ok(self.make_nil());\n                }\n                \"json_stringify\" | \"tae_json\" => {\n                    // json_stringify(val) - convert to JSON string (placeholder)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"json_stringify expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // Return the argument as-is for now (placeholder)\n                    return self.compile_expr(&args[0]);\n                }\n                \"title\" | \"title_case\" => {\n                    // title(str) - title case a string (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"title expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"bit_shove_right\" | \"bit_shift_right\" => {\n                    // bit_shove_right(a, b) - logical right shift\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"bit_shove_right expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let a_data = self.extract_data(a)?;\n                    let b_data = self.extract_data(b)?;\n                    let result = self\n                        .builder\n                        .build_right_shift(a_data, b_data, false, \"bit_shr\")\n                        .unwrap();\n                    return self.make_int(result);\n                }\n                \"roar\" | \"shout\" => {\n                    // roar(str) - return uppercase string (alias for upper)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"roar expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_upper(arg);\n                }\n                \"skelp\" | \"truncate\" => {\n                    // skelp(str, n) - truncate string to n chars (placeholder: return as-is)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"skelp expects 2 arguments (str, n)\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"the_noo\" => {\n                    // the_noo() - alias for noo() - current timestamp\n                    if !args.is_empty() {\n                        return Err(HaversError::CompileError(\n                            \"the_noo expects 0 arguments\".to_string(),\n                        ));\n                    }\n                    return self.inline_noo();\n                }\n                \"gen_int\" | \"gen_a\" | \"gen_b\" | \"gen_bool\" | \"gen_string\" | \"gen_list\" => {\n                    // Property testing generators - return simple placeholder values\n                    return Ok(self.make_nil());\n                }\n                \"screen_open\"\n                | \"screen_close\"\n                | \"screen_should_close\"\n                | \"screen_clear\"\n                | \"draw_pixel\"\n                | \"draw_rect\"\n                | \"draw_circle\"\n                | \"draw_line\"\n                | \"draw_text\"\n                | \"screen_update\"\n                | \"get_mouse_x\"\n                | \"get_mouse_y\"\n                | \"is_mouse_down\"\n                | \"is_key_pressed\"\n                | \"screen_fps\"\n                | \"set_fps\" => {\n                    // Graphics placeholders - return nil\n                    return Ok(self.make_nil());\n                }\n                \"log_whisper\" | \"log_mutter\" | \"log_blether\" | \"log_holler\" | \"log_roar\"\n                | \"mutter\" | \"whisper\" | \"holler\" => {\n                    // Logging functions - just print the message\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(format!(\n                            \"{} expects 1 argument\",\n                            name\n                        )));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    self.inline_blether(arg)?;\n                    return Ok(self.make_nil());\n                }\n                \"cannie\" | \"careful\" => {\n                    // cannie(str) - trim string (alias for wheesht)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"cannie expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    return self.inline_wheesht(arg);\n                }\n                \"skip\" | \"pass\" => {\n                    // skip() - no-op placeholder for tests\n                    return Ok(self.make_nil());\n                }\n                \"bit_coont\" | \"bit_count\" | \"popcount\" => {\n                    // bit_coont(n) - count set bits (placeholder: return 0)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"bit_coont expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"is_nummer\" | \"is_number\" | \"is_int\" | \"is_float\" => {\n                    // is_nummer(val) - check if value is a number\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_nummer expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    let tag = self.extract_tag(arg)?;\n                    let int_tag = self.types.i8_type.const_int(2, false);\n                    let float_tag = self.types.i8_type.const_int(3, false);\n                    let is_int = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::EQ, tag, int_tag, \"is_int\")\n                        .unwrap();\n                    let is_float = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::EQ, tag, float_tag, \"is_float\")\n                        .unwrap();\n                    let result = self\n                        .builder\n                        .build_or(is_int, is_float, \"is_nummer\")\n                        .unwrap();\n                    let result_i64 = self\n                        .builder\n                        .build_int_z_extend(result, self.types.i64_type, \"is_nummer_i64\")\n                        .unwrap();\n                    return self.make_bool(result_i64);\n                }\n                \"is_toom\" | \"is_empty\" => {\n                    // is_toom(val) - check if value is empty (list len 0, string len 0, etc)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_toom expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    // Check length via len builtin concept\n                    let tag = self.extract_tag(arg)?;\n                    let list_tag = self.types.i8_type.const_int(5, false);\n                    let is_list = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::EQ, tag, list_tag, \"is_list\")\n                        .unwrap();\n                    // For simplicity, return false (placeholder)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"is_prime\" => {\n                    // is_prime(n) - check if n is prime (placeholder: return false)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_prime expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"sign\" | \"signum\" => {\n                    // sign(n) - return -1, 0, or 1\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"sign expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    let data = self.extract_data(arg)?;\n                    let zero = self.types.i64_type.const_int(0, false);\n                    let is_neg = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::SLT, data, zero, \"is_neg\")\n                        .unwrap();\n                    let is_pos = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::SGT, data, zero, \"is_pos\")\n                        .unwrap();\n                    let neg_one = self.types.i64_type.const_int((-1i64) as u64, true);\n                    let one = self.types.i64_type.const_int(1, false);\n                    let tmp = self\n                        .builder\n                        .build_select(is_pos, one, zero, \"sign_tmp\")\n                        .unwrap()\n                        .into_int_value();\n                    let result = self\n                        .builder\n                        .build_select(is_neg, neg_one, tmp, \"sign_result\")\n                        .unwrap()\n                        .into_int_value();\n                    return self.make_int(result);\n                }\n                \"glaikit\" | \"silly\" => {\n                    // glaikit(str) - return silly/random string (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"glaikit expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"tae_hex\" | \"to_hex\" => {\n                    // tae_hex(n) - convert to hex string (placeholder)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tae_hex expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_string_literal(\"0x0\");\n                }\n                \"is_hale_nummer\" | \"is_whole\" | \"is_integer\" => {\n                    // is_hale_nummer(val) - check if value is a whole number\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_hale_nummer expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    let tag = self.extract_tag(arg)?;\n                    let int_tag = self.types.i8_type.const_int(2, false);\n                    let is_int = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::EQ, tag, int_tag, \"is_hale\")\n                        .unwrap();\n                    let result_i64 = self\n                        .builder\n                        .build_int_z_extend(is_int, self.types.i64_type, \"is_hale_i64\")\n                        .unwrap();\n                    return self.make_bool(result_i64);\n                }\n                \"drap\" | \"drop\" => {\n                    // drap(list, n) - drop first n elements (placeholder: return as-is)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"drap expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"screen_width\" | \"screen_height\" | \"get_screen_width\" | \"get_screen_height\" => {\n                    // Graphics screen dimensions (placeholder: return 800/600)\n                    let val = if name.contains(\"width\") {\n                        800u64\n                    } else {\n                        600u64\n                    };\n                    let int_val = self.types.i64_type.const_int(val, false);\n                    return self.make_int(int_val);\n                }\n                \"gcd\" => {\n                    // gcd(a, b) - greatest common divisor (placeholder: return 1)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"gcd expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_int(one);\n                }\n                \"lcm\" => {\n                    // lcm(a, b) - least common multiple (placeholder: return product)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"lcm expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let a = self.compile_expr(&args[0])?;\n                    let b = self.compile_expr(&args[1])?;\n                    let a_data = self.extract_data(a)?;\n                    let b_data = self.extract_data(b)?;\n                    let result = self.builder.build_int_mul(a_data, b_data, \"lcm\").unwrap();\n                    return self.make_int(result);\n                }\n                \"scottify\" | \"scots_convert\" => {\n                    // scottify(str) - convert to Scots (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"scottify expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"property\" | \"prop\" => {\n                    // property(name, fn) - property test (placeholder)\n                    return Ok(self.make_nil());\n                }\n                \"wrang_sort\" | \"wrong_type\" => {\n                    // wrang_sort(val) - type error placeholder\n                    return Ok(self.make_nil());\n                }\n                \"tae_octal\" | \"to_octal\" => {\n                    // tae_octal(n) - convert to octal string (placeholder)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tae_octal expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_string_literal(\"0o0\");\n                }\n                \"is_positive\" | \"is_negative\" | \"is_zero\" => {\n                    // is_positive/negative/zero(n) - check sign\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(format!(\n                            \"{} expects 1 argument\",\n                            name\n                        )));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    let data = self.extract_data(arg)?;\n                    let zero = self.types.i64_type.const_int(0, false);\n                    let cmp_pred = if name.contains(\"positive\") {\n                        inkwell::IntPredicate::SGT\n                    } else if name.contains(\"negative\") {\n                        inkwell::IntPredicate::SLT\n                    } else {\n                        inkwell::IntPredicate::EQ\n                    };\n                    let result = self\n                        .builder\n                        .build_int_compare(cmp_pred, data, zero, name)\n                        .unwrap();\n                    let result_i64 = self\n                        .builder\n                        .build_int_z_extend(result, self.types.i64_type, &format!(\"{}_i64\", name))\n                        .unwrap();\n                    return self.make_bool(result_i64);\n                }\n                \"backside_forrit\" | \"backwards\" | \"reverse_str\" => {\n                    // backside_forrit(str) - reverse string (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"backside_forrit expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"key_down\" | \"key_pressed\" | \"key_up\" | \"key_released\" => {\n                    // Keyboard input (placeholder: return false)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"gen_c\" | \"gen_d\" | \"gen_e\" | \"gen_f\" => {\n                    // More property testing generators\n                    return Ok(self.make_nil());\n                }\n                \"tattie_scone\" | \"potato\" => {\n                    // Scots fun placeholder\n                    return self.compile_string_literal(\"Tattie scone!\");\n                }\n                \"fae_binary\" | \"from_binary\" => {\n                    // fae_binary(str) - parse binary string (placeholder: return 0)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"fae_binary expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"fae_hex\" | \"from_hex\" => {\n                    // fae_hex(str) - parse hex string (placeholder: return 0)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"fae_hex expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"dae_times\" | \"times\" | \"repeat_n\" => {\n                    // dae_times(n, fn) - repeat fn n times (placeholder)\n                    return Ok(self.make_nil());\n                }\n                \"first\" | \"heid\" => {\n                    // first(list) - get first element (placeholder: return nil)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"first expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // For now, return nil as placeholder\n                    return Ok(self.make_nil());\n                }\n                \"last\" | \"tail_heid\" => {\n                    // last(list) - get last element (placeholder: return nil)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"last expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"screen_end\" | \"end_graphics\" => {\n                    // Graphics cleanup placeholder\n                    return Ok(self.make_nil());\n                }\n                \"haggis_hunt\" | \"search_game\" => {\n                    // Scots game placeholder\n                    return self.compile_string_literal(\"Haggis found!\");\n                }\n                \"dict_merge\" | \"merge\" | \"thegither\" => {\n                    // dict_merge(dict1, dict2) - merge dicts (placeholder: return first)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"dict_merge expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"efter\" | \"after\" => {\n                    // efter(list, idx) - elements after index (placeholder: return as-is)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"efter expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"ilka\" | \"each\" | \"for_each\" => {\n                    // ilka(list, fn) - for each (placeholder)\n                    return Ok(self.make_nil());\n                }\n                \"skip\" | \"matrix_skip\" => {\n                    // skip - test skip marker (placeholder)\n                    return Ok(self.make_nil());\n                }\n                \"creels_baith\" | \"set_intersection\" => {\n                    // creels_baith(set1, set2) - intersection (placeholder: return first)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"creels_baith expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"creels_differ\" | \"set_difference\" => {\n                    // creels_differ(set1, set2) - difference (placeholder: return first)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"creels_differ expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"is_subset\" | \"subset\" => {\n                    // is_subset(set1, set2) - check if set1 is subset of set2 (placeholder: return true)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"is_subset expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"is_superset\" | \"superset\" => {\n                    // is_superset(set1, set2) - check if set1 is superset of set2 (placeholder: return true)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"is_superset expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"is_disjoint\" | \"disjoint\" => {\n                    // is_disjoint(set1, set2) - check if sets have no common elements (placeholder: return false)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"is_disjoint expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"assert_that\" | \"assert_eq\" | \"assert_ne\" | \"assert_true\" | \"assert_false\" => {\n                    // Test assertions - placeholder: do nothing\n                    return Ok(self.make_nil());\n                }\n                \"dict_get\" | \"get\" => {\n                    // dict_get(dict, key) or dict_get(dict, key, default) - get value from dict (placeholder: return default or nil)\n                    if args.len() < 2 || args.len() > 3 {\n                        return Err(HaversError::CompileError(\n                            \"dict_get expects 2-3 arguments\".to_string(),\n                        ));\n                    }\n                    if args.len() == 3 {\n                        // Return the default value\n                        return self.compile_expr(&args[2]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"fin\" | \"find_first\" => {\n                    // fin(list, predicate) - find first matching element (placeholder: return nil)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"fin expects 2 arguments (list, predicate)\".to_string(),\n                        ));\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"end\" | \"tail\" => {\n                    // end/tail(list) - get last element (placeholder: return nil)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"tail expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"crabbit\" | \"grumpy\" => {\n                    // Scots fun - return grumpy message\n                    return self.compile_string_literal(\"Och, I'm fair crabbit!\");\n                }\n                \"sporran_fill\" | \"fill_bag\" => {\n                    // Scots fun - placeholder\n                    return self.compile_string_literal(\"Sporran's full!\");\n                }\n                \"enumerate\" | \"with_index\" => {\n                    // enumerate(list) - add indices (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"enumerate expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"assert_equal\" | \"assertEqual\" => {\n                    // Test assertion - placeholder: do nothing\n                    return Ok(self.make_nil());\n                }\n                \"stoater\" | \"excellent\" => {\n                    // Scots slang for \"excellent\" - return as-is or string\n                    if args.is_empty() {\n                        return self.compile_string_literal(\"Stoater!\");\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"gallus\" | \"bold\" => {\n                    // Scots slang for \"bold/cheeky\" - return as-is or string\n                    if args.is_empty() {\n                        return self.compile_string_literal(\"Gallus!\");\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"scunner_check\" | \"scunner\" | \"scunnered\" => {\n                    // Scots - disgust check (placeholder)\n                    return self.compile_string_literal(\"Scunnered!\");\n                }\n                \"dict_remove\" | \"dict_delete\" | \"remove_key\" => {\n                    // dict_remove(dict, key) - remove key from dict (placeholder: return dict)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"dict_remove expects 2 arguments\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"scots_miles_tae_km\" | \"miles_to_km\" => {\n                    // Convert miles to km (1.609344)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"scots_miles_tae_km expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // Return input * 1.609344 (placeholder: just return input)\n                    return self.compile_expr(&args[0]);\n                }\n                \"clarty\" | \"dirty\" => {\n                    // Scots - dirty/messy (placeholder)\n                    return self.compile_string_literal(\"Clarty!\");\n                }\n                \"hex_group\" | \"group_by\" => {\n                    // Group items (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"scots_pints_tae_litres\" | \"pints_to_litres\" => {\n                    // Convert pints to litres (0.568)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"scots_pints_tae_litres expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"drookit\" | \"soaking_wet\" => {\n                    // Scots - soaking wet\n                    return self.compile_string_literal(\"Drookit!\");\n                }\n                \"dict_invert\" | \"invert\" => {\n                    // dict_invert(dict) - swap keys and values (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"dict_invert expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"fin_index\" | \"find_index\" => {\n                    // fin_index(list, predicate) - find index of first matching element (placeholder: return -1)\n                    if args.len() != 2 {\n                        return Err(HaversError::CompileError(\n                            \"fin_index expects 2 arguments (list, predicate)\".to_string(),\n                        ));\n                    }\n                    let neg_one = self.types.i64_type.const_int((-1i64) as u64, true);\n                    return self.make_int(neg_one);\n                }\n                \"bampot_mode\" | \"crazy_mode\" => {\n                    // Scots fun - bampot mode (placeholder: return true)\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"redd_up\" | \"tidy_up\" | \"cleanup\" => {\n                    // Scots - tidy up/clean up (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"stanes_tae_kg\" | \"stones_to_kg\" => {\n                    // Convert stones to kilograms (1 stone = 6.35 kg)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"stanes_tae_kg expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"matrix_new\" | \"matrix_create\" => {\n                    // Create new matrix (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"matrix_get\" => {\n                    // Get matrix element (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"matrix_set\" => {\n                    // Set matrix element (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"matrix_add\" | \"matrix_sub\" | \"matrix_mul\" => {\n                    // Matrix operations (placeholder: return first arg or nil)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"matrix_transpose\" => {\n                    // Transpose matrix (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"matrix_transpose expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"matrix_determinant\" => {\n                    // Calculate determinant (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"matrix_inverse\" => {\n                    // Calculate inverse (placeholder: return as-is)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"matrix_inverse expects 1 argument\".to_string(),\n                        ));\n                    }\n                    return self.compile_expr(&args[0]);\n                }\n                \"matrix_identity\" => {\n                    // Create identity matrix (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"matrix_zeros\" | \"matrix_ones\" => {\n                    // Create matrix of zeros/ones (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"config_load\" | \"config_get\" | \"config_set\" | \"config_save\" => {\n                    // Config operations (placeholder: return nil or arg)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"log_debug\" | \"log_info\" | \"log_warn\" | \"log_error\" => {\n                    // Logging functions (placeholder: just print and return nil)\n                    if !args.is_empty() {\n                        let val = self.compile_expr(&args[0])?;\n                        self.inline_blether(val)?;\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"promise_new\" | \"promise_resolve\" | \"promise_reject\" | \"promise_then\"\n                | \"promise_await\" => {\n                    // Promise functions (placeholder: return arg or nil)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"event_on\" | \"event_emit\" | \"event_off\" | \"event_once\" => {\n                    // Event emitter functions (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"cli_arg\" | \"cli_flag\" | \"cli_option\" => {\n                    // CLI parsing (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"cli_args\" => {\n                    // Get all CLI args (placeholder: return empty list)\n                    return Ok(self.make_nil());\n                }\n                \"http_get\" | \"http_post\" | \"http_put\" | \"http_delete\" => {\n                    // HTTP functions (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"store_new\" | \"store_get\" | \"store_set\" | \"store_subscribe\" => {\n                    // State store functions (placeholder: return nil or arg)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"chance\" | \"gen_chance\" | \"random_chance\" => {\n                    // Random chance/probability (placeholder: return true)\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"gen_pick\" | \"random_pick\" => {\n                    // Pick random element from list (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"gen_shuffle\" | \"shuffle\" => {\n                    // Shuffle list (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"gen_uuid\" | \"uuid\" => {\n                    // Generate UUID (placeholder: return placeholder string)\n                    return self.compile_string_literal(\"00000000-0000-0000-0000-000000000000\");\n                }\n                \"try_catch\" | \"catch\" => {\n                    // Try-catch error handling (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"throw\" | \"raise\" => {\n                    // Throw error (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"runtime_version\" => {\n                    // Get runtime version\n                    return self.compile_string_literal(\"1.0.0\");\n                }\n                \"runtime_platform\" => {\n                    // Get platform\n                    return self.compile_string_literal(\"linux\");\n                }\n                \"runtime_args\" => {\n                    // Get command line args (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"runtime_env\" => {\n                    // Get environment variable (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"runtime_exit\" => {\n                    // Exit program (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"runtime_cwd\" => {\n                    // Get current working directory (placeholder)\n                    return self.compile_string_literal(\".\");\n                }\n                \"proptesting_forall\" | \"forall\" => {\n                    // Property-based testing (placeholder: return true)\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_bool(one);\n                }\n                \"gen_list\" | \"gen_string\" | \"gen_dict\" => {\n                    // Generators for property testing (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"zip_up\" | \"zip\" => {\n                    // zip_up(list1, list2) - combine two lists (placeholder: return nil/empty)\n                    return Ok(self.make_nil());\n                }\n                \"unzip\" | \"unzip_list\" => {\n                    // unzip a list of pairs (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"partition\" | \"split_by\" => {\n                    // partition(list, predicate) - split into two lists (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"group_by\" | \"groupby\" => {\n                    // group_by(list, key_fn) - group by key (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"freq\" | \"frequencies\" => {\n                    // frequencies(list) - count occurrences (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"unique\" | \"dedupe\" => {\n                    // unique(list) - remove duplicates (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"scan\" | \"running_total\" => {\n                    // scan(list, init, fn) - running accumulator (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"window\" | \"sliding_window\" => {\n                    // window(list, size) - sliding window (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"interleave\" | \"weave\" => {\n                    // interleave(list1, list2) - alternate elements (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"chunk\" | \"chunks\" | \"batch\" => {\n                    // chunk(list, size) - split into chunks (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"rotate\" | \"rotate_list\" => {\n                    // rotate(list, n) - rotate elements (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"table_new\" | \"table_create\" => {\n                    // Create new table (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"table_add_row\" | \"table_row\" => {\n                    // Add row to table (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"table_render\" | \"render_table\" => {\n                    // Render table to string (placeholder: return empty string)\n                    return self.compile_string_literal(\"\");\n                }\n                \"test_suite\" | \"describe\" => {\n                    // Testing framework (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"test_case\" | \"it\" => {\n                    // Test case (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"run_tests\" | \"run_suite\" => {\n                    // Run test suite (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"mony\" | \"replicate\" => {\n                    // mony(value, count) - create list with n copies (placeholder: return nil/empty)\n                    return Ok(self.make_nil());\n                }\n                \"grup_runs\" | \"group_runs\" | \"runs\" => {\n                    // grup_runs(list) - group consecutive equal elements (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"items\" | \"dict_items\" | \"pairs\" => {\n                    // items(dict) - get list of key-value pairs (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"scots_wisdom\" | \"wisdom\" => {\n                    // Get random Scots wisdom/proverb\n                    return self.compile_string_literal(\"Lang may yer lum reek!\");\n                }\n                \"scots_greeting\" | \"greeting\" => {\n                    // Get random Scots greeting\n                    return self.compile_string_literal(\"Haud yer wheesht!\");\n                }\n                \"scots_insult\" | \"insult\" => {\n                    // Get random Scots insult (playful)\n                    return self.compile_string_literal(\"Awa' and bile yer heid!\");\n                }\n                \"compose\" | \"pipe\" => {\n                    // Function composition (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"curry\" | \"partial\" => {\n                    // Currying/partial application (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"memoize\" | \"cache\" => {\n                    // Memoization (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"identity\" | \"id\" => {\n                    // Identity function - return argument as-is\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"constantly\" | \"always\" => {\n                    // Always return the same value (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"once\" | \"call_once\" => {\n                    // Call function once, cache result (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"throttle\" | \"rate_limit\" => {\n                    // Rate limiting (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"debounce\" | \"delay_call\" => {\n                    // Debouncing (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"fae_pairs\" | \"from_pairs\" | \"dict_from_pairs\" => {\n                    // fae_pairs(pairs) - create dict from list of pairs (placeholder: return nil/empty dict)\n                    return Ok(self.make_nil());\n                }\n                \"is_baw\" | \"is_blank\" | \"is_whitespace\" => {\n                    // is_baw(str) - check if string is blank/whitespace only\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_baw expects 1 argument\".to_string(),\n                        ));\n                    }\n                    // Placeholder: return false\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"ascii\" | \"char_code\" => {\n                    // ascii(char) - get ASCII code (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"from_ascii\" | \"char\" => {\n                    // from_ascii(code) - get char from ASCII code (placeholder: return empty string)\n                    return self.compile_string_literal(\"\");\n                }\n                \"split_lines\" | \"lines\" => {\n                    // split_lines(str) - split string into lines (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"split_words\" | \"words\" => {\n                    // split_words(str) - split string into words (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"encode_base64\" | \"base64_encode\" => {\n                    // Base64 encode (placeholder: return empty string)\n                    return self.compile_string_literal(\"\");\n                }\n                \"decode_base64\" | \"base64_decode\" => {\n                    // Base64 decode (placeholder: return empty string)\n                    return self.compile_string_literal(\"\");\n                }\n                \"url_encode\" | \"encode_uri\" => {\n                    // URL encode (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"url_decode\" | \"decode_uri\" => {\n                    // URL decode (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"hash_md5\" | \"md5\" => {\n                    // MD5 hash (placeholder: return empty string)\n                    return self.compile_string_literal(\"\");\n                }\n                \"hash_sha256\" | \"sha256\" => {\n                    // SHA256 hash (placeholder: return empty string)\n                    return self.compile_string_literal(\"\");\n                }\n                \"center\" | \"centre\" | \"center_text\" | \"pad_center\" => {\n                    // center(str, width, pad_char) - center pad string (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"repeat_say\" | \"repeat_string\" | \"str_repeat\" => {\n                    // repeat_say(str, n) - repeat string n times (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"leftpad\" | \"pad_left\" | \"lpad\" => {\n                    // leftpad(str, width, pad_char) - left pad string (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"rightpad\" | \"pad_right\" | \"rpad\" => {\n                    // rightpad(str, width, pad_char) - right pad string (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"abbreviate\" | \"ellipsis\" => {\n                    // abbreviate(str, max_len) - truncate with ellipsis (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"slug\" | \"slugify\" => {\n                    // slugify(str) - convert to URL slug (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"camelize\" | \"camel_case\" => {\n                    // camelize(str) - convert to camelCase (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"underscore\" | \"snake_case\" => {\n                    // underscore(str) - convert to snake_case (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"is_upper\" | \"is_uppercase\" => {\n                    // is_upper(str) - check if string is all uppercase\n                    // Placeholder: return false\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"is_lower\" | \"is_lowercase\" => {\n                    // is_lower(str) - check if string is all lowercase\n                    // Placeholder: return false\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"is_alpha\" | \"is_alphabetic\" => {\n                    // is_alpha(str) - check if string is all letters\n                    // Placeholder: return false\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"is_digit\" | \"is_numeric\" => {\n                    // is_digit(str) - check if string is all digits\n                    // Placeholder: return false\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"is_alnum\" | \"is_alphanumeric\" => {\n                    // is_alnum(str) - check if string is alphanumeric\n                    // Placeholder: return false\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"is_nowt\" | \"is_nil\" | \"is_null\" | \"is_none\" => {\n                    // is_nowt(val) - check if value is nil\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_nowt expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    let tag = self.extract_tag(arg)?;\n                    let nil_tag = self.types.i8_type.const_int(0, false);\n                    let is_nil = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::EQ, tag, nil_tag, \"is_nil\")\n                        .unwrap();\n                    let is_nil_i64 = self\n                        .builder\n                        .build_int_z_extend(is_nil, self.types.i64_type, \"is_nil_i64\")\n                        .unwrap();\n                    return self.make_bool(is_nil_i64);\n                }\n                \"swapcase\" | \"swap_case\" => {\n                    // swapcase(str) - swap uppercase and lowercase (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"count_str\" | \"str_count\" | \"count_char\" => {\n                    // count_str(str, substr) - count occurrences of substring\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"index_of\" | \"find_str\" | \"str_find\" => {\n                    // index_of(str, substr) - find first occurrence (-1 if not found)\n                    let neg_one = self.types.i64_type.const_int((-1i64) as u64, true);\n                    return self.make_int(neg_one);\n                }\n                \"last_index_of\" | \"rfind\" => {\n                    // last_index_of(str, substr) - find last occurrence (-1 if not found)\n                    let neg_one = self.types.i64_type.const_int((-1i64) as u64, true);\n                    return self.make_int(neg_one);\n                }\n                \"insert_at\" | \"list_insert\" => {\n                    // insert_at(list, index, value) - insert at index (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"remove_at\" => {\n                    // remove_at(list, index) - remove at index (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"index\" | \"list_index\" | \"find_value\" => {\n                    // index(list, value) - find index of value (-1 if not found)\n                    let neg_one = self.types.i64_type.const_int((-1i64) as u64, true);\n                    return self.make_int(neg_one);\n                }\n                \"count_val\" | \"list_count\" => {\n                    // count_val(list, value) - count occurrences of value\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"clear\" | \"list_clear\" | \"dict_clear\" => {\n                    // clear(collection) - clear all elements (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"copy\" | \"clone\" | \"shallow_copy\" => {\n                    // copy(val) - shallow copy (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"deep_copy\" | \"deepcopy\" => {\n                    // deep_copy(val) - deep copy (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"update\" | \"dict_update\" | \"merge\" => {\n                    // update(dict1, dict2) - merge dicts (placeholder: return first)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"setdefault\" | \"get_or_set\" => {\n                    // setdefault(dict, key, default) - get or set default (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"pop\" | \"dict_pop\" | \"list_pop\" => {\n                    // pop(collection, key/index) - remove and return (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"popitem\" | \"dict_popitem\" => {\n                    // popitem(dict) - remove and return arbitrary item (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"is_somethin\" | \"is_something\" | \"is_some\" => {\n                    // is_somethin(val) - check if value is not nil (inverse of is_nowt)\n                    if args.len() != 1 {\n                        return Err(HaversError::CompileError(\n                            \"is_somethin expects 1 argument\".to_string(),\n                        ));\n                    }\n                    let arg = self.compile_expr(&args[0])?;\n                    let tag = self.extract_tag(arg)?;\n                    let nil_tag = self.types.i8_type.const_int(0, false);\n                    let is_not_nil = self\n                        .builder\n                        .build_int_compare(inkwell::IntPredicate::NE, tag, nil_tag, \"is_not_nil\")\n                        .unwrap();\n                    let is_not_nil_i64 = self\n                        .builder\n                        .build_int_z_extend(is_not_nil, self.types.i64_type, \"is_not_nil_i64\")\n                        .unwrap();\n                    return self.make_bool(is_not_nil_i64);\n                }\n                \"strip_left\" | \"lstrip\" | \"trim_left\" => {\n                    // strip_left(str) - strip left whitespace (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"strip_right\" | \"rstrip\" | \"trim_right\" => {\n                    // strip_right(str) - strip right whitespace (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"substr_between\" | \"between\" => {\n                    // substr_between(str, start, end) - get substring between markers (placeholder)\n                    return self.compile_string_literal(\"\");\n                }\n                \"replace_first\" | \"replace_one\" => {\n                    // replace_first(str, old, new) - replace first occurrence (placeholder)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"chr\" | \"from_char_code\" => {\n                    // chr(code) - character from code (placeholder)\n                    return self.compile_string_literal(\"\");\n                }\n                \"ord\" | \"char_code_at\" => {\n                    // ord(char) - code from character (placeholder)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"char_at\" | \"get_char\" => {\n                    // char_at(str, index) - get character at index (placeholder)\n                    return self.compile_string_literal(\"\");\n                }\n                \"lerp\" | \"linear_interpolate\" => {\n                    // lerp(a, b, t) - linear interpolation (placeholder: return a)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"clamp\" | \"clamp_value\" => {\n                    // clamp(val, min, max) - clamp value (placeholder: return val)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"median\" | \"middle_value\" => {\n                    // median(list) - get median value (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"average\" | \"avg\" | \"mean\" => {\n                    // average(list) - get average (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"factorial\" | \"fact\" => {\n                    // factorial(n) (placeholder: return 1)\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_int(one);\n                }\n                \"tae_binary\" | \"to_binary\" => {\n                    // tae_binary(n) - convert to binary string (placeholder)\n                    return self.compile_string_literal(\"0b0\");\n                }\n                \"xor_cipher\" | \"xor_encrypt\" => {\n                    // xor_cipher(str, key) - XOR encryption (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return self.compile_string_literal(\"\");\n                }\n                \"assert\" | \"assert_true\" => {\n                    // assert(condition) - assert condition is true (placeholder: do nothing)\n                    return Ok(self.make_nil());\n                }\n                \"assert_nae_equal\" | \"assert_not_equal\" => {\n                    // assert_nae_equal(a, b) - assert not equal (placeholder: do nothing)\n                    return Ok(self.make_nil());\n                }\n                \"or_else\" | \"default\" | \"coalesce\" => {\n                    // or_else(val, default) - return default if val is nil\n                    if args.len() >= 2 {\n                        let val = self.compile_expr(&args[0])?;\n                        let tag = self.extract_tag(val)?;\n                        let nil_tag = self.types.i8_type.const_int(0, false);\n                        let is_nil = self\n                            .builder\n                            .build_int_compare(inkwell::IntPredicate::EQ, tag, nil_tag, \"is_nil\")\n                            .unwrap();\n                        let default_val = self.compile_expr(&args[1])?;\n                        let result = self\n                            .builder\n                            .build_select(is_nil, default_val, val, \"or_else_result\")\n                            .unwrap();\n                        return Ok(result);\n                    }\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"same\" | \"identical\" => {\n                    // same(a, b) - check if values are identical (placeholder: return false)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"nae_that\" | \"not_that\" | \"unless\" => {\n                    // nae_that(condition, value) - return value unless condition (placeholder)\n                    if args.len() >= 2 {\n                        return self.compile_expr(&args[1]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"swatch\" | \"case\" | \"switch\" => {\n                    // swatch(val, cases) - switch/case (placeholder: return nil)\n                    return Ok(self.make_nil());\n                }\n                \"wee\" | \"small\" | \"mini\" => {\n                    // wee(n) - make smaller (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"muckle\" | \"big\" | \"large\" => {\n                    // muckle(n) - make bigger (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"tak\" | \"take\" => {\n                    // tak(list, n) - take first n elements (placeholder: return as-is)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"constant\" | \"const\" => {\n                    // constant(val) - create constant function (placeholder: return val)\n                    if !args.is_empty() {\n                        return self.compile_expr(&args[0]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"apply_n\" | \"apply_times\" => {\n                    // apply_n(fn, n, val) - apply fn n times (placeholder: return val)\n                    if args.len() >= 3 {\n                        return self.compile_expr(&args[2]);\n                    }\n                    return Ok(self.make_nil());\n                }\n                \"product\" | \"prod\" => {\n                    // product(list) - multiply all elements (placeholder: return 1)\n                    let one = self.types.i64_type.const_int(1, false);\n                    return self.make_int(one);\n                }\n                \"dict_has\" | \"has_key\" | \"contains_key\" => {\n                    // dict_has(dict, key) - check if dict has key (placeholder: return false)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_bool(zero);\n                }\n                \"bit_an\" | \"bit_and\" | \"bitand\" => {\n                    // bit_an(a, b) - bitwise AND (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"bit_or\" | \"bitor\" => {\n                    // bit_or(a, b) - bitwise OR (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"bit_xor\" | \"bitxor\" => {\n                    // bit_xor(a, b) - bitwise XOR (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"bit_nae\" | \"bit_not\" | \"bitnot\" => {\n                    // bit_nae(n) - bitwise NOT (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                \"bit_shove_left\" | \"bit_shl\" | \"shl\" => {\n                    // bit_shove_left(n, amount) - left shift (placeholder: return 0)\n                    let zero = self.types.i64_type.const_int(0, false);\n                    return self.make_int(zero);\n                }\n                _ => {}\n            }\n\n            // Check if it's a variable containing a function value (lambda)\n            if let Some(&var_ptr) = self.variables.get(name) {\n                let func_val = self\n                    .builder\n                    .build_load(self.types.value_type, var_ptr, \"func_val\")\n                    .map_err(|e| HaversError::CompileError(format!(\"Failed to load var: {}\", e)))?;\n\n                // Compile arguments\n                let mut compiled_args: Vec<BasicValueEnum<'ctx>> = Vec::new();\n                for arg in args {\n                    compiled_args.push(self.compile_expr(arg)?);\n                }\n\n                return self.call_function_value(func_val, &compiled_args);\n            }\n        }\n\n        // Check if callee is any expression that evaluates to a function value\n        let func_val = self.compile_expr(callee)?;\n        let mut compiled_args: Vec<BasicValueEnum<'ctx>> = Vec::new();\n        for arg in args {\n            compiled_args.push(self.compile_expr(arg)?);\n        }\n        self.call_function_value(func_val, &compiled_args)\n    }\n\n    fn compile_if(\n        &mut self,\n        condition: &Expr,\n        then_branch: &Stmt,\n        else_branch: Option<&Stmt>,\n    ) -> Result<(), HaversError> {\n        let function = self.current_function.unwrap();\n        // Optimization: try to compile condition directly to i1 without boxing\n        let cond_bool = if let Some(direct) = self.compile_condition_direct(condition)? {\n            direct\n        } else {\n            let cond_val = self.compile_expr(condition)?;\n            self.is_truthy(cond_val)?\n        };\n\n        let then_block = self.context.append_basic_block(function, \"then\");\n        let else_block = self.context.append_basic_block(function, \"else\");\n        let merge_block = self.context.append_basic_block(function, \"merge\");\n\n        self.builder\n            .build_conditional_branch(cond_bool, then_block, else_block)\n            .unwrap();\n\n        // Then branch\n        self.builder.position_at_end(then_block);\n        self.compile_stmt(then_branch)?;\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder\n                .build_unconditional_branch(merge_block)\n                .unwrap();\n        }\n\n        // Else branch\n        self.builder.position_at_end(else_block);\n        if let Some(else_stmt) = else_branch {\n            self.compile_stmt(else_stmt)?;\n        }\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder\n                .build_unconditional_branch(merge_block)\n                .unwrap();\n        }\n\n        self.builder.position_at_end(merge_block);\n        Ok(())\n    }\n\n    fn compile_while(&mut self, condition: &Expr, body: &Stmt) -> Result<(), HaversError> {\n        let function = self.current_function.unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"loop\");\n        let body_block = self.context.append_basic_block(function, \"body\");\n        let after_block = self.context.append_basic_block(function, \"after\");\n\n        self.loop_stack.push(LoopContext {\n            break_block: after_block,\n            continue_block: loop_block,\n        });\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        // Optimization: try to compile condition directly to i1 without boxing\n        let cond_bool = if let Some(direct) = self.compile_condition_direct(condition)? {\n            direct\n        } else {\n            // Fallback: compile expression and check truthiness\n            let cond_val = self.compile_expr(condition)?;\n            self.is_truthy(cond_val)?\n        };\n        self.builder\n            .build_conditional_branch(cond_bool, body_block, after_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        // Mark that we're in a hot loop body (skip MdhValue stores)\n        let was_in_loop = self.in_loop_body;\n        self.in_loop_body = true;\n        self.compile_stmt(body)?;\n        self.in_loop_body = was_in_loop;\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder.build_unconditional_branch(loop_block).unwrap();\n        }\n\n        self.loop_stack.pop();\n        self.builder.position_at_end(after_block);\n\n        // Only sync shadows at outermost loop exit (skip for inner loops)\n        // Inner loop values will be synced when the outer loop exits\n        if !was_in_loop {\n            self.sync_all_shadows()?;\n        }\n\n        Ok(())\n    }\n\n    fn compile_for(\n        &mut self,\n        variable: &str,\n        iterable: &Expr,\n        body: &Stmt,\n    ) -> Result<(), HaversError> {\n        if let Expr::Range {\n            start,\n            end,\n            inclusive,\n            ..\n        } = iterable\n        {\n            return self.compile_for_range(variable, start, end, *inclusive, body);\n        }\n        // For-each loop over list\n        self.compile_for_list(variable, iterable, body)\n    }\n\n    fn compile_for_list(\n        &mut self,\n        variable: &str,\n        iterable: &Expr,\n        body: &Stmt,\n    ) -> Result<(), HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Compile the iterable (should be a list)\n        let list_val = self.compile_expr(iterable)?;\n\n        // Extract list pointer from the MdhValue\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self\n            .context\n            .i8_type()\n            .ptr_type(inkwell::AddressSpace::default());\n        let i64_ptr_type = self\n            .types\n            .i64_type\n            .ptr_type(inkwell::AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        // Get list length (first 8 bytes)\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Create loop variable (holds element value)\n        let var_alloca = self.create_entry_block_alloca(variable);\n        self.variables.insert(variable.to_string(), var_alloca);\n\n        // Create index counter\n        let idx_alloca = self\n            .builder\n            .build_alloca(self.types.i64_type, \"for_idx\")\n            .unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(idx_alloca, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"for_list_loop\");\n        let body_block = self.context.append_basic_block(function, \"for_list_body\");\n        let incr_block = self.context.append_basic_block(function, \"for_list_incr\");\n        let after_block = self.context.append_basic_block(function, \"for_list_after\");\n\n        self.loop_stack.push(LoopContext {\n            break_block: after_block,\n            continue_block: incr_block,\n        });\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Loop condition: idx < len\n        self.builder.position_at_end(loop_block);\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_alloca, \"idx\")\n            .unwrap()\n            .into_int_value();\n        let cmp = self\n            .builder\n            .build_int_compare(IntPredicate::ULT, idx, list_len, \"for_cmp\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cmp, body_block, after_block)\n            .unwrap();\n\n        // Body: load element at idx into variable\n        self.builder.position_at_end(body_block);\n\n        // Calculate element offset: 8 (header) + idx * 16 (element size)\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n\n        // Get pointer to element\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types\n                    .value_type\n                    .ptr_type(inkwell::AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        // Store element in loop variable\n        self.builder.build_store(var_alloca, elem_val).unwrap();\n\n        // Compile body\n        self.compile_stmt(body)?;\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder.build_unconditional_branch(incr_block).unwrap();\n        }\n\n        // Increment\n        self.builder.position_at_end(incr_block);\n        // Reload idx from alloca - can't use value from loop_block (domination issue)\n        let idx_in_incr = self\n            .builder\n            .build_load(self.types.i64_type, idx_alloca, \"idx_incr\")\n            .unwrap()\n            .into_int_value();\n        let one = self.types.i64_type.const_int(1, false);\n        let next_idx = self\n            .builder\n            .build_int_add(idx_in_incr, one, \"next_idx\")\n            .unwrap();\n        self.builder.build_store(idx_alloca, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.loop_stack.pop();\n        self.builder.position_at_end(after_block);\n        Ok(())\n    }\n\n    fn compile_for_range(\n        &mut self,\n        variable: &str,\n        start: &Expr,\n        end: &Expr,\n        inclusive: bool,\n        body: &Stmt,\n    ) -> Result<(), HaversError> {\n        let function = self.current_function.unwrap();\n\n        let start_val = self.compile_expr(start)?;\n        let end_val = self.compile_expr(end)?;\n\n        let start_data = self.extract_data(start_val)?;\n        let end_data = self.extract_data(end_val)?;\n\n        // Create loop variable\n        let var_alloca = self.create_entry_block_alloca(variable);\n        let start_mdh = self.make_int(start_data)?;\n        self.builder.build_store(var_alloca, start_mdh).unwrap();\n        self.variables.insert(variable.to_string(), var_alloca);\n\n        // Create counter\n        let counter_alloca = self\n            .builder\n            .build_alloca(self.types.i64_type, \"counter\")\n            .unwrap();\n        self.builder\n            .build_store(counter_alloca, start_data)\n            .unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"for_loop\");\n        let body_block = self.context.append_basic_block(function, \"for_body\");\n        let incr_block = self.context.append_basic_block(function, \"for_incr\");\n        let after_block = self.context.append_basic_block(function, \"for_after\");\n\n        self.loop_stack.push(LoopContext {\n            break_block: after_block,\n            continue_block: incr_block,\n        });\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Loop condition\n        self.builder.position_at_end(loop_block);\n        let current = self\n            .builder\n            .build_load(self.types.i64_type, counter_alloca, \"current\")\n            .unwrap()\n            .into_int_value();\n        let cmp = if inclusive {\n            self.builder\n                .build_int_compare(IntPredicate::SLE, current, end_data, \"cmp\")\n        } else {\n            self.builder\n                .build_int_compare(IntPredicate::SLT, current, end_data, \"cmp\")\n        }\n        .unwrap();\n        self.builder\n            .build_conditional_branch(cmp, body_block, after_block)\n            .unwrap();\n\n        // Body\n        self.builder.position_at_end(body_block);\n        self.compile_stmt(body)?;\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder.build_unconditional_branch(incr_block).unwrap();\n        }\n\n        // Increment\n        self.builder.position_at_end(incr_block);\n        // Reload counter from alloca - can't use value from loop_block (domination issue)\n        let current_in_incr = self\n            .builder\n            .build_load(self.types.i64_type, counter_alloca, \"current_incr\")\n            .unwrap()\n            .into_int_value();\n        let one = self.types.i64_type.const_int(1, false);\n        let next = self\n            .builder\n            .build_int_add(current_in_incr, one, \"next\")\n            .unwrap();\n        self.builder.build_store(counter_alloca, next).unwrap();\n\n        let next_mdh = self.make_int(next)?;\n        self.builder.build_store(var_alloca, next_mdh).unwrap();\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.loop_stack.pop();\n        self.builder.position_at_end(after_block);\n        Ok(())\n    }\n\n    fn compile_function(\n        &mut self,\n        name: &str,\n        params: &[crate::ast::Param],\n        body: &[Stmt],\n    ) -> Result<(), HaversError> {\n        // Pre-declare any nested functions in this body\n        // For nested functions, we need to analyze their bodies for captured variables\n        for stmt in body {\n            if let Stmt::Function {\n                name: nested_name,\n                params: nested_params,\n                body: nested_body,\n                ..\n            } = stmt\n            {\n                if !self.functions.contains_key(nested_name) {\n                    // Find free variables in the nested function\n                    let captures = self.find_free_variables_in_body(nested_body, nested_params);\n                    self.declare_function_with_captures(\n                        nested_name,\n                        nested_params.len(),\n                        &captures,\n                    )?;\n                }\n            }\n        }\n\n        let function =\n            self.functions.get(name).copied().ok_or_else(|| {\n                HaversError::CompileError(format!(\"Function not declared: {}\", name))\n            })?;\n\n        let entry = self.context.append_basic_block(function, \"entry\");\n\n        let saved_function = self.current_function;\n        let saved_block = self.builder.get_insert_block(); // Save the actual block, not just function\n        let saved_variables = std::mem::take(&mut self.variables);\n        let saved_var_types = std::mem::take(&mut self.var_types);\n        let saved_int_shadows = std::mem::take(&mut self.int_shadows);\n        let saved_list_ptr_shadows = std::mem::take(&mut self.list_ptr_shadows);\n        let saved_string_len_shadows = std::mem::take(&mut self.string_len_shadows);\n        let saved_string_cap_shadows = std::mem::take(&mut self.string_cap_shadows);\n        let saved_in_user_function = self.in_user_function;\n\n        self.builder.position_at_end(entry);\n        self.current_function = Some(function);\n        self.in_user_function = true;\n\n        // Set up parameters\n        // Create shadows for all parameters (optimistic: assume they're integers)\n        // The shadow will be used if the parameter is used in integer context\n        for (i, param) in params.iter().enumerate() {\n            let param_val = function\n                .get_nth_param(i as u32)\n                .ok_or_else(|| HaversError::CompileError(\"Missing parameter\".to_string()))?;\n            let alloca = self.create_entry_block_alloca(&param.name);\n            self.builder.build_store(alloca, param_val).unwrap();\n            self.variables.insert(param.name.clone(), alloca);\n\n            // Create shadow with extracted int value (optimistic)\n            // If parameter isn't actually an int at runtime, this is still safe\n            // because we only use the shadow when we KNOW it's an int context\n            let shadow = self.create_entry_block_alloca_i64(&format!(\"{}_shadow\", param.name));\n            let data = self.extract_data(param_val)?;\n            self.builder.build_store(shadow, data).unwrap();\n            self.int_shadows.insert(param.name.clone(), shadow);\n\n            // Mark as Unknown - but shadow is available for optimizations\n            self.var_types.insert(param.name.clone(), VarType::Unknown);\n        }\n\n        // Set up captured variables (come after regular parameters)\n        if let Some(captures) = self.function_captures.get(name).cloned() {\n            let base_idx = params.len();\n            for (i, capture_name) in captures.iter().enumerate() {\n                let param_val = function\n                    .get_nth_param((base_idx + i) as u32)\n                    .ok_or_else(|| {\n                        HaversError::CompileError(format!(\n                            \"Missing captured param: {}\",\n                            capture_name\n                        ))\n                    })?;\n                let alloca = self.create_entry_block_alloca(capture_name);\n                self.builder.build_store(alloca, param_val).unwrap();\n                self.variables.insert(capture_name.clone(), alloca);\n            }\n        }\n\n        // Compile body\n        for stmt in body {\n            self.compile_stmt(stmt)?;\n        }\n\n        // Add implicit return if needed\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder.build_return(Some(&self.make_nil())).unwrap();\n        }\n\n        // Restore state - all shadow maps to prevent cross-function leakage\n        self.current_function = saved_function;\n        self.variables = saved_variables;\n        self.var_types = saved_var_types;\n        self.int_shadows = saved_int_shadows;\n        self.list_ptr_shadows = saved_list_ptr_shadows;\n        self.string_len_shadows = saved_string_len_shadows;\n        self.string_cap_shadows = saved_string_cap_shadows;\n        self.in_user_function = saved_in_user_function;\n\n        // Restore the builder position to where it was before compiling this function\n        if let Some(block) = saved_block {\n            self.builder.position_at_end(block);\n        }\n\n        Ok(())\n    }\n\n    fn compile_ternary(\n        &mut self,\n        condition: &Expr,\n        then_expr: &Expr,\n        else_expr: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        let cond_val = self.compile_expr(condition)?;\n        let cond_bool = self.is_truthy(cond_val)?;\n\n        let then_block = self.context.append_basic_block(function, \"tern_then\");\n        let else_block = self.context.append_basic_block(function, \"tern_else\");\n        let merge_block = self.context.append_basic_block(function, \"tern_merge\");\n\n        self.builder\n            .build_conditional_branch(cond_bool, then_block, else_block)\n            .unwrap();\n\n        self.builder.position_at_end(then_block);\n        let then_val = self.compile_expr(then_expr)?;\n        let then_bb = self.builder.get_insert_block().unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        self.builder.position_at_end(else_block);\n        let else_val = self.compile_expr(else_expr)?;\n        let else_bb = self.builder.get_insert_block().unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"tern\")\n            .unwrap();\n        phi.add_incoming(&[(&then_val, then_bb), (&else_val, else_bb)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    fn create_entry_block_alloca(&self, name: &str) -> PointerValue<'ctx> {\n        let function = self.current_function.unwrap();\n        let entry = function.get_first_basic_block().unwrap();\n\n        let builder = self.context.create_builder();\n        match entry.get_first_instruction() {\n            Some(instr) => builder.position_before(&instr),\n            None => builder.position_at_end(entry),\n        }\n\n        builder.build_alloca(self.types.value_type, name).unwrap()\n    }\n\n    /// Create alloca for i64 shadow variable in entry block (hoisted from loop)\n    fn create_entry_block_alloca_i64(&self, name: &str) -> PointerValue<'ctx> {\n        let function = self.current_function.unwrap();\n        let entry = function.get_first_basic_block().unwrap();\n\n        let builder = self.context.create_builder();\n        match entry.get_first_instruction() {\n            Some(instr) => builder.position_before(&instr),\n            None => builder.position_at_end(entry),\n        }\n\n        builder.build_alloca(self.types.i64_type, name).unwrap()\n    }\n\n    /// Compile a list expression: allocate memory and store elements\n    /// Memory layout: [i64 length, {i8,i64} elem0, {i8,i64} elem1, ...]\n    fn compile_list(&mut self, elements: &[Expr]) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Check if any element is a spread expression\n        let has_spread = elements.iter().any(|e| matches!(e, Expr::Spread { .. }));\n\n        if has_spread {\n            // Use dynamic path with spread handling\n            return self.compile_list_with_spread(elements);\n        }\n\n        let len = elements.len();\n\n        // New layout: [capacity: i64][length: i64][elements...]\n        // Calculate capacity: at least 2048 elements or len, whichever is larger\n        // Balances memory allocation cost vs reallocation overhead\n        let initial_capacity = std::cmp::max(2048, len);\n        let value_size = 16u64; // sizeof({i8, i64}) with alignment\n        let header_size = 16u64; // 2 * sizeof(i64) for capacity + length\n        let total_size = header_size + (initial_capacity as u64) * value_size;\n\n        // Allocate memory\n        let size_val = self.types.i64_type.const_int(total_size, false);\n        let raw_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[size_val.into()], \"list_alloc\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"malloc returned void\".to_string()))?\n            .into_pointer_value();\n\n        // Cast to i64* for storing capacity and length\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"header_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Store capacity at offset 0\n        let cap_val = self\n            .types\n            .i64_type\n            .const_int(initial_capacity as u64, false);\n        self.builder\n            .build_store(header_ptr, cap_val)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store capacity: {}\", e)))?;\n\n        // Store length at offset 1\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to get len ptr: {}\", e)))?\n        };\n        let len_val = self.types.i64_type.const_int(len as u64, false);\n        self.builder\n            .build_store(len_ptr, len_val)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store length: {}\", e)))?;\n\n        // Get pointer to elements array (after capacity and length = offset 2)\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(2, false)],\n                    \"elements_base\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute elements base: {}\", e))\n                })?\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to cast elements pointer: {}\", e))\n            })?;\n\n        // Compile and store each element\n        for (i, elem) in elements.iter().enumerate() {\n            let compiled = self.compile_expr(elem)?;\n\n            // Get pointer to this element slot\n            let elem_ptr = unsafe {\n                self.builder\n                    .build_gep(\n                        self.types.value_type,\n                        elements_ptr,\n                        &[self.types.i64_type.const_int(i as u64, false)],\n                        &format!(\"elem_{}\", i),\n                    )\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\n                            \"Failed to compute element pointer: {}\",\n                            e\n                        ))\n                    })?\n            };\n\n            // Store the element\n            self.builder.build_store(elem_ptr, compiled).map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to store element: {}\", e))\n            })?;\n        }\n\n        // Return the list as a tagged value\n        self.make_list(raw_ptr)\n    }\n\n    /// Compile a list literal that contains spread expressions\n    /// Uses runtime index tracking to handle dynamic element counts\n    fn compile_list_with_spread(&mut self, elements: &[Expr]) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let initial_capacity = 2048usize;\n        let value_size = 16u64;\n        let header_size = 16u64;\n        let total_size = header_size + (initial_capacity as u64) * value_size;\n\n        // Allocate memory\n        let size_val = self.types.i64_type.const_int(total_size, false);\n        let raw_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[size_val.into()], \"spread_list_alloc\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"malloc returned void\".to_string()))?\n            .into_pointer_value();\n\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"header_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Store capacity\n        let cap_val = self.types.i64_type.const_int(initial_capacity as u64, false);\n        self.builder.build_store(header_ptr, cap_val).unwrap();\n\n        // Get length pointer (will be updated at the end)\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[self.types.i64_type.const_int(1, false)], \"len_ptr\")\n                .unwrap()\n        };\n\n        // Get elements base pointer\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, header_ptr, &[self.types.i64_type.const_int(2, false)], \"elements_base\")\n                .unwrap()\n        };\n        let elements_ptr = self.builder.build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\").unwrap();\n\n        // Create index counter alloca\n        let idx_alloca = self.builder.build_alloca(self.types.i64_type, \"spread_idx\").unwrap();\n        self.builder.build_store(idx_alloca, self.types.i64_type.const_int(0, false)).unwrap();\n\n        let function = self.current_function.unwrap();\n\n        for elem in elements {\n            if let Expr::Spread { expr, .. } = elem {\n                // Compile the spread source (should be a list or string)\n                let source_val = self.compile_expr(expr)?;\n                let source_tag = self.extract_tag(source_val)?;\n                let source_data = self.extract_data(source_val)?;\n\n                // Check if it's a list (tag == 5)\n                let list_tag = self.types.i8_type.const_int(ValueTag::List.as_u8() as u64, false);\n                let string_tag = self.types.i8_type.const_int(ValueTag::String.as_u8() as u64, false);\n                let is_list = self.builder.build_int_compare(IntPredicate::EQ, source_tag, list_tag, \"is_list\").unwrap();\n                let is_string = self.builder.build_int_compare(IntPredicate::EQ, source_tag, string_tag, \"is_string\").unwrap();\n\n                // Create blocks for list spread\n                let spread_list_block = self.context.append_basic_block(function, \"spread_list\");\n                let spread_string_block = self.context.append_basic_block(function, \"spread_string\");\n                let spread_done_block = self.context.append_basic_block(function, \"spread_done\");\n\n                self.builder.build_conditional_branch(is_list, spread_list_block, spread_string_block).unwrap();\n\n                // Handle list spread\n                self.builder.position_at_end(spread_list_block);\n                {\n                    // Get source list length\n                    let src_header = self.builder.build_int_to_ptr(source_data, i64_ptr_type, \"src_header\").unwrap();\n                    let src_len_ptr = unsafe {\n                        self.builder.build_gep(self.types.i64_type, src_header, &[self.types.i64_type.const_int(1, false)], \"src_len_ptr\").unwrap()\n                    };\n                    let src_len = self.builder.build_load(self.types.i64_type, src_len_ptr, \"src_len\").unwrap().into_int_value();\n\n                    // Loop to copy elements\n                    let loop_start = self.context.append_basic_block(function, \"spread_loop\");\n                    let loop_body = self.context.append_basic_block(function, \"spread_body\");\n                    let loop_end = self.context.append_basic_block(function, \"spread_end\");\n\n                    // Initialize loop counter\n                    let loop_i_alloca = self.builder.build_alloca(self.types.i64_type, \"loop_i\").unwrap();\n                    self.builder.build_store(loop_i_alloca, self.types.i64_type.const_int(0, false)).unwrap();\n                    self.builder.build_unconditional_branch(loop_start).unwrap();\n\n                    self.builder.position_at_end(loop_start);\n                    let loop_i = self.builder.build_load(self.types.i64_type, loop_i_alloca, \"i\").unwrap().into_int_value();\n                    let cond = self.builder.build_int_compare(IntPredicate::SLT, loop_i, src_len, \"cond\").unwrap();\n                    self.builder.build_conditional_branch(cond, loop_body, loop_end).unwrap();\n\n                    self.builder.position_at_end(loop_body);\n                    // Get element from source list\n                    let src_elem = self.compile_list_index(source_data, loop_i)?;\n                    // Get current dest index\n                    let dest_idx = self.builder.build_load(self.types.i64_type, idx_alloca, \"dest_idx\").unwrap().into_int_value();\n                    // Store element\n                    let dest_ptr = unsafe {\n                        self.builder.build_gep(self.types.value_type, elements_ptr, &[dest_idx], \"dest_ptr\").unwrap()\n                    };\n                    self.builder.build_store(dest_ptr, src_elem).unwrap();\n                    // Increment both counters\n                    let one = self.types.i64_type.const_int(1, false);\n                    let next_i = self.builder.build_int_add(loop_i, one, \"next_i\").unwrap();\n                    self.builder.build_store(loop_i_alloca, next_i).unwrap();\n                    let next_idx = self.builder.build_int_add(dest_idx, one, \"next_idx\").unwrap();\n                    self.builder.build_store(idx_alloca, next_idx).unwrap();\n                    self.builder.build_unconditional_branch(loop_start).unwrap();\n\n                    self.builder.position_at_end(loop_end);\n                    self.builder.build_unconditional_branch(spread_done_block).unwrap();\n                }\n\n                // Handle string spread (convert each char to string)\n                self.builder.position_at_end(spread_string_block);\n                {\n                    // For strings, we iterate over characters\n                    // Get string pointer and length\n                    let str_ptr = self.builder.build_int_to_ptr(source_data, self.context.i8_type().ptr_type(AddressSpace::default()), \"str_ptr\").unwrap();\n                    let str_len = self.builder.build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\").unwrap()\n                        .try_as_basic_value().left().unwrap().into_int_value();\n\n                    // Loop over characters\n                    let char_loop_start = self.context.append_basic_block(function, \"char_loop_start\");\n                    let char_loop_body = self.context.append_basic_block(function, \"char_loop_body\");\n                    let char_loop_end = self.context.append_basic_block(function, \"char_loop_end\");\n\n                    let char_i_alloca = self.builder.build_alloca(self.types.i64_type, \"char_i\").unwrap();\n                    self.builder.build_store(char_i_alloca, self.types.i64_type.const_int(0, false)).unwrap();\n                    self.builder.build_unconditional_branch(char_loop_start).unwrap();\n\n                    self.builder.position_at_end(char_loop_start);\n                    let char_i = self.builder.build_load(self.types.i64_type, char_i_alloca, \"ci\").unwrap().into_int_value();\n                    let char_cond = self.builder.build_int_compare(IntPredicate::ULT, char_i, str_len, \"char_cond\").unwrap();\n                    self.builder.build_conditional_branch(char_cond, char_loop_body, char_loop_end).unwrap();\n\n                    self.builder.position_at_end(char_loop_body);\n                    // Get character at index\n                    let char_ptr = unsafe {\n                        self.builder.build_gep(self.context.i8_type(), str_ptr, &[char_i], \"char_ptr\").unwrap()\n                    };\n                    let char_val = self.builder.build_load(self.context.i8_type(), char_ptr, \"char_val\").unwrap().into_int_value();\n\n                    // Create single-char string\n                    let two = self.types.i64_type.const_int(2, false);\n                    let char_str_ptr = self.builder.build_call(self.libc.malloc, &[two.into()], \"char_str\").unwrap()\n                        .try_as_basic_value().left().unwrap().into_pointer_value();\n                    self.builder.build_store(char_str_ptr, char_val).unwrap();\n                    let null_pos = unsafe { self.builder.build_gep(self.context.i8_type(), char_str_ptr, &[self.types.i64_type.const_int(1, false)], \"null_pos\").unwrap() };\n                    self.builder.build_store(null_pos, self.context.i8_type().const_int(0, false)).unwrap();\n\n                    // Make string MdhValue\n                    let char_str_val = self.make_string(char_str_ptr)?;\n\n                    // Store in dest list\n                    let dest_idx = self.builder.build_load(self.types.i64_type, idx_alloca, \"dest_idx\").unwrap().into_int_value();\n                    let dest_ptr = unsafe {\n                        self.builder.build_gep(self.types.value_type, elements_ptr, &[dest_idx], \"dest_ptr\").unwrap()\n                    };\n                    self.builder.build_store(dest_ptr, char_str_val).unwrap();\n\n                    // Increment counters\n                    let one = self.types.i64_type.const_int(1, false);\n                    let next_ci = self.builder.build_int_add(char_i, one, \"next_ci\").unwrap();\n                    self.builder.build_store(char_i_alloca, next_ci).unwrap();\n                    let next_idx = self.builder.build_int_add(dest_idx, one, \"next_idx\").unwrap();\n                    self.builder.build_store(idx_alloca, next_idx).unwrap();\n                    self.builder.build_unconditional_branch(char_loop_start).unwrap();\n\n                    self.builder.position_at_end(char_loop_end);\n                    self.builder.build_unconditional_branch(spread_done_block).unwrap();\n                }\n\n                self.builder.position_at_end(spread_done_block);\n            } else {\n                // Normal element - compile and store at current index\n                let compiled = self.compile_expr(elem)?;\n                let dest_idx = self.builder.build_load(self.types.i64_type, idx_alloca, \"dest_idx\").unwrap().into_int_value();\n                let dest_ptr = unsafe {\n                    self.builder.build_gep(self.types.value_type, elements_ptr, &[dest_idx], \"dest_ptr\").unwrap()\n                };\n                self.builder.build_store(dest_ptr, compiled).unwrap();\n                // Increment index\n                let one = self.types.i64_type.const_int(1, false);\n                let next_idx = self.builder.build_int_add(dest_idx, one, \"next_idx\").unwrap();\n                self.builder.build_store(idx_alloca, next_idx).unwrap();\n            }\n        }\n\n        // Store final length\n        let final_len = self.builder.build_load(self.types.i64_type, idx_alloca, \"final_len\").unwrap();\n        self.builder.build_store(len_ptr, final_len).unwrap();\n\n        self.make_list(raw_ptr)\n    }\n\n    /// Compile a dict literal expression: {key1: value1, key2: value2, ...}\n    /// Dict memory layout: [i64 count][entry0][entry1]... where entry = [{i8,i64} key][{i8,i64} val]\n    fn compile_dict(\n        &mut self,\n        pairs: &[(Expr, Expr)],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let count = pairs.len();\n\n        // Calculate memory size: 8 bytes for count + count * 32 bytes for entries (16 bytes key + 16 bytes value)\n        let entry_size = 32u64; // 16 bytes for key + 16 bytes for value\n        let header_size = 8u64; // sizeof(i64) for count\n        let total_size = header_size + (count as u64) * entry_size;\n\n        // Allocate memory\n        let size_val = self.types.i64_type.const_int(total_size, false);\n        let raw_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[size_val.into()], \"dict_alloc\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"malloc returned void\".to_string()))?\n            .into_pointer_value();\n\n        // Cast to i64* for storing the count\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let count_ptr = self\n            .builder\n            .build_pointer_cast(raw_ptr, i64_ptr_type, \"count_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Store count\n        let count_val = self.types.i64_type.const_int(count as u64, false);\n        self.builder\n            .build_store(count_ptr, count_val)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store count: {}\", e)))?;\n\n        // Get pointer to entries array (after the count)\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let entries_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    count_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"entries_base\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute entries base: {}\", e))\n                })?\n        };\n\n        // Compile and store each key-value pair\n        for (i, (key_expr, val_expr)) in pairs.iter().enumerate() {\n            let compiled_key = self.compile_expr(key_expr)?;\n            let compiled_val = self.compile_expr(val_expr)?;\n\n            // Calculate entry offset: entry_size * i\n            let entry_offset = self\n                .types\n                .i64_type\n                .const_int((i as u64) * entry_size, false);\n\n            // Get pointer to key slot\n            let entry_ptr = unsafe {\n                self.builder\n                    .build_gep(\n                        self.context.i8_type(),\n                        self.builder\n                            .build_pointer_cast(entries_base, i8_ptr_type, \"entries_i8\")\n                            .unwrap(),\n                        &[entry_offset],\n                        &format!(\"entry_{}\", i),\n                    )\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to compute entry pointer: {}\", e))\n                    })?\n            };\n\n            // Store key at entry start\n            let key_ptr = self\n                .builder\n                .build_pointer_cast(\n                    entry_ptr,\n                    self.types.value_type.ptr_type(AddressSpace::default()),\n                    &format!(\"key_ptr_{}\", i),\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to cast key pointer: {}\", e))\n                })?;\n            self.builder\n                .build_store(key_ptr, compiled_key)\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to store key: {}\", e)))?;\n\n            // Store value at entry start + 16 bytes\n            let value_offset = self.types.i64_type.const_int(16, false);\n            let val_ptr = unsafe {\n                self.builder\n                    .build_gep(\n                        self.context.i8_type(),\n                        entry_ptr,\n                        &[value_offset],\n                        &format!(\"val_gep_{}\", i),\n                    )\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to compute value pointer: {}\", e))\n                    })?\n            };\n            let val_typed_ptr = self\n                .builder\n                .build_pointer_cast(\n                    val_ptr,\n                    self.types.value_type.ptr_type(AddressSpace::default()),\n                    &format!(\"val_ptr_{}\", i),\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to cast value pointer: {}\", e))\n                })?;\n            self.builder\n                .build_store(val_typed_ptr, compiled_val)\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to store value: {}\", e)))?;\n        }\n\n        // Return the dict as a tagged value\n        self.make_dict(raw_ptr)\n    }\n\n    /// Compile an index expression: list[index], string[index], or dict[key]\n    fn compile_index(\n        &mut self,\n        object: &Expr,\n        index: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Fast path: if we know the object is a list and index is an int,\n        // skip type checking and negative index handling\n        let obj_type = self.infer_expr_type(object);\n        let idx_type = self.infer_expr_type(index);\n\n        if obj_type == VarType::List && idx_type == VarType::Int {\n            // Fast path - compile_list_index_fast handles shadow lookup internally\n            return self.compile_list_index_fast(object, index);\n        }\n\n        let obj_val = self.compile_expr(object)?;\n        let idx_val = self.compile_expr(index)?;\n\n        // Extract the tag and data from the object\n        let obj_tag = self.extract_tag(obj_val)?;\n        let obj_data = self.extract_data(obj_val)?;\n\n        // Create basic blocks for branching\n        let function = self\n            .current_function\n            .ok_or_else(|| HaversError::CompileError(\"No current function\".to_string()))?;\n        let list_block = self.context.append_basic_block(function, \"index_list\");\n        let check_dict_block = self.context.append_basic_block(function, \"check_dict\");\n        let dict_block = self.context.append_basic_block(function, \"index_dict\");\n        let string_block = self.context.append_basic_block(function, \"index_string\");\n        let merge_block = self.context.append_basic_block(function, \"index_merge\");\n\n        // Check if object is a list (tag == 5)\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let is_list = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::EQ, obj_tag, list_tag, \"is_list\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare tags: {}\", e)))?;\n\n        self.builder\n            .build_conditional_branch(is_list, list_block, check_dict_block)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to build branch: {}\", e)))?;\n\n        // List indexing - use index as integer\n        self.builder.position_at_end(list_block);\n        let idx_data = self.extract_data(idx_val)?;\n        let list_result = self.compile_list_index(obj_data, idx_data)?;\n        let list_bb = self.builder.get_insert_block().unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // Check if object is a dict (tag == 6)\n        self.builder.position_at_end(check_dict_block);\n        let dict_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Dict.as_u8() as u64, false);\n        let is_dict = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::EQ, obj_tag, dict_tag, \"is_dict\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare tags: {}\", e)))?;\n\n        self.builder\n            .build_conditional_branch(is_dict, dict_block, string_block)\n            .unwrap();\n\n        // Dict indexing - use key for lookup\n        self.builder.position_at_end(dict_block);\n        let dict_result = self.compile_dict_index(obj_data, idx_val)?;\n        let dict_bb = self.builder.get_insert_block().unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // String indexing (return character as string) - use index as integer\n        self.builder.position_at_end(string_block);\n        let idx_data_str = self.extract_data(idx_val)?;\n        let string_result = self.compile_string_index(obj_data, idx_data_str)?;\n        let string_bb = self.builder.get_insert_block().unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"index_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&list_result, list_bb),\n            (&dict_result, dict_bb),\n            (&string_result, string_bb),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// Helper for list indexing\n    fn compile_list_index(\n        &self,\n        list_data: IntValue<'ctx>,\n        index: IntValue<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List layout: [capacity: i64][length: i64][elements...]\n        // Convert data to pointer\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i64_ptr_type, \"list_ptr\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to pointer: {}\", e))\n            })?;\n\n        // Get length pointer (at offset 1)\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to get len ptr: {}\", e)))?\n        };\n\n        // Load length\n        let length = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load length: {}\", e)))?\n            .into_int_value();\n\n        // Handle negative indices: if index < 0, index = length + index\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_negative = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, index, zero, \"is_negative\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let adjusted_index = self\n            .builder\n            .build_int_add(length, index, \"adjusted\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n\n        let final_index = self\n            .builder\n            .build_select(is_negative, adjusted_index, index, \"final_index\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_int_value();\n\n        // Get pointer to elements array (at offset 2, after capacity and length)\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(2, false)],\n                    \"elements_base\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute elements base: {}\", e))\n                })?\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Get pointer to the indexed element\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    elements_ptr,\n                    &[final_index],\n                    \"elem_ptr\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute element pointer: {}\", e))\n                })?\n        };\n\n        // Load and return the element\n        let result = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"elem_val\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load element: {}\", e)))?;\n\n        Ok(result)\n    }\n\n    /// Fast path for list indexing when types are known at compile time\n    /// Skips type checking, negative index handling, and uses direct pointer arithmetic\n    fn compile_list_index_fast(\n        &mut self,\n        object: &Expr,\n        index: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Try to get list data from shadow (fastest path - avoids loading full MdhValue)\n        let list_data = if let Expr::Variable { name, .. } = object {\n            if let Some(&shadow) = self.list_ptr_shadows.get(name) {\n                // Load raw pointer from shadow\n                self.builder\n                    .build_load(self.types.i64_type, shadow, \"list_ptr_shadow_rd\")\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to load shadow: {}\", e))\n                    })?\n                    .into_int_value()\n            } else {\n                let obj_val = self.compile_expr(object)?;\n                self.extract_data(obj_val)?\n            }\n        } else {\n            let obj_val = self.compile_expr(object)?;\n            self.extract_data(obj_val)?\n        };\n\n        // Get index as i64 directly (use shadow if available)\n        let idx_i64 = if let Some(i) = self.compile_int_expr(index)? {\n            i\n        } else {\n            let idx_val = self.compile_expr(index)?;\n            self.extract_data(idx_val)?\n        };\n\n        // Convert data to pointer - list layout is [capacity: i64][length: i64][elem0: {i8, i64}][elem1: {i8, i64}]...\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i64_ptr_type, \"list_ptr_fast\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to pointer: {}\", e))\n            })?;\n\n        // Skip past capacity and length (16 bytes = offset 2) to reach elements\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    list_ptr,\n                    &[self.types.i64_type.const_int(2, false)],\n                    \"elements_base_fast\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute elements base: {}\", e))\n                })?\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr_fast\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Get pointer to the indexed element\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    elements_ptr,\n                    &[idx_i64],\n                    \"elem_ptr_fast\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute element pointer: {}\", e))\n                })?\n        };\n\n        // Load and return the element\n        let result = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"elem_val_fast\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load element: {}\", e)))?;\n\n        Ok(result)\n    }\n\n    /// Helper for dict indexing - searches for key and returns corresponding value\n    /// Dict layout: [i64 count][entry0][entry1]... where entry = [{i8,i64} key][{i8,i64} val]\n    fn compile_dict_index(\n        &mut self,\n        dict_data: IntValue<'ctx>,\n        key_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Convert dict data to pointer\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let dict_ptr = self\n            .builder\n            .build_int_to_ptr(dict_data, i8_ptr_type, \"dict_ptr\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to pointer: {}\", e))\n            })?;\n\n        // Get dict count\n        let count_ptr = self\n            .builder\n            .build_pointer_cast(dict_ptr, i64_ptr_type, \"count_ptr\")\n            .unwrap();\n        let dict_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"dict_count\")\n            .unwrap()\n            .into_int_value();\n\n        // Extract key tag and data for comparison\n        let key_tag = self.extract_tag(key_val)?;\n        let key_data = self.extract_data(key_val)?;\n\n        // Allocate result pointer and found flag\n        let result_ptr = self\n            .builder\n            .build_alloca(self.types.value_type, \"result_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(result_ptr, self.make_nil())\n            .unwrap();\n\n        // Loop through entries to find matching key\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let header_size = self.types.i64_type.const_int(8, false); // sizeof(i64) for count\n        let entry_size = self.types.i64_type.const_int(32, false);\n        let value_offset_in_entry = self.types.i64_type.const_int(16, false);\n\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self\n            .context\n            .append_basic_block(function, \"dict_lookup_loop\");\n        let body_block = self\n            .context\n            .append_basic_block(function, \"dict_lookup_body\");\n        let found_block = self.context.append_basic_block(function, \"dict_found\");\n        let continue_block = self.context.append_basic_block(function, \"dict_continue\");\n        let done_block = self\n            .context\n            .append_basic_block(function, \"dict_lookup_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, dict_count, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get entry key from dict\n        let dict_entry_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, entry_size, \"entry_mul\")\n                    .unwrap(),\n                \"entry_offset\",\n            )\n            .unwrap();\n        let dict_key_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    dict_ptr,\n                    &[dict_entry_offset],\n                    \"dict_key_ptr\",\n                )\n                .unwrap()\n        };\n        let key_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                dict_key_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"key_value_ptr\",\n            )\n            .unwrap();\n        let entry_key = self\n            .builder\n            .build_load(self.types.value_type, key_value_ptr, \"entry_key\")\n            .unwrap();\n\n        // Compare keys - check both tag and data match\n        let entry_key_tag = self.extract_tag(entry_key)?;\n        let entry_key_data = self.extract_data(entry_key)?;\n\n        let tags_match = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, key_tag, entry_key_tag, \"tags_match\")\n            .unwrap();\n        let data_match = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, key_data, entry_key_data, \"data_match\")\n            .unwrap();\n        let keys_match = self\n            .builder\n            .build_and(tags_match, data_match, \"keys_match\")\n            .unwrap();\n\n        self.builder\n            .build_conditional_branch(keys_match, found_block, continue_block)\n            .unwrap();\n\n        // Found - get the value\n        self.builder.position_at_end(found_block);\n        let dict_value_offset = self\n            .builder\n            .build_int_add(dict_entry_offset, value_offset_in_entry, \"value_offset\")\n            .unwrap();\n        let dict_value_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    dict_ptr,\n                    &[dict_value_offset],\n                    \"dict_value_ptr\",\n                )\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                dict_value_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let found_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"found_val\")\n            .unwrap();\n        self.builder.build_store(result_ptr, found_val).unwrap();\n        self.builder.build_unconditional_branch(done_block).unwrap();\n\n        // Continue loop\n        self.builder.position_at_end(continue_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Done - return result (nil if not found)\n        self.builder.position_at_end(done_block);\n        let result = self\n            .builder\n            .build_load(self.types.value_type, result_ptr, \"dict_result\")\n            .unwrap();\n        Ok(result)\n    }\n\n    /// Compile an index set expression: list[index] = value\n    fn compile_index_set(\n        &mut self,\n        object: &Expr,\n        index: &Expr,\n        value: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Fast path: if we know the object is a list and index is an int,\n        // skip type checking and negative index handling\n        let obj_type = self.infer_expr_type(object);\n        let idx_type = self.infer_expr_type(index);\n\n        if obj_type == VarType::List && idx_type == VarType::Int {\n            return self.compile_list_index_set_fast(object, index, value);\n        }\n\n        // Compile the object, index, and value\n        let obj_val = self.compile_expr(object)?;\n        let idx_val = self.compile_expr(index)?;\n        let new_val = self.compile_expr(value)?;\n\n        // Extract the object's data (pointer to list)\n        let obj_data = self.extract_data(obj_val)?;\n\n        // Extract the index (assume it's an integer)\n        let idx_data = self.extract_data(idx_val)?;\n\n        // Convert list data to pointer - layout: [capacity][length][elements...]\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_int_to_ptr(obj_data, i64_ptr_type, \"list_header_ptr\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to pointer: {}\", e))\n            })?;\n\n        // Get length pointer at offset 1\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to get len ptr: {}\", e)))?\n        };\n\n        // Load length for bounds checking and negative index handling\n        let length = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load length: {}\", e)))?\n            .into_int_value();\n\n        // Handle negative indices: if index < 0, index = length + index\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_negative = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, idx_data, zero, \"is_negative\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let adjusted_index = self\n            .builder\n            .build_int_add(length, idx_data, \"adjusted\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n\n        let final_index = self\n            .builder\n            .build_select(is_negative, adjusted_index, idx_data, \"final_index\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_int_value();\n\n        // Get pointer to elements array (at offset 2, after capacity and length)\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(2, false)],\n                    \"elements_base\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute elements base: {}\", e))\n                })?\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Get pointer to the indexed element\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    elements_ptr,\n                    &[final_index],\n                    \"elem_ptr\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute element pointer: {}\", e))\n                })?\n        };\n\n        // Store the new value at that location\n        self.builder\n            .build_store(elem_ptr, new_val)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store element: {}\", e)))?;\n\n        // Return the value that was set (for chained assignments)\n        Ok(new_val)\n    }\n\n    /// Fast path for list index assignment when types are known at compile time\n    fn compile_list_index_set_fast(\n        &mut self,\n        object: &Expr,\n        index: &Expr,\n        value: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Try to get list data from shadow (fastest path - avoids loading full MdhValue)\n        let list_data = if let Expr::Variable { name, .. } = object {\n            if let Some(&shadow) = self.list_ptr_shadows.get(name) {\n                // Load raw pointer from shadow\n                self.builder\n                    .build_load(self.types.i64_type, shadow, \"list_ptr_shadow\")\n                    .map_err(|e| {\n                        HaversError::CompileError(format!(\"Failed to load shadow: {}\", e))\n                    })?\n                    .into_int_value()\n            } else {\n                let obj_val = self.compile_expr(object)?;\n                self.extract_data(obj_val)?\n            }\n        } else {\n            let obj_val = self.compile_expr(object)?;\n            self.extract_data(obj_val)?\n        };\n\n        // Get index as i64 directly (use shadow if available)\n        let idx_i64 = if let Some(i) = self.compile_int_expr(index)? {\n            i\n        } else {\n            let idx_val = self.compile_expr(index)?;\n            self.extract_data(idx_val)?\n        };\n\n        // Convert data to pointer - list layout is [capacity: i64][length: i64][elem0: {i8, i64}][elem1: {i8, i64}]...\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i64_ptr_type, \"list_ptr_set_fast\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to pointer: {}\", e))\n            })?;\n\n        // Check for constant boolean - use data-only store (8 bytes vs 16 bytes)\n        // This is safe when storing same-type values into a homogeneous list\n        if let Expr::Literal {\n            value: Literal::Bool(b),\n            ..\n        } = value\n        {\n            // Ultra-fast path: store only the data field (8 bytes instead of 16)\n            // Skip header (16 bytes = 2 i64s), then compute data offset within element\n            // Element layout: {i8 tag, i64 data} - data is at offset 8 from element start\n            // In i64 terms: base + idx*2 + 1 (each element is 2 i64s, data is second)\n            let two = self.types.i64_type.const_int(2, false);\n            let one = self.types.i64_type.const_int(1, false);\n            let elements_base = unsafe {\n                self.builder\n                    .build_gep(self.types.i64_type, list_ptr, &[two], \"eb_set\")\n                    .unwrap()\n            };\n            let idx_times_2 = self\n                .builder\n                .build_int_mul(idx_i64, two, \"idx2_set\")\n                .unwrap();\n            let data_offset = self\n                .builder\n                .build_int_add(idx_times_2, one, \"do_set\")\n                .unwrap();\n            let data_ptr = unsafe {\n                self.builder\n                    .build_gep(self.types.i64_type, elements_base, &[data_offset], \"dp_set\")\n                    .unwrap()\n            };\n            // Store just the data value (0 for false, 1 for true)\n            let data_val = self.types.i64_type.const_int(if *b { 1 } else { 0 }, false);\n            self.builder.build_store(data_ptr, data_val).unwrap();\n            // Return the full MdhValue for correctness\n            return self.make_bool(\n                self.types\n                    .bool_type\n                    .const_int(if *b { 1 } else { 0 }, false),\n            );\n        }\n\n        // Compile the value to store\n        let new_val = self.compile_expr(value)?;\n\n        // Skip past capacity and length (16 bytes = offset 2) to reach elements\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let elements_base = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    list_ptr,\n                    &[self.types.i64_type.const_int(2, false)],\n                    \"elements_base_set_fast\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute elements base: {}\", e))\n                })?\n        };\n        let elements_ptr = self\n            .builder\n            .build_pointer_cast(elements_base, value_ptr_type, \"elements_ptr_set_fast\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to cast pointer: {}\", e)))?;\n\n        // Get pointer to the indexed element\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.value_type,\n                    elements_ptr,\n                    &[idx_i64],\n                    \"elem_ptr_set_fast\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute element pointer: {}\", e))\n                })?\n        };\n\n        // Store the new value at that location\n        self.builder\n            .build_store(elem_ptr, new_val)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store element: {}\", e)))?;\n\n        // Return the value that was set\n        Ok(new_val)\n    }\n\n    /// Helper for string indexing (return single character as string)\n    fn compile_string_index(\n        &self,\n        str_data: IntValue<'ctx>,\n        index: IntValue<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Convert data to string pointer\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr_type, \"str_ptr\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to pointer: {}\", e))\n            })?;\n\n        // Get string length\n        let length = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call strlen: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"strlen returned void\".to_string()))?\n            .into_int_value();\n\n        // Handle negative indices\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_negative = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, index, zero, \"is_negative\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to compare: {}\", e)))?;\n\n        let adjusted_index = self\n            .builder\n            .build_int_add(length, index, \"adjusted\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to add: {}\", e)))?;\n\n        let final_index = self\n            .builder\n            .build_select(is_negative, adjusted_index, index, \"final_index\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to select: {}\", e)))?\n            .into_int_value();\n\n        // Allocate 2 bytes for the new string (char + null terminator)\n        let two = self.types.i64_type.const_int(2, false);\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[two.into()], \"char_str\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"malloc returned void\".to_string()))?\n            .into_pointer_value();\n\n        // Get pointer to the character\n        let char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[final_index], \"char_ptr\")\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute char pointer: {}\", e))\n                })?\n        };\n\n        // Load the character\n        let char_val = self\n            .builder\n            .build_load(self.context.i8_type(), char_ptr, \"char_val\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to load char: {}\", e)))?;\n\n        // Store the character in new string\n        self.builder\n            .build_store(new_str, char_val)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store char: {}\", e)))?;\n\n        // Store null terminator\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_str,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"null_ptr\",\n                )\n                .map_err(|e| {\n                    HaversError::CompileError(format!(\"Failed to compute null pointer: {}\", e))\n                })?\n        };\n        let null_byte = self.context.i8_type().const_int(0, false);\n        self.builder\n            .build_store(null_ptr, null_byte)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store null: {}\", e)))?;\n\n        // Return as string value\n        self.make_string(new_str)\n    }\n\n    // ===== Phase 5: Timing functions =====\n\n    /// noo() - Returns current time in milliseconds since epoch (CLOCK_REALTIME)\n    fn inline_noo(&mut self) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Create struct timespec { i64 tv_sec; i64 tv_nsec; } on stack\n        let timespec_type = self.context.struct_type(\n            &[self.types.i64_type.into(), self.types.i64_type.into()],\n            false,\n        );\n\n        let timespec_ptr = self\n            .builder\n            .build_alloca(timespec_type, \"timespec\")\n            .unwrap();\n\n        // CLOCK_REALTIME = 0\n        let clock_id = self.context.i32_type().const_int(0, false);\n\n        // Cast timespec_ptr to i8* for clock_gettime\n        let timespec_i8_ptr = self\n            .builder\n            .build_pointer_cast(\n                timespec_ptr,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"timespec_i8_ptr\",\n            )\n            .unwrap();\n\n        // Call clock_gettime(CLOCK_REALTIME, &ts)\n        self.builder\n            .build_call(\n                self.libc.clock_gettime,\n                &[clock_id.into(), timespec_i8_ptr.into()],\n                \"clock_result\",\n            )\n            .unwrap();\n\n        // Read tv_sec\n        let sec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, timespec_ptr, 0, \"sec_ptr\")\n            .unwrap();\n        let tv_sec = self\n            .builder\n            .build_load(self.types.i64_type, sec_ptr, \"tv_sec\")\n            .unwrap()\n            .into_int_value();\n\n        // Read tv_nsec\n        let nsec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, timespec_ptr, 1, \"nsec_ptr\")\n            .unwrap();\n        let tv_nsec = self\n            .builder\n            .build_load(self.types.i64_type, nsec_ptr, \"tv_nsec\")\n            .unwrap()\n            .into_int_value();\n\n        // Convert to milliseconds: (tv_sec * 1000) + (tv_nsec / 1_000_000)\n        let thousand = self.types.i64_type.const_int(1000, false);\n        let million = self.types.i64_type.const_int(1_000_000, false);\n\n        let sec_ms = self\n            .builder\n            .build_int_mul(tv_sec, thousand, \"sec_ms\")\n            .unwrap();\n        let nsec_ms = self\n            .builder\n            .build_int_signed_div(tv_nsec, million, \"nsec_ms\")\n            .unwrap();\n        let total_ms = self\n            .builder\n            .build_int_add(sec_ms, nsec_ms, \"total_ms\")\n            .unwrap();\n\n        self.make_int(total_ms)\n    }\n\n    /// tick() - Returns high-resolution time in nanoseconds (CLOCK_MONOTONIC)\n    fn inline_tick(&mut self) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Create struct timespec { i64 tv_sec; i64 tv_nsec; } on stack\n        let timespec_type = self.context.struct_type(\n            &[self.types.i64_type.into(), self.types.i64_type.into()],\n            false,\n        );\n\n        let timespec_ptr = self\n            .builder\n            .build_alloca(timespec_type, \"timespec\")\n            .unwrap();\n\n        // CLOCK_MONOTONIC = 1\n        let clock_id = self.context.i32_type().const_int(1, false);\n\n        // Cast timespec_ptr to i8* for clock_gettime\n        let timespec_i8_ptr = self\n            .builder\n            .build_pointer_cast(\n                timespec_ptr,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"timespec_i8_ptr\",\n            )\n            .unwrap();\n\n        // Call clock_gettime(CLOCK_MONOTONIC, &ts)\n        self.builder\n            .build_call(\n                self.libc.clock_gettime,\n                &[clock_id.into(), timespec_i8_ptr.into()],\n                \"clock_result\",\n            )\n            .unwrap();\n\n        // Read tv_sec\n        let sec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, timespec_ptr, 0, \"sec_ptr\")\n            .unwrap();\n        let tv_sec = self\n            .builder\n            .build_load(self.types.i64_type, sec_ptr, \"tv_sec\")\n            .unwrap()\n            .into_int_value();\n\n        // Read tv_nsec\n        let nsec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, timespec_ptr, 1, \"nsec_ptr\")\n            .unwrap();\n        let tv_nsec = self\n            .builder\n            .build_load(self.types.i64_type, nsec_ptr, \"tv_nsec\")\n            .unwrap()\n            .into_int_value();\n\n        // Convert to nanoseconds: (tv_sec * 1_000_000_000) + tv_nsec\n        let billion = self.types.i64_type.const_int(1_000_000_000, false);\n        let sec_ns = self\n            .builder\n            .build_int_mul(tv_sec, billion, \"sec_ns\")\n            .unwrap();\n        let total_ns = self\n            .builder\n            .build_int_add(sec_ns, tv_nsec, \"total_ns\")\n            .unwrap();\n\n        self.make_int(total_ns)\n    }\n\n    /// bide(ms) - Sleep for specified milliseconds\n    fn inline_bide(\n        &mut self,\n        ms_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Extract the integer value from the tagged value\n        let ms_struct = ms_val.into_struct_value();\n        let ms = self\n            .builder\n            .build_extract_value(ms_struct, 1, \"ms_data\")\n            .unwrap()\n            .into_int_value();\n\n        // Create struct timespec { i64 tv_sec; i64 tv_nsec; } on stack\n        let timespec_type = self.context.struct_type(\n            &[self.types.i64_type.into(), self.types.i64_type.into()],\n            false,\n        );\n\n        let req_ptr = self.builder.build_alloca(timespec_type, \"req\").unwrap();\n\n        // Convert ms to seconds and nanoseconds\n        // tv_sec = ms / 1000\n        // tv_nsec = (ms % 1000) * 1_000_000\n        let thousand = self.types.i64_type.const_int(1000, false);\n        let million = self.types.i64_type.const_int(1_000_000, false);\n\n        let tv_sec = self\n            .builder\n            .build_int_signed_div(ms, thousand, \"tv_sec\")\n            .unwrap();\n        let ms_remainder = self\n            .builder\n            .build_int_signed_rem(ms, thousand, \"ms_remainder\")\n            .unwrap();\n        let tv_nsec = self\n            .builder\n            .build_int_mul(ms_remainder, million, \"tv_nsec\")\n            .unwrap();\n\n        // Store tv_sec and tv_nsec\n        let sec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, req_ptr, 0, \"sec_ptr\")\n            .unwrap();\n        self.builder.build_store(sec_ptr, tv_sec).unwrap();\n\n        let nsec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, req_ptr, 1, \"nsec_ptr\")\n            .unwrap();\n        self.builder.build_store(nsec_ptr, tv_nsec).unwrap();\n\n        // Cast req_ptr to i8* for nanosleep\n        let req_i8_ptr = self\n            .builder\n            .build_pointer_cast(\n                req_ptr,\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                \"req_i8_ptr\",\n            )\n            .unwrap();\n\n        // Pass null for the second argument (remaining time)\n        let null = self\n            .context\n            .i8_type()\n            .ptr_type(AddressSpace::default())\n            .const_null();\n\n        // Call nanosleep(&req, NULL)\n        self.builder\n            .build_call(\n                self.libc.nanosleep,\n                &[req_i8_ptr.into(), null.into()],\n                \"sleep_result\",\n            )\n            .unwrap();\n\n        // Return nil\n        Ok(self.make_nil())\n    }\n\n    // ===== Phase 7: I/O functions =====\n\n    /// speir(prompt?) - Read a line from stdin, optionally printing a prompt first\n    fn inline_speir(\n        &mut self,\n        prompt: Option<BasicValueEnum<'ctx>>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // If there's a prompt, print it first (without newline)\n        if let Some(prompt_val) = prompt {\n            // Extract string pointer from prompt\n            let prompt_struct = prompt_val.into_struct_value();\n            let prompt_data = self\n                .builder\n                .build_extract_value(prompt_struct, 1, \"prompt_data\")\n                .unwrap()\n                .into_int_value();\n            let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n            let prompt_ptr = self\n                .builder\n                .build_int_to_ptr(prompt_data, i8_ptr_type, \"prompt_ptr\")\n                .unwrap();\n\n            // Print the prompt using printf with %s format (no newline)\n            let fmt_ptr = self.get_string_ptr(self.fmt_string);\n            self.builder\n                .build_call(\n                    self.libc.printf,\n                    &[fmt_ptr.into(), prompt_ptr.into()],\n                    \"print_prompt\",\n                )\n                .unwrap();\n        }\n\n        // Allocate buffer for input (1024 bytes should be enough for most input)\n        let buf_size = self.types.i64_type.const_int(1024, false);\n        let buffer = self\n            .builder\n            .build_call(self.libc.malloc, &[buf_size.into()], \"input_buffer\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Get stdin - declare it as an external global\n        let stdin_global = self.module.add_global(\n            self.context.i8_type().ptr_type(AddressSpace::default()),\n            Some(AddressSpace::default()),\n            \"stdin\",\n        );\n        stdin_global.set_linkage(Linkage::External);\n\n        // Load stdin pointer\n        let stdin_ptr = self\n            .builder\n            .build_load(\n                self.context.i8_type().ptr_type(AddressSpace::default()),\n                stdin_global.as_pointer_value(),\n                \"stdin_val\",\n            )\n            .unwrap()\n            .into_pointer_value();\n\n        // Call fgets(buffer, 1024, stdin)\n        let size_i32 = self.context.i32_type().const_int(1024, false);\n        let result = self\n            .builder\n            .build_call(\n                self.libc.fgets,\n                &[buffer.into(), size_i32.into(), stdin_ptr.into()],\n                \"fgets_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Check if fgets returned NULL (EOF or error)\n        let null = self\n            .context\n            .i8_type()\n            .ptr_type(AddressSpace::default())\n            .const_null();\n        let is_null = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, result, null, \"is_null\")\n            .unwrap();\n\n        let function = self.current_function.unwrap();\n        let eof_block = self.context.append_basic_block(function, \"speir_eof\");\n        let ok_block = self.context.append_basic_block(function, \"speir_ok\");\n        let done_block = self.context.append_basic_block(function, \"speir_done\");\n\n        self.builder\n            .build_conditional_branch(is_null, eof_block, ok_block)\n            .unwrap();\n\n        // EOF case - return empty string\n        self.builder.position_at_end(eof_block);\n        let empty_str = self\n            .builder\n            .build_global_string_ptr(\"\", \"empty_str\")\n            .unwrap();\n        let eof_result = self.make_string(empty_str.as_pointer_value())?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let eof_block_end = self.builder.get_insert_block().unwrap();\n\n        // OK case - strip the trailing newline if present\n        self.builder.position_at_end(ok_block);\n\n        // Get string length\n        let len = self\n            .builder\n            .build_call(self.libc.strlen, &[buffer.into()], \"input_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Check if last char is newline\n        let one = self.types.i64_type.const_int(1, false);\n        let last_idx = self.builder.build_int_sub(len, one, \"last_idx\").unwrap();\n        let last_char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), buffer, &[last_idx], \"last_char_ptr\")\n                .unwrap()\n        };\n        let last_char = self\n            .builder\n            .build_load(self.context.i8_type(), last_char_ptr, \"last_char\")\n            .unwrap()\n            .into_int_value();\n        let newline = self.context.i8_type().const_int(10, false); // '\\n'\n        let is_newline = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, last_char, newline, \"is_newline\")\n            .unwrap();\n\n        let strip_block = self.context.append_basic_block(function, \"strip_newline\");\n        let no_strip_block = self.context.append_basic_block(function, \"no_strip\");\n\n        self.builder\n            .build_conditional_branch(is_newline, strip_block, no_strip_block)\n            .unwrap();\n\n        // Strip newline\n        self.builder.position_at_end(strip_block);\n        let null_byte = self.context.i8_type().const_int(0, false);\n        self.builder.build_store(last_char_ptr, null_byte).unwrap();\n        self.builder\n            .build_unconditional_branch(no_strip_block)\n            .unwrap();\n\n        // No strip (or after strip)\n        self.builder.position_at_end(no_strip_block);\n        let ok_result = self.make_string(buffer)?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let ok_block_end = self.builder.get_insert_block().unwrap();\n\n        // Done - use phi to select result\n        self.builder.position_at_end(done_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"speir_result\")\n            .unwrap();\n        phi.add_incoming(&[(&eof_result, eof_block_end), (&ok_result, ok_block_end)]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    // ===== Extra: String operations =====\n\n    /// split(str, delimiter) - Split string into list of strings\n    fn inline_split(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        delim_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract string pointers\n        let str_struct = str_val.into_struct_value();\n        let str_data = self\n            .builder\n            .build_extract_value(str_struct, 1, \"str_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr_type, \"str_ptr\")\n            .unwrap();\n\n        let delim_struct = delim_val.into_struct_value();\n        let delim_data = self\n            .builder\n            .build_extract_value(delim_struct, 1, \"delim_data\")\n            .unwrap()\n            .into_int_value();\n        let delim_ptr = self\n            .builder\n            .build_int_to_ptr(delim_data, i8_ptr_type, \"delim_ptr\")\n            .unwrap();\n\n        // Get delimiter length\n        let delim_len = self\n            .builder\n            .build_call(self.libc.strlen, &[delim_ptr.into()], \"delim_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Get string length\n        let str_len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Handle empty delimiter - return list with single element (the whole string)\n        // This prevents infinite loop when delimiter is \"\"\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let delim_is_empty = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, delim_len, zero, \"delim_empty\")\n            .unwrap();\n\n        // Check if delimiter is single character (fast path)\n        let delim_is_single = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, delim_len, one, \"delim_single\")\n            .unwrap();\n\n        let empty_delim_block = self.context.append_basic_block(function, \"empty_delim\");\n        let single_char_block = self\n            .context\n            .append_basic_block(function, \"single_char_split\");\n        let normal_split_block = self.context.append_basic_block(function, \"normal_split\");\n        let merge_block = self.context.append_basic_block(function, \"split_merge\");\n\n        // Branch: empty -> empty_delim, otherwise check for single char\n        self.builder\n            .build_conditional_branch(delim_is_empty, empty_delim_block, single_char_block)\n            .unwrap();\n\n        // Single-char check: if single -> fast byte scan, else -> normal strstr path\n        self.builder.position_at_end(single_char_block);\n\n        // Get the delimiter byte for single-char case\n        let delim_byte = self\n            .builder\n            .build_load(self.context.i8_type(), delim_ptr, \"delim_byte\")\n            .unwrap()\n            .into_int_value();\n\n        // Create blocks for single-char fast path\n        let sc_count_block = self.context.append_basic_block(function, \"sc_count_loop\");\n        let sc_count_body = self.context.append_basic_block(function, \"sc_count_body\");\n        let sc_count_done = self.context.append_basic_block(function, \"sc_count_done\");\n        let sc_split_block = self.context.append_basic_block(function, \"sc_split_loop\");\n        let sc_split_body = self.context.append_basic_block(function, \"sc_split_body\");\n        let sc_split_found = self.context.append_basic_block(function, \"sc_split_found\");\n        let sc_split_done = self.context.append_basic_block(function, \"sc_split_done\");\n\n        self.builder\n            .build_conditional_branch(delim_is_single, sc_count_block, normal_split_block)\n            .unwrap();\n\n        // === SINGLE-CHAR FAST PATH ===\n        // Phase 1: Count delimiters to know exact list size\n        self.builder.position_at_end(sc_count_block);\n        let sc_i_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"sc_i\")\n            .unwrap();\n        let sc_count_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"sc_count\")\n            .unwrap();\n        let sc_one = self.types.i64_type.const_int(1, false);\n        self.builder.build_store(sc_i_ptr, zero).unwrap();\n        self.builder.build_store(sc_count_ptr, zero).unwrap();\n        self.builder\n            .build_unconditional_branch(sc_count_body)\n            .unwrap();\n\n        // Count loop condition check\n        self.builder.position_at_end(sc_count_body);\n        let sc_i = self\n            .builder\n            .build_load(self.types.i64_type, sc_i_ptr, \"sc_i_val\")\n            .unwrap()\n            .into_int_value();\n        let sc_at_end = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, sc_i, str_len, \"sc_at_end\")\n            .unwrap();\n\n        // Create a block for the loop body work\n        let sc_count_work = self.context.append_basic_block(function, \"sc_count_work\");\n        self.builder\n            .build_conditional_branch(sc_at_end, sc_count_done, sc_count_work)\n            .unwrap();\n\n        // Loop body: check char and update count\n        self.builder.position_at_end(sc_count_work);\n        let sc_char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[sc_i], \"sc_char_ptr\")\n                .unwrap()\n        };\n        let sc_char = self\n            .builder\n            .build_load(self.context.i8_type(), sc_char_ptr, \"sc_char\")\n            .unwrap()\n            .into_int_value();\n        let sc_is_delim = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, sc_char, delim_byte, \"sc_is_delim\")\n            .unwrap();\n\n        // Increment count if delimiter\n        let sc_curr_count = self\n            .builder\n            .build_load(self.types.i64_type, sc_count_ptr, \"sc_curr_count\")\n            .unwrap()\n            .into_int_value();\n        let sc_new_count = self\n            .builder\n            .build_int_add(sc_curr_count, sc_one, \"sc_new_count\")\n            .unwrap();\n        let sc_count_to_store = self\n            .builder\n            .build_select(sc_is_delim, sc_new_count, sc_curr_count, \"sc_count_sel\")\n            .unwrap()\n            .into_int_value();\n        self.builder\n            .build_store(sc_count_ptr, sc_count_to_store)\n            .unwrap();\n\n        // Increment i and loop back\n        let sc_next_i = self\n            .builder\n            .build_int_add(sc_i, sc_one, \"sc_next_i\")\n            .unwrap();\n        self.builder.build_store(sc_i_ptr, sc_next_i).unwrap();\n        self.builder\n            .build_unconditional_branch(sc_count_body)\n            .unwrap();\n\n        // Count done - allocate list with exact size (count + 1 elements)\n        self.builder.position_at_end(sc_count_done);\n        let sc_final_count = self\n            .builder\n            .build_load(self.types.i64_type, sc_count_ptr, \"sc_final_count\")\n            .unwrap()\n            .into_int_value();\n        let sc_list_len = self\n            .builder\n            .build_int_add(sc_final_count, sc_one, \"sc_list_len\")\n            .unwrap();\n\n        let sc_header_size = self.types.i64_type.const_int(16, false);\n        let sc_elem_size = self.types.i64_type.const_int(16, false);\n        let sc_list_size = self\n            .builder\n            .build_int_add(\n                sc_header_size,\n                self.builder\n                    .build_int_mul(sc_list_len, sc_elem_size, \"sc_elems_size\")\n                    .unwrap(),\n                \"sc_list_size\",\n            )\n            .unwrap();\n\n        let sc_list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[sc_list_size.into()], \"sc_list_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store list length\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let sc_len_ptr = self\n            .builder\n            .build_pointer_cast(sc_list_ptr, i64_ptr_type, \"sc_len_ptr\")\n            .unwrap();\n        self.builder.build_store(sc_len_ptr, sc_list_len).unwrap();\n\n        // Phase 2: Split and fill list\n        let sc_pos_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"sc_pos\")\n            .unwrap();\n        let sc_elem_idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"sc_elem_idx\")\n            .unwrap();\n        let sc_token_start_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"sc_token_start\")\n            .unwrap();\n        self.builder.build_store(sc_pos_ptr, zero).unwrap();\n        self.builder.build_store(sc_elem_idx_ptr, zero).unwrap();\n        self.builder.build_store(sc_token_start_ptr, zero).unwrap();\n        self.builder\n            .build_unconditional_branch(sc_split_body)\n            .unwrap();\n\n        // Split loop - check if we've reached end\n        self.builder.position_at_end(sc_split_body);\n        let sc_pos = self\n            .builder\n            .build_load(self.types.i64_type, sc_pos_ptr, \"sc_pos_val\")\n            .unwrap()\n            .into_int_value();\n        let sc_split_end_cmp = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, sc_pos, str_len, \"sc_split_end_cmp\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(sc_split_end_cmp, sc_split_done, sc_split_block)\n            .unwrap();\n\n        // Check current char for delimiter\n        self.builder.position_at_end(sc_split_block);\n        let sc_char_ptr2 = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[sc_pos], \"sc_char_ptr2\")\n                .unwrap()\n        };\n        let sc_char2 = self\n            .builder\n            .build_load(self.context.i8_type(), sc_char_ptr2, \"sc_char2\")\n            .unwrap()\n            .into_int_value();\n        let sc_is_delim2 = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, sc_char2, delim_byte, \"sc_is_delim2\")\n            .unwrap();\n\n        // Advance position\n        let sc_next_pos = self\n            .builder\n            .build_int_add(sc_pos, sc_one, \"sc_next_pos\")\n            .unwrap();\n        self.builder.build_store(sc_pos_ptr, sc_next_pos).unwrap();\n\n        self.builder\n            .build_conditional_branch(sc_is_delim2, sc_split_found, sc_split_body)\n            .unwrap();\n\n        // Found delimiter - emit token\n        // Note: We need to recalculate position since sc_pos was an SSA value in another block\n        // The delimiter position is (current_pos - 1) since we already incremented\n        self.builder.position_at_end(sc_split_found);\n        let sc_curr_pos = self\n            .builder\n            .build_load(self.types.i64_type, sc_pos_ptr, \"sc_curr_pos\")\n            .unwrap()\n            .into_int_value();\n        let sc_delim_pos = self\n            .builder\n            .build_int_sub(sc_curr_pos, sc_one, \"sc_delim_pos\")\n            .unwrap();\n        let sc_token_start = self\n            .builder\n            .build_load(self.types.i64_type, sc_token_start_ptr, \"sc_ts\")\n            .unwrap()\n            .into_int_value();\n        let sc_token_len = self\n            .builder\n            .build_int_sub(sc_delim_pos, sc_token_start, \"sc_token_len\")\n            .unwrap();\n\n        // Allocate token string\n        let sc_token_size = self\n            .builder\n            .build_int_add(sc_token_len, sc_one, \"sc_token_size\")\n            .unwrap();\n        let sc_token_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[sc_token_size.into()], \"sc_token_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy token\n        let sc_src_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    str_ptr,\n                    &[sc_token_start],\n                    \"sc_src_ptr\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[sc_token_ptr.into(), sc_src_ptr.into(), sc_token_len.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Null terminate\n        let sc_token_end = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    sc_token_ptr,\n                    &[sc_token_len],\n                    \"sc_token_end\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_store(sc_token_end, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        // Create string value\n        let sc_token_value = self.make_string(sc_token_ptr)?;\n\n        // Store in list\n        let sc_elem_idx = self\n            .builder\n            .build_load(self.types.i64_type, sc_elem_idx_ptr, \"sc_elem_idx_val\")\n            .unwrap()\n            .into_int_value();\n        let sc_elem_offset = self\n            .builder\n            .build_int_add(\n                sc_header_size,\n                self.builder\n                    .build_int_mul(sc_elem_idx, sc_elem_size, \"sc_eo_mul\")\n                    .unwrap(),\n                \"sc_elem_offset\",\n            )\n            .unwrap();\n        let sc_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    sc_list_ptr,\n                    &[sc_elem_offset],\n                    \"sc_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let sc_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                sc_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"sc_value_ptr\",\n            )\n            .unwrap();\n        self.builder\n            .build_store(sc_value_ptr, sc_token_value)\n            .unwrap();\n\n        // Update token start and element index\n        // sc_curr_pos is already the position after the delimiter\n        self.builder\n            .build_store(sc_token_start_ptr, sc_curr_pos)\n            .unwrap();\n        let sc_next_elem = self\n            .builder\n            .build_int_add(sc_elem_idx, sc_one, \"sc_next_elem\")\n            .unwrap();\n        self.builder\n            .build_store(sc_elem_idx_ptr, sc_next_elem)\n            .unwrap();\n\n        self.builder\n            .build_unconditional_branch(sc_split_body)\n            .unwrap();\n\n        // Split done - add final token\n        self.builder.position_at_end(sc_split_done);\n        let sc_final_start = self\n            .builder\n            .build_load(self.types.i64_type, sc_token_start_ptr, \"sc_final_start\")\n            .unwrap()\n            .into_int_value();\n        let sc_final_len = self\n            .builder\n            .build_int_sub(str_len, sc_final_start, \"sc_final_len\")\n            .unwrap();\n\n        // Allocate final token\n        let sc_final_size = self\n            .builder\n            .build_int_add(sc_final_len, sc_one, \"sc_final_size\")\n            .unwrap();\n        let sc_final_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[sc_final_size.into()], \"sc_final_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy final token\n        let sc_final_src = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    str_ptr,\n                    &[sc_final_start],\n                    \"sc_final_src\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[\n                    sc_final_ptr.into(),\n                    sc_final_src.into(),\n                    sc_final_len.into(),\n                ],\n                \"\",\n            )\n            .unwrap();\n\n        // Null terminate\n        let sc_final_end = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    sc_final_ptr,\n                    &[sc_final_len],\n                    \"sc_final_end\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_store(sc_final_end, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        // Create final string value\n        let sc_final_value = self.make_string(sc_final_ptr)?;\n\n        // Store final in list\n        let sc_final_idx = self\n            .builder\n            .build_load(self.types.i64_type, sc_elem_idx_ptr, \"sc_final_idx\")\n            .unwrap()\n            .into_int_value();\n        let sc_final_offset = self\n            .builder\n            .build_int_add(\n                sc_header_size,\n                self.builder\n                    .build_int_mul(sc_final_idx, sc_elem_size, \"sc_fo_mul\")\n                    .unwrap(),\n                \"sc_final_offset\",\n            )\n            .unwrap();\n        let sc_final_elem = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    sc_list_ptr,\n                    &[sc_final_offset],\n                    \"sc_final_elem\",\n                )\n                .unwrap()\n        };\n        let sc_final_vptr = self\n            .builder\n            .build_pointer_cast(\n                sc_final_elem,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"sc_final_vptr\",\n            )\n            .unwrap();\n        self.builder\n            .build_store(sc_final_vptr, sc_final_value)\n            .unwrap();\n\n        // Create result and branch to merge\n        let sc_result = self.make_list(sc_list_ptr)?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let sc_split_end_block = self.builder.get_insert_block().unwrap();\n\n        // Empty delimiter case: return list containing the original string\n        self.builder.position_at_end(empty_delim_block);\n        let one_elem_list = self.allocate_list(self.types.i64_type.const_int(1, false))?;\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let one_len_ptr = self\n            .builder\n            .build_pointer_cast(one_elem_list, i64_ptr_type, \"one_len_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(one_len_ptr, self.types.i64_type.const_int(1, false))\n            .unwrap();\n        // Store original string as element 0\n        let header_size_const = self.types.i64_type.const_int(16, false);\n        let elem_ptr_empty = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    one_elem_list,\n                    &[header_size_const],\n                    \"elem_ptr_empty\",\n                )\n                .unwrap()\n        };\n        let value_ptr_empty = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr_empty,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr_empty\",\n            )\n            .unwrap();\n        self.builder.build_store(value_ptr_empty, str_val).unwrap();\n        let empty_result = self.make_list(one_elem_list)?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let empty_delim_end = self.builder.get_insert_block().unwrap();\n\n        // Normal split case\n        self.builder.position_at_end(normal_split_block);\n\n        // Allocate list with space for up to 100 elements initially\n        // List format: [i64 length][value elem0][value elem1]...\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let max_elems = self.types.i64_type.const_int(100, false);\n        let initial_size = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(max_elems, elem_size, \"elems_size\")\n                    .unwrap(),\n                \"initial_size\",\n            )\n            .unwrap();\n\n        let list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[initial_size.into()], \"list_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Initialize length to 0\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"len_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(len_ptr, self.types.i64_type.const_int(0, false))\n            .unwrap();\n\n        // Allocate counters on stack\n        let pos_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"pos\")\n            .unwrap();\n        let count_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"count\")\n            .unwrap();\n        self.builder\n            .build_store(pos_ptr, self.types.i64_type.const_int(0, false))\n            .unwrap();\n        self.builder\n            .build_store(count_ptr, self.types.i64_type.const_int(0, false))\n            .unwrap();\n\n        // Store list_ptr in an alloca so we can read it in the loop\n        let list_ptr_alloca = self\n            .builder\n            .build_alloca(i8_ptr_type, \"list_ptr_alloca\")\n            .unwrap();\n        self.builder.build_store(list_ptr_alloca, list_ptr).unwrap();\n\n        // Loop to find delimiters and split\n        let loop_block = self.context.append_basic_block(function, \"split_loop\");\n        let found_block = self.context.append_basic_block(function, \"split_found\");\n        let not_found_block = self.context.append_basic_block(function, \"split_not_found\");\n        let add_token_block = self.context.append_basic_block(function, \"add_token\");\n        let done_block = self.context.append_basic_block(function, \"split_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        // Get current position\n        let pos = self\n            .builder\n            .build_load(self.types.i64_type, pos_ptr, \"pos_val\")\n            .unwrap()\n            .into_int_value();\n\n        // Check if we've reached end of string\n        let at_end = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, pos, str_len, \"at_end\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(at_end, done_block, found_block)\n            .unwrap();\n\n        // Search for delimiter starting at current position\n        self.builder.position_at_end(found_block);\n        let search_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[pos], \"search_ptr\")\n                .unwrap()\n        };\n        let found_ptr = self\n            .builder\n            .build_call(\n                self.libc.strstr,\n                &[search_ptr.into(), delim_ptr.into()],\n                \"found_ptr\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        let null = i8_ptr_type.const_null();\n        let is_found = self\n            .builder\n            .build_int_compare(IntPredicate::NE, found_ptr, null, \"is_found\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(is_found, add_token_block, not_found_block)\n            .unwrap();\n\n        // Found delimiter - add token from pos to found_ptr\n        self.builder.position_at_end(add_token_block);\n        let found_as_int = self\n            .builder\n            .build_ptr_to_int(found_ptr, self.types.i64_type, \"found_int\")\n            .unwrap();\n        let search_as_int = self\n            .builder\n            .build_ptr_to_int(search_ptr, self.types.i64_type, \"search_int\")\n            .unwrap();\n        let token_len = self\n            .builder\n            .build_int_sub(found_as_int, search_as_int, \"token_len\")\n            .unwrap();\n\n        // Allocate and copy token\n        let token_alloc_size = self\n            .builder\n            .build_int_add(\n                token_len,\n                self.types.i64_type.const_int(1, false),\n                \"alloc_size\",\n            )\n            .unwrap();\n        let token_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[token_alloc_size.into()], \"token_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy token bytes\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[token_ptr.into(), search_ptr.into(), token_len.into()],\n                \"copy_token\",\n            )\n            .unwrap();\n\n        // Null-terminate\n        let token_end = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), token_ptr, &[token_len], \"token_end\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(token_end, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        // Create string value and add to list\n        let token_value = self.make_string(token_ptr)?;\n\n        // Get current count and list pointer\n        let count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"count_val\")\n            .unwrap()\n            .into_int_value();\n        let current_list_ptr = self\n            .builder\n            .build_load(i8_ptr_type, list_ptr_alloca, \"current_list\")\n            .unwrap()\n            .into_pointer_value();\n\n        // Calculate element offset: 8 + count * 16\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(count, elem_size, \"elem_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    current_list_ptr,\n                    &[elem_offset],\n                    \"elem_ptr\",\n                )\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        self.builder.build_store(value_ptr, token_value).unwrap();\n\n        // Increment count\n        let new_count = self\n            .builder\n            .build_int_add(count, self.types.i64_type.const_int(1, false), \"new_count\")\n            .unwrap();\n        self.builder.build_store(count_ptr, new_count).unwrap();\n\n        // Update position to after delimiter\n        let new_pos = self\n            .builder\n            .build_int_add(pos, token_len, \"after_token\")\n            .unwrap();\n        let new_pos = self\n            .builder\n            .build_int_add(new_pos, delim_len, \"after_delim\")\n            .unwrap();\n        self.builder.build_store(pos_ptr, new_pos).unwrap();\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Not found - add rest of string as final token\n        self.builder.position_at_end(not_found_block);\n        let rest_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[pos], \"rest_ptr\")\n                .unwrap()\n        };\n\n        // Duplicate the rest of the string\n        let rest_copy = self\n            .builder\n            .build_call(self.libc.strdup, &[rest_ptr.into()], \"rest_copy\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        let rest_value = self.make_string(rest_copy)?;\n\n        // Get current count and list pointer for final add\n        let final_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"final_count\")\n            .unwrap()\n            .into_int_value();\n        let final_list_ptr = self\n            .builder\n            .build_load(i8_ptr_type, list_ptr_alloca, \"final_list\")\n            .unwrap()\n            .into_pointer_value();\n\n        // Add rest to list\n        let final_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(final_count, elem_size, \"final_mul\")\n                    .unwrap(),\n                \"final_offset\",\n            )\n            .unwrap();\n        let final_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    final_list_ptr,\n                    &[final_offset],\n                    \"final_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let final_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                final_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"final_value_ptr\",\n            )\n            .unwrap();\n        self.builder\n            .build_store(final_value_ptr, rest_value)\n            .unwrap();\n\n        // Update count\n        let total_count = self\n            .builder\n            .build_int_add(\n                final_count,\n                self.types.i64_type.const_int(1, false),\n                \"total_count\",\n            )\n            .unwrap();\n        self.builder.build_store(count_ptr, total_count).unwrap();\n\n        self.builder.build_unconditional_branch(done_block).unwrap();\n\n        // Done - set length and return list\n        self.builder.position_at_end(done_block);\n        let done_list_ptr = self\n            .builder\n            .build_load(i8_ptr_type, list_ptr_alloca, \"done_list\")\n            .unwrap()\n            .into_pointer_value();\n        let done_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"done_count\")\n            .unwrap()\n            .into_int_value();\n\n        // Store final length\n        let done_len_ptr = self\n            .builder\n            .build_pointer_cast(done_list_ptr, i64_ptr_type, \"done_len_ptr\")\n            .unwrap();\n        self.builder.build_store(done_len_ptr, done_count).unwrap();\n\n        // Create list value for normal case\n        let normal_result = self.make_list(done_list_ptr)?;\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let normal_split_end = self.builder.get_insert_block().unwrap();\n\n        // Merge block - use phi to select result\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"split_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&empty_result, empty_delim_end),\n            (&sc_result, sc_split_end_block),\n            (&normal_result, normal_split_end),\n        ]);\n        Ok(phi.as_basic_value())\n    }\n\n    /// join(list, delimiter) - Join list elements with delimiter\n    fn inline_join(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        delim_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract list pointer\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        // Extract delimiter string\n        let delim_struct = delim_val.into_struct_value();\n        let delim_data = self\n            .builder\n            .build_extract_value(delim_struct, 1, \"delim_data\")\n            .unwrap()\n            .into_int_value();\n        let delim_ptr = self\n            .builder\n            .build_int_to_ptr(delim_data, i8_ptr_type, \"delim_ptr\")\n            .unwrap();\n\n        // Get delimiter length\n        let delim_len = self\n            .builder\n            .build_call(self.libc.strlen, &[delim_ptr.into()], \"delim_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Get list length from offset 1 (after capacity)\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Check for empty list\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_empty = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, list_len, zero, \"is_empty\")\n            .unwrap();\n\n        let empty_block = self.context.append_basic_block(function, \"join_empty\");\n        let calc_block = self.context.append_basic_block(function, \"join_calc\");\n        let done_block = self.context.append_basic_block(function, \"join_done\");\n\n        self.builder\n            .build_conditional_branch(is_empty, empty_block, calc_block)\n            .unwrap();\n\n        // Empty list - return empty string\n        self.builder.position_at_end(empty_block);\n        let empty_str = self\n            .builder\n            .build_global_string_ptr(\"\", \"empty_str\")\n            .unwrap();\n        let empty_result = self.make_string(empty_str.as_pointer_value())?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let empty_block_end = self.builder.get_insert_block().unwrap();\n\n        // Calculate total size needed\n        self.builder.position_at_end(calc_block);\n\n        // First pass: calculate total length\n        let total_len_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"total_len\")\n            .unwrap();\n        self.builder.build_store(total_len_ptr, zero).unwrap();\n\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let calc_loop = self.context.append_basic_block(function, \"calc_loop\");\n        let calc_body = self.context.append_basic_block(function, \"calc_body\");\n        let calc_done = self.context.append_basic_block(function, \"calc_done\");\n\n        self.builder.build_unconditional_branch(calc_loop).unwrap();\n        self.builder.position_at_end(calc_loop);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let calc_done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"calc_done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(calc_done_cond, calc_done, calc_body)\n            .unwrap();\n\n        self.builder.position_at_end(calc_body);\n\n        // Get element at index\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"elem_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_value = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_value\")\n            .unwrap();\n\n        // Get string pointer from element (assuming all elements are strings)\n        let elem_data = self\n            .builder\n            .build_extract_value(elem_value.into_struct_value(), 1, \"elem_data\")\n            .unwrap()\n            .into_int_value();\n        let elem_str_ptr = self\n            .builder\n            .build_int_to_ptr(elem_data, i8_ptr_type, \"elem_str_ptr\")\n            .unwrap();\n\n        // Get length of this element\n        let elem_len = self\n            .builder\n            .build_call(self.libc.strlen, &[elem_str_ptr.into()], \"elem_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Add to total\n        let current_total = self\n            .builder\n            .build_load(self.types.i64_type, total_len_ptr, \"current_total\")\n            .unwrap()\n            .into_int_value();\n        let new_total = self\n            .builder\n            .build_int_add(current_total, elem_len, \"new_total\")\n            .unwrap();\n\n        // Add delimiter length if not last element\n        let one = self.types.i64_type.const_int(1, false);\n        let list_len_minus_one = self\n            .builder\n            .build_int_sub(list_len, one, \"len_minus_one\")\n            .unwrap();\n        let is_last = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len_minus_one, \"is_last\")\n            .unwrap();\n        let delim_add = self\n            .builder\n            .build_select(is_last, zero, delim_len, \"delim_add\")\n            .unwrap()\n            .into_int_value();\n        let with_delim = self\n            .builder\n            .build_int_add(new_total, delim_add, \"with_delim\")\n            .unwrap();\n        self.builder.build_store(total_len_ptr, with_delim).unwrap();\n\n        // Increment index\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(calc_loop).unwrap();\n\n        // Allocate result buffer\n        self.builder.position_at_end(calc_done);\n        let final_total = self\n            .builder\n            .build_load(self.types.i64_type, total_len_ptr, \"final_total\")\n            .unwrap()\n            .into_int_value();\n        let alloc_size = self\n            .builder\n            .build_int_add(final_total, one, \"alloc_size\")\n            .unwrap();\n\n        let result_buf = self\n            .builder\n            .build_call(self.libc.malloc, &[alloc_size.into()], \"result_buf\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Second pass: concatenate strings using memcpy with position tracking\n        // This is O(n) instead of O(n) from strcat\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        // Track write position\n        let write_pos_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"write_pos\")\n            .unwrap();\n        self.builder.build_store(write_pos_ptr, zero).unwrap();\n\n        let concat_loop = self.context.append_basic_block(function, \"concat_loop\");\n        let concat_body = self.context.append_basic_block(function, \"concat_body\");\n        let concat_done = self.context.append_basic_block(function, \"concat_done\");\n\n        self.builder\n            .build_unconditional_branch(concat_loop)\n            .unwrap();\n        self.builder.position_at_end(concat_loop);\n\n        let idx2 = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx2_val\")\n            .unwrap()\n            .into_int_value();\n        let concat_done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx2, list_len, \"concat_done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(concat_done_cond, concat_done, concat_body)\n            .unwrap();\n\n        self.builder.position_at_end(concat_body);\n\n        // Get element at index\n        let elem_offset2 = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx2, elem_size, \"elem_mul2\")\n                    .unwrap(),\n                \"elem_offset2\",\n            )\n            .unwrap();\n        let elem_ptr2 = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    list_ptr,\n                    &[elem_offset2],\n                    \"elem_ptr2\",\n                )\n                .unwrap()\n        };\n        let value_ptr2 = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr2,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr2\",\n            )\n            .unwrap();\n        let elem_value2 = self\n            .builder\n            .build_load(self.types.value_type, value_ptr2, \"elem_value2\")\n            .unwrap();\n\n        let elem_data2 = self\n            .builder\n            .build_extract_value(elem_value2.into_struct_value(), 1, \"elem_data2\")\n            .unwrap()\n            .into_int_value();\n        let elem_str_ptr2 = self\n            .builder\n            .build_int_to_ptr(elem_data2, i8_ptr_type, \"elem_str_ptr2\")\n            .unwrap();\n\n        // Get element length\n        let elem_len2 = self\n            .builder\n            .build_call(self.libc.strlen, &[elem_str_ptr2.into()], \"elem_len2\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Get current write position\n        let write_pos = self\n            .builder\n            .build_load(self.types.i64_type, write_pos_ptr, \"write_pos\")\n            .unwrap()\n            .into_int_value();\n\n        // Copy element using memcpy\n        let dest_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[write_pos], \"dest_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dest_ptr.into(), elem_str_ptr2.into(), elem_len2.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Update write position\n        let new_write_pos = self\n            .builder\n            .build_int_add(write_pos, elem_len2, \"new_write_pos\")\n            .unwrap();\n\n        // Add delimiter if not last\n        let one2 = self.types.i64_type.const_int(1, false);\n        let list_len_minus_one2 = self\n            .builder\n            .build_int_sub(list_len, one2, \"len_minus_one2\")\n            .unwrap();\n        let is_last2 = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx2, list_len_minus_one2, \"is_last2\")\n            .unwrap();\n\n        let add_delim_block = self.context.append_basic_block(function, \"add_delim\");\n        let skip_delim_block = self.context.append_basic_block(function, \"skip_delim\");\n\n        self.builder\n            .build_conditional_branch(is_last2, skip_delim_block, add_delim_block)\n            .unwrap();\n\n        // Add delimiter using memcpy\n        self.builder.position_at_end(add_delim_block);\n        let delim_dest = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    result_buf,\n                    &[new_write_pos],\n                    \"delim_dest\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[delim_dest.into(), delim_ptr.into(), delim_len.into()],\n                \"\",\n            )\n            .unwrap();\n        let with_delim_pos = self\n            .builder\n            .build_int_add(new_write_pos, delim_len, \"with_delim_pos\")\n            .unwrap();\n        self.builder\n            .build_store(write_pos_ptr, with_delim_pos)\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(skip_delim_block)\n            .unwrap();\n\n        self.builder.position_at_end(skip_delim_block);\n        // Use phi for write position\n        let pos_phi = self\n            .builder\n            .build_phi(self.types.i64_type, \"pos_phi\")\n            .unwrap();\n        pos_phi.add_incoming(&[\n            (&new_write_pos, concat_body),\n            (&with_delim_pos, add_delim_block),\n        ]);\n        self.builder\n            .build_store(write_pos_ptr, pos_phi.as_basic_value().into_int_value())\n            .unwrap();\n\n        let next_idx2 = self.builder.build_int_add(idx2, one, \"next_idx2\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx2).unwrap();\n        self.builder\n            .build_unconditional_branch(concat_loop)\n            .unwrap();\n\n        // Done concatenating - null terminate\n        self.builder.position_at_end(concat_done);\n        let final_pos = self\n            .builder\n            .build_load(self.types.i64_type, write_pos_ptr, \"final_pos\")\n            .unwrap()\n            .into_int_value();\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), result_buf, &[final_pos], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        let concat_result = self.make_string(result_buf)?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let concat_block_end = self.builder.get_insert_block().unwrap();\n\n        // Final done block with phi\n        self.builder.position_at_end(done_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"join_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&empty_result, empty_block_end),\n            (&concat_result, concat_block_end),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// sort(list) - Return a sorted copy of the list (bubble sort for simplicity)\n    fn inline_sort(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // First, create a copy of the list\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        // Get list length\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate total size: 8 + len * 16\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_total = self\n            .builder\n            .build_int_mul(list_len, elem_size, \"elems_total\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_total, \"total_size\")\n            .unwrap();\n\n        // Allocate new list\n        let new_list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy entire list\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[new_list_ptr.into(), list_ptr.into(), total_size.into()],\n                \"copy_list\",\n            )\n            .unwrap();\n\n        // Bubble sort: outer loop i from 0 to len-1\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n\n        let i_ptr = self.builder.build_alloca(self.types.i64_type, \"i\").unwrap();\n        self.builder.build_store(i_ptr, zero).unwrap();\n\n        let outer_loop = self.context.append_basic_block(function, \"sort_outer\");\n        let outer_body = self.context.append_basic_block(function, \"sort_outer_body\");\n        let inner_loop = self.context.append_basic_block(function, \"sort_inner\");\n        let inner_body = self.context.append_basic_block(function, \"sort_inner_body\");\n        let inner_done = self.context.append_basic_block(function, \"sort_inner_done\");\n        let outer_done = self.context.append_basic_block(function, \"sort_outer_done\");\n\n        self.builder.build_unconditional_branch(outer_loop).unwrap();\n        self.builder.position_at_end(outer_loop);\n\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i_val\")\n            .unwrap()\n            .into_int_value();\n        let len_minus_one = self\n            .builder\n            .build_int_sub(list_len, one, \"len_minus_one\")\n            .unwrap();\n        let outer_done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, i, len_minus_one, \"outer_done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(outer_done_cond, outer_done, outer_body)\n            .unwrap();\n\n        self.builder.position_at_end(outer_body);\n        let j_ptr = self.builder.build_alloca(self.types.i64_type, \"j\").unwrap();\n        self.builder.build_store(j_ptr, zero).unwrap();\n\n        self.builder.build_unconditional_branch(inner_loop).unwrap();\n        self.builder.position_at_end(inner_loop);\n\n        let j = self\n            .builder\n            .build_load(self.types.i64_type, j_ptr, \"j_val\")\n            .unwrap()\n            .into_int_value();\n        let bound = self\n            .builder\n            .build_int_sub(len_minus_one, i, \"bound\")\n            .unwrap();\n        let inner_done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, j, bound, \"inner_done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(inner_done_cond, inner_done, inner_body)\n            .unwrap();\n\n        self.builder.position_at_end(inner_body);\n\n        // Get element at j\n        let j_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder.build_int_mul(j, elem_size, \"j_mul\").unwrap(),\n                \"j_offset\",\n            )\n            .unwrap();\n        let j_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[j_offset],\n                    \"j_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let j_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                j_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"j_value_ptr\",\n            )\n            .unwrap();\n        let j_value = self\n            .builder\n            .build_load(self.types.value_type, j_value_ptr, \"j_value\")\n            .unwrap();\n\n        // Get element at j+1\n        let j_plus_one = self.builder.build_int_add(j, one, \"j_plus_one\").unwrap();\n        let j1_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(j_plus_one, elem_size, \"j1_mul\")\n                    .unwrap(),\n                \"j1_offset\",\n            )\n            .unwrap();\n        let j1_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[j1_offset],\n                    \"j1_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let j1_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                j1_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"j1_value_ptr\",\n            )\n            .unwrap();\n        let j1_value = self\n            .builder\n            .build_load(self.types.value_type, j1_value_ptr, \"j1_value\")\n            .unwrap();\n\n        // Extract integer values for comparison (assuming numeric list)\n        let j_data = self\n            .builder\n            .build_extract_value(j_value.into_struct_value(), 1, \"j_data\")\n            .unwrap()\n            .into_int_value();\n        let j1_data = self\n            .builder\n            .build_extract_value(j1_value.into_struct_value(), 1, \"j1_data\")\n            .unwrap()\n            .into_int_value();\n\n        // Compare: if j_data > j1_data, swap\n        let should_swap = self\n            .builder\n            .build_int_compare(IntPredicate::SGT, j_data, j1_data, \"should_swap\")\n            .unwrap();\n\n        let swap_block = self.context.append_basic_block(function, \"sort_swap\");\n        let no_swap_block = self.context.append_basic_block(function, \"sort_no_swap\");\n\n        self.builder\n            .build_conditional_branch(should_swap, swap_block, no_swap_block)\n            .unwrap();\n\n        self.builder.position_at_end(swap_block);\n        // Swap values\n        self.builder.build_store(j_value_ptr, j1_value).unwrap();\n        self.builder.build_store(j1_value_ptr, j_value).unwrap();\n        self.builder\n            .build_unconditional_branch(no_swap_block)\n            .unwrap();\n\n        self.builder.position_at_end(no_swap_block);\n        let next_j = self.builder.build_int_add(j, one, \"next_j\").unwrap();\n        self.builder.build_store(j_ptr, next_j).unwrap();\n        self.builder.build_unconditional_branch(inner_loop).unwrap();\n\n        self.builder.position_at_end(inner_done);\n        let next_i = self.builder.build_int_add(i, one, \"next_i\").unwrap();\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(outer_loop).unwrap();\n\n        self.builder.position_at_end(outer_done);\n\n        // Return new list as value\n        let list_as_int = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"list_as_int\")\n            .unwrap();\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, list_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, list_as_int, 1, \"v2\")\n            .unwrap();\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// shuffle(list) - Return a shuffled copy of the list (Fisher-Yates shuffle)\n    fn inline_shuffle(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // First, create a copy of the list\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        // Get list length\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate total size: 8 + len * 16\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_total = self\n            .builder\n            .build_int_mul(list_len, elem_size, \"elems_total\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_total, \"total_size\")\n            .unwrap();\n\n        // Allocate new list\n        let new_list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy entire list\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[new_list_ptr.into(), list_ptr.into(), total_size.into()],\n                \"copy_list\",\n            )\n            .unwrap();\n\n        // Seed random number generator with time\n        let null = i8_ptr_type.const_null();\n        let time_val = self\n            .builder\n            .build_call(self.libc.time, &[null.into()], \"time_val\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let time_i32 = self\n            .builder\n            .build_int_truncate(time_val, self.context.i32_type(), \"time_i32\")\n            .unwrap();\n        self.builder\n            .build_call(self.libc.srand, &[time_i32.into()], \"seed_rand\")\n            .unwrap();\n\n        // Fisher-Yates shuffle: for i from len-1 down to 1\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n\n        let len_minus_one = self\n            .builder\n            .build_int_sub(list_len, one, \"len_minus_one\")\n            .unwrap();\n        let i_ptr = self.builder.build_alloca(self.types.i64_type, \"i\").unwrap();\n        self.builder.build_store(i_ptr, len_minus_one).unwrap();\n\n        let shuffle_loop = self.context.append_basic_block(function, \"shuffle_loop\");\n        let shuffle_body = self.context.append_basic_block(function, \"shuffle_body\");\n        let shuffle_done = self.context.append_basic_block(function, \"shuffle_done\");\n\n        self.builder\n            .build_unconditional_branch(shuffle_loop)\n            .unwrap();\n        self.builder.position_at_end(shuffle_loop);\n\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, i_ptr, \"i_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::ULE, i, zero, \"shuffle_done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, shuffle_done, shuffle_body)\n            .unwrap();\n\n        self.builder.position_at_end(shuffle_body);\n\n        // Generate random index j in [0, i]\n        let rand_val = self\n            .builder\n            .build_call(self.libc.rand, &[], \"rand_val\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let rand_i64 = self\n            .builder\n            .build_int_z_extend(rand_val, self.types.i64_type, \"rand_i64\")\n            .unwrap();\n        let i_plus_one = self.builder.build_int_add(i, one, \"i_plus_one\").unwrap();\n        let j = self\n            .builder\n            .build_int_unsigned_rem(rand_i64, i_plus_one, \"j\")\n            .unwrap();\n\n        // Get element at i\n        let i_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder.build_int_mul(i, elem_size, \"i_mul\").unwrap(),\n                \"i_offset\",\n            )\n            .unwrap();\n        let i_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[i_offset],\n                    \"i_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let i_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                i_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"i_value_ptr\",\n            )\n            .unwrap();\n        let i_value = self\n            .builder\n            .build_load(self.types.value_type, i_value_ptr, \"i_value\")\n            .unwrap();\n\n        // Get element at j\n        let j_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder.build_int_mul(j, elem_size, \"j_mul\").unwrap(),\n                \"j_offset\",\n            )\n            .unwrap();\n        let j_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[j_offset],\n                    \"j_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let j_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                j_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"j_value_ptr\",\n            )\n            .unwrap();\n        let j_value = self\n            .builder\n            .build_load(self.types.value_type, j_value_ptr, \"j_value\")\n            .unwrap();\n\n        // Swap values\n        self.builder.build_store(i_value_ptr, j_value).unwrap();\n        self.builder.build_store(j_value_ptr, i_value).unwrap();\n\n        // Decrement i\n        let next_i = self.builder.build_int_sub(i, one, \"next_i\").unwrap();\n        self.builder.build_store(i_ptr, next_i).unwrap();\n        self.builder\n            .build_unconditional_branch(shuffle_loop)\n            .unwrap();\n\n        self.builder.position_at_end(shuffle_done);\n\n        // Return new list as value\n        let list_as_int = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"list_as_int\")\n            .unwrap();\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, list_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, list_as_int, 1, \"v2\")\n            .unwrap();\n        Ok(v2.into_struct_value().into())\n    }\n\n    // ===== Lambda and Higher-Order Functions =====\n\n    /// Find free variables in an expression (variables used but not bound locally)\n    fn find_free_variables(&self, expr: &Expr, bound: &HashSet<String>) -> HashSet<String> {\n        let mut free = HashSet::new();\n        self.collect_free_vars(expr, bound, &mut free);\n        free\n    }\n\n    /// Recursively collect free variables from an expression\n    fn collect_free_vars(&self, expr: &Expr, bound: &HashSet<String>, free: &mut HashSet<String>) {\n        match expr {\n            Expr::Variable { name, .. } => {\n                if !bound.contains(name) && self.variables.contains_key(name) {\n                    free.insert(name.clone());\n                }\n            }\n            Expr::Binary { left, right, .. } => {\n                self.collect_free_vars(left, bound, free);\n                self.collect_free_vars(right, bound, free);\n            }\n            Expr::Unary { operand, .. } => {\n                self.collect_free_vars(operand, bound, free);\n            }\n            Expr::Logical { left, right, .. } => {\n                self.collect_free_vars(left, bound, free);\n                self.collect_free_vars(right, bound, free);\n            }\n            Expr::Call {\n                callee, arguments, ..\n            } => {\n                self.collect_free_vars(callee, bound, free);\n                for arg in arguments {\n                    self.collect_free_vars(arg, bound, free);\n                }\n            }\n            Expr::Get { object, .. } => {\n                self.collect_free_vars(object, bound, free);\n            }\n            Expr::Set { object, value, .. } => {\n                self.collect_free_vars(object, bound, free);\n                self.collect_free_vars(value, bound, free);\n            }\n            Expr::Index { object, index, .. } => {\n                self.collect_free_vars(object, bound, free);\n                self.collect_free_vars(index, bound, free);\n            }\n            Expr::IndexSet {\n                object,\n                index,\n                value,\n                ..\n            } => {\n                self.collect_free_vars(object, bound, free);\n                self.collect_free_vars(index, bound, free);\n                self.collect_free_vars(value, bound, free);\n            }\n            Expr::Ternary {\n                condition,\n                then_expr,\n                else_expr,\n                ..\n            } => {\n                self.collect_free_vars(condition, bound, free);\n                self.collect_free_vars(then_expr, bound, free);\n                self.collect_free_vars(else_expr, bound, free);\n            }\n            Expr::List { elements, .. } => {\n                for elem in elements {\n                    self.collect_free_vars(elem, bound, free);\n                }\n            }\n            Expr::Dict { pairs, .. } => {\n                for (k, v) in pairs {\n                    self.collect_free_vars(k, bound, free);\n                    self.collect_free_vars(v, bound, free);\n                }\n            }\n            Expr::Lambda { params, body, .. } => {\n                let mut new_bound = bound.clone();\n                for p in params {\n                    new_bound.insert(p.clone());\n                }\n                self.collect_free_vars(body, &new_bound, free);\n            }\n            Expr::Assign { name, value, .. } => {\n                if !bound.contains(name) && self.variables.contains_key(name) {\n                    free.insert(name.clone());\n                }\n                self.collect_free_vars(value, bound, free);\n            }\n            Expr::Slice {\n                object,\n                start,\n                end,\n                step,\n                ..\n            } => {\n                self.collect_free_vars(object, bound, free);\n                if let Some(s) = start {\n                    self.collect_free_vars(s, bound, free);\n                }\n                if let Some(e) = end {\n                    self.collect_free_vars(e, bound, free);\n                }\n                if let Some(st) = step {\n                    self.collect_free_vars(st, bound, free);\n                }\n            }\n            Expr::FString { parts, .. } => {\n                for part in parts {\n                    if let crate::ast::FStringPart::Expr(e) = part {\n                        self.collect_free_vars(e, bound, free);\n                    }\n                }\n            }\n            Expr::Range { start, end, .. } => {\n                self.collect_free_vars(start, bound, free);\n                self.collect_free_vars(end, bound, free);\n            }\n            Expr::Pipe { left, right, .. } => {\n                self.collect_free_vars(left, bound, free);\n                self.collect_free_vars(right, bound, free);\n            }\n            Expr::Grouping { expr, .. } => {\n                self.collect_free_vars(expr, bound, free);\n            }\n            Expr::Spread { expr, .. } => {\n                self.collect_free_vars(expr, bound, free);\n            }\n            Expr::Input { prompt, .. } => {\n                self.collect_free_vars(prompt, bound, free);\n            }\n            // Expressions without sub-expressions that don't reference variables\n            Expr::Literal { .. } | Expr::Masel { .. } => {}\n        }\n    }\n\n    /// Check if an expression uses 'masel' anywhere\n    fn expr_uses_masel(&self, expr: &Expr) -> bool {\n        match expr {\n            Expr::Masel { .. } => true,\n            Expr::Variable { .. } | Expr::Literal { .. } | Expr::Input { .. } => false,\n            Expr::Binary { left, right, .. } => {\n                self.expr_uses_masel(left) || self.expr_uses_masel(right)\n            }\n            Expr::Logical { left, right, .. } => {\n                self.expr_uses_masel(left) || self.expr_uses_masel(right)\n            }\n            Expr::Unary { operand, .. } => self.expr_uses_masel(operand),\n            Expr::Call {\n                callee, arguments, ..\n            } => self.expr_uses_masel(callee) || arguments.iter().any(|a| self.expr_uses_masel(a)),\n            Expr::Get { object, .. } => self.expr_uses_masel(object),\n            Expr::Set { object, value, .. } => {\n                self.expr_uses_masel(object) || self.expr_uses_masel(value)\n            }\n            Expr::Index { object, index, .. } => {\n                self.expr_uses_masel(object) || self.expr_uses_masel(index)\n            }\n            Expr::IndexSet {\n                object,\n                index,\n                value,\n                ..\n            } => {\n                self.expr_uses_masel(object)\n                    || self.expr_uses_masel(index)\n                    || self.expr_uses_masel(value)\n            }\n            Expr::Ternary {\n                condition,\n                then_expr,\n                else_expr,\n                ..\n            } => {\n                self.expr_uses_masel(condition)\n                    || self.expr_uses_masel(then_expr)\n                    || self.expr_uses_masel(else_expr)\n            }\n            Expr::List { elements, .. } => elements.iter().any(|e| self.expr_uses_masel(e)),\n            Expr::Dict { pairs, .. } => pairs\n                .iter()\n                .any(|(k, v)| self.expr_uses_masel(k) || self.expr_uses_masel(v)),\n            Expr::Lambda { body, .. } => self.expr_uses_masel(body),\n            Expr::Assign { value, .. } => self.expr_uses_masel(value),\n            Expr::Slice {\n                object,\n                start,\n                end,\n                step,\n                ..\n            } => {\n                self.expr_uses_masel(object)\n                    || start.as_ref().map_or(false, |e| self.expr_uses_masel(e))\n                    || end.as_ref().map_or(false, |e| self.expr_uses_masel(e))\n                    || step.as_ref().map_or(false, |e| self.expr_uses_masel(e))\n            }\n            Expr::Range { start, end, .. } => {\n                self.expr_uses_masel(start) || self.expr_uses_masel(end)\n            }\n            Expr::Pipe { left, right, .. } => {\n                self.expr_uses_masel(left) || self.expr_uses_masel(right)\n            }\n            Expr::FString { parts, .. } => parts.iter().any(|p| {\n                if let crate::ast::FStringPart::Expr(e) = p {\n                    self.expr_uses_masel(e)\n                } else {\n                    false\n                }\n            }),\n            Expr::Grouping { expr, .. } => self.expr_uses_masel(expr),\n            Expr::Spread { expr, .. } => self.expr_uses_masel(expr),\n        }\n    }\n\n    /// Find free variables in a function body (Vec<Stmt>)\n    fn find_free_variables_in_body(\n        &self,\n        body: &[Stmt],\n        params: &[crate::ast::Param],\n    ) -> Vec<String> {\n        let mut bound: HashSet<String> = params.iter().map(|p| p.name.clone()).collect();\n        let mut free = HashSet::new();\n\n        for stmt in body {\n            self.collect_free_vars_stmt(stmt, &mut bound, &mut free);\n        }\n\n        // Return as sorted Vec for deterministic ordering\n        let mut result: Vec<_> = free.into_iter().collect();\n        result.sort();\n        result\n    }\n\n    /// Collect free variables from a statement\n    fn collect_free_vars_stmt(\n        &self,\n        stmt: &Stmt,\n        bound: &mut HashSet<String>,\n        free: &mut HashSet<String>,\n    ) {\n        match stmt {\n            Stmt::Print { value, .. } => {\n                self.collect_free_vars(value, bound, free);\n            }\n            Stmt::Expression { expr, .. } => {\n                self.collect_free_vars(expr, bound, free);\n            }\n            Stmt::VarDecl {\n                name, initializer, ..\n            } => {\n                if let Some(val) = initializer {\n                    self.collect_free_vars(val, bound, free);\n                }\n                bound.insert(name.clone());\n            }\n            Stmt::If {\n                condition,\n                then_branch,\n                else_branch,\n                ..\n            } => {\n                self.collect_free_vars(condition, bound, free);\n                self.collect_free_vars_stmt(then_branch, bound, free);\n                if let Some(else_stmt) = else_branch {\n                    self.collect_free_vars_stmt(else_stmt, bound, free);\n                }\n            }\n            Stmt::Block { statements, .. } => {\n                for s in statements {\n                    self.collect_free_vars_stmt(s, bound, free);\n                }\n            }\n            Stmt::While {\n                condition, body, ..\n            } => {\n                self.collect_free_vars(condition, bound, free);\n                self.collect_free_vars_stmt(body, bound, free);\n            }\n            Stmt::For {\n                variable,\n                iterable,\n                body,\n                ..\n            } => {\n                self.collect_free_vars(iterable, bound, free);\n                let old_bound = bound.contains(variable);\n                bound.insert(variable.clone());\n                self.collect_free_vars_stmt(body, bound, free);\n                if !old_bound {\n                    bound.remove(variable);\n                }\n            }\n            Stmt::Return { value, .. } => {\n                if let Some(val) = value {\n                    self.collect_free_vars(val, bound, free);\n                }\n            }\n            Stmt::Assert {\n                condition, message, ..\n            } => {\n                self.collect_free_vars(condition, bound, free);\n                if let Some(msg) = message {\n                    self.collect_free_vars(msg, bound, free);\n                }\n            }\n            Stmt::Match { value, arms, .. } => {\n                self.collect_free_vars(value, bound, free);\n                for arm in arms {\n                    // Pattern introduces bindings\n                    let mut arm_bound = bound.clone();\n                    self.collect_pattern_bindings(&arm.pattern, &mut arm_bound);\n                    // Recurse into the body statement\n                    self.collect_free_vars_stmt(&arm.body, &mut arm_bound, free);\n                }\n            }\n            Stmt::Function { name, .. } => {\n                // Nested function - add name to bound, but don't recurse into body\n                // (nested function has its own scope)\n                bound.insert(name.clone());\n            }\n            Stmt::TryCatch {\n                try_block,\n                error_name,\n                catch_block,\n                ..\n            } => {\n                self.collect_free_vars_stmt(try_block, bound, free);\n                let old_bound = bound.contains(error_name);\n                bound.insert(error_name.clone());\n                self.collect_free_vars_stmt(catch_block, bound, free);\n                if !old_bound {\n                    bound.remove(error_name);\n                }\n            }\n            Stmt::Destructure {\n                patterns, value, ..\n            } => {\n                self.collect_free_vars(value, bound, free);\n                for pattern in patterns {\n                    self.add_destruct_pattern_bindings(pattern, bound);\n                }\n            }\n            Stmt::Log { message, .. } => {\n                self.collect_free_vars(message, bound, free);\n            }\n            Stmt::Hurl { message, .. } => {\n                self.collect_free_vars(message, bound, free);\n            }\n            // Statements that don't contain expressions with variables\n            Stmt::Break { .. }\n            | Stmt::Continue { .. }\n            | Stmt::Import { .. }\n            | Stmt::Class { .. }\n            | Stmt::Struct { .. } => {}\n        }\n    }\n\n    /// Collect variable bindings from a match pattern\n    fn collect_pattern_bindings(&self, pattern: &crate::ast::Pattern, bound: &mut HashSet<String>) {\n        match pattern {\n            crate::ast::Pattern::Identifier(name) if name != \"_\" => {\n                bound.insert(name.clone());\n            }\n            crate::ast::Pattern::Range { .. } => {\n                // Range patterns don't introduce bindings in this AST\n            }\n            _ => {}\n        }\n    }\n\n    /// Add destructure pattern bindings\n    fn add_destruct_pattern_bindings(\n        &self,\n        pattern: &crate::ast::DestructPattern,\n        bound: &mut HashSet<String>,\n    ) {\n        match pattern {\n            crate::ast::DestructPattern::Variable(name) => {\n                bound.insert(name.clone());\n            }\n            crate::ast::DestructPattern::Rest(name) => {\n                bound.insert(name.clone());\n            }\n            crate::ast::DestructPattern::Ignore => {}\n        }\n    }\n\n    /// Compile a lambda expression into an LLVM function and return a function pointer value\n    ///\n    /// For closures (lambdas that capture outer variables), we create a \"fat closure\"\n    /// represented as a list: [fn_ptr, captured_val1, captured_val2, ...]\n    /// The function signature includes the captured variables as extra leading parameters.\n    fn compile_lambda(\n        &mut self,\n        params: &[String],\n        body: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Generate unique lambda name\n        let lambda_name = format!(\"__lambda_{}\", self.lambda_counter);\n        self.lambda_counter += 1;\n\n        // Find free variables in the lambda body (variables from outer scope)\n        let param_set: HashSet<String> = params.iter().cloned().collect();\n        let free_vars = self.find_free_variables(body, &param_set);\n\n        // Filter to only include variables that exist in current scope\n        let mut captures: Vec<String> = free_vars\n            .iter()\n            .filter(|v| self.variables.contains_key(*v))\n            .cloned()\n            .collect();\n\n        // Check if lambda body uses 'masel' and we're in a method context\n        let uses_masel = self.expr_uses_masel(body);\n        let needs_masel_capture = uses_masel && self.current_masel.is_some();\n        if needs_masel_capture && !captures.contains(&\"masel\".to_string()) {\n            captures.push(\"masel\".to_string());\n        }\n\n        // Collect capture allocas from outer scope BEFORE we modify anything\n        let mut capture_allocas: Vec<_> = captures\n            .iter()\n            .filter(|name| *name != \"masel\")\n            .filter_map(|name| self.variables.get(name).copied())\n            .collect();\n        // Add masel alloca if needed\n        if needs_masel_capture {\n            if let Some(masel_ptr) = self.current_masel {\n                capture_allocas.push(masel_ptr);\n            }\n        }\n\n        // Create function type: captured vars first, then regular params\n        // (capture1, capture2, ..., param1, param2, ...) -> value\n        let total_params = captures.len() + params.len();\n        let param_types: Vec<BasicMetadataTypeEnum> = (0..total_params)\n            .map(|_| self.types.value_type.into())\n            .collect();\n        let fn_type = self.types.value_type.fn_type(&param_types, false);\n        let lambda_fn = self.module.add_function(&lambda_name, fn_type, None);\n\n        // Save current state\n        let saved_function = self.current_function;\n        let saved_variables = self.variables.clone();\n        let saved_var_types = self.var_types.clone();\n        let saved_int_shadows = self.int_shadows.clone();\n        let saved_list_ptr_shadows = self.list_ptr_shadows.clone();\n        let saved_string_len_shadows = self.string_len_shadows.clone();\n        let saved_string_cap_shadows = self.string_cap_shadows.clone();\n        let saved_block = self.builder.get_insert_block();\n        let saved_masel = self.current_masel;\n\n        // Set up lambda function\n        self.current_function = Some(lambda_fn);\n        let entry = self.context.append_basic_block(lambda_fn, \"entry\");\n        self.builder.position_at_end(entry);\n\n        // Clear state for the lambda's scope\n        self.variables.clear();\n        self.var_types.clear();\n        self.int_shadows.clear();\n        self.list_ptr_shadows.clear();\n        self.string_len_shadows.clear();\n        self.string_cap_shadows.clear();\n        self.current_masel = None;\n\n        // Bind captured variables (they come first in the parameter list)\n        for (i, capture_name) in captures.iter().enumerate() {\n            let alloca = self\n                .builder\n                .build_alloca(self.types.value_type, capture_name)\n                .unwrap();\n            let param_val = lambda_fn.get_nth_param(i as u32).unwrap();\n            self.builder.build_store(alloca, param_val).unwrap();\n            self.variables.insert(capture_name.clone(), alloca);\n\n            // If this is the captured 'masel', set current_masel so Expr::Masel works\n            if capture_name == \"masel\" {\n                self.current_masel = Some(alloca);\n            }\n        }\n\n        // Create allocas for regular parameters (after captures)\n        let capture_count = captures.len();\n        for (i, param_name) in params.iter().enumerate() {\n            let alloca = self\n                .builder\n                .build_alloca(self.types.value_type, param_name)\n                .unwrap();\n            let param_val = lambda_fn.get_nth_param((capture_count + i) as u32).unwrap();\n            self.builder.build_store(alloca, param_val).unwrap();\n            self.variables.insert(param_name.clone(), alloca);\n        }\n\n        // Compile the lambda body\n        let result = self.compile_expr(body)?;\n        self.builder.build_return(Some(&result)).unwrap();\n\n        // Restore state\n        self.current_function = saved_function;\n        self.variables = saved_variables;\n        self.var_types = saved_var_types;\n        self.int_shadows = saved_int_shadows;\n        self.list_ptr_shadows = saved_list_ptr_shadows;\n        self.string_len_shadows = saved_string_len_shadows;\n        self.string_cap_shadows = saved_string_cap_shadows;\n        self.current_masel = saved_masel;\n        if let Some(block) = saved_block {\n            self.builder.position_at_end(block);\n        }\n\n        // Register lambda as a callable function\n        self.functions.insert(lambda_name.clone(), lambda_fn);\n\n        // Track captures for this lambda\n        if !captures.is_empty() {\n            self.function_captures\n                .insert(lambda_name.clone(), captures.clone());\n        }\n\n        // Create function pointer value\n        let fn_ptr = lambda_fn.as_global_value().as_pointer_value();\n        let fn_ptr_int = self\n            .builder\n            .build_ptr_to_int(fn_ptr, self.types.i64_type, \"fn_ptr_int\")\n            .unwrap();\n        let fn_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::Function.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, fn_tag, 0, \"v1\")\n            .unwrap();\n        let fn_val = self\n            .builder\n            .build_insert_value(v1, fn_ptr_int, 1, \"fn_val\")\n            .unwrap()\n            .into_struct_value();\n\n        // If there are captures, create a closure list: [fn_ptr, capture1, capture2, ...]\n        // Tag=8 for Closure (list with first element being function)\n        if captures.is_empty() {\n            // Simple lambda - just return function value\n            Ok(fn_val.into())\n        } else {\n            // Create a closure list containing fn pointer and captured values\n            // Use our compile_list mechanism but manually build the list\n            let closure_len = 1 + captures.len(); // fn_ptr + captures\n            let value_size = 16u64;\n            let header_size = 16u64;\n            let total_size = header_size + (closure_len as u64) * value_size;\n\n            let size_val = self.types.i64_type.const_int(total_size, false);\n            let list_ptr = self\n                .builder\n                .build_call(self.libc.malloc, &[size_val.into()], \"closure_ptr\")\n                .unwrap()\n                .try_as_basic_value()\n                .left()\n                .unwrap()\n                .into_pointer_value();\n\n            // Store capacity and length in header\n            let i64_ptr_type = self\n                .types\n                .i64_type\n                .ptr_type(inkwell::AddressSpace::default());\n            let header_ptr = self\n                .builder\n                .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n                .unwrap();\n            let capacity_val = self.types.i64_type.const_int(closure_len as u64, false);\n            self.builder.build_store(header_ptr, capacity_val).unwrap();\n            let len_ptr = unsafe {\n                self.builder\n                    .build_gep(\n                        self.types.i64_type,\n                        header_ptr,\n                        &[self.types.i64_type.const_int(1, false)],\n                        \"len_ptr\",\n                    )\n                    .unwrap()\n            };\n            let len_val = self.types.i64_type.const_int(closure_len as u64, false);\n            self.builder.build_store(len_ptr, len_val).unwrap();\n\n            // Store function pointer as first element\n            let elem0_offset = header_size;\n            let elem0_ptr = unsafe {\n                self.builder\n                    .build_gep(\n                        self.context.i8_type(),\n                        list_ptr,\n                        &[self.types.i64_type.const_int(elem0_offset, false)],\n                        \"elem0_ptr\",\n                    )\n                    .unwrap()\n            };\n            let elem0_val_ptr = self\n                .builder\n                .build_pointer_cast(\n                    elem0_ptr,\n                    self.types\n                        .value_type\n                        .ptr_type(inkwell::AddressSpace::default()),\n                    \"elem0_val_ptr\",\n                )\n                .unwrap();\n            self.builder.build_store(elem0_val_ptr, fn_val).unwrap();\n\n            // Store captured values\n            for (i, capture_alloca) in capture_allocas.iter().enumerate() {\n                let capture_val = self\n                    .builder\n                    .build_load(\n                        self.types.value_type,\n                        *capture_alloca,\n                        &format!(\"cap{}_closure\", i),\n                    )\n                    .unwrap();\n                let elem_offset = header_size + ((i + 1) as u64) * value_size;\n                let elem_ptr = unsafe {\n                    self.builder\n                        .build_gep(\n                            self.context.i8_type(),\n                            list_ptr,\n                            &[self.types.i64_type.const_int(elem_offset, false)],\n                            &format!(\"elem{}_ptr\", i + 1),\n                        )\n                        .unwrap()\n                };\n                let elem_val_ptr = self\n                    .builder\n                    .build_pointer_cast(\n                        elem_ptr,\n                        self.types\n                            .value_type\n                            .ptr_type(inkwell::AddressSpace::default()),\n                        &format!(\"elem{}_val_ptr\", i + 1),\n                    )\n                    .unwrap();\n                self.builder.build_store(elem_val_ptr, capture_val).unwrap();\n            }\n\n            // Return closure as List value (tag=5 for List, but semantically it's a closure)\n            let list_ptr_int = self\n                .builder\n                .build_ptr_to_int(list_ptr, self.types.i64_type, \"closure_ptr_int\")\n                .unwrap();\n            let closure_tag = self\n                .types\n                .i8_type\n                .const_int(ValueTag::List.as_u8() as u64, false);\n            let undef2 = self.types.value_type.get_undef();\n            let c1 = self\n                .builder\n                .build_insert_value(undef2, closure_tag, 0, \"c1\")\n                .unwrap();\n            let c2 = self\n                .builder\n                .build_insert_value(c1, list_ptr_int, 1, \"c2\")\n                .unwrap();\n            Ok(c2.into_struct_value().into())\n        }\n    }\n\n    /// Helper to call a function value with arguments\n    ///\n    /// Handles both simple functions (tag=7) and closures (tag=5, list with fn+captures)\n    fn call_function_value(\n        &mut self,\n        func_val: BasicValueEnum<'ctx>,\n        args: &[BasicValueEnum<'ctx>],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract tag to determine if this is a simple function or closure\n        let func_struct = func_val.into_struct_value();\n        let tag = self\n            .builder\n            .build_extract_value(func_struct, 0, \"func_tag\")\n            .unwrap()\n            .into_int_value();\n\n        // Check if tag == 7 (Function) or tag == 5 (List/Closure)\n        let is_function = self\n            .builder\n            .build_int_compare(\n                IntPredicate::EQ,\n                tag,\n                self.types\n                    .i8_type\n                    .const_int(ValueTag::Function.as_u8() as u64, false),\n                \"is_function\",\n            )\n            .unwrap();\n\n        // Create blocks for both cases\n        let simple_block = self.context.append_basic_block(function, \"simple_call\");\n        let closure_block = self.context.append_basic_block(function, \"closure_call\");\n        let merge_block = self.context.append_basic_block(function, \"call_merge\");\n\n        self.builder\n            .build_conditional_branch(is_function, simple_block, closure_block)\n            .unwrap();\n\n        // Simple function call\n        self.builder.position_at_end(simple_block);\n        let func_data = self\n            .builder\n            .build_extract_value(func_struct, 1, \"func_data\")\n            .unwrap()\n            .into_int_value();\n        let param_types: Vec<BasicMetadataTypeEnum> =\n            args.iter().map(|_| self.types.value_type.into()).collect();\n        let fn_type = self.types.value_type.fn_type(&param_types, false);\n        let fn_ptr_type = fn_type.ptr_type(AddressSpace::default());\n        let fn_ptr = self\n            .builder\n            .build_int_to_ptr(func_data, fn_ptr_type, \"fn_ptr\")\n            .unwrap();\n        let call_args: Vec<BasicMetadataValueEnum> = args.iter().map(|a| (*a).into()).collect();\n        let simple_result = self\n            .builder\n            .build_indirect_call(fn_type, fn_ptr, &call_args, \"simple_result\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let simple_end = self.builder.get_insert_block().unwrap();\n\n        // Closure call - extract fn_ptr and captures from the list\n        self.builder.position_at_end(closure_block);\n        let list_data = self\n            .builder\n            .build_extract_value(func_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        // Get closure length (number of captures + 1 for fn_ptr)\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let closure_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"closure_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate number of captures\n        let one = self.types.i64_type.const_int(1, false);\n        let num_captures = self\n            .builder\n            .build_int_sub(closure_len, one, \"num_captures\")\n            .unwrap();\n\n        // Extract fn_ptr from first element\n        let header_size = 16u64;\n        let value_size = 16u64;\n        let elem0_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    list_ptr,\n                    &[self.types.i64_type.const_int(header_size, false)],\n                    \"elem0_ptr\",\n                )\n                .unwrap()\n        };\n        let elem0_val_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem0_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"elem0_val_ptr\",\n            )\n            .unwrap();\n        let fn_val_in_closure = self\n            .builder\n            .build_load(self.types.value_type, elem0_val_ptr, \"fn_in_closure\")\n            .unwrap()\n            .into_struct_value();\n        let fn_data_in_closure = self\n            .builder\n            .build_extract_value(fn_val_in_closure, 1, \"fn_data_closure\")\n            .unwrap()\n            .into_int_value();\n\n        // We need to handle variable number of captures at runtime\n        // For simplicity, support up to 4 captures statically (can be extended)\n        // Build all possible call sites and branch to the right one based on num_captures\n\n        // For now, let's handle common cases: 0-4 captures\n        // Create blocks for each case\n        let case0_block = self.context.append_basic_block(function, \"closure_0\");\n        let case1_block = self.context.append_basic_block(function, \"closure_1\");\n        let case2_block = self.context.append_basic_block(function, \"closure_2\");\n        let default_block = self.context.append_basic_block(function, \"closure_default\");\n\n        // Switch on num_captures\n        let zero = self.types.i64_type.const_int(0, false);\n        let is_0 = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, num_captures, zero, \"is_0\")\n            .unwrap();\n        let is_1 = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, num_captures, one, \"is_1\")\n            .unwrap();\n        let two = self.types.i64_type.const_int(2, false);\n        let is_2 = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, num_captures, two, \"is_2\")\n            .unwrap();\n\n        self.builder\n            .build_conditional_branch(is_0, case0_block, case1_block)\n            .unwrap();\n\n        // Case 0: no captures (shouldn't happen for closures but handle it)\n        self.builder.position_at_end(case0_block);\n        let fn_type0 = self.types.value_type.fn_type(&param_types, false);\n        let fn_ptr0 = self\n            .builder\n            .build_int_to_ptr(fn_data_in_closure, fn_ptr_type, \"fn_ptr0\")\n            .unwrap();\n        let result0 = self\n            .builder\n            .build_indirect_call(fn_type0, fn_ptr0, &call_args, \"result0\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let case0_end = self.builder.get_insert_block().unwrap();\n\n        // Case 1: 1 capture\n        self.builder.position_at_end(case1_block);\n        self.builder\n            .build_conditional_branch(is_1, default_block, case2_block)\n            .unwrap();\n\n        // For now, use default block for cases with captures - just call without captures\n        // This is a temporary solution; proper handling requires loading captures dynamically\n        self.builder.position_at_end(case2_block);\n        self.builder\n            .build_conditional_branch(is_2, default_block, default_block)\n            .unwrap();\n\n        // Default: load captures dynamically (up to 4)\n        self.builder.position_at_end(default_block);\n        // For now, just call with the args we have (ignoring captures)\n        // TODO: Properly load and pass captures\n        // For simplicity, read up to 4 captures and build a call with them\n\n        // Load capture 1\n        let cap1_offset = header_size + value_size;\n        let cap1_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    list_ptr,\n                    &[self.types.i64_type.const_int(cap1_offset, false)],\n                    \"cap1_ptr\",\n                )\n                .unwrap()\n        };\n        let cap1_val_ptr = self\n            .builder\n            .build_pointer_cast(\n                cap1_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"cap1_val_ptr\",\n            )\n            .unwrap();\n        let cap1 = self\n            .builder\n            .build_load(self.types.value_type, cap1_val_ptr, \"cap1\")\n            .unwrap();\n\n        // Load capture 2\n        let cap2_offset = header_size + 2 * value_size;\n        let cap2_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    list_ptr,\n                    &[self.types.i64_type.const_int(cap2_offset, false)],\n                    \"cap2_ptr\",\n                )\n                .unwrap()\n        };\n        let cap2_val_ptr = self\n            .builder\n            .build_pointer_cast(\n                cap2_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"cap2_val_ptr\",\n            )\n            .unwrap();\n        let cap2 = self\n            .builder\n            .build_load(self.types.value_type, cap2_val_ptr, \"cap2\")\n            .unwrap();\n\n        // Build args with captures prepended\n        let mut closure_args: Vec<BasicMetadataValueEnum> = Vec::new();\n        closure_args.push(cap1.into());\n        // Conditionally add cap2 if num_captures >= 2\n        // For simplicity, just always include both for functions that expect them\n        // The function will ignore extra args\n\n        // Actually, we need to match the exact arity. Let's try a simpler approach:\n        // Just prepend all captures we loaded and let LLVM sort it out\n        // This works because we create the fn_type based on total args\n        closure_args.push(cap2.into());\n        for arg in args {\n            closure_args.push((*arg).into());\n        }\n\n        // Create function type with captures + args\n        let closure_param_count = 2 + args.len(); // 2 captures + original args\n        let closure_param_types: Vec<BasicMetadataTypeEnum> = (0..closure_param_count)\n            .map(|_| self.types.value_type.into())\n            .collect();\n        let closure_fn_type = self.types.value_type.fn_type(&closure_param_types, false);\n        let closure_fn_ptr_type = closure_fn_type.ptr_type(AddressSpace::default());\n        let closure_fn_ptr = self\n            .builder\n            .build_int_to_ptr(fn_data_in_closure, closure_fn_ptr_type, \"closure_fn_ptr\")\n            .unwrap();\n\n        let result_default = self\n            .builder\n            .build_indirect_call(\n                closure_fn_type,\n                closure_fn_ptr,\n                &closure_args,\n                \"result_default\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let default_end = self.builder.get_insert_block().unwrap();\n\n        // Merge results\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"call_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&simple_result, simple_end),\n            (&result0, case0_end),\n            (&result_default, default_end),\n        ]);\n\n        Ok(phi.as_basic_value())\n    }\n\n    /// gaun(list, fn) - map function over list\n    fn inline_gaun(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract list pointer and length\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate new list\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_total = self\n            .builder\n            .build_int_mul(list_len, elem_size, \"elems_total\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_total, \"total_size\")\n            .unwrap();\n\n        let new_list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_list_ptr, i64_ptr_type, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(new_len_ptr, list_len).unwrap();\n\n        // Store func_val in an alloca so we can use it in the loop\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n\n        // Loop and apply function\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"gaun_loop\");\n        let body_block = self.context.append_basic_block(function, \"gaun_body\");\n        let done_block = self.context.append_basic_block(function, \"gaun_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get element at idx\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        // Load function and call it\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let mapped = self.call_function_value(func, &[elem_val])?;\n\n        // Store result in new list\n        let new_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[elem_offset],\n                    \"new_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let new_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                new_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"new_value_ptr\",\n            )\n            .unwrap();\n        self.builder.build_store(new_value_ptr, mapped).unwrap();\n\n        // Increment index\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n\n        // Return new list\n        let list_as_int = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"list_as_int\")\n            .unwrap();\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, list_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, list_as_int, 1, \"v2\")\n            .unwrap();\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// sieve(list, fn) - filter list by predicate\n    fn inline_sieve(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract list pointer and length\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate new list (max size = original size)\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_total = self\n            .builder\n            .build_int_mul(list_len, elem_size, \"elems_total\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_total, \"total_size\")\n            .unwrap();\n\n        let new_list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store func_val in an alloca\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n\n        // Counters\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        let count_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"count\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n        self.builder.build_store(count_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"sieve_loop\");\n        let body_block = self.context.append_basic_block(function, \"sieve_body\");\n        let keep_block = self.context.append_basic_block(function, \"sieve_keep\");\n        let next_block = self.context.append_basic_block(function, \"sieve_next\");\n        let done_block = self.context.append_basic_block(function, \"sieve_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get element at idx\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        // Store elem_val in alloca for use in keep_block\n        let elem_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"elem_alloca\")\n            .unwrap();\n        self.builder.build_store(elem_alloca, elem_val).unwrap();\n\n        // Call predicate\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let pred_result = self.call_function_value(func, &[elem_val])?;\n\n        // Check if truthy\n        let is_truthy = self.is_truthy(pred_result)?;\n        self.builder\n            .build_conditional_branch(is_truthy, keep_block, next_block)\n            .unwrap();\n\n        // Keep element\n        self.builder.position_at_end(keep_block);\n        let count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"count_val\")\n            .unwrap()\n            .into_int_value();\n        let new_elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(count, elem_size, \"count_mul\")\n                    .unwrap(),\n                \"new_elem_offset\",\n            )\n            .unwrap();\n        let new_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[new_elem_offset],\n                    \"new_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let new_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                new_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"new_value_ptr\",\n            )\n            .unwrap();\n        let elem_to_store = self\n            .builder\n            .build_load(self.types.value_type, elem_alloca, \"elem_to_store\")\n            .unwrap();\n        self.builder\n            .build_store(new_value_ptr, elem_to_store)\n            .unwrap();\n        let next_count = self\n            .builder\n            .build_int_add(count, one, \"next_count\")\n            .unwrap();\n        self.builder.build_store(count_ptr, next_count).unwrap();\n        self.builder.build_unconditional_branch(next_block).unwrap();\n\n        // Next iteration\n        self.builder.position_at_end(next_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n\n        // Store final count as length\n        let final_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"final_count\")\n            .unwrap()\n            .into_int_value();\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_list_ptr, i64_ptr_type, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(new_len_ptr, final_count).unwrap();\n\n        // Return new list\n        let list_as_int = self\n            .builder\n            .build_ptr_to_int(new_list_ptr, self.types.i64_type, \"list_as_int\")\n            .unwrap();\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, list_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, list_as_int, 1, \"v2\")\n            .unwrap();\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// tumble(list, init, fn) - reduce/fold\n    fn inline_tumble(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        init_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract list pointer and length\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Store func_val and accumulator\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n        let acc_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"acc_alloca\")\n            .unwrap();\n        self.builder.build_store(acc_alloca, init_val).unwrap();\n\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"tumble_loop\");\n        let body_block = self.context.append_basic_block(function, \"tumble_body\");\n        let done_block = self.context.append_basic_block(function, \"tumble_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get element at idx\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        // Call fn(acc, elem)\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let acc = self\n            .builder\n            .build_load(self.types.value_type, acc_alloca, \"acc\")\n            .unwrap();\n        let new_acc = self.call_function_value(func, &[acc, elem_val])?;\n        self.builder.build_store(acc_alloca, new_acc).unwrap();\n\n        // Increment index\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        let final_acc = self\n            .builder\n            .build_load(self.types.value_type, acc_alloca, \"final_acc\")\n            .unwrap();\n        Ok(final_acc)\n    }\n\n    /// aw(list, fn) - all elements satisfy predicate\n    fn inline_aw(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"aw_loop\");\n        let body_block = self.context.append_basic_block(function, \"aw_body\");\n        let false_block = self.context.append_basic_block(function, \"aw_false\");\n        let true_block = self.context.append_basic_block(function, \"aw_true\");\n        let done_block = self.context.append_basic_block(function, \"aw_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, true_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let pred_result = self.call_function_value(func, &[elem_val])?;\n        let is_truthy = self.is_truthy(pred_result)?;\n\n        let next_block = self.context.append_basic_block(function, \"aw_next\");\n        self.builder\n            .build_conditional_branch(is_truthy, next_block, false_block)\n            .unwrap();\n\n        self.builder.position_at_end(next_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(false_block);\n        let false_result = self.make_bool(self.types.bool_type.const_int(0, false))?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let false_block_end = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(true_block);\n        let true_result = self.make_bool(self.types.bool_type.const_int(1, false))?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let true_block_end = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(done_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"aw_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&false_result, false_block_end),\n            (&true_result, true_block_end),\n        ]);\n        Ok(phi.as_basic_value())\n    }\n\n    /// ony(list, fn) - any element satisfies predicate\n    fn inline_ony(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"ony_loop\");\n        let body_block = self.context.append_basic_block(function, \"ony_body\");\n        let true_block = self.context.append_basic_block(function, \"ony_true\");\n        let false_block = self.context.append_basic_block(function, \"ony_false\");\n        let done_block = self.context.append_basic_block(function, \"ony_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, false_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let pred_result = self.call_function_value(func, &[elem_val])?;\n        let is_truthy = self.is_truthy(pred_result)?;\n\n        let next_block = self.context.append_basic_block(function, \"ony_next\");\n        self.builder\n            .build_conditional_branch(is_truthy, true_block, next_block)\n            .unwrap();\n\n        self.builder.position_at_end(next_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(true_block);\n        let true_result = self.make_bool(self.types.bool_type.const_int(1, false))?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let true_block_end = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(false_block);\n        let false_result = self.make_bool(self.types.bool_type.const_int(0, false))?;\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let false_block_end = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(done_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"ony_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&true_result, true_block_end),\n            (&false_result, false_block_end),\n        ]);\n        Ok(phi.as_basic_value())\n    }\n\n    /// hunt(list, fn) - find first element satisfying predicate\n    fn inline_hunt(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"hunt_loop\");\n        let body_block = self.context.append_basic_block(function, \"hunt_body\");\n        let found_block = self.context.append_basic_block(function, \"hunt_found\");\n        let notfound_block = self.context.append_basic_block(function, \"hunt_notfound\");\n        let done_block = self.context.append_basic_block(function, \"hunt_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, notfound_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        // Store elem in alloca for use in found block\n        let found_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"found_alloca\")\n            .unwrap();\n        self.builder.build_store(found_alloca, elem_val).unwrap();\n\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let pred_result = self.call_function_value(func, &[elem_val])?;\n        let is_truthy = self.is_truthy(pred_result)?;\n\n        let next_block = self.context.append_basic_block(function, \"hunt_next\");\n        self.builder\n            .build_conditional_branch(is_truthy, found_block, next_block)\n            .unwrap();\n\n        self.builder.position_at_end(next_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(found_block);\n        let found_result = self\n            .builder\n            .build_load(self.types.value_type, found_alloca, \"found_result\")\n            .unwrap();\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let found_block_end = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(notfound_block);\n        let nil_result = self.make_nil();\n        self.builder.build_unconditional_branch(done_block).unwrap();\n        let notfound_block_end = self.builder.get_insert_block().unwrap();\n\n        self.builder.position_at_end(done_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.value_type, \"hunt_result\")\n            .unwrap();\n        phi.add_incoming(&[\n            (&found_result, found_block_end),\n            (&nil_result, notfound_block_end),\n        ]);\n        Ok(phi.as_basic_value())\n    }\n\n    /// ilk(list, fn) - for-each: calls fn for each element in the list\n    fn inline_ilk(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        func_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Get list pointer and length\n        let list_struct = list_val.into_struct_value();\n        let list_data = self\n            .builder\n            .build_extract_value(list_struct, 1, \"list_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr_type, \"list_ptr\")\n            .unwrap();\n\n        // Get list length\n        let header_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr_type, \"header_ptr\")\n            .unwrap();\n        let len_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.types.i64_type,\n                    header_ptr,\n                    &[self.types.i64_type.const_int(1, false)],\n                    \"len_ptr\",\n                )\n                .unwrap()\n        };\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Store function value for use in loop\n        let func_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"func_alloca\")\n            .unwrap();\n        self.builder.build_store(func_alloca, func_val).unwrap();\n\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"ilk_loop\");\n        let body_block = self.context.append_basic_block(function, \"ilk_body\");\n        let done_block = self.context.append_basic_block(function, \"ilk_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, list_len, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get current element\n        let elem_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"idx_mul\")\n                    .unwrap(),\n                \"elem_offset\",\n            )\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[elem_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let elem_val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        // Call function with element (ignore result)\n        let func = self\n            .builder\n            .build_load(self.types.value_type, func_alloca, \"func\")\n            .unwrap();\n        let _result = self.call_function_value(func, &[elem_val])?;\n\n        // Increment and continue\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        // Return nil (for-each doesn't return a value)\n        Ok(self.make_nil())\n    }\n\n    /// keys(dict) - returns a list of all keys in the dict\n    fn inline_keys(\n        &mut self,\n        dict_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Dict layout: [i64 count][entry0][entry1]... where entry = [value key][value val]\n        let dict_struct = dict_val.into_struct_value();\n        let dict_data = self\n            .builder\n            .build_extract_value(dict_struct, 1, \"dict_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let dict_ptr = self\n            .builder\n            .build_int_to_ptr(dict_data, i8_ptr_type, \"dict_ptr\")\n            .unwrap();\n\n        // Get dict count\n        let count_ptr = self\n            .builder\n            .build_pointer_cast(dict_ptr, i64_ptr_type, \"count_ptr\")\n            .unwrap();\n        let dict_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"dict_count\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate result list: 16 bytes header (capacity + length) + 16 bytes per key\n        let list_header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let result_data_size = self\n            .builder\n            .build_int_add(\n                list_header_size,\n                self.builder\n                    .build_int_mul(dict_count, elem_size, \"data_size\")\n                    .unwrap(),\n                \"result_size\",\n            )\n            .unwrap();\n        let result_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[result_data_size.into()], \"result_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let result_len_ptr = self\n            .builder\n            .build_pointer_cast(result_ptr, i64_ptr_type, \"result_len_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(result_len_ptr, dict_count)\n            .unwrap();\n\n        // Loop to copy keys\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let dict_header_size = self.types.i64_type.const_int(8, false); // sizeof(i64) for count\n        let entry_size = self.types.i64_type.const_int(32, false); // 16 bytes key + 16 bytes value\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"keys_loop\");\n        let body_block = self.context.append_basic_block(function, \"keys_body\");\n        let done_block = self.context.append_basic_block(function, \"keys_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, dict_count, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get key from dict entry\n        let dict_entry_offset = self\n            .builder\n            .build_int_add(\n                dict_header_size,\n                self.builder\n                    .build_int_mul(idx, entry_size, \"entry_mul\")\n                    .unwrap(),\n                \"entry_offset\",\n            )\n            .unwrap();\n        let dict_key_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    dict_ptr,\n                    &[dict_entry_offset],\n                    \"dict_key_ptr\",\n                )\n                .unwrap()\n        };\n        let key_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                dict_key_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"key_value_ptr\",\n            )\n            .unwrap();\n        let key_val = self\n            .builder\n            .build_load(self.types.value_type, key_value_ptr, \"key_val\")\n            .unwrap();\n\n        // Store key in result list\n        let result_elem_offset = self\n            .builder\n            .build_int_add(\n                list_header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"result_mul\")\n                    .unwrap(),\n                \"result_offset\",\n            )\n            .unwrap();\n        let result_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    result_ptr,\n                    &[result_elem_offset],\n                    \"result_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let result_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                result_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"result_value_ptr\",\n            )\n            .unwrap();\n        self.builder.build_store(result_value_ptr, key_val).unwrap();\n\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        self.make_list(result_ptr)\n    }\n\n    /// values(dict) - returns a list of all values in the dict\n    fn inline_values(\n        &mut self,\n        dict_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Dict layout: [i64 count][entry0][entry1]... where entry = [value key][value val]\n        let dict_struct = dict_val.into_struct_value();\n        let dict_data = self\n            .builder\n            .build_extract_value(dict_struct, 1, \"dict_data\")\n            .unwrap()\n            .into_int_value();\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let dict_ptr = self\n            .builder\n            .build_int_to_ptr(dict_data, i8_ptr_type, \"dict_ptr\")\n            .unwrap();\n\n        // Get dict count\n        let count_ptr = self\n            .builder\n            .build_pointer_cast(dict_ptr, i64_ptr_type, \"count_ptr\")\n            .unwrap();\n        let dict_count = self\n            .builder\n            .build_load(self.types.i64_type, count_ptr, \"dict_count\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate result list: 16 bytes header (capacity + length) + 16 bytes per value\n        let list_header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let result_data_size = self\n            .builder\n            .build_int_add(\n                list_header_size,\n                self.builder\n                    .build_int_mul(dict_count, elem_size, \"data_size\")\n                    .unwrap(),\n                \"result_size\",\n            )\n            .unwrap();\n        let result_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[result_data_size.into()], \"result_ptr\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to malloc: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let result_len_ptr = self\n            .builder\n            .build_pointer_cast(result_ptr, i64_ptr_type, \"result_len_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(result_len_ptr, dict_count)\n            .unwrap();\n\n        // Loop to copy values\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let dict_header_size = self.types.i64_type.const_int(8, false); // sizeof(i64) for count\n        let entry_size = self.types.i64_type.const_int(32, false); // 16 bytes key + 16 bytes value\n        let value_offset_in_entry = self.types.i64_type.const_int(16, false); // Value comes after key\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"values_loop\");\n        let body_block = self.context.append_basic_block(function, \"values_body\");\n        let done_block = self.context.append_basic_block(function, \"values_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, dict_count, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get value from dict entry (offset by 16 bytes from entry start)\n        let dict_entry_offset = self\n            .builder\n            .build_int_add(\n                dict_header_size,\n                self.builder\n                    .build_int_mul(idx, entry_size, \"entry_mul\")\n                    .unwrap(),\n                \"entry_offset\",\n            )\n            .unwrap();\n        let dict_value_offset = self\n            .builder\n            .build_int_add(dict_entry_offset, value_offset_in_entry, \"value_offset\")\n            .unwrap();\n        let dict_value_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    dict_ptr,\n                    &[dict_value_offset],\n                    \"dict_value_ptr\",\n                )\n                .unwrap()\n        };\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(\n                dict_value_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_ptr\",\n            )\n            .unwrap();\n        let val = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"val\")\n            .unwrap();\n\n        // Store value in result list\n        let result_elem_offset = self\n            .builder\n            .build_int_add(\n                list_header_size,\n                self.builder\n                    .build_int_mul(idx, elem_size, \"result_mul\")\n                    .unwrap(),\n                \"result_offset\",\n            )\n            .unwrap();\n        let result_elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    result_ptr,\n                    &[result_elem_offset],\n                    \"result_elem_ptr\",\n                )\n                .unwrap()\n        };\n        let result_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                result_elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"result_value_ptr\",\n            )\n            .unwrap();\n        self.builder.build_store(result_value_ptr, val).unwrap();\n\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(done_block);\n        self.make_list(result_ptr)\n    }\n\n    // ========== Class/OOP Support ==========\n\n    /// Compile `masel` expression - returns the current instance\n    fn compile_masel(&self) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        if let Some(masel_ptr) = self.current_masel {\n            // Load the masel value from the pointer\n            let masel_val = self\n                .builder\n                .build_load(self.types.value_type, masel_ptr, \"masel_val\")\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to load masel: {}\", e)))?;\n            Ok(masel_val)\n        } else {\n            Err(HaversError::CompileError(\n                \"'masel' used outside of a method\".to_string(),\n            ))\n        }\n    }\n\n    /// Compile f-string (string interpolation): f\"Hello {name}!\"\n    fn compile_fstring(\n        &mut self,\n        parts: &[FStringPart],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        if parts.is_empty() {\n            // Empty f-string -> empty string\n            let empty = self\n                .builder\n                .build_global_string_ptr(\"\", \"empty_fstr\")\n                .unwrap();\n            return self.make_string(empty.as_pointer_value());\n        }\n\n        // Start with the first part\n        let mut result = match &parts[0] {\n            FStringPart::Text(s) => {\n                let text = self\n                    .builder\n                    .build_global_string_ptr(s, \"fstr_text\")\n                    .unwrap();\n                self.make_string(text.as_pointer_value())?\n            }\n            FStringPart::Expr(expr) => {\n                let val = self.compile_expr(expr)?;\n                // Convert to string\n                self.inline_tae_string(val)?\n            }\n        };\n\n        // Concatenate remaining parts\n        for part in parts.iter().skip(1) {\n            let part_val = match part {\n                FStringPart::Text(s) => {\n                    let text = self\n                        .builder\n                        .build_global_string_ptr(s, \"fstr_text\")\n                        .unwrap();\n                    self.make_string(text.as_pointer_value())?\n                }\n                FStringPart::Expr(expr) => {\n                    let val = self.compile_expr(expr)?;\n                    self.inline_tae_string(val)?\n                }\n            };\n            // Concatenate using inline_add (handles string + string)\n            result = self.inline_add(result, part_val)?;\n        }\n\n        Ok(result)\n    }\n\n    /// Compile pipe expression: value |> func  ->  func(value)\n    fn compile_pipe(\n        &mut self,\n        left: &Expr,\n        right: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Compile the left side (the value to pass)\n        let left_val = self.compile_expr(left)?;\n\n        // The right side should be callable - compile and call with left as argument\n        match right {\n            Expr::Lambda { params, body, .. } => {\n                // Inline lambda call: compile body with parameter bound to left_val\n                if params.len() != 1 {\n                    return Err(HaversError::CompileError(\n                        \"Pipe lambda must take exactly 1 parameter\".to_string(),\n                    ));\n                }\n                // Create a temporary variable for the parameter\n                let param_name = &params[0];\n                let alloca = self.create_entry_block_alloca(param_name);\n                self.builder.build_store(alloca, left_val).unwrap();\n                let old_var = self.variables.insert(param_name.clone(), alloca);\n\n                let result = self.compile_expr(body)?;\n\n                // Restore old variable if there was one\n                if let Some(old) = old_var {\n                    self.variables.insert(param_name.clone(), old);\n                } else {\n                    self.variables.remove(param_name);\n                }\n\n                Ok(result)\n            }\n            Expr::Variable { name, span } => {\n                // Call the named function with left_val\n                if let Some(&func) = self.functions.get(name) {\n                    let call = self\n                        .builder\n                        .build_call(func, &[left_val.into()], \"pipe_call\")\n                        .unwrap();\n                    Ok(call.try_as_basic_value().left().unwrap_or(self.make_nil()))\n                } else {\n                    // Try calling as a builtin by creating a synthetic Call expression\n                    let synthetic_call = Expr::Call {\n                        callee: Box::new(right.clone()),\n                        arguments: vec![left.clone()],\n                        span: *span,\n                    };\n                    self.compile_expr(&synthetic_call)\n                }\n            }\n            Expr::Call {\n                callee, arguments, ..\n            } => {\n                // Call with left_val prepended to arguments\n                // First compile the callee\n                let callee_val = self.compile_expr(callee)?;\n\n                // Compile other arguments\n                let mut args: Vec<BasicValueEnum<'ctx>> = vec![left_val];\n                for arg in arguments {\n                    args.push(self.compile_expr(arg)?);\n                }\n\n                // Call the function\n                self.call_function_value(callee_val, &args)\n            }\n            _ => {\n                // General case: compile right as callable and call with left\n                let func_val = self.compile_expr(right)?;\n                self.call_function_value(func_val, &[left_val])\n            }\n        }\n    }\n\n    /// Compile import statement - inline imported module's declarations\n    fn compile_import(&mut self, path: &str) -> Result<(), HaversError> {\n        // Resolve the import path relative to the source file\n        let import_path = self.resolve_import_path(path)?;\n\n        // Check if already imported\n        if self.imported_modules.contains(&import_path) {\n            return Ok(());\n        }\n        self.imported_modules.insert(import_path.clone());\n\n        // Read and parse the imported file\n        let source = std::fs::read_to_string(&import_path).map_err(|e| {\n            HaversError::CompileError(format!(\n                \"Failed to read import '{}': {}\",\n                import_path.display(),\n                e\n            ))\n        })?;\n\n        let program = crate::parser::parse(&source)?;\n\n        // First pass: Handle nested imports, declare functions, pre-register classes\n        for stmt in &program.statements {\n            match stmt {\n                Stmt::Import { path: sub_path, .. } => {\n                    // Handle nested imports first\n                    let saved_path = self.source_path.clone();\n                    self.source_path = Some(import_path.clone());\n                    self.compile_import(sub_path)?;\n                    self.source_path = saved_path;\n                }\n                Stmt::Function { name, params, .. } => {\n                    // Declare the function (forward declaration)\n                    self.declare_function(name, params.len())?;\n                }\n                Stmt::Class { name, methods, .. } => {\n                    // Pre-register class and its methods (allows cross-class method calls)\n                    self.preregister_class(name, methods)?;\n                }\n                Stmt::VarDecl {\n                    name, initializer, ..\n                } => {\n                    // Create global variable\n                    if !self.globals.contains_key(name) && !self.variables.contains_key(name) {\n                        // Create an LLVM global variable for imported module-level vars\n                        let global = self.module.add_global(\n                            self.types.value_type,\n                            None,\n                            &format!(\"imported_{}\", name),\n                        );\n                        global.set_initializer(&self.types.value_type.const_zero());\n                        let global_ptr = global.as_pointer_value();\n                        self.globals.insert(name.clone(), global_ptr);\n                        // Also add to variables so current scope can find it\n                        self.variables.insert(name.clone(), global_ptr);\n\n                        // Compile the initializer and store value\n                        if let Some(init) = initializer {\n                            let value = self.compile_expr(init)?;\n                            self.builder.build_store(global_ptr, value).unwrap();\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        // Second pass: Compile function bodies and classes\n        for stmt in &program.statements {\n            match stmt {\n                Stmt::Function {\n                    name, params, body, ..\n                } => {\n                    // Compile the function body\n                    self.compile_function(name, params, body)?;\n                }\n                Stmt::Class { name, methods, .. } => {\n                    self.compile_class(name, methods)?;\n                }\n                _ => {\n                    // Skip - already handled or not needed\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Resolve import path relative to current source file\n    fn resolve_import_path(&self, path: &str) -> Result<PathBuf, HaversError> {\n        // Add .braw extension if not present\n        let path_with_ext = if path.ends_with(\".braw\") {\n            path.to_string()\n        } else {\n            format!(\"{}.braw\", path)\n        };\n\n        // Try relative to source file first\n        if let Some(ref source_path) = self.source_path {\n            if let Some(parent) = source_path.parent() {\n                let relative_path = parent.join(&path_with_ext);\n                if relative_path.exists() {\n                    return Ok(relative_path.canonicalize().unwrap_or(relative_path));\n                }\n\n                // Try parent's parent (e.g., for stdlib/foo.braw importing lib/bar.braw)\n                if let Some(grandparent) = parent.parent() {\n                    let grandparent_path = grandparent.join(&path_with_ext);\n                    if grandparent_path.exists() {\n                        return Ok(grandparent_path.canonicalize().unwrap_or(grandparent_path));\n                    }\n                }\n            }\n        }\n\n        // Try current directory\n        let cwd_path = PathBuf::from(&path_with_ext);\n        if cwd_path.exists() {\n            return Ok(cwd_path.canonicalize().unwrap_or(cwd_path));\n        }\n\n        // Try examples directory (common pattern)\n        let examples_path = PathBuf::from(\"examples\").join(&path_with_ext);\n        if examples_path.exists() {\n            return Ok(examples_path.canonicalize().unwrap_or(examples_path));\n        }\n\n        Err(HaversError::CompileError(format!(\n            \"Cannot find module to import: {}\",\n            path\n        )))\n    }\n\n    /// Compile assert statement: mak_siccar condition, \"message\"\n    fn compile_assert(\n        &mut self,\n        condition: &Expr,\n        message: Option<&Expr>,\n    ) -> Result<(), HaversError> {\n        let cond_val = self.compile_expr(condition)?;\n\n        // Check if condition is truthy\n        let is_truthy = self.inline_is_truthy(cond_val)?;\n\n        let function = self.current_function.unwrap();\n        let assert_fail = self.context.append_basic_block(function, \"assert_fail\");\n        let assert_pass = self.context.append_basic_block(function, \"assert_pass\");\n\n        self.builder\n            .build_conditional_branch(is_truthy, assert_pass, assert_fail)\n            .unwrap();\n\n        // Assert failed - print message and abort\n        self.builder.position_at_end(assert_fail);\n\n        // Print error message\n        let default_msg = self\n            .builder\n            .build_global_string_ptr(\"Assertion failed!\\n\", \"assert_msg\")\n            .unwrap();\n\n        if let Some(msg_expr) = message {\n            let msg_val = self.compile_expr(msg_expr)?;\n            let msg_str = self.inline_tae_string(msg_val)?;\n            let msg_data = self.extract_data(msg_str)?;\n            let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n            let msg_ptr = self\n                .builder\n                .build_int_to_ptr(msg_data, i8_ptr, \"msg_ptr\")\n                .unwrap();\n\n            let prefix = self\n                .builder\n                .build_global_string_ptr(\"Assertion failed: \", \"assert_prefix\")\n                .unwrap();\n            let newline = self\n                .builder\n                .build_global_string_ptr(\"\\n\", \"newline\")\n                .unwrap();\n\n            self.builder\n                .build_call(self.libc.printf, &[prefix.as_pointer_value().into()], \"\")\n                .unwrap();\n            self.builder\n                .build_call(self.libc.printf, &[msg_ptr.into()], \"\")\n                .unwrap();\n            self.builder\n                .build_call(self.libc.printf, &[newline.as_pointer_value().into()], \"\")\n                .unwrap();\n        } else {\n            self.builder\n                .build_call(\n                    self.libc.printf,\n                    &[default_msg.as_pointer_value().into()],\n                    \"\",\n                )\n                .unwrap();\n        }\n\n        // Exit with error code\n        let exit_code = self.context.i32_type().const_int(1, false);\n        self.builder\n            .build_call(self.libc.exit, &[exit_code.into()], \"\")\n            .unwrap();\n        self.builder.build_unreachable().unwrap();\n\n        // Continue after assert pass\n        self.builder.position_at_end(assert_pass);\n        Ok(())\n    }\n\n    /// Compile try/catch statement\n    /// For now, this uses a simplified implementation that just executes the try block.\n    /// The catch block becomes unreachable code - proper error handling would require\n    /// setjmp/longjmp or landing pads for C++ exceptions.\n    fn compile_try_catch(\n        &mut self,\n        try_block: &Stmt,\n        error_name: &str,\n        catch_block: &Stmt,\n    ) -> Result<(), HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Create blocks for try, catch, and after\n        let try_body = self.context.append_basic_block(function, \"try_body\");\n        let catch_body = self.context.append_basic_block(function, \"catch_body\");\n        let try_after = self.context.append_basic_block(function, \"try_after\");\n\n        // For now, we'll execute the try block directly and skip catch\n        // A proper implementation would use setjmp here\n        self.builder.build_unconditional_branch(try_body).unwrap();\n\n        // Compile try block\n        self.builder.position_at_end(try_body);\n\n        // Compile the try block statements\n        if let Stmt::Block { statements, .. } = try_block {\n            for stmt in statements {\n                self.compile_stmt(stmt)?;\n            }\n        } else {\n            self.compile_stmt(try_block)?;\n        }\n\n        // If we get here (no error), skip catch and go to after\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder.build_unconditional_branch(try_after).unwrap();\n        }\n\n        // Compile catch block (will be unreachable for now, but we need valid IR)\n        self.builder.position_at_end(catch_body);\n\n        // Create error variable with a placeholder value\n        let error_alloca = self.create_entry_block_alloca(error_name);\n        let error_str_ptr = self\n            .builder\n            .build_global_string_ptr(\"No error\", \"err_msg\")\n            .unwrap();\n        let error_msg = self.make_string(error_str_ptr.as_pointer_value())?;\n        self.builder.build_store(error_alloca, error_msg).unwrap();\n        self.variables.insert(error_name.to_string(), error_alloca);\n\n        // Compile catch block statements\n        if let Stmt::Block { statements, .. } = catch_block {\n            for stmt in statements {\n                self.compile_stmt(stmt)?;\n            }\n        } else {\n            self.compile_stmt(catch_block)?;\n        }\n\n        // Jump to after\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            self.builder.build_unconditional_branch(try_after).unwrap();\n        }\n\n        // Continue after try/catch\n        self.builder.position_at_end(try_after);\n\n        Ok(())\n    }\n\n    /// Compile match statement\n    fn compile_match(&mut self, value: &Expr, arms: &[MatchArm]) -> Result<(), HaversError> {\n        let match_val = self.compile_expr(value)?;\n\n        let function = self.current_function.unwrap();\n        let end_block = self.context.append_basic_block(function, \"match_end\");\n\n        // For each arm, create a test block and body block\n        let mut arm_blocks: Vec<(BasicBlock<'ctx>, BasicBlock<'ctx>)> = Vec::new();\n        for i in 0..arms.len() {\n            let test_block = self\n                .context\n                .append_basic_block(function, &format!(\"match_test_{}\", i));\n            let body_block = self\n                .context\n                .append_basic_block(function, &format!(\"match_body_{}\", i));\n            arm_blocks.push((test_block, body_block));\n        }\n\n        // Jump to first arm test\n        if !arm_blocks.is_empty() {\n            self.builder\n                .build_unconditional_branch(arm_blocks[0].0)\n                .unwrap();\n        } else {\n            self.builder.build_unconditional_branch(end_block).unwrap();\n        }\n\n        // Compile each arm\n        for (i, arm) in arms.iter().enumerate() {\n            let (test_block, body_block) = arm_blocks[i];\n            let next_test = if i + 1 < arm_blocks.len() {\n                arm_blocks[i + 1].0\n            } else {\n                end_block\n            };\n\n            // Test block\n            self.builder.position_at_end(test_block);\n            let matches = self.compile_pattern_test(match_val, &arm.pattern)?;\n\n            self.builder\n                .build_conditional_branch(matches, body_block, next_test)\n                .unwrap();\n\n            // Body block\n            self.builder.position_at_end(body_block);\n\n            // Bind pattern variables if needed\n            if let Pattern::Identifier(name) = &arm.pattern {\n                let alloca = self.create_entry_block_alloca(name);\n                self.builder.build_store(alloca, match_val).unwrap();\n                self.variables.insert(name.clone(), alloca);\n            }\n\n            // Compile body\n            self.compile_stmt(&arm.body)?;\n\n            // Jump to end if block doesn't have a terminator\n            if self\n                .builder\n                .get_insert_block()\n                .unwrap()\n                .get_terminator()\n                .is_none()\n            {\n                self.builder.build_unconditional_branch(end_block).unwrap();\n            }\n        }\n\n        self.builder.position_at_end(end_block);\n        Ok(())\n    }\n\n    /// Compile a pattern test - returns i1 (bool) indicating if pattern matches\n    fn compile_pattern_test(\n        &mut self,\n        value: BasicValueEnum<'ctx>,\n        pattern: &Pattern,\n    ) -> Result<IntValue<'ctx>, HaversError> {\n        match pattern {\n            Pattern::Wildcard => {\n                // Wildcard always matches\n                Ok(self.context.bool_type().const_int(1, false))\n            }\n            Pattern::Identifier(_) => {\n                // Identifier always matches (and binds)\n                Ok(self.context.bool_type().const_int(1, false))\n            }\n            Pattern::Literal(lit) => {\n                // Compare value to literal\n                let lit_val = self.compile_literal(lit)?;\n                self.inline_eq_raw(value, lit_val)\n            }\n            Pattern::Range { start, end } => {\n                // Check if value is in range [start, end)\n                let start_val = self.compile_expr(start)?;\n                let end_val = self.compile_expr(end)?;\n\n                let ge_start = self.inline_ge_raw(value, start_val)?;\n                let lt_end = self.inline_lt_raw(value, end_val)?;\n\n                Ok(self\n                    .builder\n                    .build_and(ge_start, lt_end, \"in_range\")\n                    .unwrap())\n            }\n        }\n    }\n\n    /// Compile destructure statement: ken [a, b, c] = list\n    fn compile_destructure(\n        &mut self,\n        patterns: &[DestructPattern],\n        value: &Expr,\n    ) -> Result<(), HaversError> {\n        let list_val = self.compile_expr(value)?;\n\n        // Get list pointer and length\n        let list_data = self.extract_data(list_val)?;\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr, \"list_ptr\")\n            .unwrap();\n\n        // Get list length\n        let len_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, len_ptr_type, \"len_ptr\")\n            .unwrap();\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Find rest pattern and count patterns before/after it\n        let mut rest_index = None;\n        let mut patterns_after_rest = 0;\n        for (i, pattern) in patterns.iter().enumerate() {\n            if let DestructPattern::Rest(_) = pattern {\n                rest_index = Some(i);\n                patterns_after_rest = patterns.len() - i - 1;\n                break;\n            }\n        }\n\n        // Process patterns\n        let mut index = 0u64;\n        for (i, pattern) in patterns.iter().enumerate() {\n            match pattern {\n                DestructPattern::Variable(name) => {\n                    if rest_index.is_some() && i > rest_index.unwrap() {\n                        // This pattern is after the rest - index from end\n                        let offset_from_end = patterns.len() - i;\n                        let offset_val =\n                            self.types.i64_type.const_int(offset_from_end as u64, false);\n                        let actual_index = self\n                            .builder\n                            .build_int_sub(list_len, offset_val, \"end_idx\")\n                            .unwrap();\n                        let elem = self.compile_list_index_dynamic(list_ptr, actual_index)?;\n                        let alloca = self.create_entry_block_alloca(name);\n                        self.builder.build_store(alloca, elem).unwrap();\n                        self.variables.insert(name.clone(), alloca);\n                    } else {\n                        // Normal forward indexing\n                        let elem = self.compile_list_index_ptr(list_ptr, index)?;\n                        let alloca = self.create_entry_block_alloca(name);\n                        self.builder.build_store(alloca, elem).unwrap();\n                        self.variables.insert(name.clone(), alloca);\n                        index += 1;\n                    }\n                }\n                DestructPattern::Ignore => {\n                    if rest_index.is_none() || i < rest_index.unwrap() {\n                        index += 1;\n                    }\n                }\n                DestructPattern::Rest(name) => {\n                    // Calculate slice end: list_len - patterns_after_rest\n                    let end_offset = self\n                        .types\n                        .i64_type\n                        .const_int(patterns_after_rest as u64, false);\n                    let slice_end = self\n                        .builder\n                        .build_int_sub(list_len, end_offset, \"slice_end\")\n                        .unwrap();\n                    let start_idx = self.types.i64_type.const_int(index, false);\n                    let rest_list =\n                        self.compile_list_slice_dynamic(list_ptr, start_idx, slice_end)?;\n                    let alloca = self.create_entry_block_alloca(name);\n                    self.builder.build_store(alloca, rest_list).unwrap();\n                    self.variables.insert(name.clone(), alloca);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Extract element from list at given dynamic index\n    fn compile_list_index_dynamic(\n        &mut self,\n        list_ptr: PointerValue<'ctx>,\n        index: inkwell::values::IntValue<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List structure: [len: i64][cap: i64][elem0][elem1]...\n        // Each element is a MdhValue (16 bytes)\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let data_offset = self\n            .builder\n            .build_int_mul(index, elem_size, \"data_offset\")\n            .unwrap();\n        let total_offset = self\n            .builder\n            .build_int_add(header_size, data_offset, \"total_offset\")\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    list_ptr,\n                    &[total_offset],\n                    \"elem_ptr\",\n                )\n                .unwrap()\n        };\n\n        // Cast to value type pointer and load\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(elem_ptr, value_ptr_type, \"value_ptr\")\n            .unwrap();\n        let value = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        Ok(value)\n    }\n\n    /// Create a slice of list from start_index to end_index (exclusive)\n    fn compile_list_slice_dynamic(\n        &mut self,\n        list_ptr: PointerValue<'ctx>,\n        start_index: inkwell::values::IntValue<'ctx>,\n        end_index: inkwell::values::IntValue<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Calculate slice length\n        let slice_len = self\n            .builder\n            .build_int_sub(end_index, start_index, \"slice_len\")\n            .unwrap();\n\n        // Allocate new list\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let data_size = self\n            .builder\n            .build_int_mul(slice_len, elem_size, \"data_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, data_size, \"total_size\")\n            .unwrap();\n\n        let new_list = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length and capacity\n        let len_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(new_list, len_ptr_type, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(len_ptr, slice_len).unwrap();\n\n        let one = self.types.i64_type.const_int(1, false);\n        let cap_ptr = unsafe {\n            self.builder\n                .build_gep(self.types.i64_type, len_ptr, &[one], \"cap_ptr\")\n        }\n        .unwrap();\n        self.builder.build_store(cap_ptr, slice_len).unwrap();\n\n        // Copy elements using memcpy\n        let elem_start_offset = self\n            .builder\n            .build_int_mul(start_index, elem_size, \"elem_start_offset\")\n            .unwrap();\n        let src_offset = self\n            .builder\n            .build_int_add(header_size, elem_start_offset, \"src_offset\")\n            .unwrap();\n        let src_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[src_offset], \"src_ptr\")\n        }\n        .unwrap();\n        let dst_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_list, &[header_size], \"dst_ptr\")\n        }\n        .unwrap();\n        self.builder\n            .build_memcpy(dst_ptr, 8, src_ptr, 8, data_size)\n            .unwrap();\n\n        // Return as MdhValue\n        let list_as_int = self\n            .builder\n            .build_ptr_to_int(new_list, self.types.i64_type, \"list_int\")\n            .unwrap();\n        let list_tag = self\n            .types\n            .i8_type\n            .const_int(ValueTag::List.as_u8() as u64, false);\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, list_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, list_as_int, 1, \"v2\")\n            .unwrap();\n        Ok(v2.into_struct_value().into())\n    }\n\n    /// Extract element from list at given index\n    fn compile_list_index_ptr(\n        &mut self,\n        list_ptr: PointerValue<'ctx>,\n        index: u64,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // List structure: [len: i64][cap: i64][elem0][elem1]...\n        // Each element is a MdhValue (16 bytes)\n\n        let elem_offset = 16 + (index * 16); // Skip header, then index\n        let offset = self.types.i64_type.const_int(elem_offset, false);\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[offset], \"elem_ptr\")\n                .unwrap()\n        };\n\n        // Cast to value type pointer and load\n        let value_ptr_type = self.types.value_type.ptr_type(AddressSpace::default());\n        let value_ptr = self\n            .builder\n            .build_pointer_cast(elem_ptr, value_ptr_type, \"value_ptr\")\n            .unwrap();\n        let value = self\n            .builder\n            .build_load(self.types.value_type, value_ptr, \"elem_val\")\n            .unwrap();\n\n        Ok(value)\n    }\n\n    /// Create a slice of list from index onwards\n    fn compile_list_slice(\n        &mut self,\n        list_ptr: PointerValue<'ctx>,\n        start_index: u64,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Get list length\n        let len_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, len_ptr_type, \"len_ptr\")\n            .unwrap();\n        let total_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"total_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Calculate slice length\n        let start = self.types.i64_type.const_int(start_index, false);\n        let slice_len = self\n            .builder\n            .build_int_sub(total_len, start, \"slice_len\")\n            .unwrap();\n\n        // Allocate new list\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let data_size = self\n            .builder\n            .build_int_mul(slice_len, elem_size, \"data_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, data_size, \"total_size\")\n            .unwrap();\n\n        let new_list = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length and capacity\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_list, len_ptr_type, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(new_len_ptr, slice_len).unwrap();\n\n        let cap_offset = self.types.i64_type.const_int(8, false);\n        let cap_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_list, &[cap_offset], \"cap_ptr\")\n                .unwrap()\n        };\n        let cap_ptr = self\n            .builder\n            .build_pointer_cast(cap_ptr, len_ptr_type, \"cap_ptr_typed\")\n            .unwrap();\n        self.builder.build_store(cap_ptr, slice_len).unwrap();\n\n        // Copy elements\n        let src_offset = self.types.i64_type.const_int(16 + start_index * 16, false);\n        let src_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[src_offset], \"src_ptr\")\n                .unwrap()\n        };\n        let dst_offset = self.types.i64_type.const_int(16, false);\n        let dst_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_list, &[dst_offset], \"dst_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst_ptr.into(), src_ptr.into(), data_size.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Create MdhValue for list\n        self.make_list(new_list)\n    }\n\n    /// Compile property get expression: obj.property\n    fn compile_get(\n        &mut self,\n        object: &Expr,\n        property: &str,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let obj_val = self.compile_expr(object)?;\n        self.compile_instance_get_field(obj_val, property)\n    }\n\n    /// Compile property set expression: obj.property = value\n    fn compile_set(\n        &mut self,\n        object: &Expr,\n        property: &str,\n        value: &Expr,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let obj_val = self.compile_expr(object)?;\n        let val = self.compile_expr(value)?;\n        self.compile_instance_set_field(obj_val, property, val)\n    }\n\n    /// Get a field from an instance\n    /// Instance layout: [i64 class_name_ptr][i64 field_count][field_entry0][field_entry1]...\n    /// where field_entry = [{i8,i64} key (string)][{i8,i64} value]\n    fn compile_instance_get_field(\n        &mut self,\n        instance_val: BasicValueEnum<'ctx>,\n        field_name: &str,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract instance data pointer\n        let instance_struct = instance_val.into_struct_value();\n        let instance_data = self\n            .builder\n            .build_extract_value(instance_struct, 1, \"instance_data\")\n            .unwrap()\n            .into_int_value();\n\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let instance_ptr = self\n            .builder\n            .build_int_to_ptr(instance_data, i8_ptr_type, \"instance_ptr\")\n            .unwrap();\n\n        // Skip class name pointer (8 bytes) to get to field count\n        let field_count_offset = self.types.i64_type.const_int(8, false);\n        let field_count_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[field_count_offset],\n                    \"field_count_ptr\",\n                )\n                .unwrap()\n        };\n        let field_count_i64_ptr = self\n            .builder\n            .build_pointer_cast(field_count_ptr, i64_ptr_type, \"field_count_i64\")\n            .unwrap();\n        let field_count = self\n            .builder\n            .build_load(self.types.i64_type, field_count_i64_ptr, \"field_count\")\n            .unwrap()\n            .into_int_value();\n\n        // Create field name as a global string for comparison\n        let field_name_global = self\n            .builder\n            .build_global_string_ptr(field_name, \"field_name\")\n            .unwrap();\n\n        // Loop through fields to find matching name\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let header_size = self.types.i64_type.const_int(16, false); // class_name_ptr + field_count\n        let entry_size = self.types.i64_type.const_int(32, false); // 16 bytes key + 16 bytes value\n        let value_offset_in_entry = self.types.i64_type.const_int(16, false);\n\n        let result_ptr = self\n            .builder\n            .build_alloca(self.types.value_type, \"result_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(result_ptr, self.make_nil())\n            .unwrap();\n\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"get_field_loop\");\n        let body_block = self.context.append_basic_block(function, \"get_field_body\");\n        let found_block = self.context.append_basic_block(function, \"get_field_found\");\n        let continue_block = self\n            .context\n            .append_basic_block(function, \"get_field_continue\");\n        let done_block = self.context.append_basic_block(function, \"get_field_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, field_count, \"done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, done_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get entry key (string value)\n        let entry_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, entry_size, \"entry_mul\")\n                    .unwrap(),\n                \"entry_offset\",\n            )\n            .unwrap();\n        let entry_key_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[entry_offset],\n                    \"entry_key_ptr\",\n                )\n                .unwrap()\n        };\n        let key_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                entry_key_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"key_value_ptr\",\n            )\n            .unwrap();\n        let entry_key = self\n            .builder\n            .build_load(self.types.value_type, key_value_ptr, \"entry_key\")\n            .unwrap();\n\n        // Extract string pointer from key and compare with field name\n        let entry_key_data = self\n            .builder\n            .build_extract_value(entry_key.into_struct_value(), 1, \"key_data\")\n            .unwrap()\n            .into_int_value();\n        let entry_key_str = self\n            .builder\n            .build_int_to_ptr(entry_key_data, i8_ptr_type, \"key_str\")\n            .unwrap();\n\n        // Use strstr to check if strings match (simple equality check)\n        let cmp_result = self\n            .builder\n            .build_call(\n                self.libc.strstr,\n                &[\n                    entry_key_str.into(),\n                    field_name_global.as_pointer_value().into(),\n                ],\n                \"cmp_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Check if strstr returned the start of the string (exact match at beginning)\n        let cmp_eq = self\n            .builder\n            .build_int_compare(\n                IntPredicate::EQ,\n                self.builder\n                    .build_ptr_to_int(cmp_result, self.types.i64_type, \"cmp_int\")\n                    .unwrap(),\n                self.builder\n                    .build_ptr_to_int(entry_key_str, self.types.i64_type, \"key_int\")\n                    .unwrap(),\n                \"cmp_eq\",\n            )\n            .unwrap();\n\n        // Also check string lengths are equal\n        let field_name_len = self\n            .builder\n            .build_call(\n                self.libc.strlen,\n                &[field_name_global.as_pointer_value().into()],\n                \"field_len\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let entry_key_len = self\n            .builder\n            .build_call(self.libc.strlen, &[entry_key_str.into()], \"key_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let len_eq = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, field_name_len, entry_key_len, \"len_eq\")\n            .unwrap();\n\n        let keys_match = self\n            .builder\n            .build_and(cmp_eq, len_eq, \"keys_match\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(keys_match, found_block, continue_block)\n            .unwrap();\n\n        // Found - get the value\n        self.builder.position_at_end(found_block);\n        let value_offset = self\n            .builder\n            .build_int_add(entry_offset, value_offset_in_entry, \"value_offset\")\n            .unwrap();\n        let value_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[value_offset],\n                    \"value_ptr\",\n                )\n                .unwrap()\n        };\n        let value_typed_ptr = self\n            .builder\n            .build_pointer_cast(\n                value_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_typed_ptr\",\n            )\n            .unwrap();\n        let found_val = self\n            .builder\n            .build_load(self.types.value_type, value_typed_ptr, \"found_val\")\n            .unwrap();\n        self.builder.build_store(result_ptr, found_val).unwrap();\n        self.builder.build_unconditional_branch(done_block).unwrap();\n\n        // Continue loop\n        self.builder.position_at_end(continue_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Done\n        self.builder.position_at_end(done_block);\n        let result = self\n            .builder\n            .build_load(self.types.value_type, result_ptr, \"get_result\")\n            .unwrap();\n        Ok(result)\n    }\n\n    /// Set a field on an instance (add or update)\n    /// This is complex because we may need to grow the instance if adding a new field\n    fn compile_instance_set_field(\n        &mut self,\n        instance_val: BasicValueEnum<'ctx>,\n        field_name: &str,\n        value: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let function = self.current_function.unwrap();\n\n        // Extract instance data pointer\n        let instance_struct = instance_val.into_struct_value();\n        let instance_data = self\n            .builder\n            .build_extract_value(instance_struct, 1, \"instance_data\")\n            .unwrap()\n            .into_int_value();\n\n        let i8_ptr_type = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n        let instance_ptr = self\n            .builder\n            .build_int_to_ptr(instance_data, i8_ptr_type, \"instance_ptr\")\n            .unwrap();\n\n        // Get field count\n        let field_count_offset = self.types.i64_type.const_int(8, false);\n        let field_count_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[field_count_offset],\n                    \"field_count_ptr\",\n                )\n                .unwrap()\n        };\n        let field_count_i64_ptr = self\n            .builder\n            .build_pointer_cast(field_count_ptr, i64_ptr_type, \"field_count_i64\")\n            .unwrap();\n        let field_count = self\n            .builder\n            .build_load(self.types.i64_type, field_count_i64_ptr, \"field_count\")\n            .unwrap()\n            .into_int_value();\n\n        // Create field name as a global string\n        let field_name_global = self\n            .builder\n            .build_global_string_ptr(field_name, \"field_name_set\")\n            .unwrap();\n\n        // Loop through fields to find existing field or add new\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n        let header_size = self.types.i64_type.const_int(16, false);\n        let entry_size = self.types.i64_type.const_int(32, false);\n        let value_offset_in_entry = self.types.i64_type.const_int(16, false);\n\n        let idx_ptr = self\n            .builder\n            .build_alloca(self.types.i64_type, \"idx\")\n            .unwrap();\n        self.builder.build_store(idx_ptr, zero).unwrap();\n\n        let found_flag = self\n            .builder\n            .build_alloca(self.types.bool_type, \"found_flag\")\n            .unwrap();\n        self.builder\n            .build_store(found_flag, self.types.bool_type.const_int(0, false))\n            .unwrap();\n\n        let loop_block = self.context.append_basic_block(function, \"set_field_loop\");\n        let body_block = self.context.append_basic_block(function, \"set_field_body\");\n        let found_block = self.context.append_basic_block(function, \"set_field_found\");\n        let continue_block = self\n            .context\n            .append_basic_block(function, \"set_field_continue\");\n        let add_block = self.context.append_basic_block(function, \"set_field_add\");\n        let done_block = self.context.append_basic_block(function, \"set_field_done\");\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n        self.builder.position_at_end(loop_block);\n\n        let idx = self\n            .builder\n            .build_load(self.types.i64_type, idx_ptr, \"idx_val\")\n            .unwrap()\n            .into_int_value();\n        let done_cond = self\n            .builder\n            .build_int_compare(IntPredicate::UGE, idx, field_count, \"loop_done\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(done_cond, add_block, body_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n\n        // Get entry key\n        let entry_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(idx, entry_size, \"entry_mul\")\n                    .unwrap(),\n                \"entry_offset\",\n            )\n            .unwrap();\n        let entry_key_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[entry_offset],\n                    \"entry_key_ptr\",\n                )\n                .unwrap()\n        };\n        let key_value_ptr = self\n            .builder\n            .build_pointer_cast(\n                entry_key_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"key_value_ptr\",\n            )\n            .unwrap();\n        let entry_key = self\n            .builder\n            .build_load(self.types.value_type, key_value_ptr, \"entry_key\")\n            .unwrap();\n\n        // Compare keys\n        let entry_key_data = self\n            .builder\n            .build_extract_value(entry_key.into_struct_value(), 1, \"key_data\")\n            .unwrap()\n            .into_int_value();\n        let entry_key_str = self\n            .builder\n            .build_int_to_ptr(entry_key_data, i8_ptr_type, \"key_str\")\n            .unwrap();\n\n        let cmp_result = self\n            .builder\n            .build_call(\n                self.libc.strstr,\n                &[\n                    entry_key_str.into(),\n                    field_name_global.as_pointer_value().into(),\n                ],\n                \"cmp_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        let cmp_eq = self\n            .builder\n            .build_int_compare(\n                IntPredicate::EQ,\n                self.builder\n                    .build_ptr_to_int(cmp_result, self.types.i64_type, \"cmp_int\")\n                    .unwrap(),\n                self.builder\n                    .build_ptr_to_int(entry_key_str, self.types.i64_type, \"key_int\")\n                    .unwrap(),\n                \"cmp_eq\",\n            )\n            .unwrap();\n\n        let field_name_len = self\n            .builder\n            .build_call(\n                self.libc.strlen,\n                &[field_name_global.as_pointer_value().into()],\n                \"field_len\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let entry_key_len = self\n            .builder\n            .build_call(self.libc.strlen, &[entry_key_str.into()], \"key_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let len_eq = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, field_name_len, entry_key_len, \"len_eq\")\n            .unwrap();\n\n        let keys_match = self\n            .builder\n            .build_and(cmp_eq, len_eq, \"keys_match\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(keys_match, found_block, continue_block)\n            .unwrap();\n\n        // Found - update the value in place\n        self.builder.position_at_end(found_block);\n        let value_offset = self\n            .builder\n            .build_int_add(entry_offset, value_offset_in_entry, \"value_offset\")\n            .unwrap();\n        let value_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[value_offset],\n                    \"value_ptr\",\n                )\n                .unwrap()\n        };\n        let value_typed_ptr = self\n            .builder\n            .build_pointer_cast(\n                value_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"value_typed_ptr\",\n            )\n            .unwrap();\n        self.builder.build_store(value_typed_ptr, value).unwrap();\n        self.builder\n            .build_store(found_flag, self.types.bool_type.const_int(1, false))\n            .unwrap();\n        self.builder.build_unconditional_branch(done_block).unwrap();\n\n        // Continue loop\n        self.builder.position_at_end(continue_block);\n        let next_idx = self.builder.build_int_add(idx, one, \"next_idx\").unwrap();\n        self.builder.build_store(idx_ptr, next_idx).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Add new field (not found) - need to realloc and add field\n        self.builder.position_at_end(add_block);\n\n        // Calculate new size: header (16) + (field_count + 1) * entry_size (32)\n        let new_count = self\n            .builder\n            .build_int_add(field_count, one, \"new_count\")\n            .unwrap();\n        let new_size = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(new_count, entry_size, \"data_size\")\n                    .unwrap(),\n                \"new_size\",\n            )\n            .unwrap();\n\n        // Realloc the instance\n        let new_ptr = self\n            .builder\n            .build_call(\n                self.libc.realloc,\n                &[instance_ptr.into(), new_size.into()],\n                \"new_instance\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Update field count\n        let new_count_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_ptr,\n                    &[field_count_offset],\n                    \"new_count_ptr\",\n                )\n                .unwrap()\n        };\n        let new_count_i64_ptr = self\n            .builder\n            .build_pointer_cast(new_count_ptr, i64_ptr_type, \"new_count_i64\")\n            .unwrap();\n        self.builder\n            .build_store(new_count_i64_ptr, new_count)\n            .unwrap();\n\n        // Add new field at end\n        let new_entry_offset = self\n            .builder\n            .build_int_add(\n                header_size,\n                self.builder\n                    .build_int_mul(field_count, entry_size, \"entry_mul\")\n                    .unwrap(),\n                \"new_entry_offset\",\n            )\n            .unwrap();\n\n        // Store key (string)\n        let new_key_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_ptr,\n                    &[new_entry_offset],\n                    \"new_key_ptr\",\n                )\n                .unwrap()\n        };\n        let new_key_typed_ptr = self\n            .builder\n            .build_pointer_cast(\n                new_key_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"new_key_typed_ptr\",\n            )\n            .unwrap();\n        // Create string key value\n        let key_str = self\n            .builder\n            .build_call(\n                self.libc.strdup,\n                &[field_name_global.as_pointer_value().into()],\n                \"key_str_dup\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        let key_val = self.make_string(key_str)?;\n        self.builder\n            .build_store(new_key_typed_ptr, key_val)\n            .unwrap();\n\n        // Store value\n        let new_value_offset = self\n            .builder\n            .build_int_add(new_entry_offset, value_offset_in_entry, \"new_value_offset\")\n            .unwrap();\n        let new_value_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_ptr,\n                    &[new_value_offset],\n                    \"new_value_ptr\",\n                )\n                .unwrap()\n        };\n        let new_value_typed_ptr = self\n            .builder\n            .build_pointer_cast(\n                new_value_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"new_value_typed_ptr\",\n            )\n            .unwrap();\n        self.builder\n            .build_store(new_value_typed_ptr, value)\n            .unwrap();\n\n        // Update the instance pointer in the masel variable if this is masel\n        // (This handles the case where realloc moved the memory)\n        if let Some(masel_ptr) = self.current_masel {\n            let new_instance = self.make_instance(new_ptr)?;\n            self.builder.build_store(masel_ptr, new_instance).unwrap();\n        }\n\n        self.builder.build_unconditional_branch(done_block).unwrap();\n\n        // Done\n        self.builder.position_at_end(done_block);\n        Ok(value)\n    }\n\n    /// Compile a class definition\n    fn compile_class(&mut self, name: &str, methods: &[Stmt]) -> Result<(), HaversError> {\n        // Save the current builder position (we're in main or another function)\n        let saved_block = self.builder.get_insert_block();\n        let saved_function = self.current_function;\n\n        // Store current class name for method naming\n        self.current_class = Some(name.to_string());\n\n        // Check if class was already pre-registered\n        let already_registered = self.classes.contains_key(name);\n\n        // First pass: declare all methods (create function signatures)\n        // This allows methods to call each other regardless of definition order\n        // Skip if already pre-registered\n        if !already_registered {\n            let mut method_list: Vec<(String, FunctionValue<'ctx>)> = Vec::new();\n            for method in methods {\n                if let Stmt::Function {\n                    name: method_name,\n                    params,\n                    ..\n                } = method\n                {\n                    let func_name = format!(\"{}_{}\", name, method_name);\n                    let param_types: Vec<BasicMetadataTypeEnum> =\n                        std::iter::once(self.types.value_type.into())\n                            .chain(params.iter().map(|_| self.types.value_type.into()))\n                            .collect();\n                    let fn_type = self.types.value_type.fn_type(&param_types, false);\n                    let function = self.module.add_function(&func_name, fn_type, None);\n                    self.functions.insert(func_name.clone(), function);\n                    method_list.push((method_name.clone(), function));\n\n                    // Store default parameter values for methods\n                    let defaults: Vec<Option<Expr>> =\n                        params.iter().map(|p| p.default.clone()).collect();\n                    if defaults.iter().any(|d| d.is_some()) {\n                        self.function_defaults.insert(func_name, defaults);\n                    }\n                }\n            }\n\n            // Store method table and class name early so methods can be looked up\n            self.class_methods\n                .insert(name.to_string(), method_list.clone());\n            let class_name_global = self\n                .builder\n                .build_global_string_ptr(name, &format!(\"class_{}\", name))\n                .unwrap();\n            self.classes.insert(name.to_string(), class_name_global);\n        }\n\n        // Second pass: define all methods (compile function bodies)\n        for method in methods {\n            if let Stmt::Function {\n                name: method_name,\n                params,\n                body,\n                ..\n            } = method\n            {\n                self.compile_method_body(name, method_name, params, body)?;\n            }\n        }\n\n        self.current_class = None;\n\n        // Restore the builder position to where we were before compiling the class\n        if let Some(block) = saved_block {\n            self.builder.position_at_end(block);\n        }\n        self.current_function = saved_function;\n\n        Ok(())\n    }\n\n    /// Compile the body of a method (function within a class)\n    /// The function signature is already declared in compile_class\n    fn compile_method_body(\n        &mut self,\n        class_name: &str,\n        method_name: &str,\n        params: &[crate::ast::Param],\n        body: &[Stmt],\n    ) -> Result<(), HaversError> {\n        // Get the already-declared function\n        let func_name = format!(\"{}_{}\", class_name, method_name);\n        let function = *self.functions.get(&func_name).ok_or_else(|| {\n            HaversError::CompileError(format!(\"Method {} not declared\", func_name))\n        })?;\n\n        // Save current state - IMPORTANT: save ALL shadow maps to prevent cross-method leakage\n        let old_function = self.current_function;\n        let old_variables = std::mem::take(&mut self.variables);\n        let old_int_shadows = std::mem::take(&mut self.int_shadows);\n        let old_list_ptr_shadows = std::mem::take(&mut self.list_ptr_shadows);\n        let old_string_len_shadows = std::mem::take(&mut self.string_len_shadows);\n        let old_string_cap_shadows = std::mem::take(&mut self.string_cap_shadows);\n        let old_var_types = std::mem::take(&mut self.var_types);\n        let old_masel = self.current_masel;\n\n        self.current_function = Some(function);\n\n        // Create entry block\n        let entry = self.context.append_basic_block(function, \"entry\");\n        self.builder.position_at_end(entry);\n\n        // First parameter is masel - allocate and store it\n        let masel_alloca = self\n            .builder\n            .build_alloca(self.types.value_type, \"masel\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca masel: {}\", e)))?;\n        let masel_param = function.get_nth_param(0).unwrap();\n        self.builder\n            .build_store(masel_alloca, masel_param)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to store masel: {}\", e)))?;\n        self.current_masel = Some(masel_alloca);\n        self.variables.insert(\"masel\".to_string(), masel_alloca);\n\n        // Bind remaining parameters\n        for (i, param) in params.iter().enumerate() {\n            let param_val = function.get_nth_param((i + 1) as u32).unwrap();\n            let alloca = self\n                .builder\n                .build_alloca(self.types.value_type, &param.name)\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to alloca param: {}\", e)))?;\n            self.builder\n                .build_store(alloca, param_val)\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to store param: {}\", e)))?;\n            self.variables.insert(param.name.clone(), alloca);\n        }\n\n        // Compile method body\n        for stmt in body {\n            self.compile_stmt(stmt)?;\n        }\n\n        // Add implicit return of masel (the possibly-modified instance) if needed\n        // This ensures that init() and other methods that modify the instance\n        // return the updated instance pointer to the caller\n        if self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_terminator()\n            .is_none()\n        {\n            // Return the current masel value (may have been reallocated)\n            let masel_val = self\n                .builder\n                .build_load(self.types.value_type, masel_alloca, \"return_masel\")\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to load masel: {}\", e)))?;\n            self.builder\n                .build_return(Some(&masel_val))\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to build return: {}\", e)))?;\n        }\n\n        // Restore state - IMPORTANT: restore ALL shadow maps to prevent cross-method leakage\n        self.current_function = old_function;\n        self.variables = old_variables;\n        self.int_shadows = old_int_shadows;\n        self.list_ptr_shadows = old_list_ptr_shadows;\n        self.string_len_shadows = old_string_len_shadows;\n        self.string_cap_shadows = old_string_cap_shadows;\n        self.var_types = old_var_types;\n        self.current_masel = old_masel;\n\n        Ok(())\n    }\n\n    /// Create a new instance of a class\n    fn compile_class_instantiation(\n        &mut self,\n        class_name: &str,\n        args: &[Expr],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Allocate instance memory: [class_name_ptr][field_count=0]\n        // Start with just header, fields will be added by init method\n        let header_size = self.types.i64_type.const_int(16, false); // class_name_ptr + field_count\n        let instance_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[header_size.into()], \"instance_alloc\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to malloc instance: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"malloc returned void\".to_string()))?\n            .into_pointer_value();\n\n        let i64_ptr_type = self.types.i64_type.ptr_type(AddressSpace::default());\n\n        // Store class name pointer\n        let class_name_global = self\n            .classes\n            .get(class_name)\n            .ok_or_else(|| HaversError::CompileError(format!(\"Unknown class: {}\", class_name)))?;\n        let class_name_ptr_slot = self\n            .builder\n            .build_pointer_cast(instance_ptr, i64_ptr_type, \"class_name_slot\")\n            .unwrap();\n        let class_name_int = self\n            .builder\n            .build_ptr_to_int(\n                class_name_global.as_pointer_value(),\n                self.types.i64_type,\n                \"class_name_int\",\n            )\n            .unwrap();\n        self.builder\n            .build_store(class_name_ptr_slot, class_name_int)\n            .unwrap();\n\n        // Store field count = 0\n        let field_count_offset = self.types.i64_type.const_int(8, false);\n        let field_count_ptr = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    instance_ptr,\n                    &[field_count_offset],\n                    \"field_count_ptr\",\n                )\n                .unwrap()\n        };\n        let field_count_i64_ptr = self\n            .builder\n            .build_pointer_cast(field_count_ptr, i64_ptr_type, \"field_count_i64\")\n            .unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        self.builder.build_store(field_count_i64_ptr, zero).unwrap();\n\n        // Create instance value\n        let instance = self.make_instance(instance_ptr)?;\n\n        // Call init method if it exists\n        let init_func_name = format!(\"{}_init\", class_name);\n        if let Some(&init_func) = self.functions.get(&init_func_name) {\n            // Compile arguments\n            let mut call_args: Vec<BasicMetadataValueEnum> = vec![instance.into()];\n            for arg in args {\n                let arg_val = self.compile_expr(arg)?;\n                call_args.push(arg_val.into());\n            }\n\n            // Fill in default parameter values if fewer args provided than expected\n            let expected_param_count = init_func.count_params() as usize;\n            if call_args.len() < expected_param_count {\n                if let Some(defaults) = self.function_defaults.get(&init_func_name).cloned() {\n                    // defaults[i] corresponds to the i-th init parameter (excluding self)\n                    let actual_args_without_self = call_args.len() - 1;\n                    for i in actual_args_without_self..(expected_param_count - 1) {\n                        if let Some(Some(ref default_expr)) = defaults.get(i) {\n                            call_args.push(self.compile_expr(default_expr)?.into());\n                        } else {\n                            call_args.push(self.make_nil().into());\n                        }\n                    }\n                } else {\n                    for _ in call_args.len()..expected_param_count {\n                        call_args.push(self.make_nil().into());\n                    }\n                }\n            }\n\n            // Call init - it may modify the instance via masel.field = value\n            // init returns the (possibly reallocated) instance, which we must use\n            let init_result = self\n                .builder\n                .build_call(init_func, &call_args, \"init_result\")\n                .map_err(|e| HaversError::CompileError(format!(\"Failed to call init: {}\", e)))?\n                .try_as_basic_value()\n                .left()\n                .ok_or_else(|| HaversError::CompileError(\"init returned void\".to_string()))?;\n            return Ok(init_result);\n        }\n\n        Ok(instance)\n    }\n\n    /// Compile a method call: obj.method(args)\n    fn compile_method_call(\n        &mut self,\n        object: &Expr,\n        method_name: &str,\n        args: &[Expr],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Compile the object (instance)\n        let instance = self.compile_expr(object)?;\n\n        // Try to find the method - track both the function and the func_name for defaults\n        let mut found_method: Option<(FunctionValue<'ctx>, String)> = None;\n\n        // If we're currently compiling a class, check if method is from current class first\n        if let Some(ref current_class) = self.current_class.clone() {\n            let func_name = format!(\"{}_{}\", current_class, method_name);\n            if let Some(&func) = self.functions.get(&func_name) {\n                found_method = Some((func, func_name));\n            }\n        }\n\n        // Check if we know the variable's class type (static type tracking)\n        if found_method.is_none() {\n            if let Expr::Variable { name: var_name, .. } = object {\n                if let Some(class_name) = self.variable_class_types.get(var_name).cloned() {\n                    let func_name = format!(\"{}_{}\", class_name, method_name);\n                    if let Some(&func) = self.functions.get(&func_name) {\n                        found_method = Some((func, func_name));\n                    }\n                }\n            }\n        }\n\n        // Fallback: Check in class_methods table (prefer methods with matching arg count)\n        // Method has masel + args, so expected_params = args.len() + 1\n        let expected_param_count = args.len() + 1;\n        if found_method.is_none() {\n            let mut best_match: Option<(FunctionValue<'ctx>, String)> = None;\n            for (class_name, methods) in self.class_methods.clone().iter() {\n                for (name, func) in methods {\n                    if name == method_name {\n                        let func_name = format!(\"{}_{}\", class_name, method_name);\n                        let func_param_count = func.count_params() as usize;\n                        // Prefer exact match\n                        if func_param_count == expected_param_count {\n                            found_method = Some((*func, func_name));\n                            break;\n                        } else if best_match.is_none() {\n                            // Keep first match as fallback\n                            best_match = Some((*func, func_name));\n                        }\n                    }\n                }\n                if found_method.is_some() {\n                    break;\n                }\n            }\n            if found_method.is_none() {\n                found_method = best_match;\n            }\n        }\n\n        // Also check directly in functions map with class prefixes (prefer matching arg count)\n        if found_method.is_none() {\n            let mut best_match: Option<(FunctionValue<'ctx>, String)> = None;\n            for class_name in self.classes.clone().keys() {\n                let func_name = format!(\"{}_{}\", class_name, method_name);\n                if let Some(&func) = self.functions.get(&func_name) {\n                    let func_param_count = func.count_params() as usize;\n                    if func_param_count == expected_param_count {\n                        found_method = Some((func, func_name));\n                        break;\n                    } else if best_match.is_none() {\n                        best_match = Some((func, func_name));\n                    }\n                }\n            }\n            if found_method.is_none() {\n                found_method = best_match;\n            }\n        }\n\n        // If no method found, try callable field pattern (e.g., masel.callback() where callback is a stored lambda)\n        if found_method.is_none() {\n            // Try to get the field value from the instance and call it\n            let field_val = self.compile_instance_get_field(instance, method_name)?;\n\n            // Build call arguments (without instance since this is a field call, not method call)\n            let mut field_call_args: Vec<BasicMetadataValueEnum> = vec![];\n            for arg in args {\n                let arg_val = self.compile_expr(arg)?;\n                field_call_args.push(arg_val.into());\n            }\n\n            // Call the field value as a function using the runtime's call mechanism\n            return self.call_callable_value(field_val, &field_call_args);\n        }\n\n        let (method_func, func_name) = found_method.ok_or_else(|| {\n            HaversError::CompileError(format!(\"Method '{}' not found\", method_name))\n        })?;\n\n        // Build call arguments: instance first, then regular args\n        let mut call_args: Vec<BasicMetadataValueEnum> = vec![instance.into()];\n        for arg in args {\n            let arg_val = self.compile_expr(arg)?;\n            call_args.push(arg_val.into());\n        }\n\n        // Fill in default parameter values if fewer args provided than expected\n        // Note: method_func has self as first param, so expected is count_params() and call_args includes instance\n        let expected_param_count = method_func.count_params() as usize;\n        if call_args.len() < expected_param_count {\n            if let Some(defaults) = self.function_defaults.get(&func_name).cloned() {\n                // defaults[i] corresponds to the i-th method parameter (excluding self)\n                // call_args[0] is instance, so call_args.len()-1 is the number of actual args\n                let actual_args_without_self = call_args.len() - 1;\n                for i in actual_args_without_self..(expected_param_count - 1) {\n                    if let Some(Some(ref default_expr)) = defaults.get(i) {\n                        call_args.push(self.compile_expr(default_expr)?.into());\n                    } else {\n                        // No default for this parameter - fill with nil\n                        call_args.push(self.make_nil().into());\n                    }\n                }\n            } else {\n                // No defaults defined - fill remaining with nil\n                for _ in call_args.len()..expected_param_count {\n                    call_args.push(self.make_nil().into());\n                }\n            }\n        }\n\n        // Call the method\n        let result = self\n            .builder\n            .build_call(method_func, &call_args, \"method_result\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call method: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap_or_else(|| self.make_nil());\n\n        Ok(result)\n    }\n\n    /// Call a value that is expected to be callable (a function/lambda stored in a field)\n    fn call_callable_value(\n        &mut self,\n        callable: BasicValueEnum<'ctx>,\n        args: &[BasicMetadataValueEnum<'ctx>],\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Extract the function pointer from the callable value (tag should be Function=9)\n        let fn_ptr_int = self.extract_data(callable)?;\n\n        // Build function type based on number of arguments\n        let param_types: Vec<BasicMetadataTypeEnum> =\n            args.iter().map(|_| self.types.value_type.into()).collect();\n        let fn_type = self.types.value_type.fn_type(&param_types, false);\n        let fn_ptr_type = fn_type.ptr_type(AddressSpace::default());\n\n        // Convert i64 to function pointer\n        let fn_ptr = self\n            .builder\n            .build_int_to_ptr(fn_ptr_int, fn_ptr_type, \"callable_fn_ptr\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to convert to fn ptr: {}\", e))\n            })?;\n\n        // Build indirect call\n        let result = self\n            .builder\n            .build_indirect_call(fn_type, fn_ptr, args, \"callable_result\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed indirect call: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .unwrap_or_else(|| self.make_nil());\n\n        Ok(result)\n    }\n\n    /// jammy(min, max) - random number between min and max (inclusive)\n    fn inline_jammy(\n        &mut self,\n        min_val: BasicValueEnum<'ctx>,\n        max_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Extract integer data from both arguments\n        let min_data = self.extract_data(min_val)?;\n        let max_data = self.extract_data(max_val)?;\n\n        // Get or declare the __mdh_random function\n        let random_fn = self\n            .module\n            .get_function(\"__mdh_random\")\n            .ok_or_else(|| HaversError::CompileError(\"__mdh_random not found\".to_string()))?;\n\n        // Call __mdh_random(min, max)\n        let result = self\n            .builder\n            .build_call(\n                random_fn,\n                &[min_data.into(), max_data.into()],\n                \"random_result\",\n            )\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call __mdh_random: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"__mdh_random returned void\".to_string()))?;\n\n        Ok(result)\n    }\n\n    /// get_key() - read a single key press from terminal\n    fn inline_get_key(&mut self) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let get_key_fn = self\n            .module\n            .get_function(\"__mdh_get_key\")\n            .ok_or_else(|| HaversError::CompileError(\"__mdh_get_key not found\".to_string()))?;\n\n        let result = self\n            .builder\n            .build_call(get_key_fn, &[], \"key_result\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to call __mdh_get_key: {}\", e)))?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| HaversError::CompileError(\"__mdh_get_key returned void\".to_string()))?;\n\n        Ok(result)\n    }\n\n    /// term_width() - get terminal width in columns\n    fn inline_term_width(&mut self) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let term_width_fn = self\n            .module\n            .get_function(\"__mdh_term_width\")\n            .ok_or_else(|| HaversError::CompileError(\"__mdh_term_width not found\".to_string()))?;\n\n        let result = self\n            .builder\n            .build_call(term_width_fn, &[], \"term_width_result\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to call __mdh_term_width: {}\", e))\n            })?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| {\n                HaversError::CompileError(\"__mdh_term_width returned void\".to_string())\n            })?;\n\n        Ok(result)\n    }\n\n    /// term_height() - get terminal height in rows\n    fn inline_term_height(&mut self) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let term_height_fn = self\n            .module\n            .get_function(\"__mdh_term_height\")\n            .ok_or_else(|| HaversError::CompileError(\"__mdh_term_height not found\".to_string()))?;\n\n        let result = self\n            .builder\n            .build_call(term_height_fn, &[], \"term_height_result\")\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to call __mdh_term_height: {}\", e))\n            })?\n            .try_as_basic_value()\n            .left()\n            .ok_or_else(|| {\n                HaversError::CompileError(\"__mdh_term_height returned void\".to_string())\n            })?;\n\n        Ok(result)\n    }\n\n    // =========================================================================\n    // Phase 1 & 2: New string/char builtins\n    // =========================================================================\n\n    /// ord(char) - Get ASCII value of first character\n    fn inline_ord(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let first_byte = self\n            .builder\n            .build_load(self.context.i8_type(), str_ptr, \"first_byte\")\n            .unwrap()\n            .into_int_value();\n        let byte_val = self\n            .builder\n            .build_int_z_extend(first_byte, self.types.i64_type, \"byte_i64\")\n            .unwrap();\n        self.make_int(byte_val)\n    }\n\n    /// chr(n) - Convert integer codepoint to single-character string\n    fn inline_chr(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n\n        // Allocate 2 bytes for single char + null terminator\n        let two = self.types.i64_type.const_int(2, false);\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[two.into()], \"chr_str\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Truncate i64 to i8 for the character\n        let char_val = self\n            .builder\n            .build_int_truncate(data, self.context.i8_type(), \"char_byte\")\n            .unwrap();\n        self.builder.build_store(new_str, char_val).unwrap();\n\n        // Add null terminator\n        let one = self.types.i64_type.const_int(1, false);\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_str, &[one], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        self.make_string(new_str)\n    }\n\n    /// char_at(str, idx) - Get character at index as single-char string\n    fn inline_char_at(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        idx_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let idx_data = self.extract_data(idx_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[idx_data], \"char_ptr\")\n                .unwrap()\n        };\n\n        // Allocate 2 bytes for single char + null terminator\n        let two = self.types.i64_type.const_int(2, false);\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[two.into()], \"char_str\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        let char_val = self\n            .builder\n            .build_load(self.context.i8_type(), char_ptr, \"char_val\")\n            .unwrap();\n        self.builder.build_store(new_str, char_val).unwrap();\n\n        let one = self.types.i64_type.const_int(1, false);\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_str, &[one], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        self.make_string(new_str)\n    }\n\n    /// chars(str) - Split string into list of single-character strings\n    fn inline_chars(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(val)?;\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n\n        // Get string length\n        let len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Allocate list: 16 bytes header + len * 16 bytes for elements\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let elem_size = self\n            .builder\n            .build_int_mul(len, sixteen, \"elem_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(sixteen, elem_size, \"total_size\")\n            .unwrap();\n        let list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"list_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length and capacity\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n            .unwrap();\n        self.builder.build_store(len_ptr, len).unwrap();\n        let eight = self.types.i64_type.const_int(8, false);\n        let cap_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[eight], \"cap_ptr\")\n                .unwrap()\n        };\n        let cap_ptr = self\n            .builder\n            .build_pointer_cast(cap_ptr, i64_ptr, \"cap_ptr_i64\")\n            .unwrap();\n        self.builder.build_store(cap_ptr, len).unwrap();\n\n        // Loop to create single-char strings\n        let function = self.current_function.unwrap();\n        let loop_block = self.context.append_basic_block(function, \"chars_loop\");\n        let body_block = self.context.append_basic_block(function, \"chars_body\");\n        let end_block = self.context.append_basic_block(function, \"chars_end\");\n\n        // Initialize counter\n        let counter_ptr = self.create_entry_block_alloca(\"chars_i\");\n        self.builder\n            .build_store(counter_ptr, self.types.i64_type.const_int(0, false))\n            .unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Loop condition\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, counter_ptr, \"i\")\n            .unwrap()\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(IntPredicate::ULT, i, len, \"cond\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond, body_block, end_block)\n            .unwrap();\n\n        // Loop body\n        self.builder.position_at_end(body_block);\n\n        // Get char at position i\n        let char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[i], \"char_ptr\")\n                .unwrap()\n        };\n        let char_val = self\n            .builder\n            .build_load(self.context.i8_type(), char_ptr, \"char_val\")\n            .unwrap();\n\n        // Allocate 2-byte string\n        let two = self.types.i64_type.const_int(2, false);\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[two.into()], \"new_char_str\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        self.builder.build_store(new_str, char_val).unwrap();\n        let one = self.types.i64_type.const_int(1, false);\n        let null_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_str, &[one], \"null_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        // Create MdhValue for the string\n        let str_int = self\n            .builder\n            .build_ptr_to_int(new_str, self.types.i64_type, \"str_int\")\n            .unwrap();\n        let string_tag = self.types.i8_type.const_int(4, false); // String tag\n        let undef = self.types.value_type.get_undef();\n        let v1 = self\n            .builder\n            .build_insert_value(undef, string_tag, 0, \"v1\")\n            .unwrap();\n        let v2 = self\n            .builder\n            .build_insert_value(v1, str_int, 1, \"v2\")\n            .unwrap();\n        let mdh_val = v2.into_struct_value();\n\n        // Store in list at position i\n        let elem_offset = self\n            .builder\n            .build_int_mul(i, sixteen, \"elem_offset\")\n            .unwrap();\n        let base_offset = self\n            .builder\n            .build_int_add(sixteen, elem_offset, \"base_offset\")\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[base_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let elem_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"elem_ptr_val\",\n            )\n            .unwrap();\n        self.builder.build_store(elem_ptr, mdh_val).unwrap();\n\n        // Increment counter\n        let next_i = self\n            .builder\n            .build_int_add(i, self.types.i64_type.const_int(1, false), \"next_i\")\n            .unwrap();\n        self.builder.build_store(counter_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // End\n        self.builder.position_at_end(end_block);\n        self.make_list(list_ptr)\n    }\n\n    /// repeat(str, n) - Repeat string n times\n    fn inline_repeat(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        count_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let count = self.extract_data(count_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n\n        // Get string length\n        let str_len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Calculate total size: str_len * count + 1\n        let total_len = self\n            .builder\n            .build_int_mul(str_len, count, \"total_len\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(\n                total_len,\n                self.types.i64_type.const_int(1, false),\n                \"total_size\",\n            )\n            .unwrap();\n\n        // Allocate result\n        let result_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"result_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Initialize result with null terminator\n        self.builder\n            .build_store(result_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        // Loop to concatenate\n        let function = self.current_function.unwrap();\n        let loop_block = self.context.append_basic_block(function, \"repeat_loop\");\n        let body_block = self.context.append_basic_block(function, \"repeat_body\");\n        let end_block = self.context.append_basic_block(function, \"repeat_end\");\n\n        let counter_ptr = self.create_entry_block_alloca(\"repeat_i\");\n        self.builder\n            .build_store(counter_ptr, self.types.i64_type.const_int(0, false))\n            .unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(loop_block);\n        let i = self\n            .builder\n            .build_load(self.types.i64_type, counter_ptr, \"i\")\n            .unwrap()\n            .into_int_value();\n        let cond = self\n            .builder\n            .build_int_compare(IntPredicate::ULT, i, count, \"cond\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(cond, body_block, end_block)\n            .unwrap();\n\n        self.builder.position_at_end(body_block);\n        self.builder\n            .build_call(self.libc.strcat, &[result_ptr.into(), str_ptr.into()], \"\")\n            .unwrap();\n        let next_i = self\n            .builder\n            .build_int_add(i, self.types.i64_type.const_int(1, false), \"next_i\")\n            .unwrap();\n        self.builder.build_store(counter_ptr, next_i).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        self.builder.position_at_end(end_block);\n        self.make_string(result_ptr)\n    }\n\n    /// index_of(str, substr) - Find first index of substring, or -1 if not found\n    fn inline_index_of(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        substr_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let substr_data = self.extract_data(substr_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let substr_ptr = self\n            .builder\n            .build_int_to_ptr(substr_data, i8_ptr, \"substr_ptr\")\n            .unwrap();\n\n        // Use strstr to find substring\n        let found_ptr = self\n            .builder\n            .build_call(\n                self.libc.strstr,\n                &[str_ptr.into(), substr_ptr.into()],\n                \"found_ptr\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Check if found (not null)\n        let null_ptr = i8_ptr.const_null();\n        let is_null = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, found_ptr, null_ptr, \"is_null\")\n            .unwrap();\n\n        let function = self.current_function.unwrap();\n        let found_block = self.context.append_basic_block(function, \"index_found\");\n        let not_found_block = self.context.append_basic_block(function, \"index_not_found\");\n        let merge_block = self.context.append_basic_block(function, \"index_merge\");\n\n        self.builder\n            .build_conditional_branch(is_null, not_found_block, found_block)\n            .unwrap();\n\n        // Found: calculate index\n        self.builder.position_at_end(found_block);\n        let str_int = self\n            .builder\n            .build_ptr_to_int(str_ptr, self.types.i64_type, \"str_int\")\n            .unwrap();\n        let found_int = self\n            .builder\n            .build_ptr_to_int(found_ptr, self.types.i64_type, \"found_int\")\n            .unwrap();\n        let index = self\n            .builder\n            .build_int_sub(found_int, str_int, \"index\")\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let found_block_end = self.builder.get_insert_block().unwrap();\n\n        // Not found: return -1\n        self.builder.position_at_end(not_found_block);\n        let neg_one = self.types.i64_type.const_int((-1i64) as u64, true);\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let not_found_block_end = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.types.i64_type, \"index_result\")\n            .unwrap();\n        phi.add_incoming(&[(&index, found_block_end), (&neg_one, not_found_block_end)]);\n\n        self.make_int(phi.as_basic_value().into_int_value())\n    }\n\n    /// replace(str, old, new) - Replace all occurrences of old with new\n    fn inline_replace(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        old_val: BasicValueEnum<'ctx>,\n        new_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        // Simple implementation: find first occurrence, replace, repeat\n        // For now, implement single replacement and suggest iteration for all\n        let str_data = self.extract_data(str_val)?;\n        let old_data = self.extract_data(old_val)?;\n        let new_data = self.extract_data(new_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let old_ptr = self\n            .builder\n            .build_int_to_ptr(old_data, i8_ptr, \"old_ptr\")\n            .unwrap();\n        let new_ptr = self\n            .builder\n            .build_int_to_ptr(new_data, i8_ptr, \"new_ptr\")\n            .unwrap();\n\n        // Get lengths\n        let str_len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let old_len = self\n            .builder\n            .build_call(self.libc.strlen, &[old_ptr.into()], \"old_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let new_len = self\n            .builder\n            .build_call(self.libc.strlen, &[new_ptr.into()], \"new_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Allocate generous buffer (str_len * 2 + new_len + 1 should be enough for most cases)\n        let double_len = self\n            .builder\n            .build_int_mul(\n                str_len,\n                self.types.i64_type.const_int(2, false),\n                \"double_len\",\n            )\n            .unwrap();\n        let buffer_size = self\n            .builder\n            .build_int_add(double_len, new_len, \"buf_size1\")\n            .unwrap();\n        let buffer_size = self\n            .builder\n            .build_int_add(\n                buffer_size,\n                self.types.i64_type.const_int(1, false),\n                \"buf_size\",\n            )\n            .unwrap();\n\n        let result_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[buffer_size.into()], \"result_ptr\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Initialize empty string\n        self.builder\n            .build_store(result_ptr, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        // Copy and replace loop\n        let function = self.current_function.unwrap();\n        let loop_block = self.context.append_basic_block(function, \"replace_loop\");\n        let check_block = self.context.append_basic_block(function, \"replace_check\");\n        let match_block = self.context.append_basic_block(function, \"replace_match\");\n        let no_match_block = self\n            .context\n            .append_basic_block(function, \"replace_no_match\");\n        let end_block = self.context.append_basic_block(function, \"replace_end\");\n\n        // Current position in source\n        let pos_ptr = self.create_entry_block_alloca(\"replace_pos\");\n        self.builder.build_store(pos_ptr, str_ptr).unwrap();\n\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // Loop: check if we're at end of string\n        self.builder.position_at_end(loop_block);\n        let current_pos = self\n            .builder\n            .build_load(i8_ptr, pos_ptr, \"current_pos\")\n            .unwrap()\n            .into_pointer_value();\n        let current_char = self\n            .builder\n            .build_load(self.context.i8_type(), current_pos, \"current_char\")\n            .unwrap()\n            .into_int_value();\n        let is_end = self\n            .builder\n            .build_int_compare(\n                IntPredicate::EQ,\n                current_char,\n                self.context.i8_type().const_int(0, false),\n                \"is_end\",\n            )\n            .unwrap();\n        self.builder\n            .build_conditional_branch(is_end, end_block, check_block)\n            .unwrap();\n\n        // Check if current position matches old string\n        self.builder.position_at_end(check_block);\n        let cmp_result = self\n            .builder\n            .build_call(\n                self.libc.strstr,\n                &[current_pos.into(), old_ptr.into()],\n                \"cmp_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Check if match is at current position\n        let match_at_pos = self\n            .builder\n            .build_int_compare(IntPredicate::EQ, cmp_result, current_pos, \"match_at_pos\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(match_at_pos, match_block, no_match_block)\n            .unwrap();\n\n        // Match found: append new string, advance by old_len\n        self.builder.position_at_end(match_block);\n        self.builder\n            .build_call(self.libc.strcat, &[result_ptr.into(), new_ptr.into()], \"\")\n            .unwrap();\n        let next_pos = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), current_pos, &[old_len], \"next_pos\")\n                .unwrap()\n        };\n        self.builder.build_store(pos_ptr, next_pos).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // No match: append single char, advance by 1\n        self.builder.position_at_end(no_match_block);\n        // Create single-char string to append\n        let char_buf = self\n            .builder\n            .build_alloca(self.context.i8_type().array_type(2), \"char_buf\")\n            .unwrap();\n        let char_ptr_0 = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type().array_type(2),\n                    char_buf,\n                    &[\n                        self.types.i64_type.const_int(0, false),\n                        self.types.i64_type.const_int(0, false),\n                    ],\n                    \"char_ptr_0\",\n                )\n                .unwrap()\n        };\n        self.builder.build_store(char_ptr_0, current_char).unwrap();\n        let char_ptr_1 = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type().array_type(2),\n                    char_buf,\n                    &[\n                        self.types.i64_type.const_int(0, false),\n                        self.types.i64_type.const_int(1, false),\n                    ],\n                    \"char_ptr_1\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_store(char_ptr_1, self.context.i8_type().const_int(0, false))\n            .unwrap();\n\n        let char_buf_ptr = self\n            .builder\n            .build_pointer_cast(char_buf, i8_ptr, \"char_buf_ptr\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.strcat,\n                &[result_ptr.into(), char_buf_ptr.into()],\n                \"\",\n            )\n            .unwrap();\n\n        let one = self.types.i64_type.const_int(1, false);\n        let next_pos = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), current_pos, &[one], \"next_pos_1\")\n                .unwrap()\n        };\n        self.builder.build_store(pos_ptr, next_pos).unwrap();\n        self.builder.build_unconditional_branch(loop_block).unwrap();\n\n        // End\n        self.builder.position_at_end(end_block);\n        self.make_string(result_ptr)\n    }\n\n    /// starts_wi(str, prefix) - Check if string starts with prefix\n    fn inline_starts_wi(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        prefix_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let prefix_data = self.extract_data(prefix_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let prefix_ptr = self\n            .builder\n            .build_int_to_ptr(prefix_data, i8_ptr, \"prefix_ptr\")\n            .unwrap();\n\n        // Get prefix length\n        let prefix_len = self\n            .builder\n            .build_call(self.libc.strlen, &[prefix_ptr.into()], \"prefix_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Use strncmp to compare first prefix_len chars\n        // strncmp returns 0 if equal\n        // We need to declare strncmp\n        let strncmp = self.module.get_function(\"strncmp\").unwrap_or_else(|| {\n            let strncmp_type = self.context.i32_type().fn_type(\n                &[i8_ptr.into(), i8_ptr.into(), self.types.i64_type.into()],\n                false,\n            );\n            self.module.add_function(\n                \"strncmp\",\n                strncmp_type,\n                Some(inkwell::module::Linkage::External),\n            )\n        });\n\n        let cmp_result = self\n            .builder\n            .build_call(\n                strncmp,\n                &[str_ptr.into(), prefix_ptr.into(), prefix_len.into()],\n                \"cmp_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        let is_equal = self\n            .builder\n            .build_int_compare(\n                IntPredicate::EQ,\n                cmp_result,\n                self.context.i32_type().const_int(0, false),\n                \"is_equal\",\n            )\n            .unwrap();\n\n        self.make_bool(is_equal)\n    }\n\n    /// ends_wi(str, suffix) - Check if string ends with suffix\n    fn inline_ends_wi(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        suffix_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let suffix_data = self.extract_data(suffix_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let suffix_ptr = self\n            .builder\n            .build_int_to_ptr(suffix_data, i8_ptr, \"suffix_ptr\")\n            .unwrap();\n\n        // Get lengths\n        let str_len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let suffix_len = self\n            .builder\n            .build_call(self.libc.strlen, &[suffix_ptr.into()], \"suffix_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // If suffix longer than string, return false\n        let suffix_longer = self\n            .builder\n            .build_int_compare(IntPredicate::UGT, suffix_len, str_len, \"suffix_longer\")\n            .unwrap();\n\n        let function = self.current_function.unwrap();\n        let check_block = self.context.append_basic_block(function, \"ends_check\");\n        let false_block = self.context.append_basic_block(function, \"ends_false\");\n        let merge_block = self.context.append_basic_block(function, \"ends_merge\");\n\n        self.builder\n            .build_conditional_branch(suffix_longer, false_block, check_block)\n            .unwrap();\n\n        // Check ending\n        self.builder.position_at_end(check_block);\n        // Get pointer to where suffix should start: str_ptr + (str_len - suffix_len)\n        let offset = self\n            .builder\n            .build_int_sub(str_len, suffix_len, \"offset\")\n            .unwrap();\n        let end_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr, &[offset], \"end_ptr\")\n                .unwrap()\n        };\n\n        // Compare using strcmp\n        let cmp_result = self\n            .builder\n            .build_call(\n                self.libc.strcmp,\n                &[end_ptr.into(), suffix_ptr.into()],\n                \"cmp_result\",\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        let is_equal = self\n            .builder\n            .build_int_compare(\n                IntPredicate::EQ,\n                cmp_result,\n                self.context.i32_type().const_int(0, false),\n                \"is_equal\",\n            )\n            .unwrap();\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let check_block_end = self.builder.get_insert_block().unwrap();\n\n        // False block\n        self.builder.position_at_end(false_block);\n        let false_val = self.context.bool_type().const_int(0, false);\n        self.builder\n            .build_unconditional_branch(merge_block)\n            .unwrap();\n        let false_block_end = self.builder.get_insert_block().unwrap();\n\n        // Merge\n        self.builder.position_at_end(merge_block);\n        let phi = self\n            .builder\n            .build_phi(self.context.bool_type(), \"ends_result\")\n            .unwrap();\n        phi.add_incoming(&[(&is_equal, check_block_end), (&false_val, false_block_end)]);\n\n        self.make_bool(phi.as_basic_value().into_int_value())\n    }\n\n    /// Math function wrapper (sin, cos, tan, sqrt)\n    fn inline_math_func(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n        func_name: &str,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n\n        // Convert to float\n        let float_val = self\n            .builder\n            .build_bitcast(data, self.context.f64_type(), \"float_val\")\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to bitcast: {}\", e)))?\n            .into_float_value();\n\n        // Get or declare the math function\n        let f64_type = self.context.f64_type();\n        let math_fn = self.module.get_function(func_name).unwrap_or_else(|| {\n            let fn_type = f64_type.fn_type(&[f64_type.into()], false);\n            self.module\n                .add_function(func_name, fn_type, Some(inkwell::module::Linkage::External))\n        });\n\n        // Call the function\n        let result = self\n            .builder\n            .build_call(\n                math_fn,\n                &[float_val.into()],\n                &format!(\"{}_result\", func_name),\n            )\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        self.make_float(result)\n    }\n\n    /// pow(base, exp) - power function\n    fn inline_pow(\n        &mut self,\n        base_val: BasicValueEnum<'ctx>,\n        exp_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let base_data = self.extract_data(base_val)?;\n        let exp_data = self.extract_data(exp_val)?;\n\n        // Convert to floats\n        let f64_type = self.context.f64_type();\n        let base_float = self\n            .builder\n            .build_bitcast(base_data, f64_type, \"base_float\")\n            .unwrap()\n            .into_float_value();\n        let exp_float = self\n            .builder\n            .build_bitcast(exp_data, f64_type, \"exp_float\")\n            .unwrap()\n            .into_float_value();\n\n        // Get or declare pow function\n        let pow_fn = self.module.get_function(\"pow\").unwrap_or_else(|| {\n            let fn_type = f64_type.fn_type(&[f64_type.into(), f64_type.into()], false);\n            self.module\n                .add_function(\"pow\", fn_type, Some(inkwell::module::Linkage::External))\n        });\n\n        let result = self\n            .builder\n            .build_call(pow_fn, &[base_float.into(), exp_float.into()], \"pow_result\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        self.make_float(result)\n    }\n\n    /// atan2(y, x) - two-argument arctangent\n    fn inline_atan2(\n        &mut self,\n        y_val: BasicValueEnum<'ctx>,\n        x_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let y_data = self.extract_data(y_val)?;\n        let x_data = self.extract_data(x_val)?;\n\n        // Convert to floats\n        let f64_type = self.context.f64_type();\n        let y_float = self\n            .builder\n            .build_bitcast(y_data, f64_type, \"y_float\")\n            .unwrap()\n            .into_float_value();\n        let x_float = self\n            .builder\n            .build_bitcast(x_data, f64_type, \"x_float\")\n            .unwrap()\n            .into_float_value();\n\n        // Get or declare atan2 function\n        let atan2_fn = self.module.get_function(\"atan2\").unwrap_or_else(|| {\n            let fn_type = f64_type.fn_type(&[f64_type.into(), f64_type.into()], false);\n            self.module\n                .add_function(\"atan2\", fn_type, Some(inkwell::module::Linkage::External))\n        });\n\n        let result = self\n            .builder\n            .build_call(atan2_fn, &[y_float.into(), x_float.into()], \"atan2_result\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_float_value();\n\n        self.make_float(result)\n    }\n\n    /// snooze(ms) - sleep for given milliseconds\n    fn inline_snooze(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let ms_data = self.extract_data(val)?;\n\n        // Convert ms to timespec: {tv_sec, tv_nsec}\n        // seconds = ms / 1000\n        // nanoseconds = (ms % 1000) * 1_000_000\n        let thousand = self.types.i64_type.const_int(1000, false);\n        let million = self.types.i64_type.const_int(1_000_000, false);\n\n        let seconds = self\n            .builder\n            .build_int_signed_div(ms_data, thousand, \"seconds\")\n            .unwrap();\n        let remainder = self\n            .builder\n            .build_int_signed_rem(ms_data, thousand, \"remainder\")\n            .unwrap();\n        let nanoseconds = self\n            .builder\n            .build_int_mul(remainder, million, \"nanoseconds\")\n            .unwrap();\n\n        // Allocate timespec struct on stack: {i64 tv_sec, i64 tv_nsec}\n        let timespec_type = self.context.struct_type(\n            &[self.types.i64_type.into(), self.types.i64_type.into()],\n            false,\n        );\n        let timespec_ptr = self\n            .builder\n            .build_alloca(timespec_type, \"timespec\")\n            .unwrap();\n\n        // Store values\n        let sec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, timespec_ptr, 0, \"sec_ptr\")\n            .unwrap();\n        self.builder.build_store(sec_ptr, seconds).unwrap();\n        let nsec_ptr = self\n            .builder\n            .build_struct_gep(timespec_type, timespec_ptr, 1, \"nsec_ptr\")\n            .unwrap();\n        self.builder.build_store(nsec_ptr, nanoseconds).unwrap();\n\n        // Call nanosleep\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let timespec_i8 = self\n            .builder\n            .build_pointer_cast(timespec_ptr, i8_ptr, \"timespec_i8\")\n            .unwrap();\n        let null_ptr = i8_ptr.const_null();\n\n        self.builder\n            .build_call(\n                self.libc.nanosleep,\n                &[timespec_i8.into(), null_ptr.into()],\n                \"\",\n            )\n            .unwrap();\n\n        Ok(self.make_nil())\n    }\n\n    /// slice(list, start, end) - return a sublist\n    fn inline_slice(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        start_val: BasicValueEnum<'ctx>,\n        end_val: Option<BasicValueEnum<'ctx>>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(list_val)?;\n        let start_data = self.extract_data(start_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr, \"list_ptr\")\n            .unwrap();\n\n        // Get original list length\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n            .unwrap();\n        let orig_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"orig_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Get end index (default to orig_len if not provided)\n        let end_data = if let Some(end) = end_val {\n            self.extract_data(end)?\n        } else {\n            orig_len\n        };\n\n        // Calculate new length = end - start\n        let new_len = self\n            .builder\n            .build_int_sub(end_data, start_data, \"new_len\")\n            .unwrap();\n\n        // Allocate new list\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_size = self\n            .builder\n            .build_int_mul(new_len, elem_size, \"elems_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_size, \"total_size\")\n            .unwrap();\n\n        let new_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store new length and capacity\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(new_len_ptr, new_len).unwrap();\n        let eight = self.types.i64_type.const_int(8, false);\n        let new_cap_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[eight], \"new_cap_ptr\")\n                .unwrap()\n        };\n        let new_cap_ptr = self\n            .builder\n            .build_pointer_cast(new_cap_ptr, i64_ptr, \"new_cap_ptr_i64\")\n            .unwrap();\n        self.builder.build_store(new_cap_ptr, new_len).unwrap();\n\n        // Copy elements using memcpy\n        // Source: list_ptr + 16 + start * 16\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let start_offset = self\n            .builder\n            .build_int_mul(start_data, sixteen, \"start_offset\")\n            .unwrap();\n        let src_offset = self\n            .builder\n            .build_int_add(sixteen, start_offset, \"src_offset\")\n            .unwrap();\n        let src_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[src_offset], \"src_ptr\")\n                .unwrap()\n        };\n        // Dest: new_ptr + 16\n        let dst_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[sixteen], \"dst_ptr\")\n                .unwrap()\n        };\n\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst_ptr.into(), src_ptr.into(), elems_size.into()],\n                \"\",\n            )\n            .unwrap();\n\n        self.make_list(new_ptr)\n    }\n\n    /// Compile slice expression: obj[start:end:step]\n    fn compile_slice_expr(\n        &mut self,\n        object: &Expr,\n        start: Option<&Box<Expr>>,\n        end: Option<&Box<Expr>>,\n        step: Option<&Box<Expr>>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let obj_val = self.compile_expr(object)?;\n        let obj_tag = self.extract_tag(obj_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n\n        // Get step (default 1)\n        let step_val = if let Some(s) = step {\n            let compiled = self.compile_expr(s)?;\n            self.extract_data(compiled)?\n        } else {\n            self.types.i64_type.const_int(1, false)\n        };\n\n        // Check if we're slicing a list (tag 5) or string (tag 4)\n        let string_tag = self.context.i8_type().const_int(4, false);\n        let list_tag = self.context.i8_type().const_int(5, false);\n        let is_string = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::EQ, obj_tag, string_tag, \"is_string\")\n            .unwrap();\n\n        let obj_data = self.extract_data(obj_val)?;\n\n        // Get length (for lists: stored at ptr[0]; for strings: strlen)\n        let current_fn = self\n            .builder\n            .get_insert_block()\n            .unwrap()\n            .get_parent()\n            .unwrap();\n        let get_len_list = self.context.append_basic_block(current_fn, \"get_len_list\");\n        let get_len_str = self.context.append_basic_block(current_fn, \"get_len_str\");\n        let after_len = self.context.append_basic_block(current_fn, \"after_len\");\n\n        self.builder\n            .build_conditional_branch(is_string, get_len_str, get_len_list)\n            .unwrap();\n\n        // String length via strlen\n        self.builder.position_at_end(get_len_str);\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(obj_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n        let str_len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        self.builder.build_unconditional_branch(after_len).unwrap();\n        let str_len_bb = self.builder.get_insert_block().unwrap();\n\n        // List length from header\n        self.builder.position_at_end(get_len_list);\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(obj_data, i8_ptr, \"list_ptr\")\n            .unwrap();\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n            .unwrap();\n        let list_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"list_len\")\n            .unwrap()\n            .into_int_value();\n        self.builder.build_unconditional_branch(after_len).unwrap();\n        let list_len_bb = self.builder.get_insert_block().unwrap();\n\n        // Merge lengths\n        self.builder.position_at_end(after_len);\n        let len_phi = self.builder.build_phi(self.types.i64_type, \"len\").unwrap();\n        len_phi.add_incoming(&[(&str_len, str_len_bb), (&list_len, list_len_bb)]);\n        let len = len_phi.as_basic_value().into_int_value();\n\n        // Get start (default: 0 if step > 0, len-1 if step < 0)\n        let zero = self.types.i64_type.const_int(0, false);\n        let one = self.types.i64_type.const_int(1, false);\n\n        let step_positive = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SGT, step_val, zero, \"step_positive\")\n            .unwrap();\n\n        let start_default_neg = self\n            .builder\n            .build_int_sub(len, one, \"start_default_neg\")\n            .unwrap();\n        let start_default = self\n            .builder\n            .build_select(step_positive, zero, start_default_neg, \"start_default\")\n            .unwrap()\n            .into_int_value();\n\n        let start_val = if let Some(s) = start {\n            let compiled = self.compile_expr(s)?;\n            let raw_start = self.extract_data(compiled)?;\n            // Handle negative indices\n            let is_neg = self\n                .builder\n                .build_int_compare(inkwell::IntPredicate::SLT, raw_start, zero, \"start_neg\")\n                .unwrap();\n            let adjusted = self\n                .builder\n                .build_int_add(len, raw_start, \"start_adjusted\")\n                .unwrap();\n            self.builder\n                .build_select(is_neg, adjusted, raw_start, \"start_val\")\n                .unwrap()\n                .into_int_value()\n        } else {\n            start_default\n        };\n\n        // Get end (default: len if step > 0, -1 if step < 0)\n        let neg_one_i64 = self.types.i64_type.const_int((-1i64) as u64, true);\n        let end_default = self\n            .builder\n            .build_select(step_positive, len, neg_one_i64, \"end_default\")\n            .unwrap()\n            .into_int_value();\n\n        let end_val = if let Some(e) = end {\n            let compiled = self.compile_expr(e)?;\n            let raw_end = self.extract_data(compiled)?;\n            // Handle negative indices\n            let is_neg = self\n                .builder\n                .build_int_compare(inkwell::IntPredicate::SLT, raw_end, zero, \"end_neg\")\n                .unwrap();\n            let adjusted = self\n                .builder\n                .build_int_add(len, raw_end, \"end_adjusted\")\n                .unwrap();\n            self.builder\n                .build_select(is_neg, adjusted, raw_end, \"end_val\")\n                .unwrap()\n                .into_int_value()\n        } else {\n            end_default\n        };\n\n        // For simple case (step=1, positive indices), we can use memcpy\n        // For complex cases with steps, we need a loop\n        let step_is_one = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::EQ, step_val, one, \"step_is_one\")\n            .unwrap();\n        let can_memcpy = self\n            .builder\n            .build_and(step_positive, step_is_one, \"can_memcpy\")\n            .unwrap();\n\n        let do_memcpy_slice = self.context.append_basic_block(current_fn, \"memcpy_slice\");\n        let do_loop_slice = self.context.append_basic_block(current_fn, \"loop_slice\");\n        let slice_done = self.context.append_basic_block(current_fn, \"slice_done\");\n\n        self.builder\n            .build_conditional_branch(can_memcpy, do_memcpy_slice, do_loop_slice)\n            .unwrap();\n\n        // MEMCPY path (simple contiguous slice with step=1)\n        self.builder.position_at_end(do_memcpy_slice);\n\n        // Calculate new length = end - start (clamped to >= 0)\n        let new_len_raw = self\n            .builder\n            .build_int_sub(end_val, start_val, \"new_len_raw\")\n            .unwrap();\n        let new_len_neg = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, new_len_raw, zero, \"new_len_neg\")\n            .unwrap();\n        let new_len_clamped = self\n            .builder\n            .build_select(new_len_neg, zero, new_len_raw, \"new_len\")\n            .unwrap()\n            .into_int_value();\n\n        // Branch on string vs list for result creation\n        let memcpy_str = self.context.append_basic_block(current_fn, \"memcpy_str\");\n        let memcpy_list = self.context.append_basic_block(current_fn, \"memcpy_list\");\n        let memcpy_merge = self.context.append_basic_block(current_fn, \"memcpy_merge\");\n\n        self.builder\n            .build_conditional_branch(is_string, memcpy_str, memcpy_list)\n            .unwrap();\n\n        // String slice memcpy\n        self.builder.position_at_end(memcpy_str);\n        let str_ptr2 = self\n            .builder\n            .build_int_to_ptr(obj_data, i8_ptr, \"str_ptr2\")\n            .unwrap();\n        let src_str = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr2, &[start_val], \"src_str\")\n                .unwrap()\n        };\n        let alloc_size = self\n            .builder\n            .build_int_add(new_len_clamped, one, \"alloc_size\")\n            .unwrap();\n        let new_str = self\n            .builder\n            .build_call(self.libc.malloc, &[alloc_size.into()], \"new_str\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[new_str.into(), src_str.into(), new_len_clamped.into()],\n                \"\",\n            )\n            .unwrap();\n        // Add null terminator\n        let null_pos = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_str,\n                    &[new_len_clamped],\n                    \"null_pos\",\n                )\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_pos, self.context.i8_type().const_int(0, false))\n            .unwrap();\n        let str_result = self.make_string(new_str)?;\n        self.builder\n            .build_unconditional_branch(memcpy_merge)\n            .unwrap();\n        let str_result_bb = self.builder.get_insert_block().unwrap();\n\n        // List slice memcpy\n        self.builder.position_at_end(memcpy_list);\n        let list_ptr2 = self\n            .builder\n            .build_int_to_ptr(obj_data, i8_ptr, \"list_ptr2\")\n            .unwrap();\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elems_size = self\n            .builder\n            .build_int_mul(new_len_clamped, sixteen, \"elems_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_size, \"total_size\")\n            .unwrap();\n        let new_list_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"new_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        // Store len and cap\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_list_ptr, i64_ptr, \"new_len_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(new_len_ptr, new_len_clamped)\n            .unwrap();\n        let cap_offset = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list_ptr,\n                    &[self.types.i64_type.const_int(8, false)],\n                    \"cap_offset\",\n                )\n                .unwrap()\n        };\n        let new_cap_ptr = self\n            .builder\n            .build_pointer_cast(cap_offset, i64_ptr, \"new_cap_ptr\")\n            .unwrap();\n        self.builder\n            .build_store(new_cap_ptr, new_len_clamped)\n            .unwrap();\n        // Copy elements\n        let start_byte_offset = self\n            .builder\n            .build_int_mul(start_val, sixteen, \"start_byte_off\")\n            .unwrap();\n        let src_offset = self\n            .builder\n            .build_int_add(sixteen, start_byte_offset, \"src_offset\")\n            .unwrap();\n        let src_list = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr2, &[src_offset], \"src_list\")\n                .unwrap()\n        };\n        let dst_list = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_list_ptr, &[sixteen], \"dst_list\")\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst_list.into(), src_list.into(), elems_size.into()],\n                \"\",\n            )\n            .unwrap();\n        let list_result = self.make_list(new_list_ptr)?;\n        self.builder\n            .build_unconditional_branch(memcpy_merge)\n            .unwrap();\n        let list_result_bb = self.builder.get_insert_block().unwrap();\n\n        // Merge memcpy results\n        self.builder.position_at_end(memcpy_merge);\n        let memcpy_result_phi = self\n            .builder\n            .build_phi(self.types.value_type, \"memcpy_result\")\n            .unwrap();\n        memcpy_result_phi\n            .add_incoming(&[(&str_result, str_result_bb), (&list_result, list_result_bb)]);\n        let memcpy_result = memcpy_result_phi.as_basic_value();\n        self.builder.build_unconditional_branch(slice_done).unwrap();\n        let memcpy_final_bb = self.builder.get_insert_block().unwrap();\n\n        // LOOP path (for step != 1 or negative step)\n        self.builder.position_at_end(do_loop_slice);\n\n        // Count how many elements: for step>0: (end-start+step-1)/step, for step<0: (start-end-step-1)/(-step)\n        // Simplified: iterate and count\n        // For now, just return a simple empty result and then iterate\n        // This is complex - let's use a runtime helper or simplified approach\n        // Actually, let's compute the count: count = max(0, ceil((end - start) / step))\n        let diff = self\n            .builder\n            .build_int_sub(end_val, start_val, \"diff\")\n            .unwrap();\n        let count_raw = self\n            .builder\n            .build_int_signed_div(diff, step_val, \"count_raw\")\n            .unwrap();\n        let count_neg = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, count_raw, zero, \"count_neg\")\n            .unwrap();\n        let count = self\n            .builder\n            .build_select(count_neg, zero, count_raw, \"count\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate result based on type\n        let loop_str = self.context.append_basic_block(current_fn, \"loop_str\");\n        let loop_list = self.context.append_basic_block(current_fn, \"loop_list\");\n        let loop_merge = self.context.append_basic_block(current_fn, \"loop_merge\");\n\n        self.builder\n            .build_conditional_branch(is_string, loop_str, loop_list)\n            .unwrap();\n\n        // String loop slice\n        self.builder.position_at_end(loop_str);\n        let str_ptr3 = self\n            .builder\n            .build_int_to_ptr(obj_data, i8_ptr, \"str_ptr3\")\n            .unwrap();\n        let str_alloc = self.builder.build_int_add(count, one, \"str_alloc\").unwrap();\n        let new_str2 = self\n            .builder\n            .build_call(self.libc.malloc, &[str_alloc.into()], \"new_str_loop\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Loop to copy characters\n        let str_loop_init = self.context.append_basic_block(current_fn, \"str_loop_init\");\n        let str_loop_cond = self.context.append_basic_block(current_fn, \"str_loop_cond\");\n        let str_loop_body = self.context.append_basic_block(current_fn, \"str_loop_body\");\n        let str_loop_end = self.context.append_basic_block(current_fn, \"str_loop_end\");\n\n        self.builder\n            .build_unconditional_branch(str_loop_init)\n            .unwrap();\n        self.builder.position_at_end(str_loop_init);\n        self.builder\n            .build_unconditional_branch(str_loop_cond)\n            .unwrap();\n\n        self.builder.position_at_end(str_loop_cond);\n        let str_i_phi = self\n            .builder\n            .build_phi(self.types.i64_type, \"str_i\")\n            .unwrap();\n        str_i_phi.add_incoming(&[(&zero, str_loop_init)]);\n        let str_src_phi = self\n            .builder\n            .build_phi(self.types.i64_type, \"str_src\")\n            .unwrap();\n        str_src_phi.add_incoming(&[(&start_val, str_loop_init)]);\n\n        let str_i = str_i_phi.as_basic_value().into_int_value();\n        let str_src_idx = str_src_phi.as_basic_value().into_int_value();\n        let str_continue = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, str_i, count, \"str_continue\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(str_continue, str_loop_body, str_loop_end)\n            .unwrap();\n\n        self.builder.position_at_end(str_loop_body);\n        let char_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), str_ptr3, &[str_src_idx], \"char_ptr\")\n                .unwrap()\n        };\n        let ch = self\n            .builder\n            .build_load(self.context.i8_type(), char_ptr, \"ch\")\n            .unwrap();\n        let dst_char = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_str2, &[str_i], \"dst_char\")\n                .unwrap()\n        };\n        self.builder.build_store(dst_char, ch).unwrap();\n        let str_i_next = self\n            .builder\n            .build_int_add(str_i, one, \"str_i_next\")\n            .unwrap();\n        let str_src_next = self\n            .builder\n            .build_int_add(str_src_idx, step_val, \"str_src_next\")\n            .unwrap();\n        str_i_phi.add_incoming(&[(&str_i_next, str_loop_body)]);\n        str_src_phi.add_incoming(&[(&str_src_next, str_loop_body)]);\n        self.builder\n            .build_unconditional_branch(str_loop_cond)\n            .unwrap();\n\n        self.builder.position_at_end(str_loop_end);\n        let null_pos2 = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_str2, &[count], \"null_pos2\")\n                .unwrap()\n        };\n        self.builder\n            .build_store(null_pos2, self.context.i8_type().const_int(0, false))\n            .unwrap();\n        let str_loop_result = self.make_string(new_str2)?;\n        self.builder.build_unconditional_branch(loop_merge).unwrap();\n        let str_loop_bb = self.builder.get_insert_block().unwrap();\n\n        // List loop slice\n        self.builder.position_at_end(loop_list);\n        let list_ptr3 = self\n            .builder\n            .build_int_to_ptr(obj_data, i8_ptr, \"list_ptr3\")\n            .unwrap();\n        let list_total = self\n            .builder\n            .build_int_add(\n                self.types.i64_type.const_int(16, false),\n                self.builder\n                    .build_int_mul(count, self.types.i64_type.const_int(16, false), \"elems\")\n                    .unwrap(),\n                \"list_total\",\n            )\n            .unwrap();\n        let new_list2 = self\n            .builder\n            .build_call(self.libc.malloc, &[list_total.into()], \"new_list_loop\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n        // Store len and cap\n        let len_ptr2 = self\n            .builder\n            .build_pointer_cast(new_list2, i64_ptr, \"len_ptr2\")\n            .unwrap();\n        self.builder.build_store(len_ptr2, count).unwrap();\n        let cap_ptr2 = unsafe {\n            self.builder\n                .build_gep(\n                    self.context.i8_type(),\n                    new_list2,\n                    &[self.types.i64_type.const_int(8, false)],\n                    \"cap_ptr2\",\n                )\n                .unwrap()\n        };\n        let cap_ptr2 = self\n            .builder\n            .build_pointer_cast(cap_ptr2, i64_ptr, \"cap_ptr2_i64\")\n            .unwrap();\n        self.builder.build_store(cap_ptr2, count).unwrap();\n\n        // Loop to copy elements\n        let list_loop_init = self\n            .context\n            .append_basic_block(current_fn, \"list_loop_init\");\n        let list_loop_cond = self\n            .context\n            .append_basic_block(current_fn, \"list_loop_cond\");\n        let list_loop_body = self\n            .context\n            .append_basic_block(current_fn, \"list_loop_body\");\n        let list_loop_end = self.context.append_basic_block(current_fn, \"list_loop_end\");\n\n        self.builder\n            .build_unconditional_branch(list_loop_init)\n            .unwrap();\n        self.builder.position_at_end(list_loop_init);\n        self.builder\n            .build_unconditional_branch(list_loop_cond)\n            .unwrap();\n\n        self.builder.position_at_end(list_loop_cond);\n        let list_i_phi = self\n            .builder\n            .build_phi(self.types.i64_type, \"list_i\")\n            .unwrap();\n        list_i_phi.add_incoming(&[(&zero, list_loop_init)]);\n        let list_src_phi = self\n            .builder\n            .build_phi(self.types.i64_type, \"list_src\")\n            .unwrap();\n        list_src_phi.add_incoming(&[(&start_val, list_loop_init)]);\n\n        let list_i = list_i_phi.as_basic_value().into_int_value();\n        let list_src_idx = list_src_phi.as_basic_value().into_int_value();\n        let list_continue = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SLT, list_i, count, \"list_continue\")\n            .unwrap();\n        self.builder\n            .build_conditional_branch(list_continue, list_loop_body, list_loop_end)\n            .unwrap();\n\n        self.builder.position_at_end(list_loop_body);\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let src_byte_off = self\n            .builder\n            .build_int_mul(list_src_idx, sixteen, \"src_byte_off\")\n            .unwrap();\n        let src_off = self\n            .builder\n            .build_int_add(sixteen, src_byte_off, \"src_off\")\n            .unwrap();\n        let src_elem = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr3, &[src_off], \"src_elem\")\n                .unwrap()\n        };\n        let dst_byte_off = self\n            .builder\n            .build_int_mul(list_i, sixteen, \"dst_byte_off\")\n            .unwrap();\n        let dst_off = self\n            .builder\n            .build_int_add(sixteen, dst_byte_off, \"dst_off\")\n            .unwrap();\n        let dst_elem = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_list2, &[dst_off], \"dst_elem\")\n                .unwrap()\n        };\n        // Copy 16 bytes for the MdhValue\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst_elem.into(), src_elem.into(), sixteen.into()],\n                \"\",\n            )\n            .unwrap();\n\n        let list_i_next = self\n            .builder\n            .build_int_add(list_i, one, \"list_i_next\")\n            .unwrap();\n        let list_src_next = self\n            .builder\n            .build_int_add(list_src_idx, step_val, \"list_src_next\")\n            .unwrap();\n        list_i_phi.add_incoming(&[(&list_i_next, list_loop_body)]);\n        list_src_phi.add_incoming(&[(&list_src_next, list_loop_body)]);\n        self.builder\n            .build_unconditional_branch(list_loop_cond)\n            .unwrap();\n\n        self.builder.position_at_end(list_loop_end);\n        let list_loop_result = self.make_list(new_list2)?;\n        self.builder.build_unconditional_branch(loop_merge).unwrap();\n        let list_loop_bb = self.builder.get_insert_block().unwrap();\n\n        // Merge loop results\n        self.builder.position_at_end(loop_merge);\n        let loop_result_phi = self\n            .builder\n            .build_phi(self.types.value_type, \"loop_result\")\n            .unwrap();\n        loop_result_phi.add_incoming(&[\n            (&str_loop_result, str_loop_bb),\n            (&list_loop_result, list_loop_bb),\n        ]);\n        let loop_result = loop_result_phi.as_basic_value();\n        self.builder.build_unconditional_branch(slice_done).unwrap();\n        let loop_final_bb = self.builder.get_insert_block().unwrap();\n\n        // Final merge\n        self.builder.position_at_end(slice_done);\n        let final_phi = self\n            .builder\n            .build_phi(self.types.value_type, \"slice_result\")\n            .unwrap();\n        final_phi.add_incoming(&[\n            (&memcpy_result, memcpy_final_bb),\n            (&loop_result, loop_final_bb),\n        ]);\n\n        Ok(final_phi.as_basic_value())\n    }\n\n    /// uniq(list) - remove duplicates (returns copy for now - full dedup is complex)\n    fn inline_uniq(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(list_val)?;\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr, \"list_ptr\")\n            .unwrap();\n\n        // Get original list length\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n            .unwrap();\n        let orig_len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"orig_len\")\n            .unwrap()\n            .into_int_value();\n\n        // For now, just create a copy (proper dedup is complex without hashtable)\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_size = self\n            .builder\n            .build_int_mul(orig_len, elem_size, \"elems_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_size, \"total_size\")\n            .unwrap();\n\n        let new_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"uniq_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Copy entire list including header\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[new_ptr.into(), list_ptr.into(), total_size.into()],\n                \"\",\n            )\n            .unwrap();\n\n        self.make_list(new_ptr)\n    }\n\n    /// dram(list) - pick a random element from the list\n    fn inline_dram(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(list_val)?;\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr, \"list_ptr\")\n            .unwrap();\n\n        // Get list length\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n            .unwrap();\n        let len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"len\")\n            .unwrap()\n            .into_int_value();\n\n        // Generate random index using rand() % len\n        let rand_val = self\n            .builder\n            .build_call(self.libc.rand, &[], \"rand\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n        let rand_i64 = self\n            .builder\n            .build_int_z_extend(rand_val, self.types.i64_type, \"rand_i64\")\n            .unwrap();\n        let idx = self\n            .builder\n            .build_int_unsigned_rem(rand_i64, len, \"idx\")\n            .unwrap();\n\n        // Get element at index: list_ptr + 16 + idx * 16\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let elem_offset = self\n            .builder\n            .build_int_mul(idx, sixteen, \"elem_offset\")\n            .unwrap();\n        let base_offset = self\n            .builder\n            .build_int_add(sixteen, elem_offset, \"base_offset\")\n            .unwrap();\n        let elem_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[base_offset], \"elem_ptr\")\n                .unwrap()\n        };\n        let elem_ptr = self\n            .builder\n            .build_pointer_cast(\n                elem_ptr,\n                self.types.value_type.ptr_type(AddressSpace::default()),\n                \"elem_ptr_val\",\n            )\n            .unwrap();\n        let elem = self\n            .builder\n            .build_load(self.types.value_type, elem_ptr, \"elem\")\n            .unwrap();\n\n        Ok(elem)\n    }\n\n    /// birl(list, n) - rotate list by n positions\n    fn inline_birl(\n        &mut self,\n        list_val: BasicValueEnum<'ctx>,\n        n_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list_data = self.extract_data(list_val)?;\n        let n_data = self.extract_data(n_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list_ptr = self\n            .builder\n            .build_int_to_ptr(list_data, i8_ptr, \"list_ptr\")\n            .unwrap();\n\n        // Get list length\n        let len_ptr = self\n            .builder\n            .build_pointer_cast(list_ptr, i64_ptr, \"len_ptr\")\n            .unwrap();\n        let len = self\n            .builder\n            .build_load(self.types.i64_type, len_ptr, \"len\")\n            .unwrap()\n            .into_int_value();\n\n        // Allocate new list with same size\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_size = self\n            .builder\n            .build_int_mul(len, elem_size, \"elems_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_size, \"total_size\")\n            .unwrap();\n\n        let new_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"birl_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length and capacity\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(new_len_ptr, len).unwrap();\n        let eight = self.types.i64_type.const_int(8, false);\n        let new_cap_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[eight], \"new_cap_ptr\")\n                .unwrap()\n        };\n        let new_cap_ptr = self\n            .builder\n            .build_pointer_cast(new_cap_ptr, i64_ptr, \"new_cap_ptr_i64\")\n            .unwrap();\n        self.builder.build_store(new_cap_ptr, len).unwrap();\n\n        // For simplicity, copy the entire list (proper rotation is complex in LLVM)\n        // A proper implementation would use memcpy for two segments\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let src_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list_ptr, &[sixteen], \"src_ptr\")\n                .unwrap()\n        };\n        let dst_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[sixteen], \"dst_ptr\")\n                .unwrap()\n        };\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst_ptr.into(), src_ptr.into(), elems_size.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Note: This is a simplified version that just copies without rotation\n        // A proper implementation would rotate the elements\n\n        self.make_list(new_ptr)\n    }\n\n    /// ceilidh(list1, list2) - interleave two lists\n    fn inline_ceilidh(\n        &mut self,\n        list1_val: BasicValueEnum<'ctx>,\n        list2_val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let list1_data = self.extract_data(list1_val)?;\n        let list2_data = self.extract_data(list2_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let i64_ptr = self.types.i64_type.ptr_type(AddressSpace::default());\n        let list1_ptr = self\n            .builder\n            .build_int_to_ptr(list1_data, i8_ptr, \"list1_ptr\")\n            .unwrap();\n        let list2_ptr = self\n            .builder\n            .build_int_to_ptr(list2_data, i8_ptr, \"list2_ptr\")\n            .unwrap();\n\n        // Get lengths\n        let len1_ptr = self\n            .builder\n            .build_pointer_cast(list1_ptr, i64_ptr, \"len1_ptr\")\n            .unwrap();\n        let len1 = self\n            .builder\n            .build_load(self.types.i64_type, len1_ptr, \"len1\")\n            .unwrap()\n            .into_int_value();\n        let len2_ptr = self\n            .builder\n            .build_pointer_cast(list2_ptr, i64_ptr, \"len2_ptr\")\n            .unwrap();\n        let len2 = self\n            .builder\n            .build_load(self.types.i64_type, len2_ptr, \"len2\")\n            .unwrap()\n            .into_int_value();\n\n        // New length = len1 + len2\n        let new_len = self.builder.build_int_add(len1, len2, \"new_len\").unwrap();\n\n        // Allocate new list\n        let header_size = self.types.i64_type.const_int(16, false);\n        let elem_size = self.types.i64_type.const_int(16, false);\n        let elems_size = self\n            .builder\n            .build_int_mul(new_len, elem_size, \"elems_size\")\n            .unwrap();\n        let total_size = self\n            .builder\n            .build_int_add(header_size, elems_size, \"total_size\")\n            .unwrap();\n\n        let new_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[total_size.into()], \"ceilidh_list\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // Store length and capacity\n        let new_len_ptr = self\n            .builder\n            .build_pointer_cast(new_ptr, i64_ptr, \"new_len_ptr\")\n            .unwrap();\n        self.builder.build_store(new_len_ptr, new_len).unwrap();\n        let eight = self.types.i64_type.const_int(8, false);\n        let new_cap_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[eight], \"new_cap_ptr\")\n                .unwrap()\n        };\n        let new_cap_ptr = self\n            .builder\n            .build_pointer_cast(new_cap_ptr, i64_ptr, \"new_cap_ptr_i64\")\n            .unwrap();\n        self.builder.build_store(new_cap_ptr, new_len).unwrap();\n\n        // For simplicity, just concatenate (proper interleave is complex)\n        let sixteen = self.types.i64_type.const_int(16, false);\n        let src1_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list1_ptr, &[sixteen], \"src1_ptr\")\n                .unwrap()\n        };\n        let dst_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[sixteen], \"dst_ptr\")\n                .unwrap()\n        };\n        let size1 = self\n            .builder\n            .build_int_mul(len1, elem_size, \"size1\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst_ptr.into(), src1_ptr.into(), size1.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Copy list2 after list1\n        let offset2 = self\n            .builder\n            .build_int_add(sixteen, size1, \"offset2\")\n            .unwrap();\n        let dst2_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), new_ptr, &[offset2], \"dst2_ptr\")\n                .unwrap()\n        };\n        let src2_ptr = unsafe {\n            self.builder\n                .build_gep(self.context.i8_type(), list2_ptr, &[sixteen], \"src2_ptr\")\n                .unwrap()\n        };\n        let size2 = self\n            .builder\n            .build_int_mul(len2, elem_size, \"size2\")\n            .unwrap();\n        self.builder\n            .build_call(\n                self.libc.memcpy,\n                &[dst2_ptr.into(), src2_ptr.into(), size2.into()],\n                \"\",\n            )\n            .unwrap();\n\n        // Note: This is actually concatenation, not interleaving\n        // Proper interleave would alternate elements\n\n        self.make_list(new_ptr)\n    }\n\n    /// pad_left/pad_right - pad string to given width\n    fn inline_pad(\n        &mut self,\n        str_val: BasicValueEnum<'ctx>,\n        width_val: BasicValueEnum<'ctx>,\n        pad_char: Option<BasicValueEnum<'ctx>>,\n        pad_left: bool,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let str_data = self.extract_data(str_val)?;\n        let width_data = self.extract_data(width_val)?;\n\n        let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());\n        let str_ptr = self\n            .builder\n            .build_int_to_ptr(str_data, i8_ptr, \"str_ptr\")\n            .unwrap();\n\n        // Get string length\n        let str_len = self\n            .builder\n            .build_call(self.libc.strlen, &[str_ptr.into()], \"str_len\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_int_value();\n\n        // Get pad character (default to space)\n        let pad_byte = if let Some(pc) = pad_char {\n            let pc_data = self.extract_data(pc)?;\n            let pc_ptr = self\n                .builder\n                .build_int_to_ptr(pc_data, i8_ptr, \"pc_ptr\")\n                .unwrap();\n            self.builder\n                .build_load(self.context.i8_type(), pc_ptr, \"pad_byte\")\n                .unwrap()\n                .into_int_value()\n        } else {\n            self.context.i8_type().const_int(32, false) // space\n        };\n\n        // Calculate pad length = max(0, width - str_len)\n        let pad_len = self\n            .builder\n            .build_int_sub(width_data, str_len, \"pad_len\")\n            .unwrap();\n        let zero = self.types.i64_type.const_int(0, false);\n        let need_pad = self\n            .builder\n            .build_int_compare(inkwell::IntPredicate::SGT, pad_len, zero, \"need_pad\")\n            .unwrap();\n\n        // Allocate new string: width + 1 (for null terminator)\n        let one = self.types.i64_type.const_int(1, false);\n        let new_len = self\n            .builder\n            .build_int_add(width_data, one, \"new_len\")\n            .unwrap();\n        let new_ptr = self\n            .builder\n            .build_call(self.libc.malloc, &[new_len.into()], \"padded_str\")\n            .unwrap()\n            .try_as_basic_value()\n            .left()\n            .unwrap()\n            .into_pointer_value();\n\n        // For simplicity, just copy the original string (proper padding is complex)\n        // A proper implementation would fill with pad_byte then copy string\n        self.builder\n            .build_call(self.libc.strcpy, &[new_ptr.into(), str_ptr.into()], \"\")\n            .unwrap();\n\n        self.make_string(new_ptr)\n    }\n\n    /// radians(degrees) - convert degrees to radians\n    fn inline_radians(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let f64_type = self.context.f64_type();\n        let float_val = self\n            .builder\n            .build_bitcast(data, f64_type, \"deg_float\")\n            .unwrap()\n            .into_float_value();\n\n        // radians = degrees * PI / 180\n        let pi = f64_type.const_float(std::f64::consts::PI);\n        let c180 = f64_type.const_float(180.0);\n        let temp = self.builder.build_float_mul(float_val, pi, \"temp\").unwrap();\n        let result = self.builder.build_float_div(temp, c180, \"radians\").unwrap();\n\n        self.make_float(result)\n    }\n\n    /// degrees(radians) - convert radians to degrees\n    fn inline_degrees(\n        &mut self,\n        val: BasicValueEnum<'ctx>,\n    ) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let data = self.extract_data(val)?;\n        let f64_type = self.context.f64_type();\n        let float_val = self\n            .builder\n            .build_bitcast(data, f64_type, \"rad_float\")\n            .unwrap()\n            .into_float_value();\n\n        // degrees = radians * 180 / PI\n        let pi = f64_type.const_float(std::f64::consts::PI);\n        let c180 = f64_type.const_float(180.0);\n        let temp = self\n            .builder\n            .build_float_mul(float_val, c180, \"temp\")\n            .unwrap();\n        let result = self.builder.build_float_div(temp, pi, \"degrees\").unwrap();\n\n        self.make_float(result)\n    }\n\n    /// Compile a string literal directly\n    fn compile_string_literal(&mut self, s: &str) -> Result<BasicValueEnum<'ctx>, HaversError> {\n        let global = Self::create_global_string(\n            &self.module,\n            self.context,\n            s,\n            &format!(\"str.literal.{}\", self.lambda_counter),\n        );\n        self.lambda_counter += 1;\n        let str_ptr = global.as_pointer_value();\n        self.make_string(str_ptr)\n    }\n}\n","traces":[{"line":223,"address":[55337215,55333968,55337302],"length":1,"stats":{"Line":15}},{"line":224,"address":[55152985],"length":1,"stats":{"Line":15}},{"line":229,"address":[55334146,55334078],"length":1,"stats":{"Line":30}},{"line":230,"address":[],"length":0,"stats":{"Line":15}},{"line":231,"address":[],"length":0,"stats":{"Line":15}},{"line":234,"address":[],"length":0,"stats":{"Line":15}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":15}},{"line":238,"address":[55334609],"length":1,"stats":{"Line":15}},{"line":239,"address":[],"length":0,"stats":{"Line":15}},{"line":242,"address":[56886923],"length":1,"stats":{"Line":15}},{"line":245,"address":[],"length":0,"stats":{"Line":21}},{"line":246,"address":[54321662],"length":1,"stats":{"Line":21}},{"line":247,"address":[55334885],"length":1,"stats":{"Line":16}},{"line":248,"address":[54321788],"length":1,"stats":{"Line":21}},{"line":249,"address":[56887187],"length":1,"stats":{"Line":16}},{"line":250,"address":[56887250],"length":1,"stats":{"Line":21}},{"line":251,"address":[55335137],"length":1,"stats":{"Line":16}},{"line":260,"address":[55154271],"length":1,"stats":{"Line":20}},{"line":261,"address":[],"length":0,"stats":{"Line":17}},{"line":262,"address":[55335438],"length":1,"stats":{"Line":20}},{"line":263,"address":[56887666],"length":1,"stats":{"Line":17}},{"line":264,"address":[55154514],"length":1,"stats":{"Line":20}},{"line":265,"address":[54322462],"length":1,"stats":{"Line":17}},{"line":266,"address":[],"length":0,"stats":{"Line":20}},{"line":267,"address":[55335698],"length":1,"stats":{"Line":17}},{"line":268,"address":[],"length":0,"stats":{"Line":20}},{"line":269,"address":[56887978],"length":1,"stats":{"Line":17}},{"line":270,"address":[56888030],"length":1,"stats":{"Line":20}},{"line":271,"address":[56888082],"length":1,"stats":{"Line":17}},{"line":275,"address":[55335958],"length":1,"stats":{"Line":20}},{"line":276,"address":[],"length":0,"stats":{"Line":17}},{"line":280,"address":[55336088],"length":1,"stats":{"Line":20}},{"line":292,"address":[55121728,55121834],"length":1,"stats":{"Line":0}},{"line":293,"address":[55121807,55121752,55121865],"length":1,"stats":{"Line":0}},{"line":296,"address":[55257552],"length":1,"stats":{"Line":15}},{"line":301,"address":[56809814],"length":1,"stats":{"Line":14}},{"line":302,"address":[],"length":0,"stats":{"Line":12}},{"line":303,"address":[54243424],"length":1,"stats":{"Line":14}},{"line":304,"address":[55257738],"length":1,"stats":{"Line":12}},{"line":307,"address":[55075591],"length":1,"stats":{"Line":13}},{"line":308,"address":[55257847],"length":1,"stats":{"Line":15}},{"line":311,"address":[54243607],"length":1,"stats":{"Line":12}},{"line":312,"address":[55257972],"length":1,"stats":{"Line":8}},{"line":315,"address":[55258020],"length":1,"stats":{"Line":20}},{"line":316,"address":[55075978],"length":1,"stats":{"Line":8}},{"line":319,"address":[],"length":0,"stats":{"Line":20}},{"line":320,"address":[],"length":0,"stats":{"Line":8}},{"line":323,"address":[55076151],"length":1,"stats":{"Line":20}},{"line":324,"address":[],"length":0,"stats":{"Line":8}},{"line":327,"address":[56810685],"length":1,"stats":{"Line":20}},{"line":328,"address":[56810819],"length":1,"stats":{"Line":8}},{"line":331,"address":[55258691],"length":1,"stats":{"Line":20}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[56811061],"length":1,"stats":{"Line":8}},{"line":336,"address":[],"length":0,"stats":{"Line":20}},{"line":337,"address":[54244722],"length":1,"stats":{"Line":8}},{"line":340,"address":[54244770],"length":1,"stats":{"Line":20}},{"line":341,"address":[54244904],"length":1,"stats":{"Line":8}},{"line":344,"address":[],"length":0,"stats":{"Line":20}},{"line":345,"address":[55259374],"length":1,"stats":{"Line":10}},{"line":348,"address":[],"length":0,"stats":{"Line":17}},{"line":349,"address":[55259637],"length":1,"stats":{"Line":12}},{"line":352,"address":[55259685],"length":1,"stats":{"Line":20}},{"line":353,"address":[],"length":0,"stats":{"Line":12}},{"line":356,"address":[55077634],"length":1,"stats":{"Line":20}},{"line":357,"address":[],"length":0,"stats":{"Line":12}},{"line":360,"address":[56812111],"length":1,"stats":{"Line":19}},{"line":361,"address":[55260012],"length":1,"stats":{"Line":13}},{"line":365,"address":[55077884],"length":1,"stats":{"Line":19}},{"line":366,"address":[],"length":0,"stats":{"Line":13}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":19}},{"line":371,"address":[55078224],"length":1,"stats":{"Line":13}},{"line":374,"address":[56812624],"length":1,"stats":{"Line":18}},{"line":375,"address":[],"length":0,"stats":{"Line":10}},{"line":378,"address":[54246423],"length":1,"stats":{"Line":18}},{"line":379,"address":[54246500],"length":1,"stats":{"Line":10}},{"line":382,"address":[55078660],"length":1,"stats":{"Line":18}},{"line":383,"address":[],"length":0,"stats":{"Line":10}},{"line":386,"address":[54246632],"length":1,"stats":{"Line":19}},{"line":387,"address":[55260997],"length":1,"stats":{"Line":10}},{"line":390,"address":[],"length":0,"stats":{"Line":19}},{"line":391,"address":[54246834],"length":1,"stats":{"Line":10}},{"line":394,"address":[],"length":0,"stats":{"Line":10}},{"line":395,"address":[54247062],"length":1,"stats":{"Line":19}},{"line":396,"address":[54246882],"length":1,"stats":{"Line":19}},{"line":397,"address":[56813383],"length":1,"stats":{"Line":10}},{"line":398,"address":[],"length":0,"stats":{"Line":19}},{"line":399,"address":[],"length":0,"stats":{"Line":10}},{"line":403,"address":[55261454],"length":1,"stats":{"Line":19}},{"line":406,"address":[55079326],"length":1,"stats":{"Line":10}},{"line":407,"address":[54247253],"length":1,"stats":{"Line":19}},{"line":410,"address":[55079421],"length":1,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[55261608],"length":1,"stats":{"Line":19}},{"line":413,"address":[54247466],"length":1,"stats":{"Line":10}},{"line":416,"address":[55261802],"length":1,"stats":{"Line":19}},{"line":417,"address":[54247561],"length":1,"stats":{"Line":10}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[55261905],"length":1,"stats":{"Line":19}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[56814129],"length":1,"stats":{"Line":9}},{"line":426,"address":[55079816],"length":1,"stats":{"Line":20}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[55079864],"length":1,"stats":{"Line":9}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[54247763],"length":1,"stats":{"Line":20}},{"line":436,"address":[],"length":0,"stats":{"Line":9}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[56814427],"length":1,"stats":{"Line":20}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":9}},{"line":446,"address":[55262414],"length":1,"stats":{"Line":20}},{"line":449,"address":[54248174],"length":1,"stats":{"Line":9}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[56814649],"length":1,"stats":{"Line":20}},{"line":452,"address":[56814801],"length":1,"stats":{"Line":9}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":20}},{"line":457,"address":[55262764],"length":1,"stats":{"Line":9}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[54248524],"length":1,"stats":{"Line":19}},{"line":466,"address":[54248615],"length":1,"stats":{"Line":10}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":19}},{"line":474,"address":[55080866],"length":1,"stats":{"Line":10}},{"line":477,"address":[56815266],"length":1,"stats":{"Line":19}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[56815277],"length":1,"stats":{"Line":10}},{"line":480,"address":[],"length":0,"stats":{"Line":19}},{"line":483,"address":[54249013],"length":1,"stats":{"Line":10}},{"line":484,"address":[],"length":0,"stats":{"Line":19}},{"line":487,"address":[55263440],"length":1,"stats":{"Line":10}},{"line":488,"address":[55263531],"length":1,"stats":{"Line":22}},{"line":492,"address":[55081403],"length":1,"stats":{"Line":10}},{"line":493,"address":[55081442],"length":1,"stats":{"Line":22}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[54249378],"length":1,"stats":{"Line":10}},{"line":501,"address":[56815933],"length":1,"stats":{"Line":22}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[56815981],"length":1,"stats":{"Line":10}},{"line":510,"address":[],"length":0,"stats":{"Line":22}},{"line":513,"address":[55263892],"length":1,"stats":{"Line":11}},{"line":514,"address":[55081807],"length":1,"stats":{"Line":22}},{"line":517,"address":[55264031],"length":1,"stats":{"Line":11}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[56816218],"length":1,"stats":{"Line":22}},{"line":520,"address":[56816370],"length":1,"stats":{"Line":11}},{"line":523,"address":[54249954],"length":1,"stats":{"Line":22}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[54249965],"length":1,"stats":{"Line":11}},{"line":526,"address":[55264405],"length":1,"stats":{"Line":22}},{"line":529,"address":[],"length":0,"stats":{"Line":11}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":22}},{"line":532,"address":[55264616],"length":1,"stats":{"Line":11}},{"line":535,"address":[55264664],"length":1,"stats":{"Line":22}},{"line":536,"address":[55082579],"length":1,"stats":{"Line":11}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[55082627],"length":1,"stats":{"Line":22}},{"line":541,"address":[55264894],"length":1,"stats":{"Line":11}},{"line":544,"address":[],"length":0,"stats":{"Line":33}},{"line":545,"address":[54250801],"length":1,"stats":{"Line":22}},{"line":546,"address":[54250665],"length":1,"stats":{"Line":11}},{"line":547,"address":[55082817],"length":1,"stats":{"Line":22}},{"line":548,"address":[],"length":0,"stats":{"Line":11}},{"line":552,"address":[55083001],"length":1,"stats":{"Line":22}},{"line":556,"address":[55265225],"length":1,"stats":{"Line":11}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[55083060],"length":1,"stats":{"Line":22}},{"line":559,"address":[54251100],"length":1,"stats":{"Line":14}},{"line":562,"address":[55083260],"length":1,"stats":{"Line":23}},{"line":563,"address":[56817703],"length":1,"stats":{"Line":14}},{"line":566,"address":[55265570],"length":1,"stats":{"Line":23}},{"line":567,"address":[54251321],"length":1,"stats":{"Line":14}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[55083476],"length":1,"stats":{"Line":20}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[55083487],"length":1,"stats":{"Line":16}},{"line":575,"address":[],"length":0,"stats":{"Line":21}},{"line":578,"address":[55265858],"length":1,"stats":{"Line":16}},{"line":579,"address":[55083773],"length":1,"stats":{"Line":21}},{"line":582,"address":[56818168],"length":1,"stats":{"Line":16}},{"line":583,"address":[55083907],"length":1,"stats":{"Line":21}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[54251838],"length":1,"stats":{"Line":16}},{"line":588,"address":[54251929],"length":1,"stats":{"Line":21}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":16}},{"line":593,"address":[55266351],"length":1,"stats":{"Line":21}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[55084223],"length":1,"stats":{"Line":16}},{"line":598,"address":[55266490],"length":1,"stats":{"Line":21}},{"line":601,"address":[55084362],"length":1,"stats":{"Line":16}},{"line":602,"address":[],"length":0,"stats":{"Line":21}},{"line":605,"address":[55084501],"length":1,"stats":{"Line":16}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[54252400],"length":1,"stats":{"Line":21}},{"line":608,"address":[54252552],"length":1,"stats":{"Line":16}},{"line":611,"address":[55266888],"length":1,"stats":{"Line":21}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[55084723],"length":1,"stats":{"Line":16}},{"line":614,"address":[],"length":0,"stats":{"Line":21}},{"line":617,"address":[55084923],"length":1,"stats":{"Line":16}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[55084934],"length":1,"stats":{"Line":21}},{"line":620,"address":[55085086],"length":1,"stats":{"Line":16}},{"line":623,"address":[],"length":0,"stats":{"Line":21}},{"line":624,"address":[],"length":0,"stats":{"Line":16}},{"line":690,"address":[54237152,54237953,54237959],"length":1,"stats":{"Line":16}},{"line":696,"address":[56803819],"length":1,"stats":{"Line":21}},{"line":697,"address":[56803925,56803984],"length":1,"stats":{"Line":37}},{"line":698,"address":[],"length":0,"stats":{"Line":16}},{"line":699,"address":[56804124],"length":1,"stats":{"Line":21}},{"line":700,"address":[54237601],"length":1,"stats":{"Line":16}},{"line":701,"address":[55069729],"length":1,"stats":{"Line":21}},{"line":703,"address":[56117538,56117520],"length":1,"stats":{"Line":53}},{"line":705,"address":[56804345,56804285],"length":1,"stats":{"Line":37}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[54051344],"length":1,"stats":{"Line":6}},{"line":710,"address":[54883488],"length":1,"stats":{"Line":4}},{"line":712,"address":[54051387],"length":1,"stats":{"Line":6}},{"line":713,"address":[54051403],"length":1,"stats":{"Line":4}},{"line":720,"address":[],"length":0,"stats":{"Line":11}},{"line":721,"address":[53644808],"length":1,"stats":{"Line":7}},{"line":725,"address":[54326268,54326236,54324304],"length":1,"stats":{"Line":17}},{"line":727,"address":[55156512,55156482],"length":1,"stats":{"Line":37}},{"line":728,"address":[56890799,56891378,56889691],"length":1,"stats":{"Line":34}},{"line":729,"address":[56890836],"length":1,"stats":{"Line":7}},{"line":731,"address":[54527792,54527827],"length":1,"stats":{"Line":21}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[55338893,55338961],"length":1,"stats":{"Line":28}},{"line":734,"address":[55158182],"length":1,"stats":{"Line":0}},{"line":740,"address":[55156653],"length":1,"stats":{"Line":15}},{"line":741,"address":[55337622],"length":1,"stats":{"Line":14}},{"line":742,"address":[56889856],"length":1,"stats":{"Line":15}},{"line":743,"address":[55337720],"length":1,"stats":{"Line":14}},{"line":744,"address":[55337757],"length":1,"stats":{"Line":15}},{"line":748,"address":[55337789,55337768],"length":1,"stats":{"Line":26}},{"line":749,"address":[],"length":0,"stats":{"Line":13}},{"line":750,"address":[54325412],"length":1,"stats":{"Line":0}},{"line":755,"address":[54324887,54324909],"length":1,"stats":{"Line":26}},{"line":756,"address":[55338020,55338348],"length":1,"stats":{"Line":13}},{"line":760,"address":[55157360,55157178,55157276],"length":1,"stats":{"Line":18}},{"line":761,"address":[55157193],"length":1,"stats":{"Line":9}},{"line":762,"address":[56122592,56122608],"length":1,"stats":{"Line":8}},{"line":764,"address":[54325295],"length":1,"stats":{"Line":8}},{"line":768,"address":[56687216],"length":1,"stats":{"Line":7}},{"line":769,"address":[56687248],"length":1,"stats":{"Line":7}},{"line":773,"address":[55333168,55333949,55333955],"length":1,"stats":{"Line":7}},{"line":780,"address":[54320083,54320232],"length":1,"stats":{"Line":7}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[54527758,54527744],"length":1,"stats":{"Line":21}},{"line":785,"address":[55152311,55152416],"length":1,"stats":{"Line":14}},{"line":786,"address":[55152462],"length":1,"stats":{"Line":7}},{"line":787,"address":[56885785],"length":1,"stats":{"Line":7}},{"line":790,"address":[55333677],"length":1,"stats":{"Line":7}},{"line":791,"address":[55152631,55152785],"length":1,"stats":{"Line":0}},{"line":792,"address":[56886070,56885973,56885996,56885900],"length":1,"stats":{"Line":0}},{"line":794,"address":[55152666],"length":1,"stats":{"Line":7}},{"line":798,"address":[54170658,54167792,54168904],"length":1,"stats":{"Line":0}},{"line":800,"address":[54167890],"length":1,"stats":{"Line":0}},{"line":801,"address":[56736302],"length":1,"stats":{"Line":0}},{"line":805,"address":[56736234],"length":1,"stats":{"Line":0}},{"line":806,"address":[54168092,54167988],"length":1,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[55185017],"length":1,"stats":{"Line":0}},{"line":809,"address":[56737192],"length":1,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[55001073],"length":1,"stats":{"Line":0}},{"line":815,"address":[55185339,55185262],"length":1,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[54169258,54169337],"length":1,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[53124686,53124672],"length":1,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[55185828],"length":1,"stats":{"Line":0}},{"line":824,"address":[54169867],"length":1,"stats":{"Line":0}},{"line":825,"address":[55186000],"length":1,"stats":{"Line":0}},{"line":828,"address":[55186117],"length":1,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[54516457,54516432],"length":1,"stats":{"Line":0}},{"line":831,"address":[55002481],"length":1,"stats":{"Line":0}},{"line":837,"address":[55184385],"length":1,"stats":{"Line":0}},{"line":838,"address":[54168746,54168429,54168669],"length":1,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[56736952,56736710],"length":1,"stats":{"Line":0}},{"line":842,"address":[56737044],"length":1,"stats":{"Line":0}},{"line":844,"address":[54168873],"length":1,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":4}},{"line":851,"address":[],"length":0,"stats":{"Line":4}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[55159228],"length":1,"stats":{"Line":4}},{"line":855,"address":[55159297],"length":1,"stats":{"Line":4}},{"line":856,"address":[55340178],"length":1,"stats":{"Line":4}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[55340190],"length":1,"stats":{"Line":4}},{"line":863,"address":[54339648],"length":1,"stats":{"Line":3}},{"line":864,"address":[],"length":0,"stats":{"Line":3}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":3}},{"line":870,"address":[56904773],"length":1,"stats":{"Line":3}},{"line":871,"address":[],"length":0,"stats":{"Line":3}},{"line":872,"address":[55352785],"length":1,"stats":{"Line":3}},{"line":873,"address":[],"length":0,"stats":{"Line":6}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[55172107],"length":1,"stats":{"Line":3}},{"line":877,"address":[54340093],"length":1,"stats":{"Line":3}},{"line":881,"address":[56904797,56905184,56904861],"length":1,"stats":{"Line":2}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[55352631],"length":1,"stats":{"Line":1}},{"line":884,"address":[53138176,53138192],"length":1,"stats":{"Line":1}},{"line":886,"address":[],"length":0,"stats":{"Line":1}},{"line":887,"address":[56905269,56905328,56905408],"length":1,"stats":{"Line":2}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":1}},{"line":890,"address":[55172474,55172402],"length":1,"stats":{"Line":1}},{"line":891,"address":[55353299,55353446,55353366],"length":1,"stats":{"Line":2}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[55172580],"length":1,"stats":{"Line":1}},{"line":894,"address":[54036608,54036592],"length":1,"stats":{"Line":1}},{"line":896,"address":[55172778],"length":1,"stats":{"Line":1}},{"line":900,"address":[],"length":0,"stats":{"Line":11}},{"line":901,"address":[55339307],"length":1,"stats":{"Line":8}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[54326343],"length":1,"stats":{"Line":11}},{"line":907,"address":[54326390],"length":1,"stats":{"Line":8}},{"line":908,"address":[55339667,55339539],"length":1,"stats":{"Line":19}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":8}},{"line":912,"address":[54326674],"length":1,"stats":{"Line":11}},{"line":916,"address":[54326409],"length":1,"stats":{"Line":5}},{"line":917,"address":[55158555,55158855,55158616],"length":1,"stats":{"Line":12}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[54326450],"length":1,"stats":{"Line":5}},{"line":920,"address":[54326482,54326715],"length":1,"stats":{"Line":7}},{"line":921,"address":[],"length":0,"stats":{"Line":12}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[54326818],"length":1,"stats":{"Line":5}},{"line":924,"address":[],"length":0,"stats":{"Line":7}},{"line":926,"address":[56892159],"length":1,"stats":{"Line":7}},{"line":930,"address":[56259888],"length":1,"stats":{"Line":4}},{"line":934,"address":[],"length":0,"stats":{"Line":4}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[54517671],"length":1,"stats":{"Line":6}},{"line":938,"address":[],"length":0,"stats":{"Line":11}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[56260007],"length":1,"stats":{"Line":6}},{"line":941,"address":[56260040,56260104],"length":1,"stats":{"Line":6}},{"line":943,"address":[56260198],"length":1,"stats":{"Line":5}},{"line":944,"address":[54708179,54708259,54708120],"length":1,"stats":{"Line":12}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[53685860],"length":1,"stats":{"Line":6}},{"line":947,"address":[53685892,53685964],"length":1,"stats":{"Line":6}},{"line":948,"address":[56260592,56260443,56260512],"length":1,"stats":{"Line":11}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[54518187],"length":1,"stats":{"Line":6}},{"line":951,"address":[54518229,54518301],"length":1,"stats":{"Line":6}},{"line":953,"address":[54518387],"length":1,"stats":{"Line":5}},{"line":957,"address":[56311856],"length":1,"stats":{"Line":4}},{"line":958,"address":[],"length":0,"stats":{"Line":4}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[54759799],"length":1,"stats":{"Line":4}},{"line":962,"address":[54759853,54759917,54759988],"length":1,"stats":{"Line":8}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[54759863],"length":1,"stats":{"Line":4}},{"line":965,"address":[54570474,54570540],"length":1,"stats":{"Line":4}},{"line":967,"address":[53738505],"length":1,"stats":{"Line":4}},{"line":968,"address":[56312182,56312241,56312321],"length":1,"stats":{"Line":8}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[54570658],"length":1,"stats":{"Line":4}},{"line":971,"address":[53738578,53738650],"length":1,"stats":{"Line":4}},{"line":972,"address":[56312455,56312388,56312535],"length":1,"stats":{"Line":8}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[54760283],"length":1,"stats":{"Line":4}},{"line":975,"address":[56078432,56078416],"length":1,"stats":{"Line":4}},{"line":977,"address":[54760477],"length":1,"stats":{"Line":4}},{"line":982,"address":[55173664],"length":1,"stats":{"Line":1}},{"line":983,"address":[],"length":0,"stats":{"Line":1}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[56906599],"length":1,"stats":{"Line":1}},{"line":987,"address":[56906653,56906788,56906717],"length":1,"stats":{"Line":2}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[56906663],"length":1,"stats":{"Line":1}},{"line":990,"address":[55354584,55354520],"length":1,"stats":{"Line":1}},{"line":992,"address":[],"length":0,"stats":{"Line":1}},{"line":993,"address":[],"length":0,"stats":{"Line":2}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[54341890],"length":1,"stats":{"Line":1}},{"line":996,"address":[55354802,55354732],"length":1,"stats":{"Line":1}},{"line":997,"address":[55354967,55355047,55354900],"length":1,"stats":{"Line":2}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":1}},{"line":1000,"address":[54037824,54037840],"length":1,"stats":{"Line":1}},{"line":1002,"address":[55174410],"length":1,"stats":{"Line":1}},{"line":1007,"address":[56905744],"length":1,"stats":{"Line":0}},{"line":1008,"address":[55353611],"length":1,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[56905799],"length":1,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[55353687],"length":1,"stats":{"Line":0}},{"line":1015,"address":[54037296,54037312],"length":1,"stats":{"Line":0}},{"line":1017,"address":[54341033],"length":1,"stats":{"Line":0}},{"line":1018,"address":[56906209,56906070,56906129],"length":1,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[56906077],"length":1,"stats":{"Line":0}},{"line":1021,"address":[56123824,56123840],"length":1,"stats":{"Line":0}},{"line":1022,"address":[55173389,55173458,55173539],"length":1,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[55173396],"length":1,"stats":{"Line":0}},{"line":1025,"address":[56123984,56124000],"length":1,"stats":{"Line":0}},{"line":1027,"address":[54341482],"length":1,"stats":{"Line":0}},{"line":1033,"address":[55047856],"length":1,"stats":{"Line":0}},{"line":1034,"address":[55047899],"length":1,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[55047911],"length":1,"stats":{"Line":0}},{"line":1038,"address":[54029832,54029694,54029760],"length":1,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[54861816],"length":1,"stats":{"Line":0}},{"line":1041,"address":[54029738,54029804],"length":1,"stats":{"Line":0}},{"line":1043,"address":[54029881],"length":1,"stats":{"Line":0}},{"line":1044,"address":[54862088,54862169,54862027],"length":1,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[55048189],"length":1,"stats":{"Line":0}},{"line":1047,"address":[55048290,55048220],"length":1,"stats":{"Line":0}},{"line":1048,"address":[55048535,55048455,55048388],"length":1,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[56600507],"length":1,"stats":{"Line":0}},{"line":1051,"address":[56600546,56600616],"length":1,"stats":{"Line":0}},{"line":1053,"address":[55048589],"length":1,"stats":{"Line":0}},{"line":1057,"address":[54028976],"length":1,"stats":{"Line":0}},{"line":1061,"address":[56599419],"length":1,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[56599431],"length":1,"stats":{"Line":0}},{"line":1066,"address":[54861190],"length":1,"stats":{"Line":0}},{"line":1067,"address":[54861285,54861357,54861224],"length":1,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[54029119],"length":1,"stats":{"Line":0}},{"line":1070,"address":[53115888,53115872],"length":1,"stats":{"Line":0}},{"line":1071,"address":[56599702,56599769,56599849],"length":1,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[56599709],"length":1,"stats":{"Line":0}},{"line":1074,"address":[54861538,54861466],"length":1,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[54950544],"length":1,"stats":{"Line":0}},{"line":1085,"address":[56687326],"length":1,"stats":{"Line":0}},{"line":1086,"address":[55135292,55135400,55135480],"length":1,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[54950733],"length":1,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[54118841],"length":1,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":4}},{"line":1099,"address":[56261928],"length":1,"stats":{"Line":4}},{"line":1100,"address":[],"length":0,"stats":{"Line":9}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[53687589],"length":1,"stats":{"Line":5}},{"line":1103,"address":[54709873,54709931],"length":1,"stats":{"Line":4}},{"line":1104,"address":[54710007],"length":1,"stats":{"Line":4}},{"line":1108,"address":[],"length":0,"stats":{"Line":5}},{"line":1109,"address":[54763848],"length":1,"stats":{"Line":6}},{"line":1110,"address":[54951642,54951518,54951574],"length":1,"stats":{"Line":11}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[53931765],"length":1,"stats":{"Line":7}},{"line":1113,"address":[56096336,56096320],"length":1,"stats":{"Line":4}},{"line":1114,"address":[54951690],"length":1,"stats":{"Line":4}},{"line":1119,"address":[56584032],"length":1,"stats":{"Line":0}},{"line":1123,"address":[55031966],"length":1,"stats":{"Line":0}},{"line":1124,"address":[54845868,54845721,54845787],"length":1,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[55032097],"length":1,"stats":{"Line":0}},{"line":1127,"address":[55032200,55032130],"length":1,"stats":{"Line":0}},{"line":1128,"address":[55032285],"length":1,"stats":{"Line":0}},{"line":1133,"address":[55030624],"length":1,"stats":{"Line":0}},{"line":1137,"address":[56766366],"length":1,"stats":{"Line":0}},{"line":1138,"address":[55214520,55214332,55214440],"length":1,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[55030813],"length":1,"stats":{"Line":0}},{"line":1145,"address":[55030886,55030958],"length":1,"stats":{"Line":0}},{"line":1146,"address":[56766723],"length":1,"stats":{"Line":0}},{"line":1150,"address":[55169216],"length":1,"stats":{"Line":1}},{"line":1151,"address":[55350039],"length":1,"stats":{"Line":1}},{"line":1152,"address":[54337346],"length":1,"stats":{"Line":1}},{"line":1154,"address":[56902534],"length":1,"stats":{"Line":1}},{"line":1155,"address":[54337542],"length":1,"stats":{"Line":1}},{"line":1156,"address":[54337592],"length":1,"stats":{"Line":1}},{"line":1157,"address":[55350502],"length":1,"stats":{"Line":1}},{"line":1158,"address":[56902731],"length":1,"stats":{"Line":1}},{"line":1159,"address":[56902784],"length":1,"stats":{"Line":1}},{"line":1162,"address":[54337793],"length":1,"stats":{"Line":1}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[54337805],"length":1,"stats":{"Line":1}},{"line":1166,"address":[55350714],"length":1,"stats":{"Line":1}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[54337867],"length":1,"stats":{"Line":1}},{"line":1170,"address":[],"length":0,"stats":{"Line":1}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[55350790],"length":1,"stats":{"Line":1}},{"line":1175,"address":[55350985,55350881,55351068],"length":1,"stats":{"Line":2}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[56903064],"length":1,"stats":{"Line":1}},{"line":1181,"address":[56903140,56903210],"length":1,"stats":{"Line":1}},{"line":1184,"address":[56903298],"length":1,"stats":{"Line":1}},{"line":1185,"address":[55351143],"length":1,"stats":{"Line":1}},{"line":1186,"address":[55351183],"length":1,"stats":{"Line":1}},{"line":1187,"address":[56903408],"length":1,"stats":{"Line":1}},{"line":1190,"address":[54338437],"length":1,"stats":{"Line":1}},{"line":1191,"address":[55351316],"length":1,"stats":{"Line":1}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[55170585],"length":1,"stats":{"Line":1}},{"line":1195,"address":[56903576],"length":1,"stats":{"Line":1}},{"line":1196,"address":[55170711],"length":1,"stats":{"Line":1}},{"line":1199,"address":[54338660],"length":1,"stats":{"Line":1}},{"line":1200,"address":[],"length":0,"stats":{"Line":1}},{"line":1201,"address":[55351574],"length":1,"stats":{"Line":1}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[55351581],"length":1,"stats":{"Line":1}},{"line":1205,"address":[55351655],"length":1,"stats":{"Line":1}},{"line":1206,"address":[55170969],"length":1,"stats":{"Line":1}},{"line":1209,"address":[55171030],"length":1,"stats":{"Line":1}},{"line":1210,"address":[54338939],"length":1,"stats":{"Line":1}},{"line":1211,"address":[55171092],"length":1,"stats":{"Line":1}},{"line":1212,"address":[55351876],"length":1,"stats":{"Line":1}},{"line":1215,"address":[],"length":0,"stats":{"Line":1}},{"line":1216,"address":[55351955],"length":1,"stats":{"Line":1}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[55171231],"length":1,"stats":{"Line":1}},{"line":1220,"address":[55171478],"length":1,"stats":{"Line":1}},{"line":1221,"address":[54339210],"length":1,"stats":{"Line":1}},{"line":1222,"address":[54339249],"length":1,"stats":{"Line":1}},{"line":1223,"address":[54339288],"length":1,"stats":{"Line":1}},{"line":1224,"address":[55171439],"length":1,"stats":{"Line":1}},{"line":1227,"address":[56904602],"length":1,"stats":{"Line":1}},{"line":1233,"address":[56829904],"length":1,"stats":{"Line":4}},{"line":1237,"address":[55095751,55095860],"length":1,"stats":{"Line":5}},{"line":1239,"address":[55278058],"length":1,"stats":{"Line":4}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[56830280],"length":1,"stats":{"Line":4}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[56831301,56831197,56831128],"length":1,"stats":{"Line":2}},{"line":1250,"address":[55097078,55097122,55097219],"length":1,"stats":{"Line":2}},{"line":1252,"address":[54265081],"length":1,"stats":{"Line":1}},{"line":1253,"address":[56831432],"length":1,"stats":{"Line":1}},{"line":1254,"address":[55097290],"length":1,"stats":{"Line":1}},{"line":1255,"address":[54265202],"length":1,"stats":{"Line":0}},{"line":1258,"address":[55097266],"length":1,"stats":{"Line":1}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[54032601],"length":1,"stats":{"Line":0}},{"line":1266,"address":[53133856,53133934],"length":1,"stats":{"Line":0}},{"line":1267,"address":[56119770],"length":1,"stats":{"Line":0}},{"line":1269,"address":[55097346],"length":1,"stats":{"Line":0}},{"line":1270,"address":[56831810],"length":1,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[55279968],"length":1,"stats":{"Line":0}},{"line":1276,"address":[55097980],"length":1,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[55097987],"length":1,"stats":{"Line":0}},{"line":1280,"address":[54265952],"length":1,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[56119792],"length":1,"stats":{"Line":5}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[54032883],"length":1,"stats":{"Line":6}},{"line":1291,"address":[54525223],"length":1,"stats":{"Line":5}},{"line":1294,"address":[56120046,56120123],"length":1,"stats":{"Line":0}},{"line":1295,"address":[54525418],"length":1,"stats":{"Line":0}},{"line":1298,"address":[55096959,55098096],"length":1,"stats":{"Line":9}},{"line":1299,"address":[56832525],"length":1,"stats":{"Line":6}},{"line":1301,"address":[55098596],"length":1,"stats":{"Line":5}},{"line":1302,"address":[54266554],"length":1,"stats":{"Line":4}},{"line":1303,"address":[55098676],"length":1,"stats":{"Line":3}},{"line":1304,"address":[],"length":0,"stats":{"Line":5}},{"line":1305,"address":[],"length":0,"stats":{"Line":1}},{"line":1309,"address":[55098725],"length":1,"stats":{"Line":6}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[55280746],"length":1,"stats":{"Line":5}},{"line":1313,"address":[55280821],"length":1,"stats":{"Line":6}},{"line":1315,"address":[55278920],"length":1,"stats":{"Line":0}},{"line":1319,"address":[55278260],"length":1,"stats":{"Line":1}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":2}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[55278342,55278294],"length":1,"stats":{"Line":2}},{"line":1327,"address":[],"length":0,"stats":{"Line":1}},{"line":1330,"address":[56830138],"length":1,"stats":{"Line":1}},{"line":1331,"address":[56830150,56830607,56831083],"length":1,"stats":{"Line":2}},{"line":1332,"address":[54264307],"length":1,"stats":{"Line":1}},{"line":1333,"address":[55096582],"length":1,"stats":{"Line":1}},{"line":1334,"address":[55096737],"length":1,"stats":{"Line":1}},{"line":1335,"address":[56830985],"length":1,"stats":{"Line":1}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":1}},{"line":1339,"address":[55278888],"length":1,"stats":{"Line":1}},{"line":1341,"address":[55278412],"length":1,"stats":{"Line":0}},{"line":1345,"address":[55096137],"length":1,"stats":{"Line":0}},{"line":1347,"address":[54266729,54266830,54264071],"length":1,"stats":{"Line":0}},{"line":1348,"address":[55281063,55280934,55280972],"length":1,"stats":{"Line":0}},{"line":1350,"address":[55099148,55099025],"length":1,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[56833973],"length":1,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[55099888,55099948],"length":1,"stats":{"Line":0}},{"line":1360,"address":[54268067],"length":1,"stats":{"Line":0}},{"line":1363,"address":[54268224,54267627],"length":1,"stats":{"Line":0}},{"line":1364,"address":[55100567],"length":1,"stats":{"Line":0}},{"line":1367,"address":[55099916,55100724,55100985,55102285],"length":1,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[55283885,55282987],"length":1,"stats":{"Line":0}},{"line":1371,"address":[55284114],"length":1,"stats":{"Line":0}},{"line":1376,"address":[55283022],"length":1,"stats":{"Line":0}},{"line":1377,"address":[55101080],"length":1,"stats":{"Line":0}},{"line":1378,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[54268975],"length":1,"stats":{"Line":0}},{"line":1383,"address":[54269055],"length":1,"stats":{"Line":0}},{"line":1385,"address":[55283203],"length":1,"stats":{"Line":0}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[56835497],"length":1,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1397,"address":[55101420],"length":1,"stats":{"Line":0}},{"line":1398,"address":[56835626],"length":1,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[54269359],"length":1,"stats":{"Line":0}},{"line":1403,"address":[55283524],"length":1,"stats":{"Line":0}},{"line":1405,"address":[56835710],"length":1,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[54269541],"length":1,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1419,"address":[55101754],"length":1,"stats":{"Line":0}},{"line":1420,"address":[55283777],"length":1,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":0}},{"line":1422,"address":[55283784],"length":1,"stats":{"Line":0}},{"line":1424,"address":[56836032],"length":1,"stats":{"Line":0}},{"line":1428,"address":[54266968,54267137],"length":1,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1430,"address":[54267389],"length":1,"stats":{"Line":0}},{"line":1431,"address":[56833727],"length":1,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1433,"address":[55099551],"length":1,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[54263716],"length":1,"stats":{"Line":0}},{"line":1442,"address":[55116784],"length":1,"stats":{"Line":10}},{"line":1443,"address":[55116811],"length":1,"stats":{"Line":12}},{"line":1444,"address":[56669049],"length":1,"stats":{"Line":10}},{"line":1445,"address":[54932241],"length":1,"stats":{"Line":12}},{"line":1446,"address":[55117189],"length":1,"stats":{"Line":1}},{"line":1447,"address":[55117196],"length":1,"stats":{"Line":1}},{"line":1448,"address":[56669363],"length":1,"stats":{"Line":1}},{"line":1449,"address":[54100157],"length":1,"stats":{"Line":1}},{"line":1451,"address":[54932025],"length":1,"stats":{"Line":6}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[54932044],"length":1,"stats":{"Line":5}},{"line":1455,"address":[54932059],"length":1,"stats":{"Line":6}},{"line":1456,"address":[56669240],"length":1,"stats":{"Line":2}},{"line":1457,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[55117296,55117382,55117232],"length":1,"stats":{"Line":2}},{"line":1464,"address":[55117482,55117362,55117400],"length":1,"stats":{"Line":2}},{"line":1465,"address":[54932577,54932518,54932605],"length":1,"stats":{"Line":3}},{"line":1466,"address":[],"length":0,"stats":{"Line":1}},{"line":1467,"address":[],"length":0,"stats":{"Line":2}},{"line":1468,"address":[55117574],"length":1,"stats":{"Line":0}},{"line":1469,"address":[55117584,55117610,55117643],"length":1,"stats":{"Line":2}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[54100552],"length":1,"stats":{"Line":1}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[54932797,54932712,54932316],"length":1,"stats":{"Line":4}},{"line":1477,"address":[55117835,55117719,55117755],"length":1,"stats":{"Line":4}},{"line":1478,"address":[],"length":0,"stats":{"Line":6}},{"line":1479,"address":[54100841],"length":1,"stats":{"Line":2}},{"line":1480,"address":[55117848,55117904,55117932,55117942],"length":1,"stats":{"Line":3}},{"line":1481,"address":[54932986],"length":1,"stats":{"Line":0}},{"line":1483,"address":[54100884],"length":1,"stats":{"Line":1}},{"line":1486,"address":[55117284],"length":1,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1488,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1491,"address":[],"length":0,"stats":{"Line":0}},{"line":1493,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":2}},{"line":1495,"address":[55116874],"length":1,"stats":{"Line":5}},{"line":1501,"address":[54947152,54948407,54948401],"length":1,"stats":{"Line":8}},{"line":1502,"address":[55131937,55131815],"length":1,"stats":{"Line":10}},{"line":1504,"address":[54115511],"length":1,"stats":{"Line":5}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[54115287],"length":1,"stats":{"Line":8}},{"line":1511,"address":[],"length":0,"stats":{"Line":22}},{"line":1512,"address":[55132735,55132842,55132330],"length":1,"stats":{"Line":14}},{"line":1513,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[55132345,55132689],"length":1,"stats":{"Line":15}},{"line":1515,"address":[],"length":0,"stats":{"Line":8}},{"line":1516,"address":[54513232],"length":1,"stats":{"Line":0}},{"line":1518,"address":[54116229],"length":1,"stats":{"Line":9}},{"line":1519,"address":[54948447,54947935],"length":1,"stats":{"Line":0}},{"line":1521,"address":[56685474,56685742,56685209],"length":1,"stats":{"Line":0}},{"line":1522,"address":[54948768,54948553,54948650],"length":1,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1524,"address":[56685316],"length":1,"stats":{"Line":0}},{"line":1525,"address":[56108016],"length":1,"stats":{"Line":0}},{"line":1526,"address":[56108032],"length":1,"stats":{"Line":0}},{"line":1528,"address":[54116722],"length":1,"stats":{"Line":0}},{"line":1529,"address":[56685723],"length":1,"stats":{"Line":0}},{"line":1531,"address":[56685455],"length":1,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1539,"address":[54947511],"length":1,"stats":{"Line":4}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1541,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":8}},{"line":1546,"address":[54949094,54949223,54949132],"length":1,"stats":{"Line":8}},{"line":1548,"address":[56685939,56686010],"length":1,"stats":{"Line":8}},{"line":1549,"address":[55133884],"length":1,"stats":{"Line":4}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[56686060],"length":1,"stats":{"Line":4}},{"line":1556,"address":[55134162],"length":1,"stats":{"Line":4}},{"line":1558,"address":[54949838],"length":1,"stats":{"Line":4}},{"line":1559,"address":[55134534],"length":1,"stats":{"Line":4}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[56686772],"length":1,"stats":{"Line":4}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[55134696],"length":1,"stats":{"Line":1}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1567,"address":[54118094],"length":1,"stats":{"Line":1}},{"line":1569,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[55134864],"length":1,"stats":{"Line":1}},{"line":1572,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[55134945],"length":1,"stats":{"Line":1}},{"line":1577,"address":[54950446],"length":1,"stats":{"Line":4}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[54949244],"length":1,"stats":{"Line":0}},{"line":1586,"address":[54947297],"length":1,"stats":{"Line":1}},{"line":1592,"address":[54963280,54964933,54964939],"length":1,"stats":{"Line":4}},{"line":1594,"address":[56699934],"length":1,"stats":{"Line":4}},{"line":1596,"address":[54131254,54131408],"length":1,"stats":{"Line":8}},{"line":1597,"address":[54131709,54131678,54132755,54131744],"length":1,"stats":{"Line":16}},{"line":1598,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":12}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[54131807,54132040],"length":1,"stats":{"Line":8}},{"line":1604,"address":[54132059],"length":1,"stats":{"Line":4}},{"line":1605,"address":[56108864],"length":1,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":4}},{"line":1611,"address":[55149128,55149067,55149232,55149275],"length":1,"stats":{"Line":8}},{"line":1612,"address":[54964655],"length":1,"stats":{"Line":4}},{"line":1613,"address":[56701265,56701328],"length":1,"stats":{"Line":4}},{"line":1616,"address":[56700251],"length":1,"stats":{"Line":4}},{"line":1622,"address":[53645664],"length":1,"stats":{"Line":4}},{"line":1627,"address":[56220647],"length":1,"stats":{"Line":4}},{"line":1628,"address":[56220816],"length":1,"stats":{"Line":4}},{"line":1629,"address":[53646109],"length":1,"stats":{"Line":4}},{"line":1630,"address":[53646280],"length":1,"stats":{"Line":4}},{"line":1632,"address":[53646435],"length":1,"stats":{"Line":4}},{"line":1633,"address":[54669242],"length":1,"stats":{"Line":4}},{"line":1634,"address":[53646538],"length":1,"stats":{"Line":4}},{"line":1635,"address":[56221466],"length":1,"stats":{"Line":4}},{"line":1636,"address":[],"length":0,"stats":{"Line":4}},{"line":1637,"address":[],"length":0,"stats":{"Line":4}},{"line":1639,"address":[53646754],"length":1,"stats":{"Line":4}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1641,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[54669529],"length":1,"stats":{"Line":4}},{"line":1643,"address":[56221699],"length":1,"stats":{"Line":4}},{"line":1644,"address":[],"length":0,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1646,"address":[54669602],"length":1,"stats":{"Line":4}},{"line":1647,"address":[54479014],"length":1,"stats":{"Line":4}},{"line":1648,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[56221787],"length":1,"stats":{"Line":4}},{"line":1653,"address":[54669746],"length":1,"stats":{"Line":4}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1655,"address":[],"length":0,"stats":{"Line":4}},{"line":1657,"address":[54479200],"length":1,"stats":{"Line":4}},{"line":1658,"address":[],"length":0,"stats":{"Line":0}},{"line":1659,"address":[56221962],"length":1,"stats":{"Line":4}},{"line":1661,"address":[],"length":0,"stats":{"Line":4}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1663,"address":[54669934],"length":1,"stats":{"Line":4}},{"line":1667,"address":[54670020],"length":1,"stats":{"Line":4}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[54670027],"length":1,"stats":{"Line":4}},{"line":1671,"address":[56222229],"length":1,"stats":{"Line":4}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":4}},{"line":1675,"address":[54479574],"length":1,"stats":{"Line":4}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[53647469],"length":1,"stats":{"Line":4}},{"line":1681,"address":[56222414],"length":1,"stats":{"Line":4}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":4}},{"line":1685,"address":[56222511],"length":1,"stats":{"Line":4}},{"line":1686,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":4}},{"line":1689,"address":[56222595],"length":1,"stats":{"Line":4}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[54479861],"length":1,"stats":{"Line":4}},{"line":1695,"address":[54479944],"length":1,"stats":{"Line":4}},{"line":1696,"address":[54670627],"length":1,"stats":{"Line":4}},{"line":1698,"address":[56222808],"length":1,"stats":{"Line":4}},{"line":1699,"address":[54670703],"length":1,"stats":{"Line":4}},{"line":1702,"address":[56222865],"length":1,"stats":{"Line":4}},{"line":1703,"address":[53648060],"length":1,"stats":{"Line":4}},{"line":1704,"address":[54670805],"length":1,"stats":{"Line":4}},{"line":1707,"address":[56222967],"length":1,"stats":{"Line":4}},{"line":1708,"address":[56223012],"length":1,"stats":{"Line":4}},{"line":1709,"address":[54480282],"length":1,"stats":{"Line":4}},{"line":1713,"address":[54480333],"length":1,"stats":{"Line":4}},{"line":1714,"address":[],"length":0,"stats":{"Line":4}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[54671001],"length":1,"stats":{"Line":4}},{"line":1718,"address":[],"length":0,"stats":{"Line":4}},{"line":1719,"address":[],"length":0,"stats":{"Line":4}},{"line":1720,"address":[54671300],"length":1,"stats":{"Line":4}},{"line":1723,"address":[54480745],"length":1,"stats":{"Line":4}},{"line":1725,"address":[54671393],"length":1,"stats":{"Line":4}},{"line":1726,"address":[],"length":0,"stats":{"Line":0}},{"line":1728,"address":[],"length":0,"stats":{"Line":0}},{"line":1729,"address":[],"length":0,"stats":{"Line":0}},{"line":1730,"address":[],"length":0,"stats":{"Line":4}},{"line":1731,"address":[54480802],"length":1,"stats":{"Line":4}},{"line":1732,"address":[],"length":0,"stats":{"Line":4}},{"line":1733,"address":[],"length":0,"stats":{"Line":4}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1736,"address":[56223625],"length":1,"stats":{"Line":4}},{"line":1737,"address":[56223635],"length":1,"stats":{"Line":4}},{"line":1738,"address":[53648828],"length":1,"stats":{"Line":4}},{"line":1744,"address":[],"length":0,"stats":{"Line":4}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1747,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":0}},{"line":1749,"address":[54671735],"length":1,"stats":{"Line":4}},{"line":1750,"address":[53649020],"length":1,"stats":{"Line":4}},{"line":1751,"address":[54481166],"length":1,"stats":{"Line":4}},{"line":1752,"address":[56223916],"length":1,"stats":{"Line":4}},{"line":1754,"address":[],"length":0,"stats":{"Line":0}},{"line":1755,"address":[54481226],"length":1,"stats":{"Line":4}},{"line":1756,"address":[53649124],"length":1,"stats":{"Line":4}},{"line":1757,"address":[53649158],"length":1,"stats":{"Line":4}},{"line":1763,"address":[],"length":0,"stats":{"Line":4}},{"line":1764,"address":[],"length":0,"stats":{"Line":0}},{"line":1765,"address":[54672040],"length":1,"stats":{"Line":4}},{"line":1767,"address":[],"length":0,"stats":{"Line":4}},{"line":1768,"address":[],"length":0,"stats":{"Line":4}},{"line":1769,"address":[54481737],"length":1,"stats":{"Line":4}},{"line":1772,"address":[],"length":0,"stats":{"Line":4}},{"line":1773,"address":[54481819],"length":1,"stats":{"Line":4}},{"line":1774,"address":[],"length":0,"stats":{"Line":0}},{"line":1776,"address":[],"length":0,"stats":{"Line":0}},{"line":1777,"address":[],"length":0,"stats":{"Line":4}},{"line":1781,"address":[54481958],"length":1,"stats":{"Line":4}},{"line":1782,"address":[],"length":0,"stats":{"Line":0}},{"line":1784,"address":[],"length":0,"stats":{"Line":0}},{"line":1785,"address":[56224685],"length":1,"stats":{"Line":4}},{"line":1791,"address":[56224815],"length":1,"stats":{"Line":4}},{"line":1792,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[54482120],"length":1,"stats":{"Line":4}},{"line":1799,"address":[],"length":0,"stats":{"Line":4}},{"line":1800,"address":[],"length":0,"stats":{"Line":0}},{"line":1801,"address":[54482353],"length":1,"stats":{"Line":4}},{"line":1809,"address":[54482571],"length":1,"stats":{"Line":4}},{"line":1810,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[53650466],"length":1,"stats":{"Line":4}},{"line":1813,"address":[54673243],"length":1,"stats":{"Line":4}},{"line":1814,"address":[54673298],"length":1,"stats":{"Line":4}},{"line":1815,"address":[],"length":0,"stats":{"Line":0}},{"line":1816,"address":[53650603],"length":1,"stats":{"Line":5}},{"line":1818,"address":[53650670],"length":1,"stats":{"Line":4}},{"line":1819,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[53650688],"length":1,"stats":{"Line":5}},{"line":1829,"address":[56225716],"length":1,"stats":{"Line":4}},{"line":1831,"address":[56225734],"length":1,"stats":{"Line":5}},{"line":1832,"address":[54673637],"length":1,"stats":{"Line":4}},{"line":1838,"address":[54483314],"length":1,"stats":{"Line":5}},{"line":1839,"address":[54673916],"length":1,"stats":{"Line":5}},{"line":1842,"address":[53651373],"length":1,"stats":{"Line":6}},{"line":1843,"address":[],"length":0,"stats":{"Line":0}},{"line":1844,"address":[53651380],"length":1,"stats":{"Line":6}},{"line":1846,"address":[54674155],"length":1,"stats":{"Line":6}},{"line":1848,"address":[],"length":0,"stats":{"Line":6}},{"line":1849,"address":[],"length":0,"stats":{"Line":6}},{"line":1850,"address":[],"length":0,"stats":{"Line":6}},{"line":1851,"address":[],"length":0,"stats":{"Line":6}},{"line":1852,"address":[],"length":0,"stats":{"Line":5}},{"line":1858,"address":[53651766],"length":1,"stats":{"Line":6}},{"line":1859,"address":[53651953],"length":1,"stats":{"Line":4}},{"line":1860,"address":[54674691],"length":1,"stats":{"Line":5}},{"line":1863,"address":[54484176],"length":1,"stats":{"Line":5}},{"line":1864,"address":[56226885],"length":1,"stats":{"Line":4}},{"line":1865,"address":[54674816],"length":1,"stats":{"Line":5}},{"line":1866,"address":[54674865],"length":1,"stats":{"Line":4}},{"line":1869,"address":[54674926],"length":1,"stats":{"Line":5}},{"line":1870,"address":[56227059],"length":1,"stats":{"Line":5}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1872,"address":[54484382],"length":1,"stats":{"Line":5}},{"line":1874,"address":[54484632],"length":1,"stats":{"Line":6}},{"line":1875,"address":[],"length":0,"stats":{"Line":5}},{"line":1876,"address":[53652403],"length":1,"stats":{"Line":6}},{"line":1877,"address":[],"length":0,"stats":{"Line":6}},{"line":1878,"address":[56227278],"length":1,"stats":{"Line":6}},{"line":1881,"address":[54484848],"length":1,"stats":{"Line":5}},{"line":1885,"address":[54704384],"length":1,"stats":{"Line":2}},{"line":1890,"address":[54704487],"length":1,"stats":{"Line":3}},{"line":1891,"address":[56256768],"length":1,"stats":{"Line":3}},{"line":1892,"address":[53682525],"length":1,"stats":{"Line":3}},{"line":1893,"address":[54704994],"length":1,"stats":{"Line":3}},{"line":1895,"address":[53682851],"length":1,"stats":{"Line":2}},{"line":1896,"address":[],"length":0,"stats":{"Line":2}},{"line":1897,"address":[53682948],"length":1,"stats":{"Line":2}},{"line":1898,"address":[54515113],"length":1,"stats":{"Line":2}},{"line":1900,"address":[54515158],"length":1,"stats":{"Line":2}},{"line":1901,"address":[],"length":0,"stats":{"Line":0}},{"line":1902,"address":[],"length":0,"stats":{"Line":0}},{"line":1903,"address":[53683058],"length":1,"stats":{"Line":2}},{"line":1904,"address":[54705409],"length":1,"stats":{"Line":2}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1906,"address":[],"length":0,"stats":{"Line":0}},{"line":1907,"address":[],"length":0,"stats":{"Line":2}},{"line":1909,"address":[],"length":0,"stats":{"Line":2}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1911,"address":[],"length":0,"stats":{"Line":2}},{"line":1913,"address":[54705592],"length":1,"stats":{"Line":2}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1915,"address":[],"length":0,"stats":{"Line":2}},{"line":1917,"address":[54515498],"length":1,"stats":{"Line":2}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[56257795],"length":1,"stats":{"Line":2}},{"line":1922,"address":[],"length":0,"stats":{"Line":3}},{"line":1923,"address":[],"length":0,"stats":{"Line":2}},{"line":1927,"address":[54705821],"length":1,"stats":{"Line":2}},{"line":1928,"address":[56257970],"length":1,"stats":{"Line":2}},{"line":1929,"address":[],"length":0,"stats":{"Line":0}},{"line":1930,"address":[54515690],"length":1,"stats":{"Line":2}},{"line":1932,"address":[56258042],"length":1,"stats":{"Line":2}},{"line":1933,"address":[],"length":0,"stats":{"Line":2}},{"line":1934,"address":[56258273],"length":1,"stats":{"Line":2}},{"line":1937,"address":[54516052],"length":1,"stats":{"Line":2}},{"line":1938,"address":[],"length":0,"stats":{"Line":2}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[56258378],"length":1,"stats":{"Line":2}},{"line":1942,"address":[53684073],"length":1,"stats":{"Line":2}},{"line":1943,"address":[],"length":0,"stats":{"Line":0}},{"line":1944,"address":[53684080],"length":1,"stats":{"Line":2}},{"line":1946,"address":[56258554],"length":1,"stats":{"Line":2}},{"line":1947,"address":[],"length":0,"stats":{"Line":0}},{"line":1949,"address":[],"length":0,"stats":{"Line":0}},{"line":1950,"address":[],"length":0,"stats":{"Line":0}},{"line":1951,"address":[56258569],"length":1,"stats":{"Line":2}},{"line":1952,"address":[56258579],"length":1,"stats":{"Line":2}},{"line":1953,"address":[53684223],"length":1,"stats":{"Line":2}},{"line":1954,"address":[54516362],"length":1,"stats":{"Line":2}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[54516392],"length":1,"stats":{"Line":2}},{"line":1958,"address":[56258678],"length":1,"stats":{"Line":2}},{"line":1959,"address":[53684324],"length":1,"stats":{"Line":2}},{"line":1965,"address":[],"length":0,"stats":{"Line":2}},{"line":1966,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1969,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[56258875],"length":1,"stats":{"Line":2}},{"line":1971,"address":[53684501],"length":1,"stats":{"Line":2}},{"line":1972,"address":[56258918],"length":1,"stats":{"Line":2}},{"line":1973,"address":[54516674],"length":1,"stats":{"Line":2}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1976,"address":[56258974],"length":1,"stats":{"Line":2}},{"line":1977,"address":[54706872],"length":1,"stats":{"Line":2}},{"line":1978,"address":[56259017],"length":1,"stats":{"Line":2}},{"line":1984,"address":[56259158],"length":1,"stats":{"Line":2}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1986,"address":[56259165],"length":1,"stats":{"Line":2}},{"line":1988,"address":[],"length":0,"stats":{"Line":3}},{"line":1989,"address":[56259412],"length":1,"stats":{"Line":2}},{"line":1990,"address":[56259461],"length":1,"stats":{"Line":2}},{"line":1993,"address":[54517258],"length":1,"stats":{"Line":3}},{"line":1994,"address":[56259540],"length":1,"stats":{"Line":3}},{"line":1995,"address":[],"length":0,"stats":{"Line":0}},{"line":1996,"address":[],"length":0,"stats":{"Line":3}},{"line":1998,"address":[],"length":0,"stats":{"Line":3}},{"line":2000,"address":[54517568],"length":1,"stats":{"Line":2}},{"line":2004,"address":[53666464],"length":1,"stats":{"Line":2}},{"line":2009,"address":[54689095],"length":1,"stats":{"Line":2}},{"line":2010,"address":[53666738],"length":1,"stats":{"Line":2}},{"line":2011,"address":[],"length":0,"stats":{"Line":2}},{"line":2012,"address":[54499192],"length":1,"stats":{"Line":2}},{"line":2014,"address":[],"length":0,"stats":{"Line":2}},{"line":2015,"address":[53667279],"length":1,"stats":{"Line":2}},{"line":2016,"address":[54689852],"length":1,"stats":{"Line":2}},{"line":2017,"address":[54499497],"length":1,"stats":{"Line":2}},{"line":2019,"address":[56242062],"length":1,"stats":{"Line":2}},{"line":2020,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2022,"address":[54499554],"length":1,"stats":{"Line":2}},{"line":2023,"address":[],"length":0,"stats":{"Line":2}},{"line":2024,"address":[],"length":0,"stats":{"Line":0}},{"line":2025,"address":[],"length":0,"stats":{"Line":0}},{"line":2026,"address":[54690032],"length":1,"stats":{"Line":2}},{"line":2028,"address":[54499697],"length":1,"stats":{"Line":2}},{"line":2029,"address":[],"length":0,"stats":{"Line":0}},{"line":2030,"address":[54499704],"length":1,"stats":{"Line":2}},{"line":2032,"address":[56242312],"length":1,"stats":{"Line":2}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2034,"address":[53667691],"length":1,"stats":{"Line":2}},{"line":2036,"address":[54499882],"length":1,"stats":{"Line":2}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2038,"address":[53667777],"length":1,"stats":{"Line":2}},{"line":2041,"address":[],"length":0,"stats":{"Line":2}},{"line":2042,"address":[54690379],"length":1,"stats":{"Line":2}},{"line":2046,"address":[54500030],"length":1,"stats":{"Line":2}},{"line":2047,"address":[],"length":0,"stats":{"Line":2}},{"line":2048,"address":[],"length":0,"stats":{"Line":0}},{"line":2049,"address":[56242585],"length":1,"stats":{"Line":2}},{"line":2051,"address":[54500141],"length":1,"stats":{"Line":2}},{"line":2052,"address":[54500325],"length":1,"stats":{"Line":2}},{"line":2053,"address":[54500375],"length":1,"stats":{"Line":2}},{"line":2056,"address":[53668324],"length":1,"stats":{"Line":2}},{"line":2057,"address":[],"length":0,"stats":{"Line":2}},{"line":2058,"address":[],"length":0,"stats":{"Line":0}},{"line":2059,"address":[54500480],"length":1,"stats":{"Line":2}},{"line":2061,"address":[],"length":0,"stats":{"Line":2}},{"line":2062,"address":[],"length":0,"stats":{"Line":0}},{"line":2063,"address":[56243080],"length":1,"stats":{"Line":2}},{"line":2065,"address":[54691050],"length":1,"stats":{"Line":2}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2070,"address":[54691065],"length":1,"stats":{"Line":2}},{"line":2071,"address":[],"length":0,"stats":{"Line":2}},{"line":2072,"address":[56243220],"length":1,"stats":{"Line":2}},{"line":2073,"address":[54691134],"length":1,"stats":{"Line":2}},{"line":2075,"address":[],"length":0,"stats":{"Line":0}},{"line":2076,"address":[54500776],"length":1,"stats":{"Line":2}},{"line":2077,"address":[53668674],"length":1,"stats":{"Line":2}},{"line":2078,"address":[56243319],"length":1,"stats":{"Line":2}},{"line":2084,"address":[53668860],"length":1,"stats":{"Line":2}},{"line":2085,"address":[],"length":0,"stats":{"Line":0}},{"line":2087,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[53668875],"length":1,"stats":{"Line":2}},{"line":2090,"address":[53668885],"length":1,"stats":{"Line":2}},{"line":2091,"address":[53668919],"length":1,"stats":{"Line":2}},{"line":2092,"address":[54501058],"length":1,"stats":{"Line":2}},{"line":2094,"address":[],"length":0,"stats":{"Line":0}},{"line":2095,"address":[54501088],"length":1,"stats":{"Line":2}},{"line":2096,"address":[54501098],"length":1,"stats":{"Line":2}},{"line":2097,"address":[54691513],"length":1,"stats":{"Line":2}},{"line":2103,"address":[54501276],"length":1,"stats":{"Line":2}},{"line":2104,"address":[],"length":0,"stats":{"Line":0}},{"line":2105,"address":[],"length":0,"stats":{"Line":2}},{"line":2107,"address":[],"length":0,"stats":{"Line":2}},{"line":2108,"address":[53669422],"length":1,"stats":{"Line":2}},{"line":2109,"address":[],"length":0,"stats":{"Line":2}},{"line":2112,"address":[54692015],"length":1,"stats":{"Line":2}},{"line":2113,"address":[53669551],"length":1,"stats":{"Line":2}},{"line":2114,"address":[],"length":0,"stats":{"Line":0}},{"line":2115,"address":[],"length":0,"stats":{"Line":2}},{"line":2117,"address":[54692125],"length":1,"stats":{"Line":2}},{"line":2119,"address":[54501952],"length":1,"stats":{"Line":2}},{"line":2123,"address":[54486720],"length":1,"stats":{"Line":1}},{"line":2128,"address":[54677367],"length":1,"stats":{"Line":1}},{"line":2129,"address":[53654882],"length":1,"stats":{"Line":1}},{"line":2130,"address":[54487165],"length":1,"stats":{"Line":1}},{"line":2131,"address":[56229986],"length":1,"stats":{"Line":1}},{"line":2133,"address":[54487491],"length":1,"stats":{"Line":1}},{"line":2134,"address":[56230183],"length":1,"stats":{"Line":1}},{"line":2135,"address":[56230236],"length":1,"stats":{"Line":1}},{"line":2136,"address":[],"length":0,"stats":{"Line":1}},{"line":2138,"address":[56230334],"length":1,"stats":{"Line":1}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2140,"address":[],"length":0,"stats":{"Line":0}},{"line":2141,"address":[56230346],"length":1,"stats":{"Line":1}},{"line":2142,"address":[54487754],"length":1,"stats":{"Line":1}},{"line":2143,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[54487769],"length":1,"stats":{"Line":1}},{"line":2147,"address":[53655729],"length":1,"stats":{"Line":1}},{"line":2148,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[53655736],"length":1,"stats":{"Line":1}},{"line":2151,"address":[54678472],"length":1,"stats":{"Line":1}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[54487947],"length":1,"stats":{"Line":1}},{"line":2155,"address":[],"length":0,"stats":{"Line":1}},{"line":2156,"address":[],"length":0,"stats":{"Line":0}},{"line":2157,"address":[54678563],"length":1,"stats":{"Line":1}},{"line":2160,"address":[54488116],"length":1,"stats":{"Line":1}},{"line":2161,"address":[54678651],"length":1,"stats":{"Line":1}},{"line":2165,"address":[53656062],"length":1,"stats":{"Line":1}},{"line":2166,"address":[54488211],"length":1,"stats":{"Line":1}},{"line":2167,"address":[],"length":0,"stats":{"Line":0}},{"line":2168,"address":[54488218],"length":1,"stats":{"Line":1}},{"line":2170,"address":[53656173],"length":1,"stats":{"Line":1}},{"line":2171,"address":[54488469],"length":1,"stats":{"Line":1}},{"line":2172,"address":[53656407],"length":1,"stats":{"Line":1}},{"line":2175,"address":[54679102],"length":1,"stats":{"Line":1}},{"line":2176,"address":[53656505],"length":1,"stats":{"Line":1}},{"line":2177,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[54488624],"length":1,"stats":{"Line":1}},{"line":2180,"address":[],"length":0,"stats":{"Line":1}},{"line":2181,"address":[],"length":0,"stats":{"Line":0}},{"line":2182,"address":[54488720],"length":1,"stats":{"Line":1}},{"line":2184,"address":[54679322],"length":1,"stats":{"Line":1}},{"line":2185,"address":[],"length":0,"stats":{"Line":0}},{"line":2187,"address":[],"length":0,"stats":{"Line":0}},{"line":2188,"address":[],"length":0,"stats":{"Line":0}},{"line":2189,"address":[54488819],"length":1,"stats":{"Line":1}},{"line":2190,"address":[56231459],"length":1,"stats":{"Line":1}},{"line":2191,"address":[],"length":0,"stats":{"Line":1}},{"line":2192,"address":[53656778],"length":1,"stats":{"Line":1}},{"line":2194,"address":[],"length":0,"stats":{"Line":0}},{"line":2195,"address":[56231548],"length":1,"stats":{"Line":1}},{"line":2196,"address":[],"length":0,"stats":{"Line":1}},{"line":2197,"address":[54679479],"length":1,"stats":{"Line":1}},{"line":2203,"address":[56231740],"length":1,"stats":{"Line":1}},{"line":2204,"address":[],"length":0,"stats":{"Line":0}},{"line":2206,"address":[],"length":0,"stats":{"Line":0}},{"line":2207,"address":[],"length":0,"stats":{"Line":0}},{"line":2208,"address":[56231755],"length":1,"stats":{"Line":1}},{"line":2209,"address":[54679653],"length":1,"stats":{"Line":1}},{"line":2210,"address":[56231798],"length":1,"stats":{"Line":1}},{"line":2211,"address":[53657090],"length":1,"stats":{"Line":1}},{"line":2213,"address":[],"length":0,"stats":{"Line":0}},{"line":2214,"address":[53657120],"length":1,"stats":{"Line":1}},{"line":2215,"address":[],"length":0,"stats":{"Line":1}},{"line":2216,"address":[54489276],"length":1,"stats":{"Line":1}},{"line":2222,"address":[53657308],"length":1,"stats":{"Line":1}},{"line":2223,"address":[],"length":0,"stats":{"Line":0}},{"line":2224,"address":[],"length":0,"stats":{"Line":1}},{"line":2226,"address":[56232110],"length":1,"stats":{"Line":1}},{"line":2227,"address":[54489678],"length":1,"stats":{"Line":1}},{"line":2228,"address":[54489728],"length":1,"stats":{"Line":1}},{"line":2231,"address":[56232399],"length":1,"stats":{"Line":1}},{"line":2232,"address":[56232420],"length":1,"stats":{"Line":1}},{"line":2233,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[54680318],"length":1,"stats":{"Line":1}},{"line":2236,"address":[],"length":0,"stats":{"Line":1}},{"line":2238,"address":[54680595],"length":1,"stats":{"Line":1}},{"line":2242,"address":[54498128],"length":1,"stats":{"Line":1}},{"line":2247,"address":[54688616],"length":1,"stats":{"Line":1}},{"line":2248,"address":[53666225],"length":1,"stats":{"Line":1}},{"line":2249,"address":[56241003],"length":1,"stats":{"Line":1}},{"line":2250,"address":[],"length":0,"stats":{"Line":0}},{"line":2251,"address":[],"length":0,"stats":{"Line":1}},{"line":2253,"address":[],"length":0,"stats":{"Line":1}},{"line":2257,"address":[55344704],"length":1,"stats":{"Line":1}},{"line":2262,"address":[],"length":0,"stats":{"Line":1}},{"line":2263,"address":[54332082],"length":1,"stats":{"Line":1}},{"line":2264,"address":[],"length":0,"stats":{"Line":1}},{"line":2265,"address":[55164536],"length":1,"stats":{"Line":1}},{"line":2268,"address":[],"length":0,"stats":{"Line":1}},{"line":2269,"address":[],"length":0,"stats":{"Line":0}},{"line":2270,"address":[54332602],"length":1,"stats":{"Line":1}},{"line":2274,"address":[56897743],"length":1,"stats":{"Line":1}},{"line":2275,"address":[54332733],"length":1,"stats":{"Line":1}},{"line":2276,"address":[],"length":0,"stats":{"Line":0}},{"line":2277,"address":[55164852],"length":1,"stats":{"Line":1}},{"line":2279,"address":[],"length":0,"stats":{"Line":1}},{"line":2280,"address":[],"length":0,"stats":{"Line":0}},{"line":2281,"address":[56897893],"length":1,"stats":{"Line":1}},{"line":2283,"address":[55165021],"length":1,"stats":{"Line":1}},{"line":2284,"address":[],"length":0,"stats":{"Line":0}},{"line":2285,"address":[56897974],"length":1,"stats":{"Line":1}},{"line":2289,"address":[56898044],"length":1,"stats":{"Line":1}},{"line":2290,"address":[55165144],"length":1,"stats":{"Line":1}},{"line":2291,"address":[56898138],"length":1,"stats":{"Line":1}},{"line":2292,"address":[55165247],"length":1,"stats":{"Line":1}},{"line":2294,"address":[56898254],"length":1,"stats":{"Line":1}},{"line":2295,"address":[],"length":0,"stats":{"Line":1}},{"line":2299,"address":[55346132],"length":1,"stats":{"Line":1}},{"line":2300,"address":[55165386],"length":1,"stats":{"Line":1}},{"line":2301,"address":[56898394],"length":1,"stats":{"Line":1}},{"line":2302,"address":[],"length":0,"stats":{"Line":0}},{"line":2303,"address":[55165458],"length":1,"stats":{"Line":1}},{"line":2305,"address":[55346305],"length":1,"stats":{"Line":1}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2307,"address":[],"length":0,"stats":{"Line":1}},{"line":2309,"address":[],"length":0,"stats":{"Line":1}},{"line":2310,"address":[],"length":0,"stats":{"Line":0}},{"line":2312,"address":[54333527],"length":1,"stats":{"Line":1}},{"line":2313,"address":[54333539],"length":1,"stats":{"Line":1}},{"line":2321,"address":[56898836],"length":1,"stats":{"Line":1}},{"line":2322,"address":[55346703],"length":1,"stats":{"Line":1}},{"line":2323,"address":[],"length":0,"stats":{"Line":0}},{"line":2324,"address":[55346710],"length":1,"stats":{"Line":1}},{"line":2326,"address":[55166026],"length":1,"stats":{"Line":1}},{"line":2327,"address":[55166076],"length":1,"stats":{"Line":1}},{"line":2330,"address":[55166140],"length":1,"stats":{"Line":1}},{"line":2331,"address":[54334065],"length":1,"stats":{"Line":1}},{"line":2332,"address":[],"length":0,"stats":{"Line":0}},{"line":2333,"address":[55166184],"length":1,"stats":{"Line":1}},{"line":2336,"address":[],"length":0,"stats":{"Line":1}},{"line":2337,"address":[],"length":0,"stats":{"Line":0}},{"line":2338,"address":[],"length":0,"stats":{"Line":1}},{"line":2340,"address":[55347095],"length":1,"stats":{"Line":1}},{"line":2341,"address":[54334280],"length":1,"stats":{"Line":1}},{"line":2344,"address":[54334344],"length":1,"stats":{"Line":1}},{"line":2345,"address":[55347229],"length":1,"stats":{"Line":1}},{"line":2346,"address":[],"length":0,"stats":{"Line":0}},{"line":2347,"address":[56899415],"length":1,"stats":{"Line":1}},{"line":2349,"address":[56899503],"length":1,"stats":{"Line":1}},{"line":2350,"address":[55347528],"length":1,"stats":{"Line":1}},{"line":2352,"address":[55166823],"length":1,"stats":{"Line":1}},{"line":2356,"address":[54336592],"length":1,"stats":{"Line":1}},{"line":2362,"address":[55168765],"length":1,"stats":{"Line":1}},{"line":2364,"address":[55349650],"length":1,"stats":{"Line":1}},{"line":2365,"address":[55169040],"length":1,"stats":{"Line":1}},{"line":2366,"address":[],"length":0,"stats":{"Line":0}},{"line":2367,"address":[56901974],"length":1,"stats":{"Line":1}},{"line":2369,"address":[55349866],"length":1,"stats":{"Line":1}},{"line":2370,"address":[56902115],"length":1,"stats":{"Line":1}},{"line":2374,"address":[56901168],"length":1,"stats":{"Line":1}},{"line":2379,"address":[56901240],"length":1,"stats":{"Line":1}},{"line":2380,"address":[],"length":0,"stats":{"Line":1}},{"line":2381,"address":[55168599],"length":1,"stats":{"Line":1}},{"line":2382,"address":[],"length":0,"stats":{"Line":0}},{"line":2383,"address":[55349354],"length":1,"stats":{"Line":1}},{"line":2385,"address":[55349428],"length":1,"stats":{"Line":1}},{"line":2389,"address":[54335664],"length":1,"stats":{"Line":1}},{"line":2394,"address":[55167848],"length":1,"stats":{"Line":1}},{"line":2395,"address":[56900918],"length":1,"stats":{"Line":1}},{"line":2396,"address":[54336023],"length":1,"stats":{"Line":1}},{"line":2397,"address":[],"length":0,"stats":{"Line":0}},{"line":2398,"address":[56901066],"length":1,"stats":{"Line":1}},{"line":2400,"address":[55168218],"length":1,"stats":{"Line":1}},{"line":2404,"address":[56900240],"length":1,"stats":{"Line":1}},{"line":2409,"address":[55348136],"length":1,"stats":{"Line":1}},{"line":2410,"address":[],"length":0,"stats":{"Line":1}},{"line":2411,"address":[54335559],"length":1,"stats":{"Line":1}},{"line":2412,"address":[],"length":0,"stats":{"Line":0}},{"line":2413,"address":[],"length":0,"stats":{"Line":1}},{"line":2415,"address":[55348500],"length":1,"stats":{"Line":1}},{"line":2419,"address":[55166848],"length":1,"stats":{"Line":1}},{"line":2424,"address":[54334808],"length":1,"stats":{"Line":1}},{"line":2425,"address":[],"length":0,"stats":{"Line":1}},{"line":2426,"address":[55167207],"length":1,"stats":{"Line":1}},{"line":2427,"address":[],"length":0,"stats":{"Line":0}},{"line":2428,"address":[55347962],"length":1,"stats":{"Line":1}},{"line":2430,"address":[55348036],"length":1,"stats":{"Line":1}},{"line":2434,"address":[54950992],"length":1,"stats":{"Line":0}},{"line":2438,"address":[56687768],"length":1,"stats":{"Line":0}},{"line":2439,"address":[55135750],"length":1,"stats":{"Line":0}},{"line":2449,"address":[56688054],"length":1,"stats":{"Line":0}},{"line":2450,"address":[56688094],"length":1,"stats":{"Line":0}},{"line":2451,"address":[],"length":0,"stats":{"Line":0}},{"line":2452,"address":[54951385],"length":1,"stats":{"Line":0}},{"line":2455,"address":[54951458],"length":1,"stats":{"Line":0}},{"line":2456,"address":[54951498],"length":1,"stats":{"Line":0}},{"line":2457,"address":[],"length":0,"stats":{"Line":0}},{"line":2458,"address":[],"length":0,"stats":{"Line":0}},{"line":2462,"address":[],"length":0,"stats":{"Line":0}},{"line":2463,"address":[54119547],"length":1,"stats":{"Line":0}},{"line":2464,"address":[],"length":0,"stats":{"Line":0}},{"line":2465,"address":[54119554],"length":1,"stats":{"Line":0}},{"line":2468,"address":[54951730],"length":1,"stats":{"Line":0}},{"line":2472,"address":[55032336],"length":1,"stats":{"Line":0}},{"line":2477,"address":[55032439],"length":1,"stats":{"Line":0}},{"line":2478,"address":[55032608],"length":1,"stats":{"Line":0}},{"line":2479,"address":[],"length":0,"stats":{"Line":0}},{"line":2480,"address":[],"length":0,"stats":{"Line":0}},{"line":2483,"address":[54014643],"length":1,"stats":{"Line":0}},{"line":2484,"address":[],"length":0,"stats":{"Line":0}},{"line":2485,"address":[],"length":0,"stats":{"Line":0}},{"line":2489,"address":[56585311],"length":1,"stats":{"Line":0}},{"line":2490,"address":[54846893],"length":1,"stats":{"Line":0}},{"line":2491,"address":[],"length":0,"stats":{"Line":0}},{"line":2492,"address":[54846900],"length":1,"stats":{"Line":0}},{"line":2494,"address":[],"length":0,"stats":{"Line":0}},{"line":2495,"address":[],"length":0,"stats":{"Line":0}},{"line":2496,"address":[56585461],"length":1,"stats":{"Line":0}},{"line":2498,"address":[54847069],"length":1,"stats":{"Line":0}},{"line":2499,"address":[],"length":0,"stats":{"Line":0}},{"line":2500,"address":[],"length":0,"stats":{"Line":0}},{"line":2504,"address":[54847148],"length":1,"stats":{"Line":0}},{"line":2505,"address":[54015080],"length":1,"stats":{"Line":0}},{"line":2506,"address":[],"length":0,"stats":{"Line":0}},{"line":2507,"address":[54847292],"length":1,"stats":{"Line":0}},{"line":2509,"address":[56585816],"length":1,"stats":{"Line":0}},{"line":2510,"address":[54015247],"length":1,"stats":{"Line":0}},{"line":2514,"address":[54015295],"length":1,"stats":{"Line":0}},{"line":2515,"address":[54847428],"length":1,"stats":{"Line":0}},{"line":2516,"address":[54015381],"length":1,"stats":{"Line":0}},{"line":2517,"address":[],"length":0,"stats":{"Line":0}},{"line":2518,"address":[54847500],"length":1,"stats":{"Line":0}},{"line":2520,"address":[],"length":0,"stats":{"Line":0}},{"line":2521,"address":[],"length":0,"stats":{"Line":0}},{"line":2522,"address":[54847589],"length":1,"stats":{"Line":0}},{"line":2524,"address":[55034013],"length":1,"stats":{"Line":0}},{"line":2525,"address":[],"length":0,"stats":{"Line":0}},{"line":2527,"address":[],"length":0,"stats":{"Line":0}},{"line":2528,"address":[54015581],"length":1,"stats":{"Line":0}},{"line":2536,"address":[54847942],"length":1,"stats":{"Line":0}},{"line":2537,"address":[55034329],"length":1,"stats":{"Line":0}},{"line":2538,"address":[],"length":0,"stats":{"Line":0}},{"line":2539,"address":[55034336],"length":1,"stats":{"Line":0}},{"line":2541,"address":[55034410],"length":1,"stats":{"Line":0}},{"line":2542,"address":[54016006],"length":1,"stats":{"Line":0}},{"line":2545,"address":[54848179],"length":1,"stats":{"Line":0}},{"line":2546,"address":[55034557],"length":1,"stats":{"Line":0}},{"line":2547,"address":[],"length":0,"stats":{"Line":0}},{"line":2548,"address":[54848223],"length":1,"stats":{"Line":0}},{"line":2551,"address":[56586753],"length":1,"stats":{"Line":0}},{"line":2552,"address":[],"length":0,"stats":{"Line":0}},{"line":2553,"address":[56586760],"length":1,"stats":{"Line":0}},{"line":2555,"address":[54848381],"length":1,"stats":{"Line":0}},{"line":2556,"address":[],"length":0,"stats":{"Line":0}},{"line":2559,"address":[55034831],"length":1,"stats":{"Line":0}},{"line":2560,"address":[56586964],"length":1,"stats":{"Line":0}},{"line":2561,"address":[],"length":0,"stats":{"Line":0}},{"line":2562,"address":[54016414],"length":1,"stats":{"Line":0}},{"line":2564,"address":[54016504],"length":1,"stats":{"Line":0}},{"line":2566,"address":[56587263],"length":1,"stats":{"Line":0}},{"line":2570,"address":[54848880],"length":1,"stats":{"Line":0}},{"line":2575,"address":[54848952],"length":1,"stats":{"Line":0}},{"line":2576,"address":[56587536],"length":1,"stats":{"Line":0}},{"line":2577,"address":[],"length":0,"stats":{"Line":0}},{"line":2578,"address":[],"length":0,"stats":{"Line":0}},{"line":2579,"address":[54017128],"length":1,"stats":{"Line":0}},{"line":2580,"address":[],"length":0,"stats":{"Line":0}},{"line":2584,"address":[54849328],"length":1,"stats":{"Line":0}},{"line":2589,"address":[55035736],"length":1,"stats":{"Line":0}},{"line":2590,"address":[56587984],"length":1,"stats":{"Line":0}},{"line":2591,"address":[56588125,56588193],"length":1,"stats":{"Line":0}},{"line":2592,"address":[],"length":0,"stats":{"Line":0}},{"line":2593,"address":[55036020],"length":1,"stats":{"Line":0}},{"line":2594,"address":[54017610],"length":1,"stats":{"Line":0}},{"line":2598,"address":[56244496],"length":1,"stats":{"Line":1}},{"line":2602,"address":[53669959],"length":1,"stats":{"Line":1}},{"line":2603,"address":[],"length":0,"stats":{"Line":1}},{"line":2605,"address":[],"length":0,"stats":{"Line":1}},{"line":2606,"address":[],"length":0,"stats":{"Line":0}},{"line":2607,"address":[],"length":0,"stats":{"Line":0}},{"line":2608,"address":[54692786],"length":1,"stats":{"Line":1}},{"line":2609,"address":[54502459],"length":1,"stats":{"Line":1}},{"line":2610,"address":[],"length":0,"stats":{"Line":0}},{"line":2611,"address":[],"length":0,"stats":{"Line":0}},{"line":2612,"address":[56244962],"length":1,"stats":{"Line":1}},{"line":2614,"address":[56245024],"length":1,"stats":{"Line":1}},{"line":2615,"address":[],"length":0,"stats":{"Line":0}},{"line":2616,"address":[53670429],"length":1,"stats":{"Line":1}},{"line":2619,"address":[54502617],"length":1,"stats":{"Line":1}},{"line":2620,"address":[54693037],"length":1,"stats":{"Line":1}},{"line":2621,"address":[],"length":0,"stats":{"Line":1}},{"line":2622,"address":[56245249],"length":1,"stats":{"Line":1}},{"line":2624,"address":[56245306],"length":1,"stats":{"Line":1}},{"line":2625,"address":[54693201],"length":1,"stats":{"Line":1}},{"line":2629,"address":[],"length":0,"stats":{"Line":1}},{"line":2630,"address":[54693274],"length":1,"stats":{"Line":1}},{"line":2631,"address":[54693346],"length":1,"stats":{"Line":1}},{"line":2632,"address":[53671045],"length":1,"stats":{"Line":1}},{"line":2633,"address":[53671095],"length":1,"stats":{"Line":1}},{"line":2636,"address":[54693635],"length":1,"stats":{"Line":1}},{"line":2637,"address":[54693669],"length":1,"stats":{"Line":1}},{"line":2638,"address":[],"length":0,"stats":{"Line":0}},{"line":2639,"address":[54503306],"length":1,"stats":{"Line":1}},{"line":2641,"address":[54503387],"length":1,"stats":{"Line":1}},{"line":2642,"address":[],"length":0,"stats":{"Line":0}},{"line":2643,"address":[],"length":0,"stats":{"Line":1}},{"line":2646,"address":[54503483],"length":1,"stats":{"Line":1}},{"line":2648,"address":[53671450],"length":1,"stats":{"Line":1}},{"line":2649,"address":[54503749,54503607,54503665],"length":1,"stats":{"Line":2}},{"line":2650,"address":[],"length":0,"stats":{"Line":0}},{"line":2651,"address":[56246090],"length":1,"stats":{"Line":1}},{"line":2652,"address":[54477008,54477024],"length":1,"stats":{"Line":1}},{"line":2654,"address":[54694192],"length":1,"stats":{"Line":1}},{"line":2655,"address":[54504016],"length":1,"stats":{"Line":1}},{"line":2656,"address":[54694423],"length":1,"stats":{"Line":1}},{"line":2659,"address":[53672012],"length":1,"stats":{"Line":1}},{"line":2660,"address":[54694502],"length":1,"stats":{"Line":1}},{"line":2661,"address":[],"length":0,"stats":{"Line":0}},{"line":2662,"address":[54694512],"length":1,"stats":{"Line":1}},{"line":2664,"address":[56246703],"length":1,"stats":{"Line":1}},{"line":2666,"address":[56246901],"length":1,"stats":{"Line":1}},{"line":2670,"address":[54505920],"length":1,"stats":{"Line":1}},{"line":2674,"address":[54505965],"length":1,"stats":{"Line":1}},{"line":2675,"address":[54696402],"length":1,"stats":{"Line":1}},{"line":2676,"address":[54506159],"length":1,"stats":{"Line":1}},{"line":2682,"address":[54051504],"length":1,"stats":{"Line":4}},{"line":2683,"address":[54883694],"length":1,"stats":{"Line":4}},{"line":2684,"address":[54051753],"length":1,"stats":{"Line":5}},{"line":2686,"address":[55069472],"length":1,"stats":{"Line":5}},{"line":2687,"address":[],"length":0,"stats":{"Line":4}},{"line":2688,"address":[56621726],"length":1,"stats":{"Line":5}},{"line":2689,"address":[54052052],"length":1,"stats":{"Line":4}},{"line":2690,"address":[54884217],"length":1,"stats":{"Line":5}},{"line":2691,"address":[54884270],"length":1,"stats":{"Line":4}},{"line":2692,"address":[56621935],"length":1,"stats":{"Line":5}},{"line":2693,"address":[55069828],"length":1,"stats":{"Line":4}},{"line":2695,"address":[54884424],"length":1,"stats":{"Line":6}},{"line":2696,"address":[],"length":0,"stats":{"Line":0}},{"line":2697,"address":[],"length":0,"stats":{"Line":0}},{"line":2698,"address":[56622048],"length":1,"stats":{"Line":4}},{"line":2699,"address":[],"length":0,"stats":{"Line":6}},{"line":2700,"address":[],"length":0,"stats":{"Line":0}},{"line":2701,"address":[],"length":0,"stats":{"Line":0}},{"line":2702,"address":[56622104],"length":1,"stats":{"Line":4}},{"line":2703,"address":[54052429],"length":1,"stats":{"Line":6}},{"line":2704,"address":[],"length":0,"stats":{"Line":0}},{"line":2705,"address":[],"length":0,"stats":{"Line":0}},{"line":2706,"address":[56622163],"length":1,"stats":{"Line":4}},{"line":2707,"address":[56622215],"length":1,"stats":{"Line":6}},{"line":2708,"address":[],"length":0,"stats":{"Line":0}},{"line":2709,"address":[],"length":0,"stats":{"Line":0}},{"line":2710,"address":[56622227],"length":1,"stats":{"Line":4}},{"line":2711,"address":[54052559],"length":1,"stats":{"Line":6}},{"line":2712,"address":[],"length":0,"stats":{"Line":0}},{"line":2713,"address":[],"length":0,"stats":{"Line":0}},{"line":2714,"address":[54052571],"length":1,"stats":{"Line":4}},{"line":2716,"address":[55070228],"length":1,"stats":{"Line":6}},{"line":2718,"address":[],"length":0,"stats":{"Line":0}},{"line":2719,"address":[],"length":0,"stats":{"Line":0}},{"line":2720,"address":[55070235],"length":1,"stats":{"Line":4}},{"line":2721,"address":[],"length":0,"stats":{"Line":0}},{"line":2722,"address":[],"length":0,"stats":{"Line":0}},{"line":2723,"address":[],"length":0,"stats":{"Line":0}},{"line":2724,"address":[],"length":0,"stats":{"Line":0}},{"line":2725,"address":[],"length":0,"stats":{"Line":0}},{"line":2731,"address":[56622536],"length":1,"stats":{"Line":6}},{"line":2732,"address":[56622557],"length":1,"stats":{"Line":4}},{"line":2733,"address":[54884982],"length":1,"stats":{"Line":6}},{"line":2734,"address":[55070443],"length":1,"stats":{"Line":4}},{"line":2736,"address":[54053020],"length":1,"stats":{"Line":7}},{"line":2739,"address":[],"length":0,"stats":{"Line":5}},{"line":2740,"address":[55070652],"length":1,"stats":{"Line":7}},{"line":2741,"address":[55070685],"length":1,"stats":{"Line":5}},{"line":2742,"address":[],"length":0,"stats":{"Line":5}},{"line":2743,"address":[],"length":0,"stats":{"Line":8}},{"line":2744,"address":[],"length":0,"stats":{"Line":0}},{"line":2745,"address":[55070774],"length":1,"stats":{"Line":6}},{"line":2747,"address":[55070856],"length":1,"stats":{"Line":8}},{"line":2748,"address":[],"length":0,"stats":{"Line":0}},{"line":2749,"address":[56623023],"length":1,"stats":{"Line":6}},{"line":2751,"address":[55070941],"length":1,"stats":{"Line":9}},{"line":2752,"address":[54885516],"length":1,"stats":{"Line":7}},{"line":2754,"address":[54053545],"length":1,"stats":{"Line":9}},{"line":2757,"address":[54053603],"length":1,"stats":{"Line":7}},{"line":2758,"address":[56623333],"length":1,"stats":{"Line":9}},{"line":2759,"address":[],"length":0,"stats":{"Line":8}},{"line":2760,"address":[56623382],"length":1,"stats":{"Line":10}},{"line":2762,"address":[55071437],"length":1,"stats":{"Line":10}},{"line":2765,"address":[55071494],"length":1,"stats":{"Line":10}},{"line":2766,"address":[55071515],"length":1,"stats":{"Line":10}},{"line":2767,"address":[56623722],"length":1,"stats":{"Line":10}},{"line":2768,"address":[],"length":0,"stats":{"Line":0}},{"line":2769,"address":[54886137],"length":1,"stats":{"Line":9}},{"line":2771,"address":[56623836],"length":1,"stats":{"Line":8}},{"line":2772,"address":[54886261],"length":1,"stats":{"Line":9}},{"line":2774,"address":[55071916],"length":1,"stats":{"Line":8}},{"line":2777,"address":[55071973],"length":1,"stats":{"Line":9}},{"line":2778,"address":[54054452],"length":1,"stats":{"Line":8}},{"line":2779,"address":[54886603],"length":1,"stats":{"Line":9}},{"line":2780,"address":[],"length":0,"stats":{"Line":0}},{"line":2782,"address":[],"length":0,"stats":{"Line":0}},{"line":2783,"address":[54054509],"length":1,"stats":{"Line":8}},{"line":2787,"address":[54886762],"length":1,"stats":{"Line":9}},{"line":2788,"address":[56624368],"length":1,"stats":{"Line":8}},{"line":2790,"address":[],"length":0,"stats":{"Line":9}},{"line":2793,"address":[56624640],"length":1,"stats":{"Line":8}},{"line":2794,"address":[56624669],"length":1,"stats":{"Line":9}},{"line":2797,"address":[55072566],"length":1,"stats":{"Line":8}},{"line":2798,"address":[55072587],"length":1,"stats":{"Line":9}},{"line":2799,"address":[54887193],"length":1,"stats":{"Line":8}},{"line":2800,"address":[55072636],"length":1,"stats":{"Line":9}},{"line":2803,"address":[56624931],"length":1,"stats":{"Line":8}},{"line":2809,"address":[55168464],"length":1,"stats":{"Line":1}},{"line":2813,"address":[55168560],"length":1,"stats":{"Line":1}},{"line":2814,"address":[54984555],"length":1,"stats":{"Line":1}},{"line":2816,"address":[54152598],"length":1,"stats":{"Line":1}},{"line":2817,"address":[55168929],"length":1,"stats":{"Line":1}},{"line":2818,"address":[55168985],"length":1,"stats":{"Line":1}},{"line":2819,"address":[54984869],"length":1,"stats":{"Line":1}},{"line":2820,"address":[56721257],"length":1,"stats":{"Line":1}},{"line":2821,"address":[54984981],"length":1,"stats":{"Line":1}},{"line":2822,"address":[],"length":0,"stats":{"Line":1}},{"line":2823,"address":[54985093],"length":1,"stats":{"Line":1}},{"line":2825,"address":[55169313],"length":1,"stats":{"Line":1}},{"line":2826,"address":[],"length":0,"stats":{"Line":0}},{"line":2827,"address":[],"length":0,"stats":{"Line":0}},{"line":2828,"address":[54985156],"length":1,"stats":{"Line":1}},{"line":2829,"address":[54985204],"length":1,"stats":{"Line":1}},{"line":2830,"address":[],"length":0,"stats":{"Line":0}},{"line":2831,"address":[],"length":0,"stats":{"Line":0}},{"line":2832,"address":[56721550],"length":1,"stats":{"Line":1}},{"line":2833,"address":[56721600],"length":1,"stats":{"Line":1}},{"line":2834,"address":[],"length":0,"stats":{"Line":0}},{"line":2835,"address":[],"length":0,"stats":{"Line":0}},{"line":2836,"address":[55169455],"length":1,"stats":{"Line":1}},{"line":2837,"address":[],"length":0,"stats":{"Line":1}},{"line":2838,"address":[],"length":0,"stats":{"Line":0}},{"line":2839,"address":[],"length":0,"stats":{"Line":0}},{"line":2840,"address":[54153239],"length":1,"stats":{"Line":1}},{"line":2841,"address":[],"length":0,"stats":{"Line":1}},{"line":2842,"address":[],"length":0,"stats":{"Line":0}},{"line":2843,"address":[],"length":0,"stats":{"Line":0}},{"line":2844,"address":[55169593],"length":1,"stats":{"Line":1}},{"line":2845,"address":[],"length":0,"stats":{"Line":1}},{"line":2846,"address":[],"length":0,"stats":{"Line":0}},{"line":2847,"address":[],"length":0,"stats":{"Line":0}},{"line":2848,"address":[],"length":0,"stats":{"Line":1}},{"line":2850,"address":[54985566],"length":1,"stats":{"Line":1}},{"line":2852,"address":[],"length":0,"stats":{"Line":1}},{"line":2854,"address":[],"length":0,"stats":{"Line":0}},{"line":2855,"address":[],"length":0,"stats":{"Line":0}},{"line":2856,"address":[],"length":0,"stats":{"Line":1}},{"line":2857,"address":[],"length":0,"stats":{"Line":0}},{"line":2858,"address":[],"length":0,"stats":{"Line":0}},{"line":2859,"address":[],"length":0,"stats":{"Line":0}},{"line":2860,"address":[],"length":0,"stats":{"Line":0}},{"line":2861,"address":[],"length":0,"stats":{"Line":0}},{"line":2862,"address":[],"length":0,"stats":{"Line":0}},{"line":2868,"address":[],"length":0,"stats":{"Line":1}},{"line":2869,"address":[55170021],"length":1,"stats":{"Line":1}},{"line":2870,"address":[],"length":0,"stats":{"Line":0}},{"line":2873,"address":[56722258],"length":1,"stats":{"Line":1}},{"line":2874,"address":[55170300],"length":1,"stats":{"Line":1}},{"line":2875,"address":[54986188],"length":1,"stats":{"Line":1}},{"line":2878,"address":[55170413],"length":1,"stats":{"Line":1}},{"line":2879,"address":[55170434],"length":1,"stats":{"Line":1}},{"line":2880,"address":[],"length":0,"stats":{"Line":0}},{"line":2883,"address":[54154252],"length":1,"stats":{"Line":1}},{"line":2884,"address":[],"length":0,"stats":{"Line":0}},{"line":2887,"address":[55170617],"length":1,"stats":{"Line":1}},{"line":2888,"address":[56722823],"length":1,"stats":{"Line":1}},{"line":2889,"address":[],"length":0,"stats":{"Line":0}},{"line":2890,"address":[56722830],"length":1,"stats":{"Line":1}},{"line":2892,"address":[56722918],"length":1,"stats":{"Line":1}},{"line":2893,"address":[],"length":0,"stats":{"Line":0}},{"line":2895,"address":[],"length":0,"stats":{"Line":0}},{"line":2896,"address":[56722932],"length":1,"stats":{"Line":1}},{"line":2897,"address":[55170794],"length":1,"stats":{"Line":1}},{"line":2901,"address":[56723057],"length":1,"stats":{"Line":1}},{"line":2902,"address":[55171099],"length":1,"stats":{"Line":1}},{"line":2903,"address":[55171148],"length":1,"stats":{"Line":1}},{"line":2906,"address":[],"length":0,"stats":{"Line":1}},{"line":2908,"address":[55171233],"length":1,"stats":{"Line":1}},{"line":2909,"address":[],"length":0,"stats":{"Line":1}},{"line":2910,"address":[],"length":0,"stats":{"Line":0}},{"line":2911,"address":[54987146],"length":1,"stats":{"Line":1}},{"line":2917,"address":[],"length":0,"stats":{"Line":1}},{"line":2918,"address":[],"length":0,"stats":{"Line":0}},{"line":2921,"address":[55171612],"length":1,"stats":{"Line":1}},{"line":2923,"address":[55171630],"length":1,"stats":{"Line":1}},{"line":2924,"address":[56723995],"length":1,"stats":{"Line":1}},{"line":2925,"address":[54987497],"length":1,"stats":{"Line":1}},{"line":2926,"address":[56723837],"length":1,"stats":{"Line":1}},{"line":2927,"address":[],"length":0,"stats":{"Line":1}},{"line":2928,"address":[56723920],"length":1,"stats":{"Line":1}},{"line":2933,"address":[54155720],"length":1,"stats":{"Line":1}},{"line":2934,"address":[54988019],"length":1,"stats":{"Line":1}},{"line":2935,"address":[55172213],"length":1,"stats":{"Line":1}},{"line":2938,"address":[55172277],"length":1,"stats":{"Line":1}},{"line":2939,"address":[],"length":0,"stats":{"Line":1}},{"line":2940,"address":[],"length":0,"stats":{"Line":0}},{"line":2941,"address":[],"length":0,"stats":{"Line":1}},{"line":2947,"address":[],"length":0,"stats":{"Line":1}},{"line":2948,"address":[],"length":0,"stats":{"Line":0}},{"line":2951,"address":[54156386],"length":1,"stats":{"Line":1}},{"line":2952,"address":[],"length":0,"stats":{"Line":0}},{"line":2953,"address":[54988508],"length":1,"stats":{"Line":1}},{"line":2955,"address":[54988614],"length":1,"stats":{"Line":1}},{"line":2957,"address":[54988632],"length":1,"stats":{"Line":1}},{"line":2958,"address":[54988845],"length":1,"stats":{"Line":1}},{"line":2959,"address":[55172785],"length":1,"stats":{"Line":1}},{"line":2960,"address":[55172817],"length":1,"stats":{"Line":1}},{"line":2961,"address":[54156604],"length":1,"stats":{"Line":1}},{"line":2962,"address":[55172908],"length":1,"stats":{"Line":1}},{"line":2967,"address":[],"length":0,"stats":{"Line":1}},{"line":2968,"address":[54157065],"length":1,"stats":{"Line":1}},{"line":2969,"address":[54157115],"length":1,"stats":{"Line":1}},{"line":2972,"address":[55173421],"length":1,"stats":{"Line":1}},{"line":2973,"address":[56725626],"length":1,"stats":{"Line":1}},{"line":2974,"address":[],"length":0,"stats":{"Line":1}},{"line":2975,"address":[56725691],"length":1,"stats":{"Line":1}},{"line":2978,"address":[56725752],"length":1,"stats":{"Line":1}},{"line":2980,"address":[],"length":0,"stats":{"Line":1}},{"line":2981,"address":[55173673],"length":1,"stats":{"Line":1}},{"line":2982,"address":[56725901],"length":1,"stats":{"Line":1}},{"line":2983,"address":[],"length":0,"stats":{"Line":0}},{"line":2984,"address":[54157504],"length":1,"stats":{"Line":1}},{"line":2986,"address":[54157576],"length":1,"stats":{"Line":1}},{"line":2987,"address":[],"length":0,"stats":{"Line":0}},{"line":2988,"address":[55173825],"length":1,"stats":{"Line":1}},{"line":2991,"address":[],"length":0,"stats":{"Line":1}},{"line":2993,"address":[55173910],"length":1,"stats":{"Line":1}},{"line":2994,"address":[],"length":0,"stats":{"Line":0}},{"line":2995,"address":[56726082],"length":1,"stats":{"Line":1}},{"line":3000,"address":[54157821],"length":1,"stats":{"Line":1}},{"line":3001,"address":[],"length":0,"stats":{"Line":0}},{"line":3002,"address":[54989943],"length":1,"stats":{"Line":1}},{"line":3008,"address":[55174161],"length":1,"stats":{"Line":1}},{"line":3009,"address":[54157972],"length":1,"stats":{"Line":1}},{"line":3010,"address":[54990141],"length":1,"stats":{"Line":1}},{"line":3011,"address":[],"length":0,"stats":{"Line":0}},{"line":3012,"address":[],"length":0,"stats":{"Line":1}},{"line":3014,"address":[],"length":0,"stats":{"Line":1}},{"line":3015,"address":[],"length":0,"stats":{"Line":0}},{"line":3016,"address":[],"length":0,"stats":{"Line":1}},{"line":3018,"address":[],"length":0,"stats":{"Line":1}},{"line":3019,"address":[],"length":0,"stats":{"Line":0}},{"line":3020,"address":[],"length":0,"stats":{"Line":1}},{"line":3028,"address":[55174641],"length":1,"stats":{"Line":1}},{"line":3029,"address":[],"length":0,"stats":{"Line":0}},{"line":3032,"address":[54158514],"length":1,"stats":{"Line":1}},{"line":3034,"address":[56726920],"length":1,"stats":{"Line":1}},{"line":3035,"address":[54990809],"length":1,"stats":{"Line":1}},{"line":3036,"address":[54990659],"length":1,"stats":{"Line":1}},{"line":3037,"address":[55174812],"length":1,"stats":{"Line":1}},{"line":3038,"address":[56727009],"length":1,"stats":{"Line":1}},{"line":3045,"address":[55175053],"length":1,"stats":{"Line":1}},{"line":3046,"address":[],"length":0,"stats":{"Line":0}},{"line":3047,"address":[55175057],"length":1,"stats":{"Line":1}},{"line":3048,"address":[54990994],"length":1,"stats":{"Line":1}},{"line":3049,"address":[56727325],"length":1,"stats":{"Line":1}},{"line":3052,"address":[],"length":0,"stats":{"Line":1}},{"line":3053,"address":[],"length":0,"stats":{"Line":0}},{"line":3054,"address":[55175223],"length":1,"stats":{"Line":1}},{"line":3056,"address":[56727463],"length":1,"stats":{"Line":1}},{"line":3057,"address":[56727517],"length":1,"stats":{"Line":1}},{"line":3058,"address":[56727573],"length":1,"stats":{"Line":1}},{"line":3059,"address":[54991309],"length":1,"stats":{"Line":1}},{"line":3063,"address":[54159248],"length":1,"stats":{"Line":1}},{"line":3064,"address":[56727659],"length":1,"stats":{"Line":1}},{"line":3065,"address":[],"length":0,"stats":{"Line":0}},{"line":3066,"address":[54991399],"length":1,"stats":{"Line":1}},{"line":3069,"address":[54159389],"length":1,"stats":{"Line":1}},{"line":3070,"address":[],"length":0,"stats":{"Line":0}},{"line":3071,"address":[],"length":0,"stats":{"Line":1}},{"line":3073,"address":[55175704],"length":1,"stats":{"Line":1}},{"line":3074,"address":[56727871],"length":1,"stats":{"Line":1}},{"line":3078,"address":[54159544],"length":1,"stats":{"Line":1}},{"line":3081,"address":[],"length":0,"stats":{"Line":1}},{"line":3082,"address":[],"length":0,"stats":{"Line":0}},{"line":3083,"address":[56727965],"length":1,"stats":{"Line":1}},{"line":3085,"address":[54159675],"length":1,"stats":{"Line":1}},{"line":3086,"address":[54159731],"length":1,"stats":{"Line":1}},{"line":3087,"address":[56728170],"length":1,"stats":{"Line":1}},{"line":3088,"address":[],"length":0,"stats":{"Line":1}},{"line":3091,"address":[54991965],"length":1,"stats":{"Line":1}},{"line":3092,"address":[55176088],"length":1,"stats":{"Line":1}},{"line":3093,"address":[],"length":0,"stats":{"Line":0}},{"line":3096,"address":[55176189],"length":1,"stats":{"Line":1}},{"line":3098,"address":[54159994],"length":1,"stats":{"Line":1}},{"line":3099,"address":[],"length":0,"stats":{"Line":1}},{"line":3103,"address":[],"length":0,"stats":{"Line":1}},{"line":3105,"address":[],"length":0,"stats":{"Line":1}},{"line":3107,"address":[54160306],"length":1,"stats":{"Line":1}},{"line":3108,"address":[],"length":0,"stats":{"Line":0}},{"line":3109,"address":[],"length":0,"stats":{"Line":1}},{"line":3113,"address":[54160410],"length":1,"stats":{"Line":1}},{"line":3114,"address":[54160474],"length":1,"stats":{"Line":1}},{"line":3116,"address":[],"length":0,"stats":{"Line":1}},{"line":3117,"address":[56728905],"length":1,"stats":{"Line":1}},{"line":3120,"address":[54160647],"length":1,"stats":{"Line":1}},{"line":3121,"address":[],"length":0,"stats":{"Line":0}},{"line":3122,"address":[54992766],"length":1,"stats":{"Line":1}},{"line":3125,"address":[56729094],"length":1,"stats":{"Line":1}},{"line":3127,"address":[56729104],"length":1,"stats":{"Line":1}},{"line":3128,"address":[],"length":0,"stats":{"Line":0}},{"line":3129,"address":[54160746],"length":1,"stats":{"Line":1}},{"line":3134,"address":[54992954],"length":1,"stats":{"Line":1}},{"line":3135,"address":[],"length":0,"stats":{"Line":0}},{"line":3136,"address":[56729215],"length":1,"stats":{"Line":1}},{"line":3140,"address":[56729314],"length":1,"stats":{"Line":1}},{"line":3141,"address":[],"length":0,"stats":{"Line":0}},{"line":3142,"address":[54993079],"length":1,"stats":{"Line":1}},{"line":3145,"address":[55177288],"length":1,"stats":{"Line":1}},{"line":3146,"address":[],"length":0,"stats":{"Line":0}},{"line":3147,"address":[54161103],"length":1,"stats":{"Line":1}},{"line":3152,"address":[54993324],"length":1,"stats":{"Line":1}},{"line":3153,"address":[],"length":0,"stats":{"Line":0}},{"line":3154,"address":[54993334],"length":1,"stats":{"Line":1}},{"line":3156,"address":[55177507],"length":1,"stats":{"Line":1}},{"line":3159,"address":[54993490],"length":1,"stats":{"Line":1}},{"line":3160,"address":[],"length":0,"stats":{"Line":0}},{"line":3161,"address":[55177578],"length":1,"stats":{"Line":1}},{"line":3163,"address":[],"length":0,"stats":{"Line":1}},{"line":3164,"address":[],"length":0,"stats":{"Line":0}},{"line":3165,"address":[54161484],"length":1,"stats":{"Line":1}},{"line":3167,"address":[],"length":0,"stats":{"Line":1}},{"line":3168,"address":[],"length":0,"stats":{"Line":0}},{"line":3169,"address":[54161575],"length":1,"stats":{"Line":1}},{"line":3170,"address":[54993739],"length":1,"stats":{"Line":1}},{"line":3171,"address":[],"length":0,"stats":{"Line":0}},{"line":3172,"address":[54993743],"length":1,"stats":{"Line":1}},{"line":3173,"address":[55177872],"length":1,"stats":{"Line":1}},{"line":3174,"address":[],"length":0,"stats":{"Line":0}},{"line":3175,"address":[56730036],"length":1,"stats":{"Line":1}},{"line":3176,"address":[56730088],"length":1,"stats":{"Line":1}},{"line":3177,"address":[54993907],"length":1,"stats":{"Line":1}},{"line":3178,"address":[54161864],"length":1,"stats":{"Line":1}},{"line":3179,"address":[54161871],"length":1,"stats":{"Line":1}},{"line":3183,"address":[55178110],"length":1,"stats":{"Line":1}},{"line":3184,"address":[54161967],"length":1,"stats":{"Line":1}},{"line":3185,"address":[56730322],"length":1,"stats":{"Line":1}},{"line":3189,"address":[55178212],"length":1,"stats":{"Line":1}},{"line":3190,"address":[55178241],"length":1,"stats":{"Line":1}},{"line":3191,"address":[],"length":0,"stats":{"Line":0}},{"line":3192,"address":[54162064],"length":1,"stats":{"Line":1}},{"line":3195,"address":[],"length":0,"stats":{"Line":1}},{"line":3196,"address":[],"length":0,"stats":{"Line":0}},{"line":3197,"address":[55178350],"length":1,"stats":{"Line":1}},{"line":3199,"address":[54994360],"length":1,"stats":{"Line":1}},{"line":3201,"address":[56730609],"length":1,"stats":{"Line":1}},{"line":3202,"address":[56730624],"length":1,"stats":{"Line":1}},{"line":3206,"address":[],"length":0,"stats":{"Line":1}},{"line":3209,"address":[54162540],"length":1,"stats":{"Line":1}},{"line":3210,"address":[54162569],"length":1,"stats":{"Line":1}},{"line":3211,"address":[],"length":0,"stats":{"Line":0}},{"line":3212,"address":[],"length":0,"stats":{"Line":1}},{"line":3215,"address":[54994793],"length":1,"stats":{"Line":1}},{"line":3216,"address":[],"length":0,"stats":{"Line":0}},{"line":3217,"address":[54162699],"length":1,"stats":{"Line":1}},{"line":3223,"address":[],"length":0,"stats":{"Line":1}},{"line":3224,"address":[],"length":0,"stats":{"Line":0}},{"line":3227,"address":[],"length":0,"stats":{"Line":1}},{"line":3228,"address":[],"length":0,"stats":{"Line":0}},{"line":3229,"address":[],"length":0,"stats":{"Line":1}},{"line":3231,"address":[],"length":0,"stats":{"Line":1}},{"line":3233,"address":[],"length":0,"stats":{"Line":1}},{"line":3234,"address":[55179536],"length":1,"stats":{"Line":1}},{"line":3235,"address":[56731499],"length":1,"stats":{"Line":1}},{"line":3236,"address":[],"length":0,"stats":{"Line":1}},{"line":3237,"address":[55179408],"length":1,"stats":{"Line":1}},{"line":3238,"address":[56731622],"length":1,"stats":{"Line":1}},{"line":3243,"address":[54163509],"length":1,"stats":{"Line":1}},{"line":3245,"address":[],"length":0,"stats":{"Line":1}},{"line":3246,"address":[56731873],"length":1,"stats":{"Line":1}},{"line":3250,"address":[54995855],"length":1,"stats":{"Line":1}},{"line":3253,"address":[56732130],"length":1,"stats":{"Line":1}},{"line":3254,"address":[54995942],"length":1,"stats":{"Line":1}},{"line":3255,"address":[],"length":0,"stats":{"Line":0}},{"line":3256,"address":[54163840],"length":1,"stats":{"Line":1}},{"line":3259,"address":[54163942],"length":1,"stats":{"Line":1}},{"line":3260,"address":[],"length":0,"stats":{"Line":0}},{"line":3261,"address":[54163960],"length":1,"stats":{"Line":1}},{"line":3267,"address":[56732500],"length":1,"stats":{"Line":1}},{"line":3268,"address":[],"length":0,"stats":{"Line":0}},{"line":3271,"address":[54164278],"length":1,"stats":{"Line":1}},{"line":3273,"address":[56732619],"length":1,"stats":{"Line":1}},{"line":3274,"address":[],"length":0,"stats":{"Line":1}},{"line":3275,"address":[],"length":0,"stats":{"Line":1}},{"line":3276,"address":[56732666],"length":1,"stats":{"Line":1}},{"line":3277,"address":[],"length":0,"stats":{"Line":1}},{"line":3278,"address":[54996538],"length":1,"stats":{"Line":1}},{"line":3283,"address":[54996758],"length":1,"stats":{"Line":1}},{"line":3285,"address":[56732986],"length":1,"stats":{"Line":1}},{"line":3286,"address":[56733001],"length":1,"stats":{"Line":1}},{"line":3290,"address":[56733201],"length":1,"stats":{"Line":1}},{"line":3293,"address":[56733258],"length":1,"stats":{"Line":1}},{"line":3294,"address":[55181127],"length":1,"stats":{"Line":1}},{"line":3295,"address":[],"length":0,"stats":{"Line":0}},{"line":3296,"address":[56733297],"length":1,"stats":{"Line":1}},{"line":3299,"address":[55181229],"length":1,"stats":{"Line":1}},{"line":3300,"address":[],"length":0,"stats":{"Line":0}},{"line":3301,"address":[],"length":0,"stats":{"Line":1}},{"line":3303,"address":[],"length":0,"stats":{"Line":1}},{"line":3304,"address":[54997323],"length":1,"stats":{"Line":1}},{"line":3305,"address":[54165218],"length":1,"stats":{"Line":1}},{"line":3309,"address":[54997381],"length":1,"stats":{"Line":1}},{"line":3310,"address":[56733603],"length":1,"stats":{"Line":1}},{"line":3311,"address":[],"length":0,"stats":{"Line":0}},{"line":3314,"address":[54165392],"length":1,"stats":{"Line":1}},{"line":3316,"address":[55181562],"length":1,"stats":{"Line":1}},{"line":3317,"address":[55181577],"length":1,"stats":{"Line":1}},{"line":3321,"address":[54997747],"length":1,"stats":{"Line":1}},{"line":3322,"address":[56734131],"length":1,"stats":{"Line":1}},{"line":3323,"address":[54165872],"length":1,"stats":{"Line":1}},{"line":3326,"address":[54998045],"length":1,"stats":{"Line":1}},{"line":3327,"address":[56734262],"length":1,"stats":{"Line":1}},{"line":3328,"address":[],"length":0,"stats":{"Line":0}},{"line":3331,"address":[],"length":0,"stats":{"Line":1}},{"line":3332,"address":[56734538],"length":1,"stats":{"Line":1}},{"line":3333,"address":[55182427],"length":1,"stats":{"Line":1}},{"line":3336,"address":[],"length":0,"stats":{"Line":1}},{"line":3337,"address":[54998477],"length":1,"stats":{"Line":1}},{"line":3338,"address":[],"length":0,"stats":{"Line":0}},{"line":3339,"address":[],"length":0,"stats":{"Line":1}},{"line":3341,"address":[56735065],"length":1,"stats":{"Line":1}},{"line":3342,"address":[],"length":0,"stats":{"Line":1}},{"line":3343,"address":[54998641],"length":1,"stats":{"Line":1}},{"line":3344,"address":[54998680],"length":1,"stats":{"Line":1}},{"line":3345,"address":[56734909],"length":1,"stats":{"Line":1}},{"line":3346,"address":[55182788],"length":1,"stats":{"Line":1}},{"line":3347,"address":[54166685],"length":1,"stats":{"Line":1}},{"line":3348,"address":[54166724],"length":1,"stats":{"Line":1}},{"line":3351,"address":[],"length":0,"stats":{"Line":1}},{"line":3355,"address":[54079440],"length":1,"stats":{"Line":0}},{"line":3359,"address":[55096730],"length":1,"stats":{"Line":0}},{"line":3360,"address":[55096899],"length":1,"stats":{"Line":0}},{"line":3362,"address":[54079837],"length":1,"stats":{"Line":0}},{"line":3363,"address":[55097093],"length":1,"stats":{"Line":0}},{"line":3364,"address":[],"length":0,"stats":{"Line":0}},{"line":3365,"address":[56649356],"length":1,"stats":{"Line":0}},{"line":3366,"address":[],"length":0,"stats":{"Line":0}},{"line":3367,"address":[56649462],"length":1,"stats":{"Line":0}},{"line":3368,"address":[54080143],"length":1,"stats":{"Line":0}},{"line":3370,"address":[56649560],"length":1,"stats":{"Line":0}},{"line":3371,"address":[],"length":0,"stats":{"Line":0}},{"line":3372,"address":[],"length":0,"stats":{"Line":0}},{"line":3373,"address":[54912312],"length":1,"stats":{"Line":0}},{"line":3374,"address":[54080245],"length":1,"stats":{"Line":0}},{"line":3375,"address":[],"length":0,"stats":{"Line":0}},{"line":3376,"address":[],"length":0,"stats":{"Line":0}},{"line":3377,"address":[54080257],"length":1,"stats":{"Line":0}},{"line":3378,"address":[54080310],"length":1,"stats":{"Line":0}},{"line":3379,"address":[],"length":0,"stats":{"Line":0}},{"line":3380,"address":[],"length":0,"stats":{"Line":0}},{"line":3381,"address":[55097532],"length":1,"stats":{"Line":0}},{"line":3382,"address":[],"length":0,"stats":{"Line":0}},{"line":3383,"address":[],"length":0,"stats":{"Line":0}},{"line":3384,"address":[],"length":0,"stats":{"Line":0}},{"line":3385,"address":[54080387],"length":1,"stats":{"Line":0}},{"line":3387,"address":[54912594],"length":1,"stats":{"Line":0}},{"line":3389,"address":[],"length":0,"stats":{"Line":0}},{"line":3390,"address":[],"length":0,"stats":{"Line":0}},{"line":3391,"address":[],"length":0,"stats":{"Line":0}},{"line":3392,"address":[],"length":0,"stats":{"Line":0}},{"line":3393,"address":[],"length":0,"stats":{"Line":0}},{"line":3394,"address":[],"length":0,"stats":{"Line":0}},{"line":3395,"address":[],"length":0,"stats":{"Line":0}},{"line":3401,"address":[54080618],"length":1,"stats":{"Line":0}},{"line":3402,"address":[56650006],"length":1,"stats":{"Line":0}},{"line":3403,"address":[54912797],"length":1,"stats":{"Line":0}},{"line":3404,"address":[56650234],"length":1,"stats":{"Line":0}},{"line":3405,"address":[54080919],"length":1,"stats":{"Line":0}},{"line":3408,"address":[54913089],"length":1,"stats":{"Line":0}},{"line":3409,"address":[55098207],"length":1,"stats":{"Line":0}},{"line":3410,"address":[54913299],"length":1,"stats":{"Line":0}},{"line":3411,"address":[],"length":0,"stats":{"Line":0}},{"line":3414,"address":[56650659],"length":1,"stats":{"Line":0}},{"line":3415,"address":[56650701],"length":1,"stats":{"Line":0}},{"line":3416,"address":[],"length":0,"stats":{"Line":0}},{"line":3417,"address":[54913518],"length":1,"stats":{"Line":0}},{"line":3420,"address":[54081467],"length":1,"stats":{"Line":0}},{"line":3421,"address":[54081493],"length":1,"stats":{"Line":0}},{"line":3422,"address":[],"length":0,"stats":{"Line":0}},{"line":3423,"address":[54913615],"length":1,"stats":{"Line":0}},{"line":3426,"address":[56650947],"length":1,"stats":{"Line":0}},{"line":3427,"address":[],"length":0,"stats":{"Line":0}},{"line":3428,"address":[],"length":0,"stats":{"Line":0}},{"line":3430,"address":[55098869],"length":1,"stats":{"Line":0}},{"line":3431,"address":[],"length":0,"stats":{"Line":0}},{"line":3432,"address":[56651260],"length":1,"stats":{"Line":0}},{"line":3435,"address":[56651321],"length":1,"stats":{"Line":0}},{"line":3436,"address":[54081997],"length":1,"stats":{"Line":0}},{"line":3437,"address":[54914293],"length":1,"stats":{"Line":0}},{"line":3438,"address":[54082231],"length":1,"stats":{"Line":0}},{"line":3441,"address":[54914400],"length":1,"stats":{"Line":0}},{"line":3442,"address":[],"length":0,"stats":{"Line":0}},{"line":3443,"address":[],"length":0,"stats":{"Line":0}},{"line":3444,"address":[54082319],"length":1,"stats":{"Line":0}},{"line":3446,"address":[54082609],"length":1,"stats":{"Line":0}},{"line":3447,"address":[56651762],"length":1,"stats":{"Line":0}},{"line":3448,"address":[54914565],"length":1,"stats":{"Line":0}},{"line":3449,"address":[54082492],"length":1,"stats":{"Line":0}},{"line":3450,"address":[54082531],"length":1,"stats":{"Line":0}},{"line":3451,"address":[54082570],"length":1,"stats":{"Line":0}},{"line":3454,"address":[],"length":0,"stats":{"Line":0}},{"line":3458,"address":[55138976],"length":1,"stats":{"Line":0}},{"line":3462,"address":[54122426],"length":1,"stats":{"Line":0}},{"line":3463,"address":[55139219],"length":1,"stats":{"Line":0}},{"line":3465,"address":[54954861],"length":1,"stats":{"Line":0}},{"line":3466,"address":[56691573],"length":1,"stats":{"Line":0}},{"line":3467,"address":[56691626],"length":1,"stats":{"Line":0}},{"line":3468,"address":[56691676],"length":1,"stats":{"Line":0}},{"line":3469,"address":[55139569],"length":1,"stats":{"Line":0}},{"line":3470,"address":[55139622],"length":1,"stats":{"Line":0}},{"line":3471,"address":[54123055],"length":1,"stats":{"Line":0}},{"line":3473,"address":[56691880],"length":1,"stats":{"Line":0}},{"line":3474,"address":[],"length":0,"stats":{"Line":0}},{"line":3475,"address":[],"length":0,"stats":{"Line":0}},{"line":3476,"address":[54955224],"length":1,"stats":{"Line":0}},{"line":3477,"address":[56691936],"length":1,"stats":{"Line":0}},{"line":3478,"address":[],"length":0,"stats":{"Line":0}},{"line":3479,"address":[],"length":0,"stats":{"Line":0}},{"line":3480,"address":[54123169],"length":1,"stats":{"Line":0}},{"line":3481,"address":[],"length":0,"stats":{"Line":0}},{"line":3482,"address":[],"length":0,"stats":{"Line":0}},{"line":3483,"address":[],"length":0,"stats":{"Line":0}},{"line":3484,"address":[54955346],"length":1,"stats":{"Line":0}},{"line":3485,"address":[56692064],"length":1,"stats":{"Line":0}},{"line":3486,"address":[],"length":0,"stats":{"Line":0}},{"line":3487,"address":[],"length":0,"stats":{"Line":0}},{"line":3488,"address":[54955411],"length":1,"stats":{"Line":0}},{"line":3490,"address":[54955506],"length":1,"stats":{"Line":0}},{"line":3492,"address":[],"length":0,"stats":{"Line":0}},{"line":3493,"address":[],"length":0,"stats":{"Line":0}},{"line":3494,"address":[54123401],"length":1,"stats":{"Line":0}},{"line":3495,"address":[],"length":0,"stats":{"Line":0}},{"line":3496,"address":[],"length":0,"stats":{"Line":0}},{"line":3497,"address":[],"length":0,"stats":{"Line":0}},{"line":3498,"address":[],"length":0,"stats":{"Line":0}},{"line":3504,"address":[],"length":0,"stats":{"Line":0}},{"line":3505,"address":[56692326],"length":1,"stats":{"Line":0}},{"line":3506,"address":[],"length":0,"stats":{"Line":0}},{"line":3507,"address":[],"length":0,"stats":{"Line":0}},{"line":3508,"address":[55140398],"length":1,"stats":{"Line":0}},{"line":3510,"address":[],"length":0,"stats":{"Line":0}},{"line":3513,"address":[54955998],"length":1,"stats":{"Line":0}},{"line":3514,"address":[54123912],"length":1,"stats":{"Line":0}},{"line":3515,"address":[],"length":0,"stats":{"Line":0}},{"line":3516,"address":[54123922],"length":1,"stats":{"Line":0}},{"line":3518,"address":[54956108],"length":1,"stats":{"Line":0}},{"line":3519,"address":[54124180],"length":1,"stats":{"Line":0}},{"line":3520,"address":[54124187],"length":1,"stats":{"Line":0}},{"line":3522,"address":[55140837],"length":1,"stats":{"Line":0}},{"line":3525,"address":[54124291],"length":1,"stats":{"Line":0}},{"line":3526,"address":[],"length":0,"stats":{"Line":0}},{"line":3527,"address":[],"length":0,"stats":{"Line":0}},{"line":3528,"address":[56693094],"length":1,"stats":{"Line":0}},{"line":3530,"address":[54956513],"length":1,"stats":{"Line":0}},{"line":3531,"address":[56693348],"length":1,"stats":{"Line":0}},{"line":3532,"address":[55141195],"length":1,"stats":{"Line":0}},{"line":3534,"address":[56693397],"length":1,"stats":{"Line":0}},{"line":3537,"address":[55141298],"length":1,"stats":{"Line":0}},{"line":3538,"address":[56693500],"length":1,"stats":{"Line":0}},{"line":3539,"address":[56693516],"length":1,"stats":{"Line":0}},{"line":3540,"address":[55141363],"length":1,"stats":{"Line":0}},{"line":3542,"address":[],"length":0,"stats":{"Line":0}},{"line":3545,"address":[],"length":0,"stats":{"Line":0}},{"line":3546,"address":[54124894],"length":1,"stats":{"Line":0}},{"line":3547,"address":[54125078],"length":1,"stats":{"Line":0}},{"line":3548,"address":[54957197],"length":1,"stats":{"Line":0}},{"line":3550,"address":[],"length":0,"stats":{"Line":0}},{"line":3553,"address":[54957297],"length":1,"stats":{"Line":0}},{"line":3554,"address":[54125206],"length":1,"stats":{"Line":0}},{"line":3555,"address":[],"length":0,"stats":{"Line":0}},{"line":3556,"address":[54957328],"length":1,"stats":{"Line":0}},{"line":3558,"address":[54125506],"length":1,"stats":{"Line":0}},{"line":3559,"address":[55141907],"length":1,"stats":{"Line":0}},{"line":3560,"address":[54125350],"length":1,"stats":{"Line":0}},{"line":3561,"address":[54957501],"length":1,"stats":{"Line":0}},{"line":3562,"address":[54125428],"length":1,"stats":{"Line":0}},{"line":3563,"address":[54125467],"length":1,"stats":{"Line":0}},{"line":3566,"address":[56694526],"length":1,"stats":{"Line":0}},{"line":3570,"address":[56235744],"length":1,"stats":{"Line":1}},{"line":3574,"address":[],"length":0,"stats":{"Line":1}},{"line":3575,"address":[56235984],"length":1,"stats":{"Line":1}},{"line":3577,"address":[54684025],"length":1,"stats":{"Line":1}},{"line":3578,"address":[53661481],"length":1,"stats":{"Line":1}},{"line":3579,"address":[54493646],"length":1,"stats":{"Line":1}},{"line":3580,"address":[56236287],"length":1,"stats":{"Line":1}},{"line":3581,"address":[54493749],"length":1,"stats":{"Line":1}},{"line":3582,"address":[53661687],"length":1,"stats":{"Line":1}},{"line":3585,"address":[],"length":0,"stats":{"Line":1}},{"line":3586,"address":[],"length":0,"stats":{"Line":0}},{"line":3587,"address":[],"length":0,"stats":{"Line":0}},{"line":3588,"address":[56236444],"length":1,"stats":{"Line":1}},{"line":3589,"address":[54493912],"length":1,"stats":{"Line":1}},{"line":3590,"address":[],"length":0,"stats":{"Line":0}},{"line":3591,"address":[53661807],"length":1,"stats":{"Line":1}},{"line":3593,"address":[54684479],"length":1,"stats":{"Line":1}},{"line":3594,"address":[],"length":0,"stats":{"Line":1}},{"line":3598,"address":[54494064],"length":1,"stats":{"Line":1}},{"line":3599,"address":[53661973],"length":1,"stats":{"Line":1}},{"line":3600,"address":[],"length":0,"stats":{"Line":0}},{"line":3602,"address":[],"length":0,"stats":{"Line":0}},{"line":3603,"address":[53661991],"length":1,"stats":{"Line":1}},{"line":3607,"address":[56236810],"length":1,"stats":{"Line":1}},{"line":3608,"address":[],"length":0,"stats":{"Line":0}},{"line":3609,"address":[54494246],"length":1,"stats":{"Line":1}},{"line":3615,"address":[56237036],"length":1,"stats":{"Line":1}},{"line":3616,"address":[54685106],"length":1,"stats":{"Line":1}},{"line":3617,"address":[56237267],"length":1,"stats":{"Line":1}},{"line":3620,"address":[54494752],"length":1,"stats":{"Line":1}},{"line":3621,"address":[54494773],"length":1,"stats":{"Line":1}},{"line":3622,"address":[],"length":0,"stats":{"Line":0}},{"line":3623,"address":[],"length":0,"stats":{"Line":0}},{"line":3624,"address":[],"length":0,"stats":{"Line":1}},{"line":3625,"address":[],"length":0,"stats":{"Line":1}},{"line":3626,"address":[],"length":0,"stats":{"Line":0}},{"line":3627,"address":[54494848],"length":1,"stats":{"Line":1}},{"line":3629,"address":[53662817],"length":1,"stats":{"Line":1}},{"line":3630,"address":[54494936],"length":1,"stats":{"Line":1}},{"line":3635,"address":[56237556],"length":1,"stats":{"Line":1}},{"line":3636,"address":[],"length":0,"stats":{"Line":1}},{"line":3637,"address":[54495063],"length":1,"stats":{"Line":1}},{"line":3638,"address":[],"length":0,"stats":{"Line":0}},{"line":3639,"address":[],"length":0,"stats":{"Line":1}},{"line":3642,"address":[53663030],"length":1,"stats":{"Line":1}},{"line":3644,"address":[],"length":0,"stats":{"Line":1}},{"line":3645,"address":[],"length":0,"stats":{"Line":0}},{"line":3646,"address":[53663057],"length":1,"stats":{"Line":1}},{"line":3651,"address":[54495300],"length":1,"stats":{"Line":1}},{"line":3652,"address":[],"length":0,"stats":{"Line":0}},{"line":3653,"address":[53663198],"length":1,"stats":{"Line":1}},{"line":3656,"address":[56237962],"length":1,"stats":{"Line":1}},{"line":3657,"address":[],"length":0,"stats":{"Line":1}},{"line":3658,"address":[54495630],"length":1,"stats":{"Line":1}},{"line":3661,"address":[56238251],"length":1,"stats":{"Line":1}},{"line":3662,"address":[53663597],"length":1,"stats":{"Line":1}},{"line":3663,"address":[],"length":0,"stats":{"Line":1}},{"line":3664,"address":[],"length":0,"stats":{"Line":1}},{"line":3665,"address":[56238541],"length":1,"stats":{"Line":1}},{"line":3668,"address":[],"length":0,"stats":{"Line":1}},{"line":3669,"address":[54686508],"length":1,"stats":{"Line":1}},{"line":3670,"address":[],"length":0,"stats":{"Line":0}},{"line":3671,"address":[],"length":0,"stats":{"Line":1}},{"line":3673,"address":[],"length":0,"stats":{"Line":1}},{"line":3674,"address":[],"length":0,"stats":{"Line":1}},{"line":3675,"address":[54496195],"length":1,"stats":{"Line":1}},{"line":3676,"address":[56238792],"length":1,"stats":{"Line":1}},{"line":3679,"address":[54686887],"length":1,"stats":{"Line":1}},{"line":3682,"address":[54785568],"length":1,"stats":{"Line":0}},{"line":3688,"address":[54785671],"length":1,"stats":{"Line":0}},{"line":3689,"address":[54973184],"length":1,"stats":{"Line":0}},{"line":3691,"address":[54973334],"length":1,"stats":{"Line":0}},{"line":3692,"address":[54786038],"length":1,"stats":{"Line":0}},{"line":3693,"address":[53953976],"length":1,"stats":{"Line":0}},{"line":3694,"address":[54973478],"length":1,"stats":{"Line":0}},{"line":3697,"address":[],"length":0,"stats":{"Line":0}},{"line":3698,"address":[],"length":0,"stats":{"Line":0}},{"line":3699,"address":[],"length":0,"stats":{"Line":0}},{"line":3700,"address":[54786195],"length":1,"stats":{"Line":0}},{"line":3701,"address":[54786251],"length":1,"stats":{"Line":0}},{"line":3702,"address":[],"length":0,"stats":{"Line":0}},{"line":3703,"address":[],"length":0,"stats":{"Line":0}},{"line":3705,"address":[56525788],"length":1,"stats":{"Line":0}},{"line":3706,"address":[],"length":0,"stats":{"Line":0}},{"line":3710,"address":[53954282],"length":1,"stats":{"Line":0}},{"line":3713,"address":[56525863],"length":1,"stats":{"Line":0}},{"line":3714,"address":[56525923],"length":1,"stats":{"Line":0}},{"line":3715,"address":[53954426],"length":1,"stats":{"Line":0}},{"line":3716,"address":[],"length":0,"stats":{"Line":0}},{"line":3717,"address":[],"length":0,"stats":{"Line":0}},{"line":3721,"address":[54973946,54973963],"length":1,"stats":{"Line":0}},{"line":3722,"address":[],"length":0,"stats":{"Line":0}},{"line":3723,"address":[56526083,56526068],"length":1,"stats":{"Line":0}},{"line":3728,"address":[54786721],"length":1,"stats":{"Line":0}},{"line":3730,"address":[54974097,54974122],"length":1,"stats":{"Line":0}},{"line":3731,"address":[56526219,56526242],"length":1,"stats":{"Line":0}},{"line":3736,"address":[54786886],"length":1,"stats":{"Line":0}},{"line":3737,"address":[],"length":0,"stats":{"Line":0}},{"line":3738,"address":[],"length":0,"stats":{"Line":0}},{"line":3743,"address":[54786998],"length":1,"stats":{"Line":0}},{"line":3746,"address":[],"length":0,"stats":{"Line":0}},{"line":3747,"address":[],"length":0,"stats":{"Line":0}},{"line":3748,"address":[56526530],"length":1,"stats":{"Line":0}},{"line":3752,"address":[56526612],"length":1,"stats":{"Line":0}},{"line":3753,"address":[],"length":0,"stats":{"Line":0}},{"line":3754,"address":[],"length":0,"stats":{"Line":0}},{"line":3756,"address":[53955230],"length":1,"stats":{"Line":0}},{"line":3757,"address":[54974673],"length":1,"stats":{"Line":0}},{"line":3761,"address":[53955285],"length":1,"stats":{"Line":0}},{"line":3762,"address":[54787418],"length":1,"stats":{"Line":0}},{"line":3763,"address":[54787470],"length":1,"stats":{"Line":0}},{"line":3764,"address":[],"length":0,"stats":{"Line":0}},{"line":3765,"address":[54974800],"length":1,"stats":{"Line":0}},{"line":3768,"address":[],"length":0,"stats":{"Line":0}},{"line":3769,"address":[56527040],"length":1,"stats":{"Line":0}},{"line":3770,"address":[],"length":0,"stats":{"Line":0}},{"line":3771,"address":[56527047],"length":1,"stats":{"Line":0}},{"line":3773,"address":[54787704],"length":1,"stats":{"Line":0}},{"line":3774,"address":[],"length":0,"stats":{"Line":0}},{"line":3775,"address":[54975030],"length":1,"stats":{"Line":0}},{"line":3780,"address":[54975117],"length":1,"stats":{"Line":0}},{"line":3781,"address":[54787847],"length":1,"stats":{"Line":0}},{"line":3782,"address":[53955782],"length":1,"stats":{"Line":0}},{"line":3783,"address":[],"length":0,"stats":{"Line":0}},{"line":3784,"address":[54787901],"length":1,"stats":{"Line":0}},{"line":3786,"address":[],"length":0,"stats":{"Line":0}},{"line":3787,"address":[],"length":0,"stats":{"Line":0}},{"line":3788,"address":[53955871],"length":1,"stats":{"Line":0}},{"line":3792,"address":[],"length":0,"stats":{"Line":0}},{"line":3793,"address":[],"length":0,"stats":{"Line":0}},{"line":3794,"address":[56527503],"length":1,"stats":{"Line":0}},{"line":3796,"address":[],"length":0,"stats":{"Line":0}},{"line":3797,"address":[],"length":0,"stats":{"Line":0}},{"line":3799,"address":[54975474],"length":1,"stats":{"Line":0}},{"line":3800,"address":[],"length":0,"stats":{"Line":0}},{"line":3808,"address":[56527871],"length":1,"stats":{"Line":0}},{"line":3809,"address":[],"length":0,"stats":{"Line":0}},{"line":3810,"address":[],"length":0,"stats":{"Line":0}},{"line":3814,"address":[53956418],"length":1,"stats":{"Line":0}},{"line":3815,"address":[56527963],"length":1,"stats":{"Line":0}},{"line":3817,"address":[56528012],"length":1,"stats":{"Line":0}},{"line":3818,"address":[],"length":0,"stats":{"Line":0}},{"line":3820,"address":[53956534],"length":1,"stats":{"Line":0}},{"line":3823,"address":[54976013],"length":1,"stats":{"Line":0}},{"line":3824,"address":[],"length":0,"stats":{"Line":0}},{"line":3825,"address":[],"length":0,"stats":{"Line":0}},{"line":3827,"address":[],"length":0,"stats":{"Line":0}},{"line":3830,"address":[53956741],"length":1,"stats":{"Line":0}},{"line":3831,"address":[54976184],"length":1,"stats":{"Line":0}},{"line":3832,"address":[],"length":0,"stats":{"Line":0}},{"line":3833,"address":[],"length":0,"stats":{"Line":0}},{"line":3835,"address":[54976350],"length":1,"stats":{"Line":0}},{"line":3836,"address":[54976272],"length":1,"stats":{"Line":0}},{"line":3837,"address":[54976311],"length":1,"stats":{"Line":0}},{"line":3839,"address":[],"length":0,"stats":{"Line":0}},{"line":3843,"address":[56528638],"length":1,"stats":{"Line":0}},{"line":3845,"address":[54789236],"length":1,"stats":{"Line":0}},{"line":3846,"address":[],"length":0,"stats":{"Line":0}},{"line":3847,"address":[53957131],"length":1,"stats":{"Line":0}},{"line":3854,"address":[54789347],"length":1,"stats":{"Line":0}},{"line":3857,"address":[54976693],"length":1,"stats":{"Line":0}},{"line":3859,"address":[54976773],"length":1,"stats":{"Line":0}},{"line":3861,"address":[56528895],"length":1,"stats":{"Line":0}},{"line":3862,"address":[],"length":0,"stats":{"Line":0}},{"line":3863,"address":[56528902],"length":1,"stats":{"Line":0}},{"line":3868,"address":[53957486],"length":1,"stats":{"Line":0}},{"line":3869,"address":[],"length":0,"stats":{"Line":0}},{"line":3870,"address":[53957493],"length":1,"stats":{"Line":0}},{"line":3875,"address":[53957568],"length":1,"stats":{"Line":0}},{"line":3876,"address":[56529094],"length":1,"stats":{"Line":0}},{"line":3879,"address":[54977099],"length":1,"stats":{"Line":0}},{"line":3882,"address":[54789941,54790038],"length":1,"stats":{"Line":0}},{"line":3883,"address":[54977163],"length":1,"stats":{"Line":0}},{"line":3884,"address":[56529282],"length":1,"stats":{"Line":0}},{"line":3885,"address":[53957797],"length":1,"stats":{"Line":0}},{"line":3887,"address":[56529521],"length":1,"stats":{"Line":0}},{"line":3888,"address":[53958020],"length":1,"stats":{"Line":0}},{"line":3890,"address":[],"length":0,"stats":{"Line":0}},{"line":3893,"address":[54977516],"length":1,"stats":{"Line":0}},{"line":3894,"address":[54790254],"length":1,"stats":{"Line":0}},{"line":3895,"address":[53958182],"length":1,"stats":{"Line":0}},{"line":3896,"address":[54977584],"length":1,"stats":{"Line":0}},{"line":3898,"address":[54977626],"length":1,"stats":{"Line":0}},{"line":3901,"address":[56529796],"length":1,"stats":{"Line":0}},{"line":3902,"address":[54790423],"length":1,"stats":{"Line":0}},{"line":3903,"address":[],"length":0,"stats":{"Line":0}},{"line":3904,"address":[54790433],"length":1,"stats":{"Line":0}},{"line":3906,"address":[56529906],"length":1,"stats":{"Line":0}},{"line":3908,"address":[54977992],"length":1,"stats":{"Line":0}},{"line":3913,"address":[54979840],"length":1,"stats":{"Line":0}},{"line":3919,"address":[55164167],"length":1,"stats":{"Line":0}},{"line":3921,"address":[54147983],"length":1,"stats":{"Line":0}},{"line":3924,"address":[55164377],"length":1,"stats":{"Line":0}},{"line":3925,"address":[56716597],"length":1,"stats":{"Line":0}},{"line":3926,"address":[54980262],"length":1,"stats":{"Line":0}},{"line":3927,"address":[],"length":0,"stats":{"Line":0}},{"line":3928,"address":[54148157],"length":1,"stats":{"Line":0}},{"line":3932,"address":[54980344],"length":1,"stats":{"Line":0}},{"line":3933,"address":[],"length":0,"stats":{"Line":0}},{"line":3934,"address":[],"length":0,"stats":{"Line":0}},{"line":3939,"address":[55164679],"length":1,"stats":{"Line":0}},{"line":3941,"address":[54148385],"length":1,"stats":{"Line":0}},{"line":3942,"address":[54148395],"length":1,"stats":{"Line":0}},{"line":3947,"address":[54148503],"length":1,"stats":{"Line":0}},{"line":3948,"address":[],"length":0,"stats":{"Line":0}},{"line":3949,"address":[54980625],"length":1,"stats":{"Line":0}},{"line":3954,"address":[],"length":0,"stats":{"Line":0}},{"line":3955,"address":[],"length":0,"stats":{"Line":0}},{"line":3956,"address":[],"length":0,"stats":{"Line":0}},{"line":3960,"address":[55165042],"length":1,"stats":{"Line":0}},{"line":3961,"address":[],"length":0,"stats":{"Line":0}},{"line":3962,"address":[56717209],"length":1,"stats":{"Line":0}},{"line":3966,"address":[54148793],"length":1,"stats":{"Line":0}},{"line":3967,"address":[56717341],"length":1,"stats":{"Line":0}},{"line":3968,"address":[],"length":0,"stats":{"Line":0}},{"line":3969,"address":[54980959],"length":1,"stats":{"Line":0}},{"line":3970,"address":[54981005],"length":1,"stats":{"Line":0}},{"line":3971,"address":[],"length":0,"stats":{"Line":0}},{"line":3972,"address":[54981009],"length":1,"stats":{"Line":0}},{"line":3974,"address":[],"length":0,"stats":{"Line":0}},{"line":3975,"address":[55165295],"length":1,"stats":{"Line":0}},{"line":3979,"address":[54981117],"length":1,"stats":{"Line":0}},{"line":3980,"address":[],"length":0,"stats":{"Line":0}},{"line":3981,"address":[],"length":0,"stats":{"Line":0}},{"line":3982,"address":[],"length":0,"stats":{"Line":0}},{"line":3983,"address":[54981197],"length":1,"stats":{"Line":0}},{"line":3986,"address":[54149160],"length":1,"stats":{"Line":0}},{"line":3987,"address":[54149215],"length":1,"stats":{"Line":0}},{"line":3988,"address":[],"length":0,"stats":{"Line":0}},{"line":3989,"address":[],"length":0,"stats":{"Line":0}},{"line":3991,"address":[55165645],"length":1,"stats":{"Line":0}},{"line":3992,"address":[],"length":0,"stats":{"Line":0}},{"line":3993,"address":[54981431],"length":1,"stats":{"Line":0}},{"line":3998,"address":[55165739],"length":1,"stats":{"Line":0}},{"line":3999,"address":[54981567],"length":1,"stats":{"Line":0}},{"line":4000,"address":[54981614],"length":1,"stats":{"Line":0}},{"line":4001,"address":[],"length":0,"stats":{"Line":0}},{"line":4002,"address":[],"length":0,"stats":{"Line":0}},{"line":4004,"address":[56718073],"length":1,"stats":{"Line":0}},{"line":4005,"address":[],"length":0,"stats":{"Line":0}},{"line":4006,"address":[55165920],"length":1,"stats":{"Line":0}},{"line":4010,"address":[54981791],"length":1,"stats":{"Line":0}},{"line":4011,"address":[],"length":0,"stats":{"Line":0}},{"line":4012,"address":[],"length":0,"stats":{"Line":0}},{"line":4014,"address":[54149753],"length":1,"stats":{"Line":0}},{"line":4015,"address":[],"length":0,"stats":{"Line":0}},{"line":4017,"address":[56718256],"length":1,"stats":{"Line":0}},{"line":4018,"address":[56718271],"length":1,"stats":{"Line":0}},{"line":4026,"address":[55166381],"length":1,"stats":{"Line":0}},{"line":4027,"address":[],"length":0,"stats":{"Line":0}},{"line":4028,"address":[55166388],"length":1,"stats":{"Line":0}},{"line":4032,"address":[55166469],"length":1,"stats":{"Line":0}},{"line":4033,"address":[],"length":0,"stats":{"Line":0}},{"line":4038,"address":[54982327],"length":1,"stats":{"Line":0}},{"line":4040,"address":[54150225],"length":1,"stats":{"Line":0}},{"line":4041,"address":[],"length":0,"stats":{"Line":0}},{"line":4042,"address":[55166550],"length":1,"stats":{"Line":0}},{"line":4047,"address":[54982448],"length":1,"stats":{"Line":0}},{"line":4050,"address":[54150386],"length":1,"stats":{"Line":0}},{"line":4052,"address":[55166780],"length":1,"stats":{"Line":0}},{"line":4054,"address":[],"length":0,"stats":{"Line":0}},{"line":4055,"address":[],"length":0,"stats":{"Line":0}},{"line":4056,"address":[55166797],"length":1,"stats":{"Line":0}},{"line":4061,"address":[55166899],"length":1,"stats":{"Line":0}},{"line":4062,"address":[],"length":0,"stats":{"Line":0}},{"line":4063,"address":[55166906],"length":1,"stats":{"Line":0}},{"line":4066,"address":[56719139],"length":1,"stats":{"Line":0}},{"line":4068,"address":[],"length":0,"stats":{"Line":0}},{"line":4069,"address":[],"length":0,"stats":{"Line":0}},{"line":4070,"address":[],"length":0,"stats":{"Line":0}},{"line":4075,"address":[],"length":0,"stats":{"Line":0}},{"line":4078,"address":[54983139,54983042],"length":1,"stats":{"Line":0}},{"line":4079,"address":[55167170],"length":1,"stats":{"Line":0}},{"line":4080,"address":[],"length":0,"stats":{"Line":0}},{"line":4081,"address":[56719363],"length":1,"stats":{"Line":0}},{"line":4083,"address":[55167416],"length":1,"stats":{"Line":0}},{"line":4084,"address":[56719583],"length":1,"stats":{"Line":0}},{"line":4086,"address":[54151164],"length":1,"stats":{"Line":0}},{"line":4089,"address":[54151222],"length":1,"stats":{"Line":0}},{"line":4092,"address":[55167557],"length":1,"stats":{"Line":0}},{"line":4096,"address":[56719781],"length":1,"stats":{"Line":0}},{"line":4098,"address":[],"length":0,"stats":{"Line":0}},{"line":4099,"address":[],"length":0,"stats":{"Line":0}},{"line":4100,"address":[56719798],"length":1,"stats":{"Line":0}},{"line":4105,"address":[54983555],"length":1,"stats":{"Line":0}},{"line":4106,"address":[],"length":0,"stats":{"Line":0}},{"line":4107,"address":[54983562],"length":1,"stats":{"Line":0}},{"line":4110,"address":[],"length":0,"stats":{"Line":0}},{"line":4112,"address":[56719990],"length":1,"stats":{"Line":0}},{"line":4113,"address":[],"length":0,"stats":{"Line":0}},{"line":4114,"address":[56719997],"length":1,"stats":{"Line":0}},{"line":4119,"address":[54151654],"length":1,"stats":{"Line":0}},{"line":4122,"address":[],"length":0,"stats":{"Line":0}},{"line":4123,"address":[],"length":0,"stats":{"Line":0}},{"line":4125,"address":[54983871],"length":1,"stats":{"Line":0}},{"line":4128,"address":[],"length":0,"stats":{"Line":0}},{"line":4129,"address":[],"length":0,"stats":{"Line":0}},{"line":4130,"address":[],"length":0,"stats":{"Line":0}},{"line":4131,"address":[],"length":0,"stats":{"Line":0}},{"line":4133,"address":[54152007],"length":1,"stats":{"Line":0}},{"line":4134,"address":[],"length":0,"stats":{"Line":0}},{"line":4135,"address":[54984080],"length":1,"stats":{"Line":0}},{"line":4138,"address":[55168415],"length":1,"stats":{"Line":0}},{"line":4143,"address":[54315040],"length":1,"stats":{"Line":0}},{"line":4150,"address":[55328471],"length":1,"stats":{"Line":0}},{"line":4151,"address":[],"length":0,"stats":{"Line":0}},{"line":4152,"address":[55147281],"length":1,"stats":{"Line":0}},{"line":4156,"address":[],"length":0,"stats":{"Line":0}},{"line":4157,"address":[],"length":0,"stats":{"Line":0}},{"line":4158,"address":[56880841],"length":1,"stats":{"Line":0}},{"line":4159,"address":[56880904],"length":1,"stats":{"Line":0}},{"line":4160,"address":[],"length":0,"stats":{"Line":0}},{"line":4161,"address":[55147537],"length":1,"stats":{"Line":0}},{"line":4165,"address":[54315500],"length":1,"stats":{"Line":0}},{"line":4166,"address":[],"length":0,"stats":{"Line":0}},{"line":4167,"address":[55328818],"length":1,"stats":{"Line":0}},{"line":4170,"address":[54315598],"length":1,"stats":{"Line":0}},{"line":4172,"address":[],"length":0,"stats":{"Line":0}},{"line":4173,"address":[56881142],"length":1,"stats":{"Line":0}},{"line":4176,"address":[],"length":0,"stats":{"Line":0}},{"line":4177,"address":[],"length":0,"stats":{"Line":0}},{"line":4178,"address":[55147890],"length":1,"stats":{"Line":0}},{"line":4181,"address":[55147992],"length":1,"stats":{"Line":0}},{"line":4182,"address":[],"length":0,"stats":{"Line":0}},{"line":4183,"address":[],"length":0,"stats":{"Line":0}},{"line":4187,"address":[56881443],"length":1,"stats":{"Line":0}},{"line":4188,"address":[],"length":0,"stats":{"Line":0}},{"line":4189,"address":[56881450],"length":1,"stats":{"Line":0}},{"line":4191,"address":[55329356],"length":1,"stats":{"Line":0}},{"line":4192,"address":[56881582],"length":1,"stats":{"Line":0}},{"line":4193,"address":[],"length":0,"stats":{"Line":0}},{"line":4194,"address":[55148224],"length":1,"stats":{"Line":0}},{"line":4195,"address":[],"length":0,"stats":{"Line":0}},{"line":4196,"address":[55148327],"length":1,"stats":{"Line":0}},{"line":4197,"address":[55148334],"length":1,"stats":{"Line":0}},{"line":4201,"address":[54316270],"length":1,"stats":{"Line":0}},{"line":4202,"address":[56881764],"length":1,"stats":{"Line":0}},{"line":4203,"address":[56881816],"length":1,"stats":{"Line":0}},{"line":4204,"address":[],"length":0,"stats":{"Line":0}},{"line":4205,"address":[],"length":0,"stats":{"Line":0}},{"line":4207,"address":[54316419],"length":1,"stats":{"Line":0}},{"line":4208,"address":[55329763],"length":1,"stats":{"Line":0}},{"line":4209,"address":[],"length":0,"stats":{"Line":0}},{"line":4210,"address":[],"length":0,"stats":{"Line":0}},{"line":4212,"address":[55148671],"length":1,"stats":{"Line":0}},{"line":4213,"address":[],"length":0,"stats":{"Line":0}},{"line":4214,"address":[56882035],"length":1,"stats":{"Line":0}},{"line":4217,"address":[54316652],"length":1,"stats":{"Line":0}},{"line":4218,"address":[],"length":0,"stats":{"Line":0}},{"line":4219,"address":[55330034],"length":1,"stats":{"Line":0}},{"line":4220,"address":[],"length":0,"stats":{"Line":0}},{"line":4221,"address":[55148862],"length":1,"stats":{"Line":0}},{"line":4223,"address":[],"length":0,"stats":{"Line":0}},{"line":4224,"address":[],"length":0,"stats":{"Line":0}},{"line":4225,"address":[55148944],"length":1,"stats":{"Line":0}},{"line":4227,"address":[54316920],"length":1,"stats":{"Line":0}},{"line":4228,"address":[],"length":0,"stats":{"Line":0}},{"line":4229,"address":[56882390],"length":1,"stats":{"Line":0}},{"line":4231,"address":[56882455],"length":1,"stats":{"Line":0}},{"line":4232,"address":[],"length":0,"stats":{"Line":0}},{"line":4234,"address":[56882472],"length":1,"stats":{"Line":0}},{"line":4235,"address":[],"length":0,"stats":{"Line":0}},{"line":4243,"address":[55330589],"length":1,"stats":{"Line":0}},{"line":4244,"address":[],"length":0,"stats":{"Line":0}},{"line":4245,"address":[56882772],"length":1,"stats":{"Line":0}},{"line":4247,"address":[],"length":0,"stats":{"Line":0}},{"line":4248,"address":[55330733],"length":1,"stats":{"Line":0}},{"line":4249,"address":[],"length":0,"stats":{"Line":0}},{"line":4250,"address":[54317465],"length":1,"stats":{"Line":0}},{"line":4252,"address":[],"length":0,"stats":{"Line":0}},{"line":4254,"address":[55330895],"length":1,"stats":{"Line":0}},{"line":4255,"address":[56883081],"length":1,"stats":{"Line":0}},{"line":4258,"address":[56883190],"length":1,"stats":{"Line":0}},{"line":4259,"address":[55149904],"length":1,"stats":{"Line":0}},{"line":4261,"address":[],"length":0,"stats":{"Line":0}},{"line":4262,"address":[54317882],"length":1,"stats":{"Line":0}},{"line":4265,"address":[55150105],"length":1,"stats":{"Line":0}},{"line":4266,"address":[],"length":0,"stats":{"Line":0}},{"line":4267,"address":[56883444],"length":1,"stats":{"Line":0}},{"line":4270,"address":[],"length":0,"stats":{"Line":0}},{"line":4271,"address":[56883527],"length":1,"stats":{"Line":0}},{"line":4274,"address":[],"length":0,"stats":{"Line":0}},{"line":4275,"address":[56883692],"length":1,"stats":{"Line":0}},{"line":4276,"address":[],"length":0,"stats":{"Line":0}},{"line":4277,"address":[],"length":0,"stats":{"Line":0}},{"line":4278,"address":[55331531],"length":1,"stats":{"Line":0}},{"line":4279,"address":[55150437],"length":1,"stats":{"Line":0}},{"line":4280,"address":[55331626],"length":1,"stats":{"Line":0}},{"line":4281,"address":[],"length":0,"stats":{"Line":0}},{"line":4282,"address":[54318372],"length":1,"stats":{"Line":0}},{"line":4284,"address":[],"length":0,"stats":{"Line":0}},{"line":4285,"address":[],"length":0,"stats":{"Line":0}},{"line":4286,"address":[55331742],"length":1,"stats":{"Line":0}},{"line":4289,"address":[55150684],"length":1,"stats":{"Line":0}},{"line":4290,"address":[55331875],"length":1,"stats":{"Line":0}},{"line":4292,"address":[55331928],"length":1,"stats":{"Line":0}},{"line":4293,"address":[55150792],"length":1,"stats":{"Line":0}},{"line":4297,"address":[54318728],"length":1,"stats":{"Line":0}},{"line":4298,"address":[55150874],"length":1,"stats":{"Line":0}},{"line":4300,"address":[55150940],"length":1,"stats":{"Line":0}},{"line":4301,"address":[54318838],"length":1,"stats":{"Line":0}},{"line":4304,"address":[54318949],"length":1,"stats":{"Line":0}},{"line":4305,"address":[],"length":0,"stats":{"Line":0}},{"line":4306,"address":[55151068],"length":1,"stats":{"Line":0}},{"line":4309,"address":[],"length":0,"stats":{"Line":0}},{"line":4310,"address":[],"length":0,"stats":{"Line":0}},{"line":4313,"address":[55151272],"length":1,"stats":{"Line":0}},{"line":4315,"address":[54319215],"length":1,"stats":{"Line":0}},{"line":4316,"address":[55151334],"length":1,"stats":{"Line":0}},{"line":4320,"address":[56884689],"length":1,"stats":{"Line":0}},{"line":4321,"address":[55332534],"length":1,"stats":{"Line":0}},{"line":4326,"address":[55086096],"length":1,"stats":{"Line":0}},{"line":4333,"address":[54254092],"length":1,"stats":{"Line":0}},{"line":4334,"address":[],"length":0,"stats":{"Line":0}},{"line":4335,"address":[],"length":0,"stats":{"Line":0}},{"line":4339,"address":[54254193],"length":1,"stats":{"Line":0}},{"line":4340,"address":[55268523],"length":1,"stats":{"Line":0}},{"line":4341,"address":[55086412],"length":1,"stats":{"Line":0}},{"line":4342,"address":[],"length":0,"stats":{"Line":0}},{"line":4343,"address":[],"length":0,"stats":{"Line":0}},{"line":4344,"address":[56820841],"length":1,"stats":{"Line":0}},{"line":4348,"address":[],"length":0,"stats":{"Line":0}},{"line":4349,"address":[],"length":0,"stats":{"Line":0}},{"line":4350,"address":[],"length":0,"stats":{"Line":0}},{"line":4353,"address":[],"length":0,"stats":{"Line":0}},{"line":4354,"address":[55086711],"length":1,"stats":{"Line":0}},{"line":4356,"address":[54254662],"length":1,"stats":{"Line":0}},{"line":4357,"address":[55268954],"length":1,"stats":{"Line":0}},{"line":4360,"address":[56821239],"length":1,"stats":{"Line":0}},{"line":4361,"address":[],"length":0,"stats":{"Line":0}},{"line":4362,"address":[54254793],"length":1,"stats":{"Line":0}},{"line":4365,"address":[],"length":0,"stats":{"Line":0}},{"line":4366,"address":[],"length":0,"stats":{"Line":0}},{"line":4367,"address":[55087014],"length":1,"stats":{"Line":0}},{"line":4371,"address":[55269261],"length":1,"stats":{"Line":0}},{"line":4372,"address":[],"length":0,"stats":{"Line":0}},{"line":4373,"address":[56821444],"length":1,"stats":{"Line":0}},{"line":4375,"address":[56821532],"length":1,"stats":{"Line":0}},{"line":4376,"address":[54255138],"length":1,"stats":{"Line":0}},{"line":4377,"address":[],"length":0,"stats":{"Line":0}},{"line":4378,"address":[55269416],"length":1,"stats":{"Line":0}},{"line":4379,"address":[55087306],"length":1,"stats":{"Line":0}},{"line":4380,"address":[56821713],"length":1,"stats":{"Line":0}},{"line":4381,"address":[55087382],"length":1,"stats":{"Line":0}},{"line":4385,"address":[],"length":0,"stats":{"Line":0}},{"line":4386,"address":[],"length":0,"stats":{"Line":0}},{"line":4387,"address":[],"length":0,"stats":{"Line":0}},{"line":4388,"address":[55269608,55269654],"length":1,"stats":{"Line":0}},{"line":4389,"address":[],"length":0,"stats":{"Line":0}},{"line":4390,"address":[],"length":0,"stats":{"Line":0}},{"line":4391,"address":[],"length":0,"stats":{"Line":0}},{"line":4392,"address":[55087540],"length":1,"stats":{"Line":0}},{"line":4395,"address":[56821937],"length":1,"stats":{"Line":0}},{"line":4396,"address":[55087638],"length":1,"stats":{"Line":0}},{"line":4397,"address":[],"length":0,"stats":{"Line":0}},{"line":4398,"address":[56821981],"length":1,"stats":{"Line":0}},{"line":4400,"address":[56822051],"length":1,"stats":{"Line":0}},{"line":4401,"address":[56822100],"length":1,"stats":{"Line":0}},{"line":4402,"address":[],"length":0,"stats":{"Line":0}},{"line":4403,"address":[55087773],"length":1,"stats":{"Line":0}},{"line":4405,"address":[55270013],"length":1,"stats":{"Line":0}},{"line":4406,"address":[],"length":0,"stats":{"Line":0}},{"line":4407,"address":[55087864],"length":1,"stats":{"Line":0}},{"line":4410,"address":[56822280],"length":1,"stats":{"Line":0}},{"line":4411,"address":[],"length":0,"stats":{"Line":0}},{"line":4412,"address":[],"length":0,"stats":{"Line":0}},{"line":4413,"address":[],"length":0,"stats":{"Line":0}},{"line":4414,"address":[55088045],"length":1,"stats":{"Line":0}},{"line":4416,"address":[],"length":0,"stats":{"Line":0}},{"line":4417,"address":[],"length":0,"stats":{"Line":0}},{"line":4418,"address":[56822452],"length":1,"stats":{"Line":0}},{"line":4420,"address":[],"length":0,"stats":{"Line":0}},{"line":4421,"address":[],"length":0,"stats":{"Line":0}},{"line":4422,"address":[55088216],"length":1,"stats":{"Line":0}},{"line":4424,"address":[],"length":0,"stats":{"Line":0}},{"line":4425,"address":[],"length":0,"stats":{"Line":0}},{"line":4427,"address":[],"length":0,"stats":{"Line":0}},{"line":4428,"address":[],"length":0,"stats":{"Line":0}},{"line":4436,"address":[55270712],"length":1,"stats":{"Line":0}},{"line":4437,"address":[],"length":0,"stats":{"Line":0}},{"line":4438,"address":[54256462],"length":1,"stats":{"Line":0}},{"line":4440,"address":[55088651],"length":1,"stats":{"Line":0}},{"line":4441,"address":[55270847],"length":1,"stats":{"Line":0}},{"line":4442,"address":[],"length":0,"stats":{"Line":0}},{"line":4443,"address":[55088716],"length":1,"stats":{"Line":0}},{"line":4445,"address":[54256694],"length":1,"stats":{"Line":0}},{"line":4447,"address":[56823182],"length":1,"stats":{"Line":0}},{"line":4448,"address":[],"length":0,"stats":{"Line":0}},{"line":4451,"address":[55271125],"length":1,"stats":{"Line":0}},{"line":4453,"address":[56823349],"length":1,"stats":{"Line":0}},{"line":4455,"address":[55271241],"length":1,"stats":{"Line":0}},{"line":4456,"address":[56823427],"length":1,"stats":{"Line":0}},{"line":4459,"address":[55271357],"length":1,"stats":{"Line":0}},{"line":4460,"address":[],"length":0,"stats":{"Line":0}},{"line":4461,"address":[56823540],"length":1,"stats":{"Line":0}},{"line":4464,"address":[54257196],"length":1,"stats":{"Line":0}},{"line":4465,"address":[55089318],"length":1,"stats":{"Line":0}},{"line":4469,"address":[55271564],"length":1,"stats":{"Line":0}},{"line":4470,"address":[],"length":0,"stats":{"Line":0}},{"line":4471,"address":[],"length":0,"stats":{"Line":0}},{"line":4472,"address":[],"length":0,"stats":{"Line":0}},{"line":4473,"address":[],"length":0,"stats":{"Line":0}},{"line":4474,"address":[55089662],"length":1,"stats":{"Line":0}},{"line":4475,"address":[],"length":0,"stats":{"Line":0}},{"line":4476,"address":[],"length":0,"stats":{"Line":0}},{"line":4477,"address":[55089677],"length":1,"stats":{"Line":0}},{"line":4478,"address":[54257624],"length":1,"stats":{"Line":0}},{"line":4479,"address":[56824076],"length":1,"stats":{"Line":0}},{"line":4480,"address":[],"length":0,"stats":{"Line":0}},{"line":4481,"address":[54257671],"length":1,"stats":{"Line":0}},{"line":4483,"address":[55272009],"length":1,"stats":{"Line":0}},{"line":4484,"address":[],"length":0,"stats":{"Line":0}},{"line":4485,"address":[55272016],"length":1,"stats":{"Line":0}},{"line":4488,"address":[56824279],"length":1,"stats":{"Line":0}},{"line":4489,"address":[55090029],"length":1,"stats":{"Line":0}},{"line":4491,"address":[54257975],"length":1,"stats":{"Line":0}},{"line":4492,"address":[55090094],"length":1,"stats":{"Line":0}},{"line":4496,"address":[55090145],"length":1,"stats":{"Line":0}},{"line":4497,"address":[],"length":0,"stats":{"Line":0}},{"line":4502,"address":[55272363],"length":1,"stats":{"Line":0}},{"line":4503,"address":[56824549],"length":1,"stats":{"Line":0}},{"line":4506,"address":[54258254],"length":1,"stats":{"Line":0}},{"line":4507,"address":[],"length":0,"stats":{"Line":0}},{"line":4508,"address":[],"length":0,"stats":{"Line":0}},{"line":4511,"address":[56824735],"length":1,"stats":{"Line":0}},{"line":4512,"address":[],"length":0,"stats":{"Line":0}},{"line":4516,"address":[54258457],"length":1,"stats":{"Line":0}},{"line":4517,"address":[54258515],"length":1,"stats":{"Line":0}},{"line":4518,"address":[55272741],"length":1,"stats":{"Line":0}},{"line":4522,"address":[55090685],"length":1,"stats":{"Line":0}},{"line":4523,"address":[54258594],"length":1,"stats":{"Line":0}},{"line":4529,"address":[54263104],"length":1,"stats":{"Line":0}},{"line":4535,"address":[],"length":0,"stats":{"Line":0}},{"line":4536,"address":[55277385],"length":1,"stats":{"Line":0}},{"line":4538,"address":[56829568],"length":1,"stats":{"Line":0}},{"line":4539,"address":[54263338],"length":1,"stats":{"Line":0}},{"line":4540,"address":[55277520],"length":1,"stats":{"Line":0}},{"line":4541,"address":[54263292],"length":1,"stats":{"Line":0}},{"line":4543,"address":[],"length":0,"stats":{"Line":0}},{"line":4548,"address":[56219696],"length":1,"stats":{"Line":0}},{"line":4552,"address":[53644862],"length":1,"stats":{"Line":0}},{"line":4555,"address":[54477102],"length":1,"stats":{"Line":0}},{"line":4556,"address":[54667857,54667937,54667796],"length":1,"stats":{"Line":0}},{"line":4557,"address":[],"length":0,"stats":{"Line":0}},{"line":4558,"address":[54667803],"length":1,"stats":{"Line":0}},{"line":4559,"address":[53645143,53645071],"length":1,"stats":{"Line":0}},{"line":4560,"address":[56220105,56220159,56220239],"length":1,"stats":{"Line":0}},{"line":4561,"address":[],"length":0,"stats":{"Line":0}},{"line":4562,"address":[54668000],"length":1,"stats":{"Line":0}},{"line":4563,"address":[],"length":0,"stats":{"Line":0}},{"line":4564,"address":[54668183,54668239,54668319],"length":1,"stats":{"Line":0}},{"line":4565,"address":[],"length":0,"stats":{"Line":0}},{"line":4566,"address":[54477544],"length":1,"stats":{"Line":0}},{"line":4567,"address":[53979760,53979744],"length":1,"stats":{"Line":0}},{"line":4570,"address":[54668400],"length":1,"stats":{"Line":0}},{"line":4574,"address":[54497312],"length":1,"stats":{"Line":0}},{"line":4579,"address":[54687816],"length":1,"stats":{"Line":0}},{"line":4580,"address":[54497528],"length":1,"stats":{"Line":0}},{"line":4583,"address":[56240219,56240280,56240360],"length":1,"stats":{"Line":0}},{"line":4584,"address":[],"length":0,"stats":{"Line":0}},{"line":4585,"address":[],"length":0,"stats":{"Line":0}},{"line":4586,"address":[56240259,56240329],"length":1,"stats":{"Line":0}},{"line":4588,"address":[56240472,56240416,56240552],"length":1,"stats":{"Line":0}},{"line":4589,"address":[],"length":0,"stats":{"Line":0}},{"line":4590,"address":[],"length":0,"stats":{"Line":0}},{"line":4591,"address":[54497916,54497988],"length":1,"stats":{"Line":0}},{"line":4594,"address":[54688521],"length":1,"stats":{"Line":0}},{"line":4598,"address":[56239056],"length":1,"stats":{"Line":0}},{"line":4603,"address":[],"length":0,"stats":{"Line":0}},{"line":4604,"address":[53664600],"length":1,"stats":{"Line":0}},{"line":4607,"address":[56239419,56239560,56239480],"length":1,"stats":{"Line":0}},{"line":4608,"address":[],"length":0,"stats":{"Line":0}},{"line":4609,"address":[56239426],"length":1,"stats":{"Line":0}},{"line":4610,"address":[56239459,56239529],"length":1,"stats":{"Line":0}},{"line":4612,"address":[53665010,53664952,53665091],"length":1,"stats":{"Line":0}},{"line":4613,"address":[],"length":0,"stats":{"Line":0}},{"line":4614,"address":[],"length":0,"stats":{"Line":0}},{"line":4615,"address":[53081520,53081504],"length":1,"stats":{"Line":0}},{"line":4618,"address":[],"length":0,"stats":{"Line":0}},{"line":4622,"address":[53940160],"length":1,"stats":{"Line":0}},{"line":4626,"address":[54959822],"length":1,"stats":{"Line":0}},{"line":4627,"address":[54959949,54960013,54960093],"length":1,"stats":{"Line":0}},{"line":4628,"address":[],"length":0,"stats":{"Line":0}},{"line":4629,"address":[56512071],"length":1,"stats":{"Line":0}},{"line":4630,"address":[56512174,56512104],"length":1,"stats":{"Line":0}},{"line":4633,"address":[54772768],"length":1,"stats":{"Line":0}},{"line":4635,"address":[56512289],"length":1,"stats":{"Line":0}},{"line":4636,"address":[],"length":0,"stats":{"Line":0}},{"line":4638,"address":[],"length":0,"stats":{"Line":0}},{"line":4639,"address":[],"length":0,"stats":{"Line":0}},{"line":4640,"address":[56512448],"length":1,"stats":{"Line":0}},{"line":4641,"address":[54007856,54007840],"length":1,"stats":{"Line":0}},{"line":4647,"address":[53941181,53941100,53941034],"length":1,"stats":{"Line":0}},{"line":4648,"address":[],"length":0,"stats":{"Line":0}},{"line":4649,"address":[53941044],"length":1,"stats":{"Line":0}},{"line":4650,"address":[54960682,54960752],"length":1,"stats":{"Line":0}},{"line":4652,"address":[],"length":0,"stats":{"Line":0}},{"line":4656,"address":[54713936],"length":1,"stats":{"Line":0}},{"line":4660,"address":[],"length":0,"stats":{"Line":0}},{"line":4661,"address":[54714253,54714109,54714173],"length":1,"stats":{"Line":0}},{"line":4662,"address":[],"length":0,"stats":{"Line":0}},{"line":4663,"address":[54524057],"length":1,"stats":{"Line":0}},{"line":4664,"address":[54478144,54478160],"length":1,"stats":{"Line":0}},{"line":4667,"address":[54714426],"length":1,"stats":{"Line":0}},{"line":4669,"address":[53692167],"length":1,"stats":{"Line":0}},{"line":4670,"address":[54714375],"length":1,"stats":{"Line":0}},{"line":4672,"address":[53692315,53692517,53692436],"length":1,"stats":{"Line":0}},{"line":4673,"address":[],"length":0,"stats":{"Line":0}},{"line":4674,"address":[54524438],"length":1,"stats":{"Line":0}},{"line":4675,"address":[],"length":0,"stats":{"Line":0}},{"line":4681,"address":[54524746,54524812,54524893],"length":1,"stats":{"Line":0}},{"line":4682,"address":[],"length":0,"stats":{"Line":0}},{"line":4683,"address":[54524756],"length":1,"stats":{"Line":0}},{"line":4684,"address":[54478320,54478304],"length":1,"stats":{"Line":0}},{"line":4686,"address":[53692830],"length":1,"stats":{"Line":0}},{"line":4690,"address":[56520400],"length":1,"stats":{"Line":0}},{"line":4694,"address":[56520446],"length":1,"stats":{"Line":0}},{"line":4695,"address":[56520717,56520637,56520573],"length":1,"stats":{"Line":0}},{"line":4696,"address":[],"length":0,"stats":{"Line":0}},{"line":4697,"address":[53948969],"length":1,"stats":{"Line":0}},{"line":4698,"address":[],"length":0,"stats":{"Line":0}},{"line":4701,"address":[53949280],"length":1,"stats":{"Line":0}},{"line":4703,"address":[56520801],"length":1,"stats":{"Line":0}},{"line":4704,"address":[],"length":0,"stats":{"Line":0}},{"line":4706,"address":[53949339,53949541,53949460],"length":1,"stats":{"Line":0}},{"line":4707,"address":[],"length":0,"stats":{"Line":0}},{"line":4708,"address":[],"length":0,"stats":{"Line":0}},{"line":4709,"address":[54781622,54781550],"length":1,"stats":{"Line":0}},{"line":4715,"address":[56521263,56521327,56521407],"length":1,"stats":{"Line":0}},{"line":4716,"address":[],"length":0,"stats":{"Line":0}},{"line":4717,"address":[54781780],"length":1,"stats":{"Line":0}},{"line":4718,"address":[53110160,53110144],"length":1,"stats":{"Line":0}},{"line":4720,"address":[53949854],"length":1,"stats":{"Line":0}},{"line":4724,"address":[54751264],"length":1,"stats":{"Line":0}},{"line":4728,"address":[54751310],"length":1,"stats":{"Line":0}},{"line":4729,"address":[54751437,54751581,54751501],"length":1,"stats":{"Line":0}},{"line":4730,"address":[],"length":0,"stats":{"Line":0}},{"line":4731,"address":[56303559],"length":1,"stats":{"Line":0}},{"line":4732,"address":[53985136,53985120],"length":1,"stats":{"Line":0}},{"line":4735,"address":[53730096],"length":1,"stats":{"Line":0}},{"line":4737,"address":[53730007],"length":1,"stats":{"Line":0}},{"line":4738,"address":[54751703],"length":1,"stats":{"Line":0}},{"line":4740,"address":[],"length":0,"stats":{"Line":0}},{"line":4741,"address":[],"length":0,"stats":{"Line":0}},{"line":4742,"address":[],"length":0,"stats":{"Line":0}},{"line":4743,"address":[56075616,56075600],"length":1,"stats":{"Line":0}},{"line":4749,"address":[53730476],"length":1,"stats":{"Line":0}},{"line":4755,"address":[55252320],"length":1,"stats":{"Line":0}},{"line":4760,"address":[],"length":0,"stats":{"Line":0}},{"line":4761,"address":[56804731,56804606,56804660],"length":1,"stats":{"Line":0}},{"line":4762,"address":[],"length":0,"stats":{"Line":0}},{"line":4763,"address":[],"length":0,"stats":{"Line":0}},{"line":4764,"address":[54030608,54030624],"length":1,"stats":{"Line":0}},{"line":4765,"address":[],"length":0,"stats":{"Line":0}},{"line":4766,"address":[56804968,56804888,56804834],"length":1,"stats":{"Line":0}},{"line":4767,"address":[],"length":0,"stats":{"Line":0}},{"line":4768,"address":[55070445],"length":1,"stats":{"Line":0}},{"line":4769,"address":[56804937,56804867],"length":1,"stats":{"Line":0}},{"line":4770,"address":[],"length":0,"stats":{"Line":0}},{"line":4772,"address":[],"length":0,"stats":{"Line":0}},{"line":4774,"address":[54238582],"length":1,"stats":{"Line":0}},{"line":4775,"address":[],"length":0,"stats":{"Line":0}},{"line":4776,"address":[55252922],"length":1,"stats":{"Line":0}},{"line":4779,"address":[53132384,53132368],"length":1,"stats":{"Line":0}},{"line":4781,"address":[54238977,54238896,54238840],"length":1,"stats":{"Line":0}},{"line":4782,"address":[],"length":0,"stats":{"Line":0}},{"line":4783,"address":[56805347],"length":1,"stats":{"Line":0}},{"line":4784,"address":[],"length":0,"stats":{"Line":0}},{"line":4786,"address":[56805618,56805698,56805525],"length":1,"stats":{"Line":0}},{"line":4787,"address":[56805535],"length":1,"stats":{"Line":0}},{"line":4788,"address":[54030784],"length":1,"stats":{"Line":0}},{"line":4789,"address":[53132032],"length":1,"stats":{"Line":0}},{"line":4792,"address":[55253565],"length":1,"stats":{"Line":0}},{"line":4796,"address":[54098976],"length":1,"stats":{"Line":0}},{"line":4797,"address":[54099019],"length":1,"stats":{"Line":0}},{"line":4798,"address":[54099195,54099126,54099073],"length":1,"stats":{"Line":0}},{"line":4799,"address":[],"length":0,"stats":{"Line":0}},{"line":4800,"address":[55116136],"length":1,"stats":{"Line":0}},{"line":4801,"address":[53120160,53120176],"length":1,"stats":{"Line":0}},{"line":4802,"address":[54099244],"length":1,"stats":{"Line":0}},{"line":4803,"address":[55116480,55116346,55116400],"length":1,"stats":{"Line":0}},{"line":4804,"address":[],"length":0,"stats":{"Line":0}},{"line":4805,"address":[56668513],"length":1,"stats":{"Line":0}},{"line":4806,"address":[56107088,56107104],"length":1,"stats":{"Line":0}},{"line":4807,"address":[55116526,55116670,55116590],"length":1,"stats":{"Line":0}},{"line":4808,"address":[],"length":0,"stats":{"Line":0}},{"line":4809,"address":[],"length":0,"stats":{"Line":0}},{"line":4810,"address":[54099594,54099522],"length":1,"stats":{"Line":0}},{"line":4812,"address":[54931814],"length":1,"stats":{"Line":0}},{"line":4816,"address":[53998992],"length":1,"stats":{"Line":0}},{"line":4818,"address":[54831147],"length":1,"stats":{"Line":0}},{"line":4819,"address":[55017905],"length":1,"stats":{"Line":0}},{"line":4820,"address":[55018078,55018007,55017953],"length":1,"stats":{"Line":0}},{"line":4821,"address":[],"length":0,"stats":{"Line":0}},{"line":4822,"address":[53999128],"length":1,"stats":{"Line":0}},{"line":4823,"address":[54012640,54012624],"length":1,"stats":{"Line":0}},{"line":4824,"address":[],"length":0,"stats":{"Line":0}},{"line":4825,"address":[],"length":0,"stats":{"Line":0}},{"line":4826,"address":[55018133],"length":1,"stats":{"Line":0}},{"line":4827,"address":[54012976,54012992],"length":1,"stats":{"Line":0}},{"line":4829,"address":[54831812,54831731,54831594],"length":1,"stats":{"Line":0}},{"line":4830,"address":[],"length":0,"stats":{"Line":0}},{"line":4831,"address":[53999497],"length":1,"stats":{"Line":0}},{"line":4832,"address":[53114032,53114048],"length":1,"stats":{"Line":0}},{"line":4839,"address":[54831934],"length":1,"stats":{"Line":0}},{"line":4840,"address":[55018747,55018693,55018827],"length":1,"stats":{"Line":0}},{"line":4841,"address":[],"length":0,"stats":{"Line":0}},{"line":4842,"address":[],"length":0,"stats":{"Line":0}},{"line":4843,"address":[],"length":0,"stats":{"Line":0}},{"line":4844,"address":[],"length":0,"stats":{"Line":0}},{"line":4845,"address":[54832182],"length":1,"stats":{"Line":0}},{"line":4846,"address":[54000156,54000084],"length":1,"stats":{"Line":0}},{"line":4848,"address":[54000236],"length":1,"stats":{"Line":0}},{"line":4852,"address":[54757952],"length":1,"stats":{"Line":0}},{"line":4856,"address":[54757998],"length":1,"stats":{"Line":0}},{"line":4857,"address":[53736564],"length":1,"stats":{"Line":0}},{"line":4860,"address":[],"length":0,"stats":{"Line":0}},{"line":4861,"address":[54568868,54568924,54569005],"length":1,"stats":{"Line":0}},{"line":4862,"address":[],"length":0,"stats":{"Line":0}},{"line":4863,"address":[],"length":0,"stats":{"Line":0}},{"line":4864,"address":[53736790,53736862],"length":1,"stats":{"Line":0}},{"line":4865,"address":[54758505],"length":1,"stats":{"Line":0}},{"line":4866,"address":[],"length":0,"stats":{"Line":0}},{"line":4867,"address":[],"length":0,"stats":{"Line":0}},{"line":4868,"address":[56310766],"length":1,"stats":{"Line":0}},{"line":4869,"address":[56077296,56077312],"length":1,"stats":{"Line":0}},{"line":4872,"address":[53737306],"length":1,"stats":{"Line":0}},{"line":4873,"address":[56311080,56311160,56311026],"length":1,"stats":{"Line":0}},{"line":4874,"address":[],"length":0,"stats":{"Line":0}},{"line":4875,"address":[],"length":0,"stats":{"Line":0}},{"line":4876,"address":[53737394,53737466],"length":1,"stats":{"Line":0}},{"line":4877,"address":[53737549],"length":1,"stats":{"Line":0}},{"line":4878,"address":[],"length":0,"stats":{"Line":0}},{"line":4879,"address":[],"length":0,"stats":{"Line":0}},{"line":4880,"address":[53737608],"length":1,"stats":{"Line":0}},{"line":4881,"address":[53737635,53737707],"length":1,"stats":{"Line":0}},{"line":4882,"address":[54569912,54570049,54569968],"length":1,"stats":{"Line":0}},{"line":4883,"address":[],"length":0,"stats":{"Line":0}},{"line":4884,"address":[53737807],"length":1,"stats":{"Line":0}},{"line":4885,"address":[],"length":0,"stats":{"Line":0}},{"line":4886,"address":[],"length":0,"stats":{"Line":0}},{"line":4887,"address":[56311650],"length":1,"stats":{"Line":0}},{"line":4888,"address":[53987872,53987856],"length":1,"stats":{"Line":0}},{"line":4890,"address":[54759705],"length":1,"stats":{"Line":0}},{"line":4894,"address":[53698736],"length":1,"stats":{"Line":0}},{"line":4898,"address":[54530894],"length":1,"stats":{"Line":0}},{"line":4899,"address":[54531021],"length":1,"stats":{"Line":0}},{"line":4900,"address":[],"length":0,"stats":{"Line":0}},{"line":4901,"address":[54531201,54531267,54531348],"length":1,"stats":{"Line":0}},{"line":4902,"address":[],"length":0,"stats":{"Line":0}},{"line":4903,"address":[],"length":0,"stats":{"Line":0}},{"line":4904,"address":[53699133,53699205],"length":1,"stats":{"Line":0}},{"line":4905,"address":[56273496],"length":1,"stats":{"Line":0}},{"line":4909,"address":[54675472],"length":1,"stats":{"Line":0}},{"line":4913,"address":[53652830],"length":1,"stats":{"Line":0}},{"line":4914,"address":[54675644],"length":1,"stats":{"Line":0}},{"line":4915,"address":[],"length":0,"stats":{"Line":0}},{"line":4916,"address":[54485311,54485392,54485255],"length":1,"stats":{"Line":0}},{"line":4917,"address":[],"length":0,"stats":{"Line":0}},{"line":4918,"address":[56227946],"length":1,"stats":{"Line":0}},{"line":4919,"address":[53081168,53081152],"length":1,"stats":{"Line":0}},{"line":4920,"address":[54676012],"length":1,"stats":{"Line":0}},{"line":4921,"address":[56228407,56228263,56228327],"length":1,"stats":{"Line":0}},{"line":4922,"address":[],"length":0,"stats":{"Line":0}},{"line":4923,"address":[53653483],"length":1,"stats":{"Line":0}},{"line":4924,"address":[53081344,53081328],"length":1,"stats":{"Line":0}},{"line":4925,"address":[53653680],"length":1,"stats":{"Line":0}},{"line":4929,"address":[54562608],"length":1,"stats":{"Line":0}},{"line":4933,"address":[56304324],"length":1,"stats":{"Line":0}},{"line":4934,"address":[54752359],"length":1,"stats":{"Line":0}},{"line":4936,"address":[56304618],"length":1,"stats":{"Line":0}},{"line":4937,"address":[54752552,54752606,54752689],"length":1,"stats":{"Line":0}},{"line":4938,"address":[],"length":0,"stats":{"Line":0}},{"line":4939,"address":[54563011],"length":1,"stats":{"Line":0}},{"line":4940,"address":[54482016,54482032],"length":1,"stats":{"Line":0}},{"line":4943,"address":[56304852],"length":1,"stats":{"Line":0}},{"line":4946,"address":[54752907,54752990,54752887],"length":1,"stats":{"Line":0}},{"line":4947,"address":[],"length":0,"stats":{"Line":0}},{"line":4948,"address":[54563416,54563352],"length":1,"stats":{"Line":0}},{"line":4949,"address":[54563502],"length":1,"stats":{"Line":0}},{"line":4950,"address":[],"length":0,"stats":{"Line":0}},{"line":4953,"address":[54753277,54753194,54753130],"length":1,"stats":{"Line":0}},{"line":4954,"address":[],"length":0,"stats":{"Line":0}},{"line":4955,"address":[54563601],"length":1,"stats":{"Line":0}},{"line":4956,"address":[53731523,53731595],"length":1,"stats":{"Line":0}},{"line":4957,"address":[54753328],"length":1,"stats":{"Line":0}},{"line":4958,"address":[56305480],"length":1,"stats":{"Line":0}},{"line":4959,"address":[54753418],"length":1,"stats":{"Line":0}},{"line":4961,"address":[56305581],"length":1,"stats":{"Line":0}},{"line":4962,"address":[56305751,56305604,56305668],"length":1,"stats":{"Line":0}},{"line":4963,"address":[],"length":0,"stats":{"Line":0}},{"line":4964,"address":[],"length":0,"stats":{"Line":0}},{"line":4965,"address":[],"length":0,"stats":{"Line":0}},{"line":4967,"address":[54564347,54564263,54564200],"length":1,"stats":{"Line":0}},{"line":4968,"address":[],"length":0,"stats":{"Line":0}},{"line":4969,"address":[53732095],"length":1,"stats":{"Line":0}},{"line":4970,"address":[54481536,54481552],"length":1,"stats":{"Line":0}},{"line":4972,"address":[56306040],"length":1,"stats":{"Line":0}},{"line":4973,"address":[54753980],"length":1,"stats":{"Line":0}},{"line":4974,"address":[53732351],"length":1,"stats":{"Line":0}},{"line":4977,"address":[54754031],"length":1,"stats":{"Line":0}},{"line":4979,"address":[56306225,56306308,56306171],"length":1,"stats":{"Line":0}},{"line":4980,"address":[],"length":0,"stats":{"Line":0}},{"line":4981,"address":[],"length":0,"stats":{"Line":0}},{"line":4982,"address":[54564570,54564642],"length":1,"stats":{"Line":0}},{"line":4983,"address":[53732616],"length":1,"stats":{"Line":0}},{"line":4984,"address":[],"length":0,"stats":{"Line":0}},{"line":4985,"address":[],"length":0,"stats":{"Line":0}},{"line":4986,"address":[54754399],"length":1,"stats":{"Line":0}},{"line":4987,"address":[53086992,53086976],"length":1,"stats":{"Line":0}},{"line":4989,"address":[54565166,54565100,54565250],"length":1,"stats":{"Line":0}},{"line":4990,"address":[],"length":0,"stats":{"Line":0}},{"line":4991,"address":[54754623],"length":1,"stats":{"Line":0}},{"line":4992,"address":[53733104,53733032],"length":1,"stats":{"Line":0}},{"line":4993,"address":[56306923],"length":1,"stats":{"Line":0}},{"line":4994,"address":[53733344],"length":1,"stats":{"Line":0}},{"line":4997,"address":[54755018,54755072,54755155],"length":1,"stats":{"Line":0}},{"line":4998,"address":[],"length":0,"stats":{"Line":0}},{"line":4999,"address":[56307137],"length":1,"stats":{"Line":0}},{"line":5000,"address":[53087696,53087680],"length":1,"stats":{"Line":0}},{"line":5001,"address":[],"length":0,"stats":{"Line":0}},{"line":5002,"address":[],"length":0,"stats":{"Line":0}},{"line":5004,"address":[56307419],"length":1,"stats":{"Line":0}},{"line":5006,"address":[],"length":0,"stats":{"Line":0}},{"line":5010,"address":[54781984],"length":1,"stats":{"Line":0}},{"line":5016,"address":[],"length":0,"stats":{"Line":0}},{"line":5017,"address":[],"length":0,"stats":{"Line":0}},{"line":5018,"address":[54969831],"length":1,"stats":{"Line":0}},{"line":5021,"address":[],"length":0,"stats":{"Line":0}},{"line":5022,"address":[],"length":0,"stats":{"Line":0}},{"line":5023,"address":[],"length":0,"stats":{"Line":0}},{"line":5024,"address":[],"length":0,"stats":{"Line":0}},{"line":5026,"address":[54970172],"length":1,"stats":{"Line":0}},{"line":5028,"address":[54782942,54782963,54783047],"length":1,"stats":{"Line":0}},{"line":5029,"address":[],"length":0,"stats":{"Line":0}},{"line":5030,"address":[54504128,54504142],"length":1,"stats":{"Line":0}},{"line":5031,"address":[54783102],"length":1,"stats":{"Line":0}},{"line":5032,"address":[54970529],"length":1,"stats":{"Line":0}},{"line":5034,"address":[54970574,54970638,54970721],"length":1,"stats":{"Line":0}},{"line":5035,"address":[],"length":0,"stats":{"Line":0}},{"line":5036,"address":[53951095],"length":1,"stats":{"Line":0}},{"line":5037,"address":[56522799,56522729],"length":1,"stats":{"Line":0}},{"line":5038,"address":[54783402],"length":1,"stats":{"Line":0}},{"line":5039,"address":[54783445],"length":1,"stats":{"Line":0}},{"line":5040,"address":[56522983],"length":1,"stats":{"Line":0}},{"line":5042,"address":[],"length":0,"stats":{"Line":0}},{"line":5043,"address":[54783647,54783581,54783731],"length":1,"stats":{"Line":0}},{"line":5044,"address":[],"length":0,"stats":{"Line":0}},{"line":5045,"address":[],"length":0,"stats":{"Line":0}},{"line":5046,"address":[54783697,54783625],"length":1,"stats":{"Line":0}},{"line":5048,"address":[],"length":0,"stats":{"Line":0}},{"line":5049,"address":[],"length":0,"stats":{"Line":0}},{"line":5050,"address":[53951719],"length":1,"stats":{"Line":0}},{"line":5051,"address":[53110672,53110688],"length":1,"stats":{"Line":0}},{"line":5053,"address":[53951919],"length":1,"stats":{"Line":0}},{"line":5054,"address":[56523560],"length":1,"stats":{"Line":0}},{"line":5055,"address":[],"length":0,"stats":{"Line":0}},{"line":5058,"address":[54971502],"length":1,"stats":{"Line":0}},{"line":5059,"address":[54971670,54971533,54971587],"length":1,"stats":{"Line":0}},{"line":5060,"address":[],"length":0,"stats":{"Line":0}},{"line":5061,"address":[54784179],"length":1,"stats":{"Line":0}},{"line":5062,"address":[54971566,54971636],"length":1,"stats":{"Line":0}},{"line":5063,"address":[54971724],"length":1,"stats":{"Line":0}},{"line":5064,"address":[56524045,56524128,56523981],"length":1,"stats":{"Line":0}},{"line":5065,"address":[],"length":0,"stats":{"Line":0}},{"line":5066,"address":[56523991],"length":1,"stats":{"Line":0}},{"line":5067,"address":[54503968,54503984],"length":1,"stats":{"Line":0}},{"line":5069,"address":[54784745,54784811,54784895],"length":1,"stats":{"Line":0}},{"line":5070,"address":[],"length":0,"stats":{"Line":0}},{"line":5071,"address":[53952643],"length":1,"stats":{"Line":0}},{"line":5072,"address":[56524251,56524321],"length":1,"stats":{"Line":0}},{"line":5073,"address":[54972297],"length":1,"stats":{"Line":0}},{"line":5074,"address":[53952995],"length":1,"stats":{"Line":0}},{"line":5076,"address":[56524612],"length":1,"stats":{"Line":0}},{"line":5077,"address":[54785201,54785341,54785257],"length":1,"stats":{"Line":0}},{"line":5078,"address":[],"length":0,"stats":{"Line":0}},{"line":5079,"address":[53953096],"length":1,"stats":{"Line":0}},{"line":5080,"address":[53111824,53111840],"length":1,"stats":{"Line":0}},{"line":5081,"address":[54785396],"length":1,"stats":{"Line":0}},{"line":5082,"address":[],"length":0,"stats":{"Line":0}},{"line":5084,"address":[54972842],"length":1,"stats":{"Line":0}},{"line":5086,"address":[54785540],"length":1,"stats":{"Line":0}},{"line":5090,"address":[56291776],"length":1,"stats":{"Line":0}},{"line":5095,"address":[54550038],"length":1,"stats":{"Line":0}},{"line":5096,"address":[54550209],"length":1,"stats":{"Line":0}},{"line":5097,"address":[54550372],"length":1,"stats":{"Line":0}},{"line":5098,"address":[56292369],"length":1,"stats":{"Line":0}},{"line":5100,"address":[54740472,54740418,54740555],"length":1,"stats":{"Line":0}},{"line":5101,"address":[],"length":0,"stats":{"Line":0}},{"line":5102,"address":[54740425],"length":1,"stats":{"Line":0}},{"line":5103,"address":[],"length":0,"stats":{"Line":0}},{"line":5105,"address":[],"length":0,"stats":{"Line":0}},{"line":5106,"address":[54740757,54740821,54740904],"length":1,"stats":{"Line":0}},{"line":5107,"address":[],"length":0,"stats":{"Line":0}},{"line":5108,"address":[54740767],"length":1,"stats":{"Line":0}},{"line":5109,"address":[56073584,56073600],"length":1,"stats":{"Line":0}},{"line":5111,"address":[53719160,53719139,53719244],"length":1,"stats":{"Line":0}},{"line":5112,"address":[],"length":0,"stats":{"Line":0}},{"line":5113,"address":[53085200,53085214],"length":1,"stats":{"Line":0}},{"line":5116,"address":[53719299],"length":1,"stats":{"Line":0}},{"line":5117,"address":[53719349],"length":1,"stats":{"Line":0}},{"line":5118,"address":[56293330],"length":1,"stats":{"Line":0}},{"line":5120,"address":[54741330,54741266,54741413],"length":1,"stats":{"Line":0}},{"line":5121,"address":[],"length":0,"stats":{"Line":0}},{"line":5122,"address":[53719457],"length":1,"stats":{"Line":0}},{"line":5123,"address":[53719563,53719491],"length":1,"stats":{"Line":0}},{"line":5124,"address":[],"length":0,"stats":{"Line":0}},{"line":5125,"address":[54741510],"length":1,"stats":{"Line":0}},{"line":5126,"address":[53719746],"length":1,"stats":{"Line":0}},{"line":5127,"address":[54741614],"length":1,"stats":{"Line":0}},{"line":5129,"address":[],"length":0,"stats":{"Line":0}},{"line":5130,"address":[],"length":0,"stats":{"Line":0}},{"line":5131,"address":[],"length":0,"stats":{"Line":0}},{"line":5132,"address":[54552004],"length":1,"stats":{"Line":0}},{"line":5133,"address":[],"length":0,"stats":{"Line":0}},{"line":5135,"address":[54741936,54742080,54741997],"length":1,"stats":{"Line":0}},{"line":5136,"address":[],"length":0,"stats":{"Line":0}},{"line":5137,"address":[53720135],"length":1,"stats":{"Line":0}},{"line":5138,"address":[53086192,53086176],"length":1,"stats":{"Line":0}},{"line":5139,"address":[54742142],"length":1,"stats":{"Line":0}},{"line":5140,"address":[53720345],"length":1,"stats":{"Line":0}},{"line":5143,"address":[53720393],"length":1,"stats":{"Line":0}},{"line":5144,"address":[54552539],"length":1,"stats":{"Line":0}},{"line":5145,"address":[54742375,54742439,54742522],"length":1,"stats":{"Line":0}},{"line":5146,"address":[],"length":0,"stats":{"Line":0}},{"line":5147,"address":[54742385],"length":1,"stats":{"Line":0}},{"line":5148,"address":[53982912,53982928],"length":1,"stats":{"Line":0}},{"line":5149,"address":[],"length":0,"stats":{"Line":0}},{"line":5150,"address":[54553082],"length":1,"stats":{"Line":0}},{"line":5151,"address":[53721030,53721170,53721086],"length":1,"stats":{"Line":0}},{"line":5152,"address":[],"length":0,"stats":{"Line":0}},{"line":5153,"address":[],"length":0,"stats":{"Line":0}},{"line":5154,"address":[53085488,53085472],"length":1,"stats":{"Line":0}},{"line":5155,"address":[],"length":0,"stats":{"Line":0}},{"line":5156,"address":[54743067],"length":1,"stats":{"Line":0}},{"line":5159,"address":[],"length":0,"stats":{"Line":0}},{"line":5160,"address":[54743150],"length":1,"stats":{"Line":0}},{"line":5161,"address":[],"length":0,"stats":{"Line":0}},{"line":5162,"address":[53721464],"length":1,"stats":{"Line":0}},{"line":5164,"address":[54553628],"length":1,"stats":{"Line":0}},{"line":5165,"address":[56295467],"length":1,"stats":{"Line":0}},{"line":5167,"address":[54553738],"length":1,"stats":{"Line":0}},{"line":5168,"address":[],"length":0,"stats":{"Line":0}},{"line":5169,"address":[],"length":0,"stats":{"Line":0}},{"line":5170,"address":[56295557],"length":1,"stats":{"Line":0}},{"line":5171,"address":[54479280,54479264],"length":1,"stats":{"Line":0}},{"line":5173,"address":[54743738,54743821,54743677],"length":1,"stats":{"Line":0}},{"line":5174,"address":[],"length":0,"stats":{"Line":0}},{"line":5175,"address":[53721905],"length":1,"stats":{"Line":0}},{"line":5176,"address":[56295829,56295899],"length":1,"stats":{"Line":0}},{"line":5177,"address":[54743880],"length":1,"stats":{"Line":0}},{"line":5178,"address":[56295999],"length":1,"stats":{"Line":0}},{"line":5181,"address":[56296046],"length":1,"stats":{"Line":0}},{"line":5182,"address":[54743968],"length":1,"stats":{"Line":0}},{"line":5183,"address":[53722491,53722341,53722407],"length":1,"stats":{"Line":0}},{"line":5184,"address":[],"length":0,"stats":{"Line":0}},{"line":5185,"address":[53722351],"length":1,"stats":{"Line":0}},{"line":5186,"address":[56296268,56296338],"length":1,"stats":{"Line":0}},{"line":5187,"address":[],"length":0,"stats":{"Line":0}},{"line":5188,"address":[],"length":0,"stats":{"Line":0}},{"line":5189,"address":[54554699],"length":1,"stats":{"Line":0}},{"line":5190,"address":[56073904,56073920],"length":1,"stats":{"Line":0}},{"line":5191,"address":[53722778],"length":1,"stats":{"Line":0}},{"line":5192,"address":[54744697],"length":1,"stats":{"Line":0}},{"line":5193,"address":[56296921,56297004,56296867],"length":1,"stats":{"Line":0}},{"line":5194,"address":[],"length":0,"stats":{"Line":0}},{"line":5195,"address":[53723002],"length":1,"stats":{"Line":0}},{"line":5196,"address":[53723101,53723029],"length":1,"stats":{"Line":0}},{"line":5197,"address":[],"length":0,"stats":{"Line":0}},{"line":5198,"address":[54744999],"length":1,"stats":{"Line":0}},{"line":5200,"address":[56297165],"length":1,"stats":{"Line":0}},{"line":5202,"address":[54745090],"length":1,"stats":{"Line":0}},{"line":5206,"address":[55088144],"length":1,"stats":{"Line":0}},{"line":5210,"address":[56640356],"length":1,"stats":{"Line":0}},{"line":5211,"address":[],"length":0,"stats":{"Line":0}},{"line":5213,"address":[56640650],"length":1,"stats":{"Line":0}},{"line":5214,"address":[54071449,54071299,54071365],"length":1,"stats":{"Line":0}},{"line":5215,"address":[],"length":0,"stats":{"Line":0}},{"line":5216,"address":[56640807],"length":1,"stats":{"Line":0}},{"line":5217,"address":[55088750,55088680],"length":1,"stats":{"Line":0}},{"line":5219,"address":[54903613,54903634,54903718],"length":1,"stats":{"Line":0}},{"line":5220,"address":[],"length":0,"stats":{"Line":0}},{"line":5221,"address":[55088842,55088904],"length":1,"stats":{"Line":0}},{"line":5222,"address":[55088989],"length":1,"stats":{"Line":0}},{"line":5223,"address":[54071705],"length":1,"stats":{"Line":0}},{"line":5224,"address":[54903864],"length":1,"stats":{"Line":0}},{"line":5226,"address":[56641349,56641285,56641432],"length":1,"stats":{"Line":0}},{"line":5227,"address":[],"length":0,"stats":{"Line":0}},{"line":5228,"address":[55089135],"length":1,"stats":{"Line":0}},{"line":5229,"address":[54017840,54017824],"length":1,"stats":{"Line":0}},{"line":5230,"address":[55089323],"length":1,"stats":{"Line":0}},{"line":5231,"address":[54904148],"length":1,"stats":{"Line":0}},{"line":5232,"address":[55089411],"length":1,"stats":{"Line":0}},{"line":5233,"address":[],"length":0,"stats":{"Line":0}},{"line":5235,"address":[],"length":0,"stats":{"Line":0}},{"line":5236,"address":[54072211,54072277,54072361],"length":1,"stats":{"Line":0}},{"line":5237,"address":[],"length":0,"stats":{"Line":0}},{"line":5238,"address":[54072221],"length":1,"stats":{"Line":0}},{"line":5239,"address":[54510896,54510912],"length":1,"stats":{"Line":0}},{"line":5241,"address":[54904626,54904563,54904710],"length":1,"stats":{"Line":0}},{"line":5242,"address":[],"length":0,"stats":{"Line":0}},{"line":5243,"address":[56641938],"length":1,"stats":{"Line":0}},{"line":5244,"address":[54904604,54904676],"length":1,"stats":{"Line":0}},{"line":5245,"address":[55089971],"length":1,"stats":{"Line":0}},{"line":5246,"address":[56642138],"length":1,"stats":{"Line":0}},{"line":5249,"address":[54904819],"length":1,"stats":{"Line":0}},{"line":5250,"address":[],"length":0,"stats":{"Line":0}},{"line":5251,"address":[54905141,54904991,54905057],"length":1,"stats":{"Line":0}},{"line":5252,"address":[],"length":0,"stats":{"Line":0}},{"line":5253,"address":[54072889],"length":1,"stats":{"Line":0}},{"line":5254,"address":[56642395,56642465],"length":1,"stats":{"Line":0}},{"line":5256,"address":[],"length":0,"stats":{"Line":0}},{"line":5257,"address":[],"length":0,"stats":{"Line":0}},{"line":5258,"address":[56642588],"length":1,"stats":{"Line":0}},{"line":5259,"address":[53118352,53118368],"length":1,"stats":{"Line":0}},{"line":5260,"address":[],"length":0,"stats":{"Line":0}},{"line":5261,"address":[],"length":0,"stats":{"Line":0}},{"line":5262,"address":[54905423],"length":1,"stats":{"Line":0}},{"line":5263,"address":[55090712,55090642],"length":1,"stats":{"Line":0}},{"line":5264,"address":[],"length":0,"stats":{"Line":0}},{"line":5265,"address":[56643109],"length":1,"stats":{"Line":0}},{"line":5267,"address":[55091141,55091004,55091058],"length":1,"stats":{"Line":0}},{"line":5268,"address":[],"length":0,"stats":{"Line":0}},{"line":5269,"address":[54905826],"length":1,"stats":{"Line":0}},{"line":5270,"address":[53118704,53118720],"length":1,"stats":{"Line":0}},{"line":5271,"address":[],"length":0,"stats":{"Line":0}},{"line":5272,"address":[55091242],"length":1,"stats":{"Line":0}},{"line":5274,"address":[55091293],"length":1,"stats":{"Line":0}},{"line":5276,"address":[55091324],"length":1,"stats":{"Line":0}},{"line":5280,"address":[55011248],"length":1,"stats":{"Line":0}},{"line":5284,"address":[55011294],"length":1,"stats":{"Line":0}},{"line":5285,"address":[55011438],"length":1,"stats":{"Line":0}},{"line":5287,"address":[56563694,56563794,56563714],"length":1,"stats":{"Line":0}},{"line":5288,"address":[],"length":0,"stats":{"Line":0}},{"line":5289,"address":[56100304,56100318],"length":1,"stats":{"Line":0}},{"line":5290,"address":[56563845],"length":1,"stats":{"Line":0}},{"line":5291,"address":[],"length":0,"stats":{"Line":0}},{"line":5292,"address":[53992906],"length":1,"stats":{"Line":0}},{"line":5294,"address":[56564045,56563981,56564125],"length":1,"stats":{"Line":0}},{"line":5295,"address":[],"length":0,"stats":{"Line":0}},{"line":5296,"address":[53992958],"length":1,"stats":{"Line":0}},{"line":5297,"address":[56099824,56099840],"length":1,"stats":{"Line":0}},{"line":5298,"address":[56564176,56564240,56564320],"length":1,"stats":{"Line":0}},{"line":5299,"address":[],"length":0,"stats":{"Line":0}},{"line":5300,"address":[56564186],"length":1,"stats":{"Line":0}},{"line":5301,"address":[56100160,56100144],"length":1,"stats":{"Line":0}},{"line":5302,"address":[],"length":0,"stats":{"Line":0}},{"line":5303,"address":[53993386],"length":1,"stats":{"Line":0}},{"line":5304,"address":[54825546],"length":1,"stats":{"Line":0}},{"line":5305,"address":[],"length":0,"stats":{"Line":0}},{"line":5306,"address":[54825655],"length":1,"stats":{"Line":0}},{"line":5308,"address":[54825707],"length":1,"stats":{"Line":0}},{"line":5309,"address":[],"length":0,"stats":{"Line":0}},{"line":5310,"address":[],"length":0,"stats":{"Line":0}},{"line":5311,"address":[56564648],"length":1,"stats":{"Line":0}},{"line":5312,"address":[54505776,54505760],"length":1,"stats":{"Line":0}},{"line":5314,"address":[53993999,53993918,53993855],"length":1,"stats":{"Line":0}},{"line":5315,"address":[],"length":0,"stats":{"Line":0}},{"line":5316,"address":[55012766],"length":1,"stats":{"Line":0}},{"line":5317,"address":[],"length":0,"stats":{"Line":0}},{"line":5318,"address":[53994056],"length":1,"stats":{"Line":0}},{"line":5319,"address":[54826175],"length":1,"stats":{"Line":0}},{"line":5322,"address":[55013007],"length":1,"stats":{"Line":0}},{"line":5323,"address":[53994136],"length":1,"stats":{"Line":0}},{"line":5324,"address":[],"length":0,"stats":{"Line":0}},{"line":5325,"address":[],"length":0,"stats":{"Line":0}},{"line":5326,"address":[55013184],"length":1,"stats":{"Line":0}},{"line":5327,"address":[],"length":0,"stats":{"Line":0}},{"line":5328,"address":[54826599],"length":1,"stats":{"Line":0}},{"line":5330,"address":[54826750,54826816,54826897],"length":1,"stats":{"Line":0}},{"line":5331,"address":[],"length":0,"stats":{"Line":0}},{"line":5332,"address":[55013539],"length":1,"stats":{"Line":0}},{"line":5333,"address":[54826794,54826866],"length":1,"stats":{"Line":0}},{"line":5335,"address":[55013811,55013757,55013891],"length":1,"stats":{"Line":0}},{"line":5336,"address":[],"length":0,"stats":{"Line":0}},{"line":5337,"address":[],"length":0,"stats":{"Line":0}},{"line":5338,"address":[56100560,56100576],"length":1,"stats":{"Line":0}},{"line":5339,"address":[55013942],"length":1,"stats":{"Line":0}},{"line":5341,"address":[54827284,54827365,54827228],"length":1,"stats":{"Line":0}},{"line":5342,"address":[],"length":0,"stats":{"Line":0}},{"line":5343,"address":[54827235],"length":1,"stats":{"Line":0}},{"line":5344,"address":[54504544,54504560],"length":1,"stats":{"Line":0}},{"line":5345,"address":[55014182],"length":1,"stats":{"Line":0}},{"line":5346,"address":[53995357],"length":1,"stats":{"Line":0}},{"line":5348,"address":[56566395],"length":1,"stats":{"Line":0}},{"line":5349,"address":[54827610,54827544,54827691],"length":1,"stats":{"Line":0}},{"line":5350,"address":[],"length":0,"stats":{"Line":0}},{"line":5351,"address":[56566428],"length":1,"stats":{"Line":0}},{"line":5352,"address":[53112704,53112720],"length":1,"stats":{"Line":0}},{"line":5355,"address":[56566643],"length":1,"stats":{"Line":0}},{"line":5361,"address":[54933088],"length":1,"stats":{"Line":0}},{"line":5366,"address":[54101063],"length":1,"stats":{"Line":0}},{"line":5367,"address":[],"length":0,"stats":{"Line":0}},{"line":5369,"address":[56670598],"length":1,"stats":{"Line":0}},{"line":5370,"address":[54101451],"length":1,"stats":{"Line":0}},{"line":5371,"address":[],"length":0,"stats":{"Line":0}},{"line":5372,"address":[54933570],"length":1,"stats":{"Line":0}},{"line":5374,"address":[56670747],"length":1,"stats":{"Line":0}},{"line":5375,"address":[],"length":0,"stats":{"Line":0}},{"line":5376,"address":[54933656],"length":1,"stats":{"Line":0}},{"line":5380,"address":[55118669],"length":1,"stats":{"Line":0}},{"line":5381,"address":[],"length":0,"stats":{"Line":0}},{"line":5383,"address":[54101636],"length":1,"stats":{"Line":0}},{"line":5384,"address":[54933760],"length":1,"stats":{"Line":0}},{"line":5394,"address":[],"length":0,"stats":{"Line":0}},{"line":5395,"address":[],"length":0,"stats":{"Line":0}},{"line":5396,"address":[],"length":0,"stats":{"Line":0}},{"line":5397,"address":[55118973],"length":1,"stats":{"Line":0}},{"line":5401,"address":[54934114],"length":1,"stats":{"Line":0}},{"line":5402,"address":[],"length":0,"stats":{"Line":0}},{"line":5403,"address":[54102012],"length":1,"stats":{"Line":0}},{"line":5407,"address":[54934203],"length":1,"stats":{"Line":0}},{"line":5408,"address":[],"length":0,"stats":{"Line":0}},{"line":5409,"address":[],"length":0,"stats":{"Line":0}},{"line":5410,"address":[55119144],"length":1,"stats":{"Line":0}},{"line":5411,"address":[56671356],"length":1,"stats":{"Line":0}},{"line":5412,"address":[54934305],"length":1,"stats":{"Line":0}},{"line":5413,"address":[],"length":0,"stats":{"Line":0}},{"line":5414,"address":[54934312],"length":1,"stats":{"Line":0}},{"line":5416,"address":[54934407],"length":1,"stats":{"Line":0}},{"line":5417,"address":[],"length":0,"stats":{"Line":0}},{"line":5418,"address":[],"length":0,"stats":{"Line":0}},{"line":5420,"address":[],"length":0,"stats":{"Line":0}},{"line":5424,"address":[55014560],"length":1,"stats":{"Line":0}},{"line":5428,"address":[56566727],"length":1,"stats":{"Line":0}},{"line":5429,"address":[53995887],"length":1,"stats":{"Line":0}},{"line":5430,"address":[54828056],"length":1,"stats":{"Line":0}},{"line":5431,"address":[],"length":0,"stats":{"Line":0}},{"line":5432,"address":[53995951],"length":1,"stats":{"Line":0}},{"line":5436,"address":[],"length":0,"stats":{"Line":0}},{"line":5437,"address":[],"length":0,"stats":{"Line":0}},{"line":5438,"address":[],"length":0,"stats":{"Line":0}},{"line":5446,"address":[53996248],"length":1,"stats":{"Line":0}},{"line":5447,"address":[53996303],"length":1,"stats":{"Line":0}},{"line":5448,"address":[53996377],"length":1,"stats":{"Line":0}},{"line":5449,"address":[],"length":0,"stats":{"Line":0}},{"line":5450,"address":[54828504],"length":1,"stats":{"Line":0}},{"line":5458,"address":[53996602],"length":1,"stats":{"Line":0}},{"line":5459,"address":[],"length":0,"stats":{"Line":0}},{"line":5460,"address":[56567679],"length":1,"stats":{"Line":0}},{"line":5461,"address":[],"length":0,"stats":{"Line":0}},{"line":5463,"address":[],"length":0,"stats":{"Line":0}},{"line":5464,"address":[56567867],"length":1,"stats":{"Line":0}},{"line":5465,"address":[],"length":0,"stats":{"Line":0}},{"line":5466,"address":[],"length":0,"stats":{"Line":0}},{"line":5468,"address":[54829163],"length":1,"stats":{"Line":0}},{"line":5469,"address":[54829192],"length":1,"stats":{"Line":0}},{"line":5470,"address":[],"length":0,"stats":{"Line":0}},{"line":5471,"address":[53997090],"length":1,"stats":{"Line":0}},{"line":5474,"address":[55016053],"length":1,"stats":{"Line":0}},{"line":5475,"address":[],"length":0,"stats":{"Line":0}},{"line":5476,"address":[56568172],"length":1,"stats":{"Line":0}},{"line":5478,"address":[],"length":0,"stats":{"Line":0}},{"line":5479,"address":[54829405],"length":1,"stats":{"Line":0}},{"line":5482,"address":[54829453],"length":1,"stats":{"Line":0}},{"line":5484,"address":[53997362],"length":1,"stats":{"Line":0}},{"line":5485,"address":[55016235],"length":1,"stats":{"Line":0}},{"line":5488,"address":[],"length":0,"stats":{"Line":0}},{"line":5489,"address":[],"length":0,"stats":{"Line":0}},{"line":5490,"address":[54829635],"length":1,"stats":{"Line":0}},{"line":5495,"address":[54829744],"length":1,"stats":{"Line":0}},{"line":5496,"address":[54829769],"length":1,"stats":{"Line":0}},{"line":5497,"address":[55016542],"length":1,"stats":{"Line":0}},{"line":5498,"address":[56568688],"length":1,"stats":{"Line":0}},{"line":5500,"address":[],"length":0,"stats":{"Line":0}},{"line":5501,"address":[],"length":0,"stats":{"Line":0}},{"line":5502,"address":[54829891],"length":1,"stats":{"Line":0}},{"line":5504,"address":[56568838],"length":1,"stats":{"Line":0}},{"line":5505,"address":[],"length":0,"stats":{"Line":0}},{"line":5506,"address":[54829993],"length":1,"stats":{"Line":0}},{"line":5508,"address":[56568925],"length":1,"stats":{"Line":0}},{"line":5510,"address":[54830170],"length":1,"stats":{"Line":0}},{"line":5511,"address":[],"length":0,"stats":{"Line":0}},{"line":5512,"address":[56569025],"length":1,"stats":{"Line":0}},{"line":5514,"address":[55016994],"length":1,"stats":{"Line":0}},{"line":5515,"address":[],"length":0,"stats":{"Line":0}},{"line":5516,"address":[],"length":0,"stats":{"Line":0}},{"line":5521,"address":[53998244],"length":1,"stats":{"Line":0}},{"line":5522,"address":[],"length":0,"stats":{"Line":0}},{"line":5525,"address":[],"length":0,"stats":{"Line":0}},{"line":5527,"address":[54830580],"length":1,"stats":{"Line":0}},{"line":5528,"address":[56569500],"length":1,"stats":{"Line":0}},{"line":5529,"address":[56569556],"length":1,"stats":{"Line":0}},{"line":5531,"address":[55017501],"length":1,"stats":{"Line":0}},{"line":5534,"address":[53998687],"length":1,"stats":{"Line":0}},{"line":5535,"address":[55017540],"length":1,"stats":{"Line":0}},{"line":5538,"address":[56569790],"length":1,"stats":{"Line":0}},{"line":5539,"address":[56569808],"length":1,"stats":{"Line":0}},{"line":5542,"address":[54831077],"length":1,"stats":{"Line":0}},{"line":5546,"address":[53942304],"length":1,"stats":{"Line":0}},{"line":5550,"address":[54774471],"length":1,"stats":{"Line":0}},{"line":5551,"address":[54774623],"length":1,"stats":{"Line":0}},{"line":5552,"address":[54962166],"length":1,"stats":{"Line":0}},{"line":5553,"address":[],"length":0,"stats":{"Line":0}},{"line":5554,"address":[56514285],"length":1,"stats":{"Line":0}},{"line":5557,"address":[53942647],"length":1,"stats":{"Line":0}},{"line":5558,"address":[],"length":0,"stats":{"Line":0}},{"line":5559,"address":[53942662],"length":1,"stats":{"Line":0}},{"line":5566,"address":[53942872],"length":1,"stats":{"Line":0}},{"line":5567,"address":[],"length":0,"stats":{"Line":0}},{"line":5568,"address":[],"length":0,"stats":{"Line":0}},{"line":5569,"address":[],"length":0,"stats":{"Line":0}},{"line":5570,"address":[53943016],"length":1,"stats":{"Line":0}},{"line":5577,"address":[53943226],"length":1,"stats":{"Line":0}},{"line":5578,"address":[54775382],"length":1,"stats":{"Line":0}},{"line":5579,"address":[56515023],"length":1,"stats":{"Line":0}},{"line":5580,"address":[54962961],"length":1,"stats":{"Line":0}},{"line":5582,"address":[54775533],"length":1,"stats":{"Line":0}},{"line":5583,"address":[54775625],"length":1,"stats":{"Line":0}},{"line":5584,"address":[56515257],"length":1,"stats":{"Line":0}},{"line":5585,"address":[54775729],"length":1,"stats":{"Line":0}},{"line":5587,"address":[53943675],"length":1,"stats":{"Line":0}},{"line":5588,"address":[],"length":0,"stats":{"Line":0}},{"line":5589,"address":[],"length":0,"stats":{"Line":0}},{"line":5590,"address":[54963297],"length":1,"stats":{"Line":0}},{"line":5593,"address":[53943816],"length":1,"stats":{"Line":0}},{"line":5594,"address":[],"length":0,"stats":{"Line":0}},{"line":5595,"address":[54775935],"length":1,"stats":{"Line":0}},{"line":5597,"address":[54963489],"length":1,"stats":{"Line":0}},{"line":5598,"address":[],"length":0,"stats":{"Line":0}},{"line":5601,"address":[54963543],"length":1,"stats":{"Line":0}},{"line":5603,"address":[54776098],"length":1,"stats":{"Line":0}},{"line":5604,"address":[54776113],"length":1,"stats":{"Line":0}},{"line":5607,"address":[54776244],"length":1,"stats":{"Line":0}},{"line":5608,"address":[],"length":0,"stats":{"Line":0}},{"line":5609,"address":[54963723],"length":1,"stats":{"Line":0}},{"line":5614,"address":[53944256],"length":1,"stats":{"Line":0}},{"line":5615,"address":[54776393],"length":1,"stats":{"Line":0}},{"line":5616,"address":[56515998],"length":1,"stats":{"Line":0}},{"line":5617,"address":[54963920],"length":1,"stats":{"Line":0}},{"line":5619,"address":[54776508],"length":1,"stats":{"Line":0}},{"line":5620,"address":[],"length":0,"stats":{"Line":0}},{"line":5621,"address":[56516089],"length":1,"stats":{"Line":0}},{"line":5623,"address":[54776610],"length":1,"stats":{"Line":0}},{"line":5624,"address":[],"length":0,"stats":{"Line":0}},{"line":5625,"address":[56516189],"length":1,"stats":{"Line":0}},{"line":5627,"address":[53944587],"length":1,"stats":{"Line":0}},{"line":5629,"address":[53944682],"length":1,"stats":{"Line":0}},{"line":5630,"address":[],"length":0,"stats":{"Line":0}},{"line":5631,"address":[54776801],"length":1,"stats":{"Line":0}},{"line":5633,"address":[56516450],"length":1,"stats":{"Line":0}},{"line":5634,"address":[],"length":0,"stats":{"Line":0}},{"line":5635,"address":[56516457],"length":1,"stats":{"Line":0}},{"line":5640,"address":[53944868],"length":1,"stats":{"Line":0}},{"line":5641,"address":[54776998],"length":1,"stats":{"Line":0}},{"line":5644,"address":[56516700],"length":1,"stats":{"Line":0}},{"line":5646,"address":[],"length":0,"stats":{"Line":0}},{"line":5647,"address":[54964732],"length":1,"stats":{"Line":0}},{"line":5648,"address":[54964788],"length":1,"stats":{"Line":0}},{"line":5650,"address":[54964845],"length":1,"stats":{"Line":0}},{"line":5652,"address":[54777423],"length":1,"stats":{"Line":0}},{"line":5653,"address":[53945329],"length":1,"stats":{"Line":0}},{"line":5656,"address":[56517134],"length":1,"stats":{"Line":0}},{"line":5657,"address":[54777599],"length":1,"stats":{"Line":0}},{"line":5660,"address":[54965140],"length":1,"stats":{"Line":0}},{"line":5664,"address":[56652272],"length":1,"stats":{"Line":0}},{"line":5668,"address":[56652327],"length":1,"stats":{"Line":0}},{"line":5669,"address":[54915247],"length":1,"stats":{"Line":0}},{"line":5670,"address":[56652534],"length":1,"stats":{"Line":0}},{"line":5671,"address":[],"length":0,"stats":{"Line":0}},{"line":5672,"address":[54083199],"length":1,"stats":{"Line":0}},{"line":5675,"address":[],"length":0,"stats":{"Line":0}},{"line":5676,"address":[],"length":0,"stats":{"Line":0}},{"line":5677,"address":[56652629],"length":1,"stats":{"Line":0}},{"line":5684,"address":[54915608],"length":1,"stats":{"Line":0}},{"line":5687,"address":[56652880],"length":1,"stats":{"Line":0}},{"line":5688,"address":[56652936],"length":1,"stats":{"Line":0}},{"line":5689,"address":[55100829],"length":1,"stats":{"Line":0}},{"line":5690,"address":[],"length":0,"stats":{"Line":0}},{"line":5691,"address":[56653101],"length":1,"stats":{"Line":0}},{"line":5693,"address":[54915924],"length":1,"stats":{"Line":0}},{"line":5694,"address":[],"length":0,"stats":{"Line":0}},{"line":5695,"address":[55100999],"length":1,"stats":{"Line":0}},{"line":5697,"address":[55101079],"length":1,"stats":{"Line":0}},{"line":5698,"address":[],"length":0,"stats":{"Line":0}},{"line":5699,"address":[54083914],"length":1,"stats":{"Line":0}},{"line":5701,"address":[54916108],"length":1,"stats":{"Line":0}},{"line":5702,"address":[54084039],"length":1,"stats":{"Line":0}},{"line":5703,"address":[],"length":0,"stats":{"Line":0}},{"line":5704,"address":[55101330],"length":1,"stats":{"Line":0}},{"line":5705,"address":[55101386],"length":1,"stats":{"Line":0}},{"line":5708,"address":[],"length":0,"stats":{"Line":0}},{"line":5709,"address":[55101472],"length":1,"stats":{"Line":0}},{"line":5710,"address":[],"length":0,"stats":{"Line":0}},{"line":5711,"address":[54084314],"length":1,"stats":{"Line":0}},{"line":5714,"address":[56653739],"length":1,"stats":{"Line":0}},{"line":5715,"address":[],"length":0,"stats":{"Line":0}},{"line":5716,"address":[54916532],"length":1,"stats":{"Line":0}},{"line":5718,"address":[56653831],"length":1,"stats":{"Line":0}},{"line":5719,"address":[56653838],"length":1,"stats":{"Line":0}},{"line":5722,"address":[54916674],"length":1,"stats":{"Line":0}},{"line":5724,"address":[56653906],"length":1,"stats":{"Line":0}},{"line":5725,"address":[],"length":0,"stats":{"Line":0}},{"line":5728,"address":[],"length":0,"stats":{"Line":0}},{"line":5729,"address":[],"length":0,"stats":{"Line":0}},{"line":5730,"address":[54916859],"length":1,"stats":{"Line":0}},{"line":5733,"address":[54084848],"length":1,"stats":{"Line":0}},{"line":5734,"address":[],"length":0,"stats":{"Line":0}},{"line":5735,"address":[56654177],"length":1,"stats":{"Line":0}},{"line":5737,"address":[56654249],"length":1,"stats":{"Line":0}},{"line":5738,"address":[],"length":0,"stats":{"Line":0}},{"line":5739,"address":[56654264],"length":1,"stats":{"Line":0}},{"line":5745,"address":[56654471],"length":1,"stats":{"Line":0}},{"line":5746,"address":[],"length":0,"stats":{"Line":0}},{"line":5748,"address":[],"length":0,"stats":{"Line":0}},{"line":5749,"address":[],"length":0,"stats":{"Line":0}},{"line":5750,"address":[],"length":0,"stats":{"Line":0}},{"line":5756,"address":[54085297],"length":1,"stats":{"Line":0}},{"line":5759,"address":[],"length":0,"stats":{"Line":0}},{"line":5760,"address":[54085368],"length":1,"stats":{"Line":0}},{"line":5764,"address":[],"length":0,"stats":{"Line":0}},{"line":5765,"address":[54085456],"length":1,"stats":{"Line":0}},{"line":5766,"address":[],"length":0,"stats":{"Line":0}},{"line":5767,"address":[56654774],"length":1,"stats":{"Line":0}},{"line":5769,"address":[],"length":0,"stats":{"Line":0}},{"line":5770,"address":[54917708],"length":1,"stats":{"Line":0}},{"line":5773,"address":[],"length":0,"stats":{"Line":0}},{"line":5774,"address":[54917795],"length":1,"stats":{"Line":0}},{"line":5775,"address":[],"length":0,"stats":{"Line":0}},{"line":5776,"address":[54917805],"length":1,"stats":{"Line":0}},{"line":5779,"address":[54085795],"length":1,"stats":{"Line":0}},{"line":5780,"address":[],"length":0,"stats":{"Line":0}},{"line":5781,"address":[54917917],"length":1,"stats":{"Line":0}},{"line":5784,"address":[54085899],"length":1,"stats":{"Line":0}},{"line":5785,"address":[],"length":0,"stats":{"Line":0}},{"line":5786,"address":[56655208],"length":1,"stats":{"Line":0}},{"line":5788,"address":[],"length":0,"stats":{"Line":0}},{"line":5789,"address":[55103143],"length":1,"stats":{"Line":0}},{"line":5792,"address":[54918166],"length":1,"stats":{"Line":0}},{"line":5793,"address":[],"length":0,"stats":{"Line":0}},{"line":5795,"address":[55103310],"length":1,"stats":{"Line":0}},{"line":5796,"address":[54086191],"length":1,"stats":{"Line":0}},{"line":5799,"address":[54918443],"length":1,"stats":{"Line":0}},{"line":5800,"address":[],"length":0,"stats":{"Line":0}},{"line":5801,"address":[54086349],"length":1,"stats":{"Line":0}},{"line":5804,"address":[],"length":0,"stats":{"Line":0}},{"line":5805,"address":[],"length":0,"stats":{"Line":0}},{"line":5806,"address":[54086466],"length":1,"stats":{"Line":0}},{"line":5808,"address":[55103671],"length":1,"stats":{"Line":0}},{"line":5809,"address":[],"length":0,"stats":{"Line":0}},{"line":5810,"address":[54086558],"length":1,"stats":{"Line":0}},{"line":5816,"address":[],"length":0,"stats":{"Line":0}},{"line":5817,"address":[],"length":0,"stats":{"Line":0}},{"line":5819,"address":[],"length":0,"stats":{"Line":0}},{"line":5820,"address":[],"length":0,"stats":{"Line":0}},{"line":5821,"address":[],"length":0,"stats":{"Line":0}},{"line":5827,"address":[56656209],"length":1,"stats":{"Line":0}},{"line":5828,"address":[56656273],"length":1,"stats":{"Line":0}},{"line":5829,"address":[56656280],"length":1,"stats":{"Line":0}},{"line":5832,"address":[],"length":0,"stats":{"Line":0}},{"line":5833,"address":[56656367],"length":1,"stats":{"Line":0}},{"line":5834,"address":[54087140],"length":1,"stats":{"Line":0}},{"line":5837,"address":[54919310],"length":1,"stats":{"Line":0}},{"line":5838,"address":[56656509],"length":1,"stats":{"Line":0}},{"line":5839,"address":[],"length":0,"stats":{"Line":0}},{"line":5840,"address":[56656519],"length":1,"stats":{"Line":0}},{"line":5843,"address":[54087339],"length":1,"stats":{"Line":0}},{"line":5844,"address":[],"length":0,"stats":{"Line":0}},{"line":5845,"address":[56656629],"length":1,"stats":{"Line":0}},{"line":5848,"address":[],"length":0,"stats":{"Line":0}},{"line":5849,"address":[],"length":0,"stats":{"Line":0}},{"line":5850,"address":[56656728],"length":1,"stats":{"Line":0}},{"line":5852,"address":[],"length":0,"stats":{"Line":0}},{"line":5853,"address":[],"length":0,"stats":{"Line":0}},{"line":5854,"address":[],"length":0,"stats":{"Line":0}},{"line":5857,"address":[55104721],"length":1,"stats":{"Line":0}},{"line":5858,"address":[],"length":0,"stats":{"Line":0}},{"line":5859,"address":[56656899],"length":1,"stats":{"Line":0}},{"line":5867,"address":[56657115],"length":1,"stats":{"Line":0}},{"line":5868,"address":[54087862],"length":1,"stats":{"Line":0}},{"line":5871,"address":[],"length":0,"stats":{"Line":0}},{"line":5873,"address":[55105137],"length":1,"stats":{"Line":0}},{"line":5874,"address":[55105152],"length":1,"stats":{"Line":0}},{"line":5880,"address":[54088305],"length":1,"stats":{"Line":0}},{"line":5881,"address":[56657591],"length":1,"stats":{"Line":0}},{"line":5884,"address":[54088463],"length":1,"stats":{"Line":0}},{"line":5885,"address":[54088481],"length":1,"stats":{"Line":0}},{"line":5888,"address":[],"length":0,"stats":{"Line":0}},{"line":5892,"address":[54957040],"length":1,"stats":{"Line":0}},{"line":5897,"address":[56509239],"length":1,"stats":{"Line":0}},{"line":5898,"address":[54769746],"length":1,"stats":{"Line":0}},{"line":5899,"address":[54957446],"length":1,"stats":{"Line":0}},{"line":5901,"address":[],"length":0,"stats":{"Line":0}},{"line":5902,"address":[],"length":0,"stats":{"Line":0}},{"line":5903,"address":[56509630],"length":1,"stats":{"Line":0}},{"line":5905,"address":[54770049],"length":1,"stats":{"Line":0}},{"line":5906,"address":[],"length":0,"stats":{"Line":0}},{"line":5907,"address":[56509714],"length":1,"stats":{"Line":0}},{"line":5910,"address":[53938016],"length":1,"stats":{"Line":0}},{"line":5911,"address":[],"length":0,"stats":{"Line":0}},{"line":5912,"address":[53938031],"length":1,"stats":{"Line":0}},{"line":5919,"address":[54957894],"length":1,"stats":{"Line":0}},{"line":5920,"address":[54957938],"length":1,"stats":{"Line":0}},{"line":5921,"address":[54957991],"length":1,"stats":{"Line":0}},{"line":5922,"address":[54770500],"length":1,"stats":{"Line":0}},{"line":5924,"address":[54770548],"length":1,"stats":{"Line":0}},{"line":5925,"address":[],"length":0,"stats":{"Line":0}},{"line":5926,"address":[54770558],"length":1,"stats":{"Line":0}},{"line":5928,"address":[56510293],"length":1,"stats":{"Line":0}},{"line":5929,"address":[],"length":0,"stats":{"Line":0}},{"line":5930,"address":[54958307],"length":1,"stats":{"Line":0}},{"line":5931,"address":[56510480],"length":1,"stats":{"Line":0}},{"line":5932,"address":[54770891],"length":1,"stats":{"Line":0}},{"line":5934,"address":[],"length":0,"stats":{"Line":0}},{"line":5935,"address":[56510627],"length":1,"stats":{"Line":0}},{"line":5936,"address":[],"length":0,"stats":{"Line":0}},{"line":5937,"address":[56510634],"length":1,"stats":{"Line":0}},{"line":5940,"address":[56510711],"length":1,"stats":{"Line":0}},{"line":5941,"address":[],"length":0,"stats":{"Line":0}},{"line":5942,"address":[53938972],"length":1,"stats":{"Line":0}},{"line":5948,"address":[54958869],"length":1,"stats":{"Line":0}},{"line":5949,"address":[54958902],"length":1,"stats":{"Line":0}},{"line":5950,"address":[],"length":0,"stats":{"Line":0}},{"line":5951,"address":[56511021],"length":1,"stats":{"Line":0}},{"line":5953,"address":[56511106],"length":1,"stats":{"Line":0}},{"line":5954,"address":[53939364],"length":1,"stats":{"Line":0}},{"line":5957,"address":[56511160],"length":1,"stats":{"Line":0}},{"line":5958,"address":[53939441],"length":1,"stats":{"Line":0}},{"line":5959,"address":[],"length":0,"stats":{"Line":0}},{"line":5960,"address":[54959087],"length":1,"stats":{"Line":0}},{"line":5963,"address":[53939545],"length":1,"stats":{"Line":0}},{"line":5964,"address":[],"length":0,"stats":{"Line":0}},{"line":5965,"address":[54771786],"length":1,"stats":{"Line":0}},{"line":5969,"address":[54959354],"length":1,"stats":{"Line":0}},{"line":5970,"address":[53939742],"length":1,"stats":{"Line":0}},{"line":5973,"address":[53939882],"length":1,"stats":{"Line":0}},{"line":5974,"address":[54959566],"length":1,"stats":{"Line":0}},{"line":5976,"address":[54959623],"length":1,"stats":{"Line":0}},{"line":5977,"address":[],"length":0,"stats":{"Line":0}},{"line":5978,"address":[],"length":0,"stats":{"Line":0}},{"line":5979,"address":[56511774],"length":1,"stats":{"Line":0}},{"line":5982,"address":[53940131],"length":1,"stats":{"Line":0}},{"line":5988,"address":[54957936],"length":1,"stats":{"Line":0}},{"line":5992,"address":[54958001],"length":1,"stats":{"Line":0}},{"line":5994,"address":[],"length":0,"stats":{"Line":0}},{"line":5995,"address":[54958200],"length":1,"stats":{"Line":0}},{"line":5996,"address":[54126141],"length":1,"stats":{"Line":0}},{"line":5997,"address":[56694957],"length":1,"stats":{"Line":0}},{"line":5998,"address":[54126241],"length":1,"stats":{"Line":0}},{"line":5999,"address":[],"length":0,"stats":{"Line":0}},{"line":6000,"address":[54126344],"length":1,"stats":{"Line":0}},{"line":6001,"address":[54126397],"length":1,"stats":{"Line":0}},{"line":6002,"address":[56695216],"length":1,"stats":{"Line":0}},{"line":6003,"address":[54958615],"length":1,"stats":{"Line":0}},{"line":6006,"address":[],"length":0,"stats":{"Line":0}},{"line":6007,"address":[],"length":0,"stats":{"Line":0}},{"line":6010,"address":[56695399],"length":1,"stats":{"Line":0}},{"line":6011,"address":[],"length":0,"stats":{"Line":0}},{"line":6014,"address":[54958834],"length":1,"stats":{"Line":0}},{"line":6015,"address":[],"length":0,"stats":{"Line":0}},{"line":6018,"address":[54958925],"length":1,"stats":{"Line":0}},{"line":6019,"address":[],"length":0,"stats":{"Line":0}},{"line":6022,"address":[55143506],"length":1,"stats":{"Line":0}},{"line":6023,"address":[],"length":0,"stats":{"Line":0}},{"line":6026,"address":[56695756],"length":1,"stats":{"Line":0}},{"line":6027,"address":[],"length":0,"stats":{"Line":0}},{"line":6032,"address":[54127089],"length":1,"stats":{"Line":0}},{"line":6034,"address":[],"length":0,"stats":{"Line":0}},{"line":6035,"address":[],"length":0,"stats":{"Line":0}},{"line":6036,"address":[56696163],"length":1,"stats":{"Line":0}},{"line":6037,"address":[56695867],"length":1,"stats":{"Line":0}},{"line":6038,"address":[55143745],"length":1,"stats":{"Line":0}},{"line":6039,"address":[56695936],"length":1,"stats":{"Line":0}},{"line":6040,"address":[54127207],"length":1,"stats":{"Line":0}},{"line":6041,"address":[],"length":0,"stats":{"Line":0}},{"line":6042,"address":[],"length":0,"stats":{"Line":0}},{"line":6043,"address":[],"length":0,"stats":{"Line":0}},{"line":6048,"address":[55144195],"length":1,"stats":{"Line":0}},{"line":6049,"address":[55144216],"length":1,"stats":{"Line":0}},{"line":6050,"address":[54959930],"length":1,"stats":{"Line":0}},{"line":6051,"address":[54127825],"length":1,"stats":{"Line":0}},{"line":6053,"address":[56696624],"length":1,"stats":{"Line":0}},{"line":6055,"address":[54127926],"length":1,"stats":{"Line":0}},{"line":6056,"address":[55144540],"length":1,"stats":{"Line":0}},{"line":6057,"address":[54128145],"length":1,"stats":{"Line":0}},{"line":6058,"address":[],"length":0,"stats":{"Line":0}},{"line":6060,"address":[],"length":0,"stats":{"Line":0}},{"line":6062,"address":[],"length":0,"stats":{"Line":0}},{"line":6063,"address":[55144867],"length":1,"stats":{"Line":0}},{"line":6064,"address":[54128475],"length":1,"stats":{"Line":0}},{"line":6065,"address":[56697233],"length":1,"stats":{"Line":0}},{"line":6067,"address":[54960637],"length":1,"stats":{"Line":0}},{"line":6069,"address":[54960695],"length":1,"stats":{"Line":0}},{"line":6070,"address":[55145194],"length":1,"stats":{"Line":0}},{"line":6071,"address":[54960917],"length":1,"stats":{"Line":0}},{"line":6072,"address":[56697560],"length":1,"stats":{"Line":0}},{"line":6074,"address":[54960967],"length":1,"stats":{"Line":0}},{"line":6076,"address":[56697663],"length":1,"stats":{"Line":0}},{"line":6077,"address":[54128937],"length":1,"stats":{"Line":0}},{"line":6078,"address":[54961250],"length":1,"stats":{"Line":0}},{"line":6079,"address":[54961257],"length":1,"stats":{"Line":0}},{"line":6081,"address":[55145772],"length":1,"stats":{"Line":0}},{"line":6083,"address":[54129249],"length":1,"stats":{"Line":0}},{"line":6084,"address":[56698014],"length":1,"stats":{"Line":0}},{"line":6085,"address":[56698213],"length":1,"stats":{"Line":0}},{"line":6086,"address":[56698220],"length":1,"stats":{"Line":0}},{"line":6088,"address":[56698262],"length":1,"stats":{"Line":0}},{"line":6090,"address":[56698323],"length":1,"stats":{"Line":0}},{"line":6091,"address":[54961715],"length":1,"stats":{"Line":0}},{"line":6092,"address":[54961916],"length":1,"stats":{"Line":0}},{"line":6093,"address":[54129811],"length":1,"stats":{"Line":0}},{"line":6095,"address":[56698592],"length":1,"stats":{"Line":0}},{"line":6097,"address":[],"length":0,"stats":{"Line":0}},{"line":6098,"address":[54129936],"length":1,"stats":{"Line":0}},{"line":6099,"address":[56698873],"length":1,"stats":{"Line":0}},{"line":6100,"address":[56698880],"length":1,"stats":{"Line":0}},{"line":6102,"address":[55146762],"length":1,"stats":{"Line":0}},{"line":6104,"address":[54962357],"length":1,"stats":{"Line":0}},{"line":6105,"address":[54962378],"length":1,"stats":{"Line":0}},{"line":6106,"address":[],"length":0,"stats":{"Line":0}},{"line":6107,"address":[],"length":0,"stats":{"Line":0}},{"line":6109,"address":[55147272],"length":1,"stats":{"Line":0}},{"line":6110,"address":[],"length":0,"stats":{"Line":0}},{"line":6111,"address":[55146999],"length":1,"stats":{"Line":0}},{"line":6112,"address":[56699198],"length":1,"stats":{"Line":0}},{"line":6113,"address":[56699237],"length":1,"stats":{"Line":0}},{"line":6114,"address":[],"length":0,"stats":{"Line":0}},{"line":6115,"address":[56699315],"length":1,"stats":{"Line":0}},{"line":6116,"address":[],"length":0,"stats":{"Line":0}},{"line":6117,"address":[54130660],"length":1,"stats":{"Line":0}},{"line":6120,"address":[55147680],"length":1,"stats":{"Line":0}},{"line":6124,"address":[54777728],"length":1,"stats":{"Line":0}},{"line":6129,"address":[53945703],"length":1,"stats":{"Line":0}},{"line":6130,"address":[53945874],"length":1,"stats":{"Line":0}},{"line":6132,"address":[54965574],"length":1,"stats":{"Line":0}},{"line":6135,"address":[],"length":0,"stats":{"Line":0}},{"line":6136,"address":[53946159],"length":1,"stats":{"Line":0}},{"line":6137,"address":[54965753],"length":1,"stats":{"Line":0}},{"line":6138,"address":[],"length":0,"stats":{"Line":0}},{"line":6139,"address":[53946214],"length":1,"stats":{"Line":0}},{"line":6141,"address":[54965842],"length":1,"stats":{"Line":0}},{"line":6142,"address":[],"length":0,"stats":{"Line":0}},{"line":6143,"address":[54778417],"length":1,"stats":{"Line":0}},{"line":6148,"address":[53946394],"length":1,"stats":{"Line":0}},{"line":6149,"address":[54778550],"length":1,"stats":{"Line":0}},{"line":6150,"address":[56518139],"length":1,"stats":{"Line":0}},{"line":6151,"address":[],"length":0,"stats":{"Line":0}},{"line":6152,"address":[56518146],"length":1,"stats":{"Line":0}},{"line":6154,"address":[54778676],"length":1,"stats":{"Line":0}},{"line":6155,"address":[],"length":0,"stats":{"Line":0}},{"line":6156,"address":[],"length":0,"stats":{"Line":0}},{"line":6159,"address":[53946638],"length":1,"stats":{"Line":0}},{"line":6160,"address":[],"length":0,"stats":{"Line":0}},{"line":6161,"address":[],"length":0,"stats":{"Line":0}},{"line":6169,"address":[56518507],"length":1,"stats":{"Line":0}},{"line":6170,"address":[53946915],"length":1,"stats":{"Line":0}},{"line":6171,"address":[],"length":0,"stats":{"Line":0}},{"line":6172,"address":[53946922],"length":1,"stats":{"Line":0}},{"line":6174,"address":[54779114],"length":1,"stats":{"Line":0}},{"line":6177,"address":[53947052],"length":1,"stats":{"Line":0}},{"line":6178,"address":[56518739],"length":1,"stats":{"Line":0}},{"line":6180,"address":[56518804],"length":1,"stats":{"Line":0}},{"line":6181,"address":[54779283],"length":1,"stats":{"Line":0}},{"line":6184,"address":[54966808],"length":1,"stats":{"Line":0}},{"line":6185,"address":[],"length":0,"stats":{"Line":0}},{"line":6186,"address":[54966815],"length":1,"stats":{"Line":0}},{"line":6190,"address":[],"length":0,"stats":{"Line":0}},{"line":6191,"address":[56519058],"length":1,"stats":{"Line":0}},{"line":6192,"address":[53947472],"length":1,"stats":{"Line":0}},{"line":6194,"address":[54779632],"length":1,"stats":{"Line":0}},{"line":6195,"address":[],"length":0,"stats":{"Line":0}},{"line":6196,"address":[53947675],"length":1,"stats":{"Line":0}},{"line":6198,"address":[56519367],"length":1,"stats":{"Line":0}},{"line":6199,"address":[54779874],"length":1,"stats":{"Line":0}},{"line":6200,"address":[],"length":0,"stats":{"Line":0}},{"line":6201,"address":[],"length":0,"stats":{"Line":0}},{"line":6204,"address":[53947874],"length":1,"stats":{"Line":0}},{"line":6205,"address":[],"length":0,"stats":{"Line":0}},{"line":6206,"address":[53947881],"length":1,"stats":{"Line":0}},{"line":6208,"address":[54967489],"length":1,"stats":{"Line":0}},{"line":6209,"address":[],"length":0,"stats":{"Line":0}},{"line":6212,"address":[],"length":0,"stats":{"Line":0}},{"line":6213,"address":[56519695],"length":1,"stats":{"Line":0}},{"line":6215,"address":[54780276],"length":1,"stats":{"Line":0}},{"line":6216,"address":[],"length":0,"stats":{"Line":0}},{"line":6219,"address":[56519915],"length":1,"stats":{"Line":0}},{"line":6220,"address":[53948461],"length":1,"stats":{"Line":0}},{"line":6222,"address":[54968033],"length":1,"stats":{"Line":0}},{"line":6223,"address":[56520225],"length":1,"stats":{"Line":0}},{"line":6224,"address":[53948664],"length":1,"stats":{"Line":0}},{"line":6226,"address":[53948722],"length":1,"stats":{"Line":0}},{"line":6227,"address":[53948756],"length":1,"stats":{"Line":0}},{"line":6232,"address":[53920597,53920629,53917856],"length":1,"stats":{"Line":13}},{"line":6233,"address":[56489949],"length":1,"stats":{"Line":13}},{"line":6234,"address":[53918245],"length":1,"stats":{"Line":10}},{"line":6235,"address":[],"length":0,"stats":{"Line":0}},{"line":6236,"address":[],"length":0,"stats":{"Line":0}},{"line":6238,"address":[],"length":0,"stats":{"Line":22}},{"line":6239,"address":[54939876],"length":1,"stats":{"Line":12}},{"line":6241,"address":[],"length":0,"stats":{"Line":1}},{"line":6243,"address":[56492018],"length":1,"stats":{"Line":10}},{"line":6246,"address":[54752209],"length":1,"stats":{"Line":12}},{"line":6247,"address":[54752257,54752338],"length":1,"stats":{"Line":14}},{"line":6248,"address":[56492293],"length":1,"stats":{"Line":4}},{"line":6249,"address":[],"length":0,"stats":{"Line":4}},{"line":6250,"address":[],"length":0,"stats":{"Line":0}},{"line":6252,"address":[54752447],"length":1,"stats":{"Line":4}},{"line":6253,"address":[53920388,53920527],"length":1,"stats":{"Line":0}},{"line":6254,"address":[56492484,56492558,56492605,56492401],"length":1,"stats":{"Line":0}},{"line":6262,"address":[53920657,53920200],"length":1,"stats":{"Line":13}},{"line":6263,"address":[54940526],"length":1,"stats":{"Line":9}},{"line":6264,"address":[54940557],"length":1,"stats":{"Line":13}},{"line":6265,"address":[56492693],"length":1,"stats":{"Line":9}},{"line":6266,"address":[56492722],"length":1,"stats":{"Line":13}},{"line":6270,"address":[56492753,56492810],"length":1,"stats":{"Line":8}},{"line":6272,"address":[54940801,54941238,54940715],"length":1,"stats":{"Line":0}},{"line":6273,"address":[53920915],"length":1,"stats":{"Line":0}},{"line":6275,"address":[53920928,53921151],"length":1,"stats":{"Line":0}},{"line":6276,"address":[],"length":0,"stats":{"Line":0}},{"line":6277,"address":[53921353],"length":1,"stats":{"Line":0}},{"line":6281,"address":[54940988,54941259],"length":1,"stats":{"Line":0}},{"line":6282,"address":[56493380],"length":1,"stats":{"Line":0}},{"line":6283,"address":[],"length":0,"stats":{"Line":0}},{"line":6284,"address":[],"length":0,"stats":{"Line":0}},{"line":6287,"address":[54941728,54941645],"length":1,"stats":{"Line":0}},{"line":6288,"address":[56493833],"length":1,"stats":{"Line":0}},{"line":6290,"address":[56493846],"length":1,"stats":{"Line":0}},{"line":6291,"address":[],"length":0,"stats":{"Line":0}},{"line":6292,"address":[56493980],"length":1,"stats":{"Line":0}},{"line":6294,"address":[56494012],"length":1,"stats":{"Line":0}},{"line":6295,"address":[54941955],"length":1,"stats":{"Line":0}},{"line":6301,"address":[56494140,56492777],"length":1,"stats":{"Line":19}},{"line":6303,"address":[],"length":0,"stats":{"Line":2}},{"line":6304,"address":[],"length":0,"stats":{"Line":0}},{"line":6306,"address":[56494472,56494249],"length":1,"stats":{"Line":1}},{"line":6307,"address":[56494593],"length":1,"stats":{"Line":1}},{"line":6308,"address":[],"length":0,"stats":{"Line":1}},{"line":6312,"address":[56494431,56494702],"length":1,"stats":{"Line":2}},{"line":6313,"address":[54754844],"length":1,"stats":{"Line":1}},{"line":6315,"address":[54500080],"length":1,"stats":{"Line":1}},{"line":6316,"address":[],"length":0,"stats":{"Line":0}},{"line":6320,"address":[53923122],"length":1,"stats":{"Line":1}},{"line":6322,"address":[54755251,54755349,54755376],"length":1,"stats":{"Line":1}},{"line":6323,"address":[56495226],"length":1,"stats":{"Line":0}},{"line":6325,"address":[56495239],"length":1,"stats":{"Line":1}},{"line":6326,"address":[53923325],"length":1,"stats":{"Line":1}},{"line":6327,"address":[54943260],"length":1,"stats":{"Line":1}},{"line":6329,"address":[54755540],"length":1,"stats":{"Line":1}},{"line":6330,"address":[53107840],"length":1,"stats":{"Line":1}},{"line":6331,"address":[56095376],"length":1,"stats":{"Line":0}},{"line":6335,"address":[],"length":0,"stats":{"Line":1}},{"line":6336,"address":[53923788],"length":1,"stats":{"Line":1}},{"line":6337,"address":[56495807],"length":1,"stats":{"Line":1}},{"line":6340,"address":[53923776],"length":1,"stats":{"Line":1}},{"line":6346,"address":[54941986,54943785],"length":1,"stats":{"Line":19}},{"line":6347,"address":[54943793,54943888],"length":1,"stats":{"Line":11}},{"line":6349,"address":[56495978],"length":1,"stats":{"Line":1}},{"line":6355,"address":[54756268,54756299],"length":1,"stats":{"Line":12}},{"line":6356,"address":[54944020],"length":1,"stats":{"Line":8}},{"line":6357,"address":[53924205],"length":1,"stats":{"Line":11}},{"line":6358,"address":[53924229],"length":1,"stats":{"Line":8}},{"line":6360,"address":[54756378,54756462],"length":1,"stats":{"Line":11}},{"line":6361,"address":[53924342],"length":1,"stats":{"Line":0}},{"line":6362,"address":[54944203,54944402,54944429],"length":1,"stats":{"Line":8}},{"line":6364,"address":[],"length":0,"stats":{"Line":0}},{"line":6365,"address":[],"length":0,"stats":{"Line":21}},{"line":6367,"address":[54944603],"length":1,"stats":{"Line":8}},{"line":6368,"address":[53924868],"length":1,"stats":{"Line":11}},{"line":6369,"address":[54944763],"length":1,"stats":{"Line":8}},{"line":6370,"address":[53924959],"length":1,"stats":{"Line":10}},{"line":6372,"address":[56496990],"length":1,"stats":{"Line":9}},{"line":6373,"address":[56497068],"length":1,"stats":{"Line":10}},{"line":6375,"address":[54756721],"length":1,"stats":{"Line":1}},{"line":6376,"address":[56496618],"length":1,"stats":{"Line":1}},{"line":6377,"address":[54756856],"length":1,"stats":{"Line":1}},{"line":6379,"address":[54756616,54757278,54756549],"length":1,"stats":{"Line":19}},{"line":6380,"address":[54944286],"length":1,"stats":{"Line":9}},{"line":6381,"address":[54944967,54944323],"length":1,"stats":{"Line":10}},{"line":6384,"address":[56497156,56497221],"length":1,"stats":{"Line":19}},{"line":6385,"address":[54945131],"length":1,"stats":{"Line":8}},{"line":6386,"address":[56497540],"length":1,"stats":{"Line":11}},{"line":6387,"address":[53107664],"length":1,"stats":{"Line":9}},{"line":6388,"address":[53107680],"length":1,"stats":{"Line":0}},{"line":6390,"address":[54758053],"length":1,"stats":{"Line":10}},{"line":6394,"address":[54758159,54757344],"length":1,"stats":{"Line":10}},{"line":6395,"address":[56498011],"length":1,"stats":{"Line":1}},{"line":6396,"address":[],"length":0,"stats":{"Line":0}},{"line":6397,"address":[54758474],"length":1,"stats":{"Line":1}},{"line":6398,"address":[],"length":0,"stats":{"Line":0}},{"line":6400,"address":[54948619,54946482],"length":1,"stats":{"Line":1}},{"line":6401,"address":[54758817,54759045],"length":1,"stats":{"Line":2}},{"line":6402,"address":[],"length":0,"stats":{"Line":1}},{"line":6403,"address":[],"length":0,"stats":{"Line":0}},{"line":6404,"address":[],"length":0,"stats":{"Line":0}},{"line":6407,"address":[54759209],"length":1,"stats":{"Line":1}},{"line":6408,"address":[],"length":0,"stats":{"Line":1}},{"line":6409,"address":[54501200],"length":1,"stats":{"Line":1}},{"line":6410,"address":[54005392],"length":1,"stats":{"Line":0}},{"line":6414,"address":[53927340],"length":1,"stats":{"Line":1}},{"line":6415,"address":[54759498,54759625],"length":1,"stats":{"Line":1}},{"line":6416,"address":[54499776],"length":1,"stats":{"Line":0}},{"line":6420,"address":[54759101,54759828],"length":1,"stats":{"Line":0}},{"line":6421,"address":[54947615],"length":1,"stats":{"Line":0}},{"line":6422,"address":[],"length":0,"stats":{"Line":0}},{"line":6423,"address":[54759974],"length":1,"stats":{"Line":0}},{"line":6424,"address":[],"length":0,"stats":{"Line":0}},{"line":6425,"address":[],"length":0,"stats":{"Line":0}},{"line":6427,"address":[54760048],"length":1,"stats":{"Line":0}},{"line":6428,"address":[],"length":0,"stats":{"Line":0}},{"line":6429,"address":[],"length":0,"stats":{"Line":0}},{"line":6435,"address":[53108368],"length":1,"stats":{"Line":0}},{"line":6436,"address":[53108384],"length":1,"stats":{"Line":0}},{"line":6439,"address":[54760450],"length":1,"stats":{"Line":0}},{"line":6440,"address":[53928511,53928384],"length":1,"stats":{"Line":0}},{"line":6441,"address":[],"length":0,"stats":{"Line":0}},{"line":6446,"address":[54946594],"length":1,"stats":{"Line":0}},{"line":6447,"address":[53928592,53926823],"length":1,"stats":{"Line":0}},{"line":6448,"address":[53106448],"length":1,"stats":{"Line":0}},{"line":6450,"address":[53108544],"length":1,"stats":{"Line":0}},{"line":6451,"address":[],"length":0,"stats":{"Line":0}},{"line":6454,"address":[54759675],"length":1,"stats":{"Line":1}},{"line":6455,"address":[],"length":0,"stats":{"Line":1}},{"line":6457,"address":[54945853],"length":1,"stats":{"Line":10}},{"line":6460,"address":[56490361],"length":1,"stats":{"Line":4}},{"line":6461,"address":[],"length":0,"stats":{"Line":4}},{"line":6462,"address":[],"length":0,"stats":{"Line":4}},{"line":6465,"address":[53918438],"length":1,"stats":{"Line":5}},{"line":6466,"address":[54948735,54938360],"length":1,"stats":{"Line":11}},{"line":6467,"address":[54948811,54948898],"length":1,"stats":{"Line":5}},{"line":6469,"address":[56501000],"length":1,"stats":{"Line":4}},{"line":6472,"address":[],"length":0,"stats":{"Line":6}},{"line":6473,"address":[53919035,53930263],"length":1,"stats":{"Line":4}},{"line":6474,"address":[54950139],"length":1,"stats":{"Line":4}},{"line":6475,"address":[54950268],"length":1,"stats":{"Line":9}},{"line":6478,"address":[54750648],"length":1,"stats":{"Line":5}},{"line":6479,"address":[],"length":0,"stats":{"Line":0}},{"line":6480,"address":[],"length":0,"stats":{"Line":0}},{"line":6481,"address":[],"length":0,"stats":{"Line":0}},{"line":6482,"address":[],"length":0,"stats":{"Line":0}},{"line":6483,"address":[],"length":0,"stats":{"Line":0}},{"line":6485,"address":[56490659,56501201],"length":1,"stats":{"Line":8}},{"line":6486,"address":[],"length":0,"stats":{"Line":0}},{"line":6487,"address":[],"length":0,"stats":{"Line":0}},{"line":6489,"address":[56490690],"length":1,"stats":{"Line":0}},{"line":6490,"address":[],"length":0,"stats":{"Line":0}},{"line":6491,"address":[],"length":0,"stats":{"Line":0}},{"line":6492,"address":[],"length":0,"stats":{"Line":0}},{"line":6493,"address":[],"length":0,"stats":{"Line":0}},{"line":6494,"address":[],"length":0,"stats":{"Line":0}},{"line":6496,"address":[54938725],"length":1,"stats":{"Line":7}},{"line":6497,"address":[],"length":0,"stats":{"Line":0}},{"line":6498,"address":[],"length":0,"stats":{"Line":0}},{"line":6500,"address":[54938809],"length":1,"stats":{"Line":7}},{"line":6501,"address":[54761640,54761875],"length":1,"stats":{"Line":0}},{"line":6503,"address":[56501548],"length":1,"stats":{"Line":7}},{"line":6506,"address":[54938834],"length":1,"stats":{"Line":4}},{"line":6507,"address":[],"length":0,"stats":{"Line":8}},{"line":6508,"address":[56501838,56501743],"length":1,"stats":{"Line":6}},{"line":6510,"address":[54949701],"length":1,"stats":{"Line":0}},{"line":6512,"address":[53930201,53930059],"length":1,"stats":{"Line":5}},{"line":6513,"address":[54006096],"length":1,"stats":{"Line":0}},{"line":6515,"address":[54950028],"length":1,"stats":{"Line":5}},{"line":6518,"address":[],"length":0,"stats":{"Line":0}},{"line":6519,"address":[53930743,53930514,53919115,53930839],"length":1,"stats":{"Line":0}},{"line":6520,"address":[53930782,53930530,53930576],"length":1,"stats":{"Line":0}},{"line":6521,"address":[54950311],"length":1,"stats":{"Line":0}},{"line":6522,"address":[53930554],"length":1,"stats":{"Line":0}},{"line":6523,"address":[],"length":0,"stats":{"Line":0}},{"line":6525,"address":[],"length":0,"stats":{"Line":0}},{"line":6527,"address":[],"length":0,"stats":{"Line":0}},{"line":6531,"address":[],"length":0,"stats":{"Line":0}},{"line":6532,"address":[54950946,54950851,54939090,54950623],"length":1,"stats":{"Line":0}},{"line":6533,"address":[54763027,54762980,54763233],"length":1,"stats":{"Line":0}},{"line":6534,"address":[53930875],"length":1,"stats":{"Line":0}},{"line":6535,"address":[53108016],"length":1,"stats":{"Line":0}},{"line":6536,"address":[],"length":0,"stats":{"Line":0}},{"line":6538,"address":[53931171],"length":1,"stats":{"Line":0}},{"line":6540,"address":[54950773],"length":1,"stats":{"Line":0}},{"line":6541,"address":[],"length":0,"stats":{"Line":0}},{"line":6546,"address":[53919283],"length":1,"stats":{"Line":0}},{"line":6547,"address":[],"length":0,"stats":{"Line":0}},{"line":6548,"address":[],"length":0,"stats":{"Line":0}},{"line":6549,"address":[],"length":0,"stats":{"Line":0}},{"line":6550,"address":[],"length":0,"stats":{"Line":0}},{"line":6551,"address":[],"length":0,"stats":{"Line":0}},{"line":6553,"address":[54939288],"length":1,"stats":{"Line":0}},{"line":6555,"address":[54939561],"length":1,"stats":{"Line":0}},{"line":6556,"address":[],"length":0,"stats":{"Line":0}},{"line":6557,"address":[],"length":0,"stats":{"Line":0}},{"line":6559,"address":[53919574],"length":1,"stats":{"Line":0}},{"line":6561,"address":[],"length":0,"stats":{"Line":0}},{"line":6562,"address":[],"length":0,"stats":{"Line":0}},{"line":6563,"address":[],"length":0,"stats":{"Line":0}},{"line":6565,"address":[56491521],"length":1,"stats":{"Line":0}},{"line":6566,"address":[],"length":0,"stats":{"Line":0}},{"line":6567,"address":[],"length":0,"stats":{"Line":0}},{"line":6568,"address":[],"length":0,"stats":{"Line":0}},{"line":6569,"address":[],"length":0,"stats":{"Line":0}},{"line":6570,"address":[],"length":0,"stats":{"Line":0}},{"line":6572,"address":[56491873],"length":1,"stats":{"Line":0}},{"line":6573,"address":[],"length":0,"stats":{"Line":0}},{"line":6574,"address":[],"length":0,"stats":{"Line":0}},{"line":6576,"address":[54951176,54939781],"length":1,"stats":{"Line":0}},{"line":6577,"address":[],"length":0,"stats":{"Line":0}},{"line":6578,"address":[],"length":0,"stats":{"Line":0}},{"line":6582,"address":[56490044],"length":1,"stats":{"Line":0}},{"line":6583,"address":[],"length":0,"stats":{"Line":0}},{"line":6584,"address":[],"length":0,"stats":{"Line":0}},{"line":6591,"address":[54916096,54919161,54919167],"length":1,"stats":{"Line":7}},{"line":6592,"address":[54916166],"length":1,"stats":{"Line":5}},{"line":6593,"address":[56468375],"length":1,"stats":{"Line":7}},{"line":6595,"address":[53896125],"length":1,"stats":{"Line":5}},{"line":6596,"address":[54728249,54731257,54730094],"length":1,"stats":{"Line":15}},{"line":6600,"address":[54730121],"length":1,"stats":{"Line":5}},{"line":6601,"address":[54730400],"length":1,"stats":{"Line":3}},{"line":6602,"address":[],"length":0,"stats":{"Line":9}},{"line":6603,"address":[],"length":0,"stats":{"Line":0}},{"line":6605,"address":[53898405],"length":1,"stats":{"Line":3}},{"line":6606,"address":[],"length":0,"stats":{"Line":0}},{"line":6607,"address":[54730532],"length":1,"stats":{"Line":3}},{"line":6609,"address":[56090912],"length":1,"stats":{"Line":3}},{"line":6610,"address":[54497696],"length":1,"stats":{"Line":0}},{"line":6611,"address":[],"length":0,"stats":{"Line":0}},{"line":6612,"address":[],"length":0,"stats":{"Line":0}},{"line":6616,"address":[54919132],"length":1,"stats":{"Line":3}},{"line":6619,"address":[54731176,54730221,54730333],"length":1,"stats":{"Line":10}},{"line":6620,"address":[],"length":0,"stats":{"Line":0}},{"line":6621,"address":[54730239],"length":1,"stats":{"Line":5}},{"line":6622,"address":[54002928,54002944],"length":1,"stats":{"Line":5}},{"line":6623,"address":[53899130],"length":1,"stats":{"Line":5}},{"line":6624,"address":[53899158,53899853,53898032],"length":1,"stats":{"Line":0}},{"line":6626,"address":[],"length":0,"stats":{"Line":0}},{"line":6627,"address":[],"length":0,"stats":{"Line":0}},{"line":6628,"address":[54731315,54731665],"length":1,"stats":{"Line":0}},{"line":6629,"address":[53103984],"length":1,"stats":{"Line":0}},{"line":6630,"address":[56092336],"length":1,"stats":{"Line":0}},{"line":6632,"address":[54919970],"length":1,"stats":{"Line":0}},{"line":6633,"address":[56472121,56471661],"length":1,"stats":{"Line":0}},{"line":6635,"address":[54732008],"length":1,"stats":{"Line":0}},{"line":6636,"address":[54920062],"length":1,"stats":{"Line":0}},{"line":6637,"address":[],"length":0,"stats":{"Line":0}},{"line":6638,"address":[56472184],"length":1,"stats":{"Line":0}},{"line":6640,"address":[53900022],"length":1,"stats":{"Line":0}},{"line":6641,"address":[56472274],"length":1,"stats":{"Line":0}},{"line":6643,"address":[],"length":0,"stats":{"Line":0}},{"line":6644,"address":[],"length":0,"stats":{"Line":0}},{"line":6645,"address":[],"length":0,"stats":{"Line":0}},{"line":6647,"address":[54920321],"length":1,"stats":{"Line":0}},{"line":6648,"address":[54732359],"length":1,"stats":{"Line":0}},{"line":6649,"address":[54732267,54732581],"length":1,"stats":{"Line":0}},{"line":6651,"address":[54732594],"length":1,"stats":{"Line":0}},{"line":6652,"address":[56472777],"length":1,"stats":{"Line":0}},{"line":6654,"address":[53900257],"length":1,"stats":{"Line":0}},{"line":6655,"address":[],"length":0,"stats":{"Line":0}},{"line":6656,"address":[],"length":0,"stats":{"Line":0}},{"line":6661,"address":[],"length":0,"stats":{"Line":4}},{"line":6663,"address":[],"length":0,"stats":{"Line":8}},{"line":6665,"address":[],"length":0,"stats":{"Line":8}},{"line":6667,"address":[53900975,53901102],"length":1,"stats":{"Line":4}},{"line":6668,"address":[54496288],"length":1,"stats":{"Line":0}},{"line":6672,"address":[54921272],"length":1,"stats":{"Line":4}},{"line":6674,"address":[],"length":0,"stats":{"Line":4}},{"line":6675,"address":[56474096],"length":1,"stats":{"Line":4}},{"line":6679,"address":[56473566,56473412],"length":1,"stats":{"Line":1}},{"line":6680,"address":[53901449,53901768],"length":1,"stats":{"Line":2}},{"line":6681,"address":[56092480],"length":1,"stats":{"Line":1}},{"line":6682,"address":[56092496],"length":1,"stats":{"Line":0}},{"line":6685,"address":[53901672],"length":1,"stats":{"Line":1}},{"line":6691,"address":[54922009,54920738],"length":1,"stats":{"Line":1}},{"line":6692,"address":[56474294,56474151],"length":1,"stats":{"Line":0}},{"line":6693,"address":[56474393,56474321],"length":1,"stats":{"Line":0}},{"line":6694,"address":[54922300],"length":1,"stats":{"Line":0}},{"line":6695,"address":[],"length":0,"stats":{"Line":0}},{"line":6696,"address":[54922315],"length":1,"stats":{"Line":0}},{"line":6697,"address":[],"length":0,"stats":{"Line":0}},{"line":6698,"address":[],"length":0,"stats":{"Line":0}},{"line":6701,"address":[54734339],"length":1,"stats":{"Line":0}},{"line":6702,"address":[],"length":0,"stats":{"Line":0}},{"line":6703,"address":[],"length":0,"stats":{"Line":0}},{"line":6705,"address":[53902341],"length":1,"stats":{"Line":0}},{"line":6707,"address":[56474707,56474633,56474689],"length":1,"stats":{"Line":0}},{"line":6708,"address":[54922602],"length":1,"stats":{"Line":0}},{"line":6709,"address":[],"length":0,"stats":{"Line":0}},{"line":6710,"address":[],"length":0,"stats":{"Line":0}},{"line":6712,"address":[56474729],"length":1,"stats":{"Line":0}},{"line":6714,"address":[54734586],"length":1,"stats":{"Line":0}},{"line":6716,"address":[],"length":0,"stats":{"Line":0}},{"line":6717,"address":[],"length":0,"stats":{"Line":0}},{"line":6719,"address":[54734877],"length":1,"stats":{"Line":0}},{"line":6720,"address":[54734701,54734896],"length":1,"stats":{"Line":0}},{"line":6730,"address":[],"length":0,"stats":{"Line":2}},{"line":6732,"address":[54922938,54923025],"length":1,"stats":{"Line":0}},{"line":6733,"address":[56475175],"length":1,"stats":{"Line":0}},{"line":6734,"address":[],"length":0,"stats":{"Line":0}},{"line":6735,"address":[54923075],"length":1,"stats":{"Line":0}},{"line":6736,"address":[],"length":0,"stats":{"Line":0}},{"line":6737,"address":[],"length":0,"stats":{"Line":0}},{"line":6740,"address":[54923095],"length":1,"stats":{"Line":0}},{"line":6741,"address":[],"length":0,"stats":{"Line":0}},{"line":6742,"address":[],"length":0,"stats":{"Line":0}},{"line":6744,"address":[56475323],"length":1,"stats":{"Line":0}},{"line":6746,"address":[],"length":0,"stats":{"Line":0}},{"line":6748,"address":[],"length":0,"stats":{"Line":0}},{"line":6749,"address":[],"length":0,"stats":{"Line":0}},{"line":6750,"address":[54735277],"length":1,"stats":{"Line":0}},{"line":6753,"address":[],"length":0,"stats":{"Line":0}},{"line":6754,"address":[53903550],"length":1,"stats":{"Line":0}},{"line":6755,"address":[],"length":0,"stats":{"Line":0}},{"line":6756,"address":[],"length":0,"stats":{"Line":0}},{"line":6758,"address":[54923661],"length":1,"stats":{"Line":0}},{"line":6759,"address":[53903464,53903703],"length":1,"stats":{"Line":0}},{"line":6760,"address":[],"length":0,"stats":{"Line":0}},{"line":6761,"address":[54735951],"length":1,"stats":{"Line":0}},{"line":6762,"address":[],"length":0,"stats":{"Line":0}},{"line":6767,"address":[53903937],"length":1,"stats":{"Line":0}},{"line":6770,"address":[54923877],"length":1,"stats":{"Line":0}},{"line":6773,"address":[54735784,54736131],"length":1,"stats":{"Line":0}},{"line":6774,"address":[],"length":0,"stats":{"Line":0}},{"line":6775,"address":[],"length":0,"stats":{"Line":0}},{"line":6776,"address":[],"length":0,"stats":{"Line":0}},{"line":6778,"address":[53904096],"length":1,"stats":{"Line":0}},{"line":6779,"address":[54736244,54736145,54736288],"length":1,"stats":{"Line":0}},{"line":6780,"address":[54924238],"length":1,"stats":{"Line":0}},{"line":6782,"address":[53904168],"length":1,"stats":{"Line":0}},{"line":6784,"address":[],"length":0,"stats":{"Line":0}},{"line":6786,"address":[54924304],"length":1,"stats":{"Line":0}},{"line":6787,"address":[54736330],"length":1,"stats":{"Line":0}},{"line":6788,"address":[56476460],"length":1,"stats":{"Line":0}},{"line":6791,"address":[53904178],"length":1,"stats":{"Line":0}},{"line":6794,"address":[54923226],"length":1,"stats":{"Line":0}},{"line":6797,"address":[],"length":0,"stats":{"Line":0}},{"line":6800,"address":[56475115],"length":1,"stats":{"Line":1}},{"line":6804,"address":[53904307,53903330],"length":1,"stats":{"Line":1}},{"line":6805,"address":[],"length":0,"stats":{"Line":0}},{"line":6806,"address":[54736546],"length":1,"stats":{"Line":0}},{"line":6807,"address":[],"length":0,"stats":{"Line":0}},{"line":6809,"address":[],"length":0,"stats":{"Line":0}},{"line":6810,"address":[53904504,53904646],"length":1,"stats":{"Line":0}},{"line":6811,"address":[53904601,53904654,53904518],"length":1,"stats":{"Line":0}},{"line":6817,"address":[54924831,54924478],"length":1,"stats":{"Line":2}},{"line":6819,"address":[],"length":0,"stats":{"Line":1}},{"line":6820,"address":[],"length":0,"stats":{"Line":0}},{"line":6821,"address":[],"length":0,"stats":{"Line":1}},{"line":6823,"address":[53905040],"length":1,"stats":{"Line":1}},{"line":6824,"address":[54738257,54737561,54737189],"length":1,"stats":{"Line":2}},{"line":6825,"address":[56092160],"length":1,"stats":{"Line":1}},{"line":6826,"address":[53103648],"length":1,"stats":{"Line":0}},{"line":6829,"address":[56477729,56478238],"length":1,"stats":{"Line":1}},{"line":6830,"address":[53905649,53905794],"length":1,"stats":{"Line":0}},{"line":6831,"address":[53905886,53906013],"length":1,"stats":{"Line":0}},{"line":6832,"address":[54496128],"length":1,"stats":{"Line":0}},{"line":6836,"address":[54926128,54925799],"length":1,"stats":{"Line":1}},{"line":6837,"address":[53906166,53906448,53907091,53906087],"length":1,"stats":{"Line":0}},{"line":6839,"address":[53103280],"length":1,"stats":{"Line":0}},{"line":6840,"address":[53103296],"length":1,"stats":{"Line":0}},{"line":6844,"address":[54738565,54738416],"length":1,"stats":{"Line":0}},{"line":6845,"address":[54738657],"length":1,"stats":{"Line":0}},{"line":6846,"address":[],"length":0,"stats":{"Line":0}},{"line":6847,"address":[],"length":0,"stats":{"Line":0}},{"line":6848,"address":[],"length":0,"stats":{"Line":0}},{"line":6849,"address":[54926680],"length":1,"stats":{"Line":0}},{"line":6851,"address":[56478860],"length":1,"stats":{"Line":0}},{"line":6852,"address":[],"length":0,"stats":{"Line":0}},{"line":6853,"address":[],"length":0,"stats":{"Line":0}},{"line":6859,"address":[56091680],"length":1,"stats":{"Line":0}},{"line":6860,"address":[],"length":0,"stats":{"Line":0}},{"line":6864,"address":[],"length":0,"stats":{"Line":1}},{"line":6866,"address":[53905237],"length":1,"stats":{"Line":0}},{"line":6867,"address":[],"length":0,"stats":{"Line":0}},{"line":6868,"address":[],"length":0,"stats":{"Line":0}},{"line":6873,"address":[],"length":0,"stats":{"Line":7}},{"line":6874,"address":[],"length":0,"stats":{"Line":0}},{"line":6875,"address":[],"length":0,"stats":{"Line":0}},{"line":6876,"address":[],"length":0,"stats":{"Line":0}},{"line":6877,"address":[],"length":0,"stats":{"Line":0}},{"line":6878,"address":[],"length":0,"stats":{"Line":0}},{"line":6880,"address":[],"length":0,"stats":{"Line":1}},{"line":6881,"address":[],"length":0,"stats":{"Line":0}},{"line":6882,"address":[],"length":0,"stats":{"Line":0}},{"line":6884,"address":[54927496,54916745],"length":1,"stats":{"Line":2}},{"line":6885,"address":[],"length":0,"stats":{"Line":0}},{"line":6886,"address":[],"length":0,"stats":{"Line":0}},{"line":6887,"address":[],"length":0,"stats":{"Line":0}},{"line":6888,"address":[],"length":0,"stats":{"Line":0}},{"line":6889,"address":[],"length":0,"stats":{"Line":0}},{"line":6891,"address":[],"length":0,"stats":{"Line":5}},{"line":6892,"address":[],"length":0,"stats":{"Line":0}},{"line":6893,"address":[],"length":0,"stats":{"Line":0}},{"line":6895,"address":[54917540,54929346],"length":1,"stats":{"Line":2}},{"line":6897,"address":[54918052],"length":1,"stats":{"Line":0}},{"line":6898,"address":[],"length":0,"stats":{"Line":0}},{"line":6899,"address":[],"length":0,"stats":{"Line":0}},{"line":6900,"address":[],"length":0,"stats":{"Line":0}},{"line":6901,"address":[],"length":0,"stats":{"Line":0}},{"line":6902,"address":[],"length":0,"stats":{"Line":0}},{"line":6904,"address":[54729403],"length":1,"stats":{"Line":0}},{"line":6906,"address":[53897329,53908766],"length":1,"stats":{"Line":0}},{"line":6907,"address":[56481165],"length":1,"stats":{"Line":0}},{"line":6908,"address":[54929302],"length":1,"stats":{"Line":0}},{"line":6911,"address":[53897149],"length":1,"stats":{"Line":1}},{"line":6913,"address":[54917393],"length":1,"stats":{"Line":0}},{"line":6915,"address":[54928186,54917023],"length":1,"stats":{"Line":0}},{"line":6917,"address":[53896941],"length":1,"stats":{"Line":0}},{"line":6918,"address":[],"length":0,"stats":{"Line":0}},{"line":6919,"address":[],"length":0,"stats":{"Line":0}},{"line":6920,"address":[],"length":0,"stats":{"Line":0}},{"line":6921,"address":[],"length":0,"stats":{"Line":0}},{"line":6922,"address":[],"length":0,"stats":{"Line":0}},{"line":6924,"address":[54729659],"length":1,"stats":{"Line":0}},{"line":6926,"address":[],"length":0,"stats":{"Line":0}},{"line":6927,"address":[53909887,53909750,53909971,53910142,53910058],"length":1,"stats":{"Line":0}},{"line":6928,"address":[],"length":0,"stats":{"Line":0}},{"line":6929,"address":[53909765],"length":1,"stats":{"Line":0}},{"line":6930,"address":[54929907,54929977],"length":1,"stats":{"Line":0}},{"line":6933,"address":[53102798,53102784],"length":1,"stats":{"Line":0}},{"line":6934,"address":[],"length":0,"stats":{"Line":0}},{"line":6937,"address":[],"length":0,"stats":{"Line":0}},{"line":6939,"address":[54917701],"length":1,"stats":{"Line":0}},{"line":6941,"address":[56468973],"length":1,"stats":{"Line":0}},{"line":6942,"address":[],"length":0,"stats":{"Line":0}},{"line":6943,"address":[],"length":0,"stats":{"Line":0}},{"line":6945,"address":[54728891],"length":1,"stats":{"Line":0}},{"line":6946,"address":[],"length":0,"stats":{"Line":0}},{"line":6947,"address":[],"length":0,"stats":{"Line":0}},{"line":6948,"address":[],"length":0,"stats":{"Line":0}},{"line":6949,"address":[],"length":0,"stats":{"Line":0}},{"line":6950,"address":[],"length":0,"stats":{"Line":0}},{"line":6952,"address":[54729713],"length":1,"stats":{"Line":0}},{"line":6954,"address":[56482386,56470072],"length":1,"stats":{"Line":0}},{"line":6956,"address":[],"length":0,"stats":{"Line":0}},{"line":6959,"address":[54729810],"length":1,"stats":{"Line":0}},{"line":6960,"address":[54729776],"length":1,"stats":{"Line":0}},{"line":6964,"address":[],"length":0,"stats":{"Line":0}},{"line":6965,"address":[],"length":0,"stats":{"Line":0}},{"line":6966,"address":[],"length":0,"stats":{"Line":0}},{"line":6967,"address":[],"length":0,"stats":{"Line":0}},{"line":6968,"address":[],"length":0,"stats":{"Line":0}},{"line":6969,"address":[],"length":0,"stats":{"Line":0}},{"line":6970,"address":[],"length":0,"stats":{"Line":0}},{"line":6973,"address":[],"length":0,"stats":{"Line":0}},{"line":6974,"address":[],"length":0,"stats":{"Line":0}},{"line":6975,"address":[],"length":0,"stats":{"Line":0}},{"line":6980,"address":[],"length":0,"stats":{"Line":5}},{"line":6981,"address":[],"length":0,"stats":{"Line":7}},{"line":6982,"address":[54923451],"length":1,"stats":{"Line":2}},{"line":6984,"address":[54923378],"length":1,"stats":{"Line":3}},{"line":6985,"address":[56660527],"length":1,"stats":{"Line":3}},{"line":6986,"address":[54923439],"length":1,"stats":{"Line":3}},{"line":6989,"address":[54923072],"length":1,"stats":{"Line":8}},{"line":6990,"address":[55108063],"length":1,"stats":{"Line":11}},{"line":6991,"address":[],"length":0,"stats":{"Line":8}},{"line":6994,"address":[54091038],"length":1,"stats":{"Line":1}},{"line":6995,"address":[55108141],"length":1,"stats":{"Line":1}},{"line":6996,"address":[55108180],"length":1,"stats":{"Line":1}},{"line":6999,"address":[54091112],"length":1,"stats":{"Line":4}},{"line":7000,"address":[54923232,54923315,54923520],"length":1,"stats":{"Line":8}},{"line":7001,"address":[],"length":0,"stats":{"Line":0}},{"line":7002,"address":[55108219],"length":1,"stats":{"Line":4}},{"line":7003,"address":[55108269],"length":1,"stats":{"Line":4}},{"line":7004,"address":[54018016],"length":1,"stats":{"Line":0}},{"line":7006,"address":[54923556],"length":1,"stats":{"Line":4}},{"line":7011,"address":[54864992],"length":1,"stats":{"Line":6}},{"line":7018,"address":[55051205],"length":1,"stats":{"Line":5}},{"line":7019,"address":[56603336],"length":1,"stats":{"Line":5}},{"line":7022,"address":[54865105,54865153],"length":1,"stats":{"Line":9}},{"line":7023,"address":[54033068],"length":1,"stats":{"Line":4}},{"line":7024,"address":[],"length":0,"stats":{"Line":0}},{"line":7025,"address":[],"length":0,"stats":{"Line":0}},{"line":7026,"address":[],"length":0,"stats":{"Line":0}},{"line":7027,"address":[],"length":0,"stats":{"Line":0}},{"line":7028,"address":[],"length":0,"stats":{"Line":0}},{"line":7029,"address":[],"length":0,"stats":{"Line":2}},{"line":7036,"address":[56603366,56603539],"length":1,"stats":{"Line":5}},{"line":7037,"address":[56603566],"length":1,"stats":{"Line":1}},{"line":7038,"address":[54865356],"length":1,"stats":{"Line":1}},{"line":7042,"address":[56603605,56603481],"length":1,"stats":{"Line":4}},{"line":7043,"address":[55051592],"length":1,"stats":{"Line":4}},{"line":7045,"address":[55051756],"length":1,"stats":{"Line":4}},{"line":7046,"address":[55051817],"length":1,"stats":{"Line":4}},{"line":7047,"address":[54033621],"length":1,"stats":{"Line":2}},{"line":7048,"address":[54033661],"length":1,"stats":{"Line":2}},{"line":7049,"address":[56604049],"length":1,"stats":{"Line":1}},{"line":7050,"address":[55051977],"length":1,"stats":{"Line":1}},{"line":7051,"address":[54865893],"length":1,"stats":{"Line":1}},{"line":7052,"address":[54033821],"length":1,"stats":{"Line":1}},{"line":7053,"address":[],"length":0,"stats":{"Line":1}},{"line":7054,"address":[54866013],"length":1,"stats":{"Line":1}},{"line":7055,"address":[55052177],"length":1,"stats":{"Line":1}},{"line":7056,"address":[],"length":0,"stats":{"Line":1}},{"line":7061,"address":[56825040],"length":1,"stats":{"Line":5}},{"line":7068,"address":[54258897,54259294,54258725],"length":1,"stats":{"Line":5}},{"line":7069,"address":[55273098],"length":1,"stats":{"Line":2}},{"line":7071,"address":[],"length":0,"stats":{"Line":1}},{"line":7072,"address":[56825532],"length":1,"stats":{"Line":1}},{"line":7075,"address":[56825368,56825676,56826152,56825802],"length":1,"stats":{"Line":11}},{"line":7076,"address":[54259418],"length":1,"stats":{"Line":3}},{"line":7078,"address":[56825917,56825814],"length":1,"stats":{"Line":1}},{"line":7079,"address":[],"length":0,"stats":{"Line":1}},{"line":7083,"address":[56825882],"length":1,"stats":{"Line":3}},{"line":7084,"address":[55274011],"length":1,"stats":{"Line":2}},{"line":7085,"address":[],"length":0,"stats":{"Line":0}},{"line":7086,"address":[],"length":0,"stats":{"Line":2}},{"line":7088,"address":[54259901],"length":1,"stats":{"Line":3}},{"line":7089,"address":[],"length":0,"stats":{"Line":0}},{"line":7090,"address":[55274102],"length":1,"stats":{"Line":3}},{"line":7092,"address":[],"length":0,"stats":{"Line":2}},{"line":7093,"address":[],"length":0,"stats":{"Line":0}},{"line":7094,"address":[55092106],"length":1,"stats":{"Line":2}},{"line":7096,"address":[55092185],"length":1,"stats":{"Line":2}},{"line":7097,"address":[],"length":0,"stats":{"Line":0}},{"line":7098,"address":[54260080],"length":1,"stats":{"Line":2}},{"line":7100,"address":[55274344],"length":1,"stats":{"Line":2}},{"line":7101,"address":[],"length":0,"stats":{"Line":0}},{"line":7102,"address":[55274351],"length":1,"stats":{"Line":2}},{"line":7108,"address":[55092354],"length":1,"stats":{"Line":5}},{"line":7112,"address":[54295632],"length":1,"stats":{"Line":1}},{"line":7117,"address":[54295703],"length":1,"stats":{"Line":1}},{"line":7118,"address":[55309584],"length":1,"stats":{"Line":1}},{"line":7120,"address":[55128197],"length":1,"stats":{"Line":1}},{"line":7121,"address":[55128368],"length":1,"stats":{"Line":1}},{"line":7123,"address":[],"length":0,"stats":{"Line":1}},{"line":7124,"address":[54296485],"length":1,"stats":{"Line":1}},{"line":7125,"address":[],"length":0,"stats":{"Line":0}},{"line":7126,"address":[55310180],"length":1,"stats":{"Line":1}},{"line":7128,"address":[],"length":0,"stats":{"Line":1}},{"line":7129,"address":[],"length":0,"stats":{"Line":0}},{"line":7130,"address":[55310273],"length":1,"stats":{"Line":1}},{"line":7134,"address":[],"length":0,"stats":{"Line":1}},{"line":7135,"address":[56862597,56862725],"length":1,"stats":{"Line":2}},{"line":7136,"address":[55128997],"length":1,"stats":{"Line":1}},{"line":7137,"address":[56862754],"length":1,"stats":{"Line":1}},{"line":7141,"address":[56862848],"length":1,"stats":{"Line":0}},{"line":7142,"address":[55310690],"length":1,"stats":{"Line":0}},{"line":7149,"address":[56862661,56863135],"length":1,"stats":{"Line":2}},{"line":7150,"address":[56863439],"length":1,"stats":{"Line":1}},{"line":7151,"address":[],"length":0,"stats":{"Line":0}},{"line":7152,"address":[],"length":0,"stats":{"Line":0}},{"line":7154,"address":[],"length":0,"stats":{"Line":1}},{"line":7156,"address":[55311027],"length":1,"stats":{"Line":0}},{"line":7157,"address":[54297367],"length":1,"stats":{"Line":0}},{"line":7166,"address":[55310895,55311335],"length":1,"stats":{"Line":2}},{"line":7167,"address":[54297788],"length":1,"stats":{"Line":1}},{"line":7168,"address":[],"length":0,"stats":{"Line":0}},{"line":7169,"address":[],"length":0,"stats":{"Line":0}},{"line":7171,"address":[56863651],"length":1,"stats":{"Line":1}},{"line":7172,"address":[55311391,55312814],"length":1,"stats":{"Line":2}},{"line":7173,"address":[56865002,56865294],"length":1,"stats":{"Line":2}},{"line":7174,"address":[56865313],"length":1,"stats":{"Line":1}},{"line":7175,"address":[55313147],"length":1,"stats":{"Line":1}},{"line":7179,"address":[56865417],"length":1,"stats":{"Line":0}},{"line":7180,"address":[55131712],"length":1,"stats":{"Line":0}},{"line":7188,"address":[55312902],"length":1,"stats":{"Line":0}},{"line":7189,"address":[54299256],"length":1,"stats":{"Line":0}},{"line":7198,"address":[55311530],"length":1,"stats":{"Line":1}},{"line":7199,"address":[],"length":0,"stats":{"Line":0}},{"line":7200,"address":[],"length":0,"stats":{"Line":1}},{"line":7202,"address":[55311623],"length":1,"stats":{"Line":1}},{"line":7203,"address":[55130114],"length":1,"stats":{"Line":1}},{"line":7204,"address":[],"length":0,"stats":{"Line":0}},{"line":7205,"address":[54298009],"length":1,"stats":{"Line":1}},{"line":7207,"address":[55311747],"length":1,"stats":{"Line":1}},{"line":7208,"address":[],"length":0,"stats":{"Line":0}},{"line":7209,"address":[54298091],"length":1,"stats":{"Line":1}},{"line":7217,"address":[54298301],"length":1,"stats":{"Line":1}},{"line":7219,"address":[55130428],"length":1,"stats":{"Line":1}},{"line":7220,"address":[55130440],"length":1,"stats":{"Line":1}},{"line":7225,"address":[55130672],"length":1,"stats":{"Line":1}},{"line":7227,"address":[],"length":0,"stats":{"Line":1}},{"line":7228,"address":[],"length":0,"stats":{"Line":0}},{"line":7229,"address":[55130712],"length":1,"stats":{"Line":1}},{"line":7234,"address":[],"length":0,"stats":{"Line":1}},{"line":7235,"address":[],"length":0,"stats":{"Line":0}},{"line":7236,"address":[56864565],"length":1,"stats":{"Line":1}},{"line":7238,"address":[55312478],"length":1,"stats":{"Line":1}},{"line":7240,"address":[55312496],"length":1,"stats":{"Line":1}},{"line":7241,"address":[55312652],"length":1,"stats":{"Line":1}},{"line":7242,"address":[55130960],"length":1,"stats":{"Line":1}},{"line":7243,"address":[],"length":0,"stats":{"Line":1}},{"line":7244,"address":[54298922],"length":1,"stats":{"Line":1}},{"line":7250,"address":[55312788],"length":1,"stats":{"Line":1}},{"line":7255,"address":[56865648],"length":1,"stats":{"Line":0}},{"line":7263,"address":[55313591],"length":1,"stats":{"Line":0}},{"line":7264,"address":[54299987],"length":1,"stats":{"Line":0}},{"line":7265,"address":[56865885],"length":1,"stats":{"Line":0}},{"line":7268,"address":[55132220],"length":1,"stats":{"Line":0}},{"line":7269,"address":[55132383],"length":1,"stats":{"Line":0}},{"line":7270,"address":[],"length":0,"stats":{"Line":0}},{"line":7271,"address":[],"length":0,"stats":{"Line":0}},{"line":7272,"address":[55132545],"length":1,"stats":{"Line":0}},{"line":7276,"address":[55132617,55132752],"length":1,"stats":{"Line":0}},{"line":7277,"address":[53134968],"length":1,"stats":{"Line":0}},{"line":7279,"address":[55132821],"length":1,"stats":{"Line":0}},{"line":7280,"address":[],"length":0,"stats":{"Line":0}},{"line":7281,"address":[55314357],"length":1,"stats":{"Line":0}},{"line":7283,"address":[54300817],"length":1,"stats":{"Line":0}},{"line":7284,"address":[54300972],"length":1,"stats":{"Line":0}},{"line":7285,"address":[],"length":0,"stats":{"Line":0}},{"line":7286,"address":[],"length":0,"stats":{"Line":0}},{"line":7289,"address":[56866870],"length":1,"stats":{"Line":0}},{"line":7290,"address":[],"length":0,"stats":{"Line":0}},{"line":7291,"address":[],"length":0,"stats":{"Line":0}},{"line":7294,"address":[55133286],"length":1,"stats":{"Line":0}},{"line":7295,"address":[],"length":0,"stats":{"Line":0}},{"line":7296,"address":[55314814],"length":1,"stats":{"Line":0}},{"line":7301,"address":[],"length":0,"stats":{"Line":0}},{"line":7302,"address":[],"length":0,"stats":{"Line":0}},{"line":7303,"address":[],"length":0,"stats":{"Line":0}},{"line":7305,"address":[55314996],"length":1,"stats":{"Line":0}},{"line":7306,"address":[55133537],"length":1,"stats":{"Line":0}},{"line":7307,"address":[],"length":0,"stats":{"Line":0}},{"line":7308,"address":[55315058],"length":1,"stats":{"Line":0}},{"line":7312,"address":[56867309],"length":1,"stats":{"Line":0}},{"line":7313,"address":[],"length":0,"stats":{"Line":0}},{"line":7314,"address":[56867316],"length":1,"stats":{"Line":0}},{"line":7316,"address":[54301599],"length":1,"stats":{"Line":0}},{"line":7317,"address":[],"length":0,"stats":{"Line":0}},{"line":7321,"address":[],"length":0,"stats":{"Line":0}},{"line":7322,"address":[],"length":0,"stats":{"Line":0}},{"line":7323,"address":[],"length":0,"stats":{"Line":0}},{"line":7326,"address":[55133865],"length":1,"stats":{"Line":0}},{"line":7327,"address":[55133918],"length":1,"stats":{"Line":0}},{"line":7329,"address":[55133976],"length":1,"stats":{"Line":0}},{"line":7330,"address":[54301871],"length":1,"stats":{"Line":0}},{"line":7334,"address":[56867712],"length":1,"stats":{"Line":0}},{"line":7336,"address":[],"length":0,"stats":{"Line":0}},{"line":7337,"address":[56867777],"length":1,"stats":{"Line":0}},{"line":7338,"address":[],"length":0,"stats":{"Line":0}},{"line":7341,"address":[56867905],"length":1,"stats":{"Line":0}},{"line":7342,"address":[],"length":0,"stats":{"Line":0}},{"line":7343,"address":[55134233],"length":1,"stats":{"Line":0}},{"line":7345,"address":[55134317],"length":1,"stats":{"Line":0}},{"line":7346,"address":[],"length":0,"stats":{"Line":0}},{"line":7347,"address":[54302212],"length":1,"stats":{"Line":0}},{"line":7352,"address":[54302303],"length":1,"stats":{"Line":0}},{"line":7353,"address":[],"length":0,"stats":{"Line":0}},{"line":7354,"address":[54302310],"length":1,"stats":{"Line":0}},{"line":7356,"address":[56868179],"length":1,"stats":{"Line":0}},{"line":7357,"address":[],"length":0,"stats":{"Line":0}},{"line":7358,"address":[],"length":0,"stats":{"Line":0}},{"line":7363,"address":[55316097],"length":1,"stats":{"Line":0}},{"line":7364,"address":[55316140],"length":1,"stats":{"Line":0}},{"line":7365,"address":[],"length":0,"stats":{"Line":0}},{"line":7366,"address":[55134652],"length":1,"stats":{"Line":0}},{"line":7369,"address":[],"length":0,"stats":{"Line":0}},{"line":7370,"address":[55134789],"length":1,"stats":{"Line":0}},{"line":7371,"address":[55134845],"length":1,"stats":{"Line":0}},{"line":7373,"address":[56868577],"length":1,"stats":{"Line":0}},{"line":7374,"address":[56868584],"length":1,"stats":{"Line":0}},{"line":7378,"address":[54302851],"length":1,"stats":{"Line":0}},{"line":7379,"address":[],"length":0,"stats":{"Line":0}},{"line":7380,"address":[],"length":0,"stats":{"Line":0}},{"line":7381,"address":[],"length":0,"stats":{"Line":0}},{"line":7388,"address":[56868882],"length":1,"stats":{"Line":0}},{"line":7390,"address":[55135235],"length":1,"stats":{"Line":0}},{"line":7391,"address":[56868915],"length":1,"stats":{"Line":0}},{"line":7395,"address":[54303410],"length":1,"stats":{"Line":0}},{"line":7396,"address":[55135529],"length":1,"stats":{"Line":0}},{"line":7398,"address":[56869242],"length":1,"stats":{"Line":0}},{"line":7401,"address":[],"length":0,"stats":{"Line":0}},{"line":7402,"address":[55317152],"length":1,"stats":{"Line":0}},{"line":7403,"address":[],"length":0,"stats":{"Line":0}},{"line":7405,"address":[55135685],"length":1,"stats":{"Line":0}},{"line":7406,"address":[56869361],"length":1,"stats":{"Line":0}},{"line":7414,"address":[56869631],"length":1,"stats":{"Line":0}},{"line":7415,"address":[54303868],"length":1,"stats":{"Line":0}},{"line":7417,"address":[],"length":0,"stats":{"Line":0}},{"line":7420,"address":[56869744],"length":1,"stats":{"Line":0}},{"line":7421,"address":[55136126],"length":1,"stats":{"Line":0}},{"line":7422,"address":[54304072],"length":1,"stats":{"Line":0}},{"line":7423,"address":[56869844],"length":1,"stats":{"Line":0}},{"line":7427,"address":[56869894],"length":1,"stats":{"Line":0}},{"line":7428,"address":[55317755],"length":1,"stats":{"Line":0}},{"line":7429,"address":[],"length":0,"stats":{"Line":0}},{"line":7430,"address":[],"length":0,"stats":{"Line":0}},{"line":7436,"address":[54304261],"length":1,"stats":{"Line":0}},{"line":7437,"address":[55136391],"length":1,"stats":{"Line":0}},{"line":7442,"address":[],"length":0,"stats":{"Line":0}},{"line":7443,"address":[],"length":0,"stats":{"Line":0}},{"line":7444,"address":[],"length":0,"stats":{"Line":0}},{"line":7446,"address":[56870280],"length":1,"stats":{"Line":0}},{"line":7448,"address":[55136652],"length":1,"stats":{"Line":0}},{"line":7449,"address":[54304555],"length":1,"stats":{"Line":0}},{"line":7455,"address":[55318414],"length":1,"stats":{"Line":0}},{"line":7458,"address":[54304891],"length":1,"stats":{"Line":0}},{"line":7459,"address":[],"length":0,"stats":{"Line":0}},{"line":7461,"address":[56870883],"length":1,"stats":{"Line":0}},{"line":7464,"address":[56582320],"length":1,"stats":{"Line":1}},{"line":7469,"address":[55030271],"length":1,"stats":{"Line":1}},{"line":7470,"address":[56582529],"length":1,"stats":{"Line":1}},{"line":7471,"address":[56582589],"length":1,"stats":{"Line":1}},{"line":7472,"address":[54011940],"length":1,"stats":{"Line":1}},{"line":7476,"address":[54091472],"length":1,"stats":{"Line":1}},{"line":7482,"address":[56660791],"length":1,"stats":{"Line":1}},{"line":7483,"address":[54923698],"length":1,"stats":{"Line":1}},{"line":7484,"address":[56660999],"length":1,"stats":{"Line":1}},{"line":7486,"address":[54924026],"length":1,"stats":{"Line":1}},{"line":7487,"address":[55109045],"length":1,"stats":{"Line":1}},{"line":7489,"address":[],"length":0,"stats":{"Line":1}},{"line":7490,"address":[],"length":0,"stats":{"Line":0}},{"line":7491,"address":[],"length":0,"stats":{"Line":1}},{"line":7492,"address":[56661349],"length":1,"stats":{"Line":1}},{"line":7495,"address":[],"length":0,"stats":{"Line":0}},{"line":7496,"address":[54924147],"length":1,"stats":{"Line":1}},{"line":7497,"address":[54092042],"length":1,"stats":{"Line":1}},{"line":7502,"address":[56661388],"length":1,"stats":{"Line":1}},{"line":7503,"address":[54924313],"length":1,"stats":{"Line":1}},{"line":7504,"address":[54924336],"length":1,"stats":{"Line":1}},{"line":7505,"address":[55109477],"length":1,"stats":{"Line":1}},{"line":7506,"address":[54924564],"length":1,"stats":{"Line":1}},{"line":7508,"address":[54092504],"length":1,"stats":{"Line":1}},{"line":7509,"address":[54092522],"length":1,"stats":{"Line":1}},{"line":7510,"address":[],"length":0,"stats":{"Line":0}},{"line":7511,"address":[56661771],"length":1,"stats":{"Line":1}},{"line":7513,"address":[55109690],"length":1,"stats":{"Line":1}},{"line":7515,"address":[54092808],"length":1,"stats":{"Line":1}},{"line":7518,"address":[53739024,53742339,53746012],"length":1,"stats":{"Line":5}},{"line":7524,"address":[53739234],"length":1,"stats":{"Line":5}},{"line":7525,"address":[54760768],"length":1,"stats":{"Line":0}},{"line":7526,"address":[],"length":0,"stats":{"Line":0}},{"line":7528,"address":[54571398,54571494],"length":1,"stats":{"Line":0}},{"line":7531,"address":[],"length":0,"stats":{"Line":10}},{"line":7533,"address":[54761073],"length":1,"stats":{"Line":5}},{"line":7534,"address":[53739745],"length":1,"stats":{"Line":0}},{"line":7538,"address":[54571931,54571792],"length":1,"stats":{"Line":10}},{"line":7539,"address":[53739846],"length":1,"stats":{"Line":5}},{"line":7542,"address":[54761396,54761544],"length":1,"stats":{"Line":20}},{"line":7544,"address":[],"length":0,"stats":{"Line":5}},{"line":7546,"address":[54572259,54572772],"length":1,"stats":{"Line":0}},{"line":7547,"address":[53992041,53992032],"length":1,"stats":{"Line":0}},{"line":7548,"address":[54762240],"length":1,"stats":{"Line":0}},{"line":7551,"address":[54762287],"length":1,"stats":{"Line":0}},{"line":7552,"address":[53740943],"length":1,"stats":{"Line":0}},{"line":7553,"address":[],"length":0,"stats":{"Line":0}},{"line":7555,"address":[53741002],"length":1,"stats":{"Line":0}},{"line":7556,"address":[54576650,54577504,54573275],"length":1,"stats":{"Line":0}},{"line":7558,"address":[54765866,54765932,54767017],"length":1,"stats":{"Line":0}},{"line":7559,"address":[56318311],"length":1,"stats":{"Line":0}},{"line":7560,"address":[],"length":0,"stats":{"Line":0}},{"line":7561,"address":[],"length":0,"stats":{"Line":0}},{"line":7562,"address":[54577056],"length":1,"stats":{"Line":0}},{"line":7567,"address":[],"length":0,"stats":{"Line":0}},{"line":7568,"address":[],"length":0,"stats":{"Line":0}},{"line":7569,"address":[56318851,56318722],"length":1,"stats":{"Line":0}},{"line":7570,"address":[54577570,54577843],"length":1,"stats":{"Line":0}},{"line":7571,"address":[54577762],"length":1,"stats":{"Line":0}},{"line":7573,"address":[],"length":0,"stats":{"Line":0}},{"line":7575,"address":[],"length":0,"stats":{"Line":0}},{"line":7580,"address":[54572296,54572224],"length":1,"stats":{"Line":10}},{"line":7581,"address":[54761871,54761807],"length":1,"stats":{"Line":10}},{"line":7586,"address":[54761822,54762688],"length":1,"stats":{"Line":9}},{"line":7587,"address":[53741506,53741315,53741371],"length":1,"stats":{"Line":0}},{"line":7589,"address":[56315132,56315229],"length":1,"stats":{"Line":0}},{"line":7590,"address":[54763589,54763191],"length":1,"stats":{"Line":0}},{"line":7591,"address":[],"length":0,"stats":{"Line":0}},{"line":7593,"address":[56315321],"length":1,"stats":{"Line":0}},{"line":7594,"address":[],"length":0,"stats":{"Line":0}},{"line":7595,"address":[],"length":0,"stats":{"Line":0}},{"line":7598,"address":[54763662],"length":1,"stats":{"Line":0}},{"line":7600,"address":[54573942,54574457],"length":1,"stats":{"Line":0}},{"line":7601,"address":[],"length":0,"stats":{"Line":0}},{"line":7602,"address":[],"length":0,"stats":{"Line":0}},{"line":7609,"address":[54764044,54762795],"length":1,"stats":{"Line":8}},{"line":7610,"address":[53742653],"length":1,"stats":{"Line":4}},{"line":7611,"address":[54764170],"length":1,"stats":{"Line":0}},{"line":7612,"address":[],"length":0,"stats":{"Line":0}},{"line":7613,"address":[54575521,54575292,54575373],"length":1,"stats":{"Line":0}},{"line":7614,"address":[53743433],"length":1,"stats":{"Line":0}},{"line":7617,"address":[54575487,54575856],"length":1,"stats":{"Line":0}},{"line":7622,"address":[54764323,54765182],"length":1,"stats":{"Line":0}},{"line":7623,"address":[54576561,54576067],"length":1,"stats":{"Line":0}},{"line":7628,"address":[56317861,56316226,56317648,56317541],"length":1,"stats":{"Line":8}},{"line":7629,"address":[],"length":0,"stats":{"Line":0}},{"line":7630,"address":[],"length":0,"stats":{"Line":8}},{"line":7631,"address":[53098096,53098080],"length":1,"stats":{"Line":4}},{"line":7633,"address":[54576368],"length":1,"stats":{"Line":4}},{"line":7635,"address":[],"length":0,"stats":{"Line":4}},{"line":7639,"address":[54761419],"length":1,"stats":{"Line":1}},{"line":7640,"address":[54761454],"length":1,"stats":{"Line":1}},{"line":7641,"address":[53746072],"length":1,"stats":{"Line":1}},{"line":7642,"address":[],"length":0,"stats":{"Line":0}},{"line":7643,"address":[54909969],"length":1,"stats":{"Line":0}},{"line":7646,"address":[54909957,54910102],"length":1,"stats":{"Line":2}},{"line":7647,"address":[56462411],"length":1,"stats":{"Line":1}},{"line":7649,"address":[54578153],"length":1,"stats":{"Line":1}},{"line":7650,"address":[54578246],"length":1,"stats":{"Line":0}},{"line":7651,"address":[54909644],"length":1,"stats":{"Line":0}},{"line":7652,"address":[54909610],"length":1,"stats":{"Line":0}},{"line":7655,"address":[],"length":0,"stats":{"Line":0}},{"line":7656,"address":[54909939],"length":1,"stats":{"Line":0}},{"line":7658,"address":[56319480],"length":1,"stats":{"Line":1}},{"line":7659,"address":[53746196],"length":1,"stats":{"Line":0}},{"line":7660,"address":[56461398],"length":1,"stats":{"Line":0}},{"line":7661,"address":[56461364],"length":1,"stats":{"Line":0}},{"line":7664,"address":[56461497,56461352],"length":1,"stats":{"Line":0}},{"line":7665,"address":[54721379],"length":1,"stats":{"Line":0}},{"line":7667,"address":[56319542],"length":1,"stats":{"Line":1}},{"line":7668,"address":[],"length":0,"stats":{"Line":1}},{"line":7669,"address":[56461039],"length":1,"stats":{"Line":0}},{"line":7670,"address":[],"length":0,"stats":{"Line":0}},{"line":7673,"address":[53888563,53888708],"length":1,"stats":{"Line":2}},{"line":7674,"address":[],"length":0,"stats":{"Line":1}},{"line":7676,"address":[],"length":0,"stats":{"Line":0}},{"line":7677,"address":[56319697],"length":1,"stats":{"Line":0}},{"line":7678,"address":[],"length":0,"stats":{"Line":0}},{"line":7679,"address":[56458242],"length":1,"stats":{"Line":0}},{"line":7684,"address":[53885773,53885910],"length":1,"stats":{"Line":0}},{"line":7685,"address":[54718132,54718219],"length":1,"stats":{"Line":0}},{"line":7687,"address":[54718243,54718334,54718360],"length":1,"stats":{"Line":0}},{"line":7688,"address":[54906689],"length":1,"stats":{"Line":0}},{"line":7689,"address":[],"length":0,"stats":{"Line":0}},{"line":7690,"address":[],"length":0,"stats":{"Line":0}},{"line":7692,"address":[54906705],"length":1,"stats":{"Line":0}},{"line":7693,"address":[56458889],"length":1,"stats":{"Line":0}},{"line":7696,"address":[54906646,54906810],"length":1,"stats":{"Line":0}},{"line":7697,"address":[54718798],"length":1,"stats":{"Line":0}},{"line":7698,"address":[53886764],"length":1,"stats":{"Line":0}},{"line":7703,"address":[54907130,54906422],"length":1,"stats":{"Line":0}},{"line":7706,"address":[],"length":0,"stats":{"Line":0}},{"line":7707,"address":[53887034,53887924],"length":1,"stats":{"Line":0}},{"line":7708,"address":[54719665,54719222],"length":1,"stats":{"Line":0}},{"line":7709,"address":[],"length":0,"stats":{"Line":0}},{"line":7711,"address":[53887142,53887093],"length":1,"stats":{"Line":0}},{"line":7712,"address":[54719454],"length":1,"stats":{"Line":0}},{"line":7716,"address":[53887521,53887937],"length":1,"stats":{"Line":0}},{"line":7718,"address":[53888153,53888044],"length":1,"stats":{"Line":0}},{"line":7719,"address":[],"length":0,"stats":{"Line":0}},{"line":7720,"address":[56460855],"length":1,"stats":{"Line":0}},{"line":7723,"address":[56460711,56460908],"length":1,"stats":{"Line":0}},{"line":7724,"address":[53888492],"length":1,"stats":{"Line":0}},{"line":7727,"address":[56460547],"length":1,"stats":{"Line":0}},{"line":7730,"address":[56319666],"length":1,"stats":{"Line":0}},{"line":7731,"address":[53746382],"length":1,"stats":{"Line":0}},{"line":7732,"address":[56457917],"length":1,"stats":{"Line":0}},{"line":7733,"address":[54717536],"length":1,"stats":{"Line":0}},{"line":7736,"address":[56457871,56458016],"length":1,"stats":{"Line":0}},{"line":7737,"address":[54717867],"length":1,"stats":{"Line":0}},{"line":7739,"address":[54767616],"length":1,"stats":{"Line":0}},{"line":7740,"address":[],"length":0,"stats":{"Line":0}},{"line":7741,"address":[],"length":0,"stats":{"Line":0}},{"line":7742,"address":[56457273],"length":1,"stats":{"Line":0}},{"line":7745,"address":[53884943,53884798],"length":1,"stats":{"Line":0}},{"line":7746,"address":[],"length":0,"stats":{"Line":0}},{"line":7747,"address":[54905740],"length":1,"stats":{"Line":0}},{"line":7749,"address":[54767678],"length":1,"stats":{"Line":0}},{"line":7750,"address":[],"length":0,"stats":{"Line":0}},{"line":7751,"address":[53884230],"length":1,"stats":{"Line":0}},{"line":7752,"address":[56456663],"length":1,"stats":{"Line":0}},{"line":7755,"address":[],"length":0,"stats":{"Line":0}},{"line":7756,"address":[],"length":0,"stats":{"Line":0}},{"line":7757,"address":[54905130],"length":1,"stats":{"Line":0}},{"line":7759,"address":[53746475],"length":1,"stats":{"Line":0}},{"line":7760,"address":[],"length":0,"stats":{"Line":0}},{"line":7761,"address":[53883168],"length":1,"stats":{"Line":0}},{"line":7762,"address":[54903496],"length":1,"stats":{"Line":0}},{"line":7765,"address":[54903629,54903484],"length":1,"stats":{"Line":0}},{"line":7766,"address":[56455946],"length":1,"stats":{"Line":0}},{"line":7767,"address":[56456181],"length":1,"stats":{"Line":0}},{"line":7769,"address":[53883979],"length":1,"stats":{"Line":0}},{"line":7770,"address":[],"length":0,"stats":{"Line":0}},{"line":7772,"address":[53746537],"length":1,"stats":{"Line":0}},{"line":7773,"address":[56320007],"length":1,"stats":{"Line":0}},{"line":7774,"address":[53882807],"length":1,"stats":{"Line":0}},{"line":7775,"address":[53882773],"length":1,"stats":{"Line":0}},{"line":7778,"address":[53882761,53882906],"length":1,"stats":{"Line":0}},{"line":7779,"address":[54715216],"length":1,"stats":{"Line":0}},{"line":7781,"address":[56319976],"length":1,"stats":{"Line":0}},{"line":7782,"address":[56320069],"length":1,"stats":{"Line":0}},{"line":7783,"address":[56454925],"length":1,"stats":{"Line":0}},{"line":7784,"address":[54902778],"length":1,"stats":{"Line":0}},{"line":7787,"address":[],"length":0,"stats":{"Line":0}},{"line":7788,"address":[53882743],"length":1,"stats":{"Line":0}},{"line":7790,"address":[56320038],"length":1,"stats":{"Line":0}},{"line":7791,"address":[53746754],"length":1,"stats":{"Line":0}},{"line":7792,"address":[54902453],"length":1,"stats":{"Line":0}},{"line":7793,"address":[54714163],"length":1,"stats":{"Line":0}},{"line":7796,"address":[54902407,54902552],"length":1,"stats":{"Line":0}},{"line":7797,"address":[54714494],"length":1,"stats":{"Line":0}},{"line":7799,"address":[54578835],"length":1,"stats":{"Line":0}},{"line":7800,"address":[54768081],"length":1,"stats":{"Line":0}},{"line":7801,"address":[54713836],"length":1,"stats":{"Line":0}},{"line":7802,"address":[54902060],"length":1,"stats":{"Line":0}},{"line":7805,"address":[54902048,54902193],"length":1,"stats":{"Line":0}},{"line":7806,"address":[54714133],"length":1,"stats":{"Line":0}},{"line":7809,"address":[54768050],"length":1,"stats":{"Line":0}},{"line":7810,"address":[54768143],"length":1,"stats":{"Line":0}},{"line":7811,"address":[54713475],"length":1,"stats":{"Line":0}},{"line":7812,"address":[],"length":0,"stats":{"Line":0}},{"line":7815,"address":[],"length":0,"stats":{"Line":0}},{"line":7816,"address":[],"length":0,"stats":{"Line":0}},{"line":7818,"address":[53746847],"length":1,"stats":{"Line":0}},{"line":7819,"address":[56320317],"length":1,"stats":{"Line":0}},{"line":7820,"address":[54901376],"length":1,"stats":{"Line":0}},{"line":7821,"address":[53880968],"length":1,"stats":{"Line":0}},{"line":7824,"address":[56453588,56453443],"length":1,"stats":{"Line":0}},{"line":7825,"address":[54901671],"length":1,"stats":{"Line":0}},{"line":7827,"address":[54579021],"length":1,"stats":{"Line":0}},{"line":7828,"address":[53747002],"length":1,"stats":{"Line":0}},{"line":7829,"address":[56453130],"length":1,"stats":{"Line":0}},{"line":7830,"address":[],"length":0,"stats":{"Line":0}},{"line":7833,"address":[56453229,56453084],"length":1,"stats":{"Line":0}},{"line":7834,"address":[],"length":0,"stats":{"Line":0}},{"line":7836,"address":[],"length":0,"stats":{"Line":0}},{"line":7837,"address":[53747064],"length":1,"stats":{"Line":0}},{"line":7838,"address":[54712392],"length":1,"stats":{"Line":0}},{"line":7839,"address":[53880246],"length":1,"stats":{"Line":0}},{"line":7842,"address":[54900757,54900612],"length":1,"stats":{"Line":0}},{"line":7843,"address":[],"length":0,"stats":{"Line":0}},{"line":7845,"address":[56320410],"length":1,"stats":{"Line":0}},{"line":7846,"address":[54579238],"length":1,"stats":{"Line":0}},{"line":7847,"address":[],"length":0,"stats":{"Line":0}},{"line":7848,"address":[54899754],"length":1,"stats":{"Line":0}},{"line":7851,"address":[53879358,53879503],"length":1,"stats":{"Line":0}},{"line":7852,"address":[53879709],"length":1,"stats":{"Line":0}},{"line":7853,"address":[56452439],"length":1,"stats":{"Line":0}},{"line":7854,"address":[53880207],"length":1,"stats":{"Line":0}},{"line":7856,"address":[54579207],"length":1,"stats":{"Line":0}},{"line":7857,"address":[],"length":0,"stats":{"Line":0}},{"line":7858,"address":[54710902],"length":1,"stats":{"Line":0}},{"line":7859,"address":[56451257],"length":1,"stats":{"Line":0}},{"line":7862,"address":[56451390,56451245],"length":1,"stats":{"Line":0}},{"line":7863,"address":[54711207],"length":1,"stats":{"Line":0}},{"line":7864,"address":[54711452],"length":1,"stats":{"Line":0}},{"line":7866,"address":[54768422],"length":1,"stats":{"Line":0}},{"line":7867,"address":[],"length":0,"stats":{"Line":0}},{"line":7868,"address":[54710541],"length":1,"stats":{"Line":0}},{"line":7869,"address":[54710507],"length":1,"stats":{"Line":0}},{"line":7872,"address":[56450886,56451031],"length":1,"stats":{"Line":0}},{"line":7873,"address":[54899114],"length":1,"stats":{"Line":0}},{"line":7875,"address":[54768484],"length":1,"stats":{"Line":0}},{"line":7876,"address":[56320689],"length":1,"stats":{"Line":0}},{"line":7877,"address":[56450573],"length":1,"stats":{"Line":0}},{"line":7878,"address":[53878034],"length":1,"stats":{"Line":0}},{"line":7881,"address":[],"length":0,"stats":{"Line":0}},{"line":7882,"address":[56450868],"length":1,"stats":{"Line":0}},{"line":7885,"address":[54768546,54768608],"length":1,"stats":{"Line":0}},{"line":7887,"address":[56320751],"length":1,"stats":{"Line":0}},{"line":7888,"address":[],"length":0,"stats":{"Line":0}},{"line":7889,"address":[56449929],"length":1,"stats":{"Line":0}},{"line":7892,"address":[54709520,54709665],"length":1,"stats":{"Line":0}},{"line":7893,"address":[53877759],"length":1,"stats":{"Line":0}},{"line":7894,"address":[54898396],"length":1,"stats":{"Line":0}},{"line":7896,"address":[54579517],"length":1,"stats":{"Line":0}},{"line":7898,"address":[53747473],"length":1,"stats":{"Line":0}},{"line":7899,"address":[54896684],"length":1,"stats":{"Line":0}},{"line":7900,"address":[54708353],"length":1,"stats":{"Line":0}},{"line":7903,"address":[54896783,54896638],"length":1,"stats":{"Line":0}},{"line":7904,"address":[56449100],"length":1,"stats":{"Line":0}},{"line":7906,"address":[53877314,53877143,53876833,53877059,53877230],"length":1,"stats":{"Line":0}},{"line":7907,"address":[],"length":0,"stats":{"Line":0}},{"line":7909,"address":[54897256],"length":1,"stats":{"Line":0}},{"line":7910,"address":[],"length":0,"stats":{"Line":0}},{"line":7913,"address":[54486880],"length":1,"stats":{"Line":0}},{"line":7914,"address":[53096496],"length":1,"stats":{"Line":0}},{"line":7915,"address":[],"length":0,"stats":{"Line":0}},{"line":7916,"address":[],"length":0,"stats":{"Line":0}},{"line":7921,"address":[56449728],"length":1,"stats":{"Line":0}},{"line":7922,"address":[],"length":0,"stats":{"Line":0}},{"line":7924,"address":[56449889],"length":1,"stats":{"Line":0}},{"line":7926,"address":[54579554],"length":1,"stats":{"Line":0}},{"line":7928,"address":[54579647],"length":1,"stats":{"Line":0}},{"line":7929,"address":[53875096],"length":1,"stats":{"Line":0}},{"line":7930,"address":[],"length":0,"stats":{"Line":0}},{"line":7933,"address":[53875195,53875050],"length":1,"stats":{"Line":0}},{"line":7934,"address":[56447934],"length":1,"stats":{"Line":0}},{"line":7936,"address":[54896295,54896462,54896545,54896072,54896378],"length":1,"stats":{"Line":0}},{"line":7937,"address":[],"length":0,"stats":{"Line":0}},{"line":7939,"address":[],"length":0,"stats":{"Line":0}},{"line":7940,"address":[53875687],"length":1,"stats":{"Line":0}},{"line":7943,"address":[56081616],"length":1,"stats":{"Line":0}},{"line":7944,"address":[56081632],"length":1,"stats":{"Line":0}},{"line":7948,"address":[56087904],"length":1,"stats":{"Line":0}},{"line":7949,"address":[54489454],"length":1,"stats":{"Line":0}},{"line":7951,"address":[53876201],"length":1,"stats":{"Line":0}},{"line":7953,"address":[53747504],"length":1,"stats":{"Line":0}},{"line":7955,"address":[56320974],"length":1,"stats":{"Line":0}},{"line":7956,"address":[53873917],"length":1,"stats":{"Line":0}},{"line":7957,"address":[54705995],"length":1,"stats":{"Line":0}},{"line":7960,"address":[53874016,53873871],"length":1,"stats":{"Line":0}},{"line":7961,"address":[],"length":0,"stats":{"Line":0}},{"line":7963,"address":[54894906,54895129,54895296,54895212,54895379],"length":1,"stats":{"Line":0}},{"line":7964,"address":[],"length":0,"stats":{"Line":0}},{"line":7966,"address":[54894924],"length":1,"stats":{"Line":0}},{"line":7967,"address":[54706620],"length":1,"stats":{"Line":0}},{"line":7970,"address":[],"length":0,"stats":{"Line":0}},{"line":7971,"address":[53991872],"length":1,"stats":{"Line":0}},{"line":7975,"address":[54706970],"length":1,"stats":{"Line":0}},{"line":7976,"address":[53091710],"length":1,"stats":{"Line":0}},{"line":7978,"address":[],"length":0,"stats":{"Line":0}},{"line":7980,"address":[53747566],"length":1,"stats":{"Line":0}},{"line":7982,"address":[56321044],"length":1,"stats":{"Line":0}},{"line":7983,"address":[54705465],"length":1,"stats":{"Line":0}},{"line":7984,"address":[],"length":0,"stats":{"Line":0}},{"line":7988,"address":[],"length":0,"stats":{"Line":0}},{"line":7989,"address":[],"length":0,"stats":{"Line":0}},{"line":7990,"address":[56446009],"length":1,"stats":{"Line":0}},{"line":7991,"address":[53094272],"length":1,"stats":{"Line":0}},{"line":7992,"address":[53094288],"length":1,"stats":{"Line":0}},{"line":7996,"address":[53997808],"length":1,"stats":{"Line":0}},{"line":7997,"address":[53099054],"length":1,"stats":{"Line":0}},{"line":7999,"address":[56446391],"length":1,"stats":{"Line":0}},{"line":8001,"address":[54579740],"length":1,"stats":{"Line":0}},{"line":8003,"address":[],"length":0,"stats":{"Line":0}},{"line":8004,"address":[54893392],"length":1,"stats":{"Line":0}},{"line":8005,"address":[53872911],"length":1,"stats":{"Line":0}},{"line":8010,"address":[53872778,53872856,53873062,53873233,53873149],"length":1,"stats":{"Line":0}},{"line":8011,"address":[],"length":0,"stats":{"Line":0}},{"line":8012,"address":[53872788],"length":1,"stats":{"Line":0}},{"line":8013,"address":[],"length":0,"stats":{"Line":0}},{"line":8014,"address":[54484560],"length":1,"stats":{"Line":0}},{"line":8018,"address":[56086992],"length":1,"stats":{"Line":0}},{"line":8019,"address":[56087006],"length":1,"stats":{"Line":0}},{"line":8021,"address":[56445854],"length":1,"stats":{"Line":0}},{"line":8023,"address":[56321078],"length":1,"stats":{"Line":0}},{"line":8025,"address":[54579907],"length":1,"stats":{"Line":0}},{"line":8026,"address":[],"length":0,"stats":{"Line":0}},{"line":8027,"address":[56444529],"length":1,"stats":{"Line":0}},{"line":8030,"address":[54704202,54704057],"length":1,"stats":{"Line":0}},{"line":8031,"address":[53872280,53872429,53872600,53872513,53872684],"length":1,"stats":{"Line":0}},{"line":8032,"address":[],"length":0,"stats":{"Line":0}},{"line":8034,"address":[],"length":0,"stats":{"Line":0}},{"line":8035,"address":[54892770],"length":1,"stats":{"Line":0}},{"line":8038,"address":[54488000],"length":1,"stats":{"Line":0}},{"line":8039,"address":[54488016],"length":1,"stats":{"Line":0}},{"line":8040,"address":[],"length":0,"stats":{"Line":0}},{"line":8041,"address":[],"length":0,"stats":{"Line":0}},{"line":8046,"address":[54492720],"length":1,"stats":{"Line":0}},{"line":8047,"address":[54492734],"length":1,"stats":{"Line":0}},{"line":8049,"address":[53872750],"length":1,"stats":{"Line":0}},{"line":8051,"address":[],"length":0,"stats":{"Line":0}},{"line":8053,"address":[53747857],"length":1,"stats":{"Line":0}},{"line":8054,"address":[54703907],"length":1,"stats":{"Line":0}},{"line":8055,"address":[53871761],"length":1,"stats":{"Line":0}},{"line":8058,"address":[54892361,54892208],"length":1,"stats":{"Line":0}},{"line":8061,"address":[53747888],"length":1,"stats":{"Line":0}},{"line":8062,"address":[54769220],"length":1,"stats":{"Line":0}},{"line":8063,"address":[54703074],"length":1,"stats":{"Line":0}},{"line":8064,"address":[54891397],"length":1,"stats":{"Line":0}},{"line":8067,"address":[54891385,54891530],"length":1,"stats":{"Line":0}},{"line":8068,"address":[56444228,56444061,56443831,56443978,56444145],"length":1,"stats":{"Line":0}},{"line":8069,"address":[],"length":0,"stats":{"Line":0}},{"line":8070,"address":[],"length":0,"stats":{"Line":0}},{"line":8071,"address":[54491536],"length":1,"stats":{"Line":0}},{"line":8072,"address":[53993232],"length":1,"stats":{"Line":0}},{"line":8076,"address":[54892019],"length":1,"stats":{"Line":0}},{"line":8077,"address":[53093838],"length":1,"stats":{"Line":0}},{"line":8079,"address":[],"length":0,"stats":{"Line":0}},{"line":8081,"address":[56321301],"length":1,"stats":{"Line":0}},{"line":8082,"address":[54580130],"length":1,"stats":{"Line":0}},{"line":8083,"address":[54702241],"length":1,"stats":{"Line":0}},{"line":8084,"address":[54890574],"length":1,"stats":{"Line":0}},{"line":8087,"address":[],"length":0,"stats":{"Line":0}},{"line":8088,"address":[],"length":0,"stats":{"Line":0}},{"line":8089,"address":[],"length":0,"stats":{"Line":0}},{"line":8090,"address":[56443026],"length":1,"stats":{"Line":0}},{"line":8091,"address":[53870545],"length":1,"stats":{"Line":0}},{"line":8092,"address":[54486576],"length":1,"stats":{"Line":0}},{"line":8096,"address":[54891196],"length":1,"stats":{"Line":0}},{"line":8097,"address":[53993582],"length":1,"stats":{"Line":0}},{"line":8099,"address":[54703000],"length":1,"stats":{"Line":0}},{"line":8101,"address":[54769251],"length":1,"stats":{"Line":0}},{"line":8102,"address":[54580192],"length":1,"stats":{"Line":0}},{"line":8103,"address":[54889442],"length":1,"stats":{"Line":0}},{"line":8104,"address":[56441521],"length":1,"stats":{"Line":0}},{"line":8107,"address":[53868904,53869049],"length":1,"stats":{"Line":0}},{"line":8108,"address":[56441858],"length":1,"stats":{"Line":0}},{"line":8109,"address":[56442332,56442415,56442582,56442109,56442499],"length":1,"stats":{"Line":0}},{"line":8110,"address":[],"length":0,"stats":{"Line":0}},{"line":8112,"address":[53869526],"length":1,"stats":{"Line":0}},{"line":8113,"address":[54890029],"length":1,"stats":{"Line":0}},{"line":8116,"address":[56442311],"length":1,"stats":{"Line":0}},{"line":8117,"address":[],"length":0,"stats":{"Line":0}},{"line":8121,"address":[53869891],"length":1,"stats":{"Line":0}},{"line":8122,"address":[54485966],"length":1,"stats":{"Line":0}},{"line":8124,"address":[],"length":0,"stats":{"Line":0}},{"line":8126,"address":[53748049],"length":1,"stats":{"Line":0}},{"line":8127,"address":[53748142],"length":1,"stats":{"Line":0}},{"line":8128,"address":[54700229],"length":1,"stats":{"Line":0}},{"line":8129,"address":[54700195],"length":1,"stats":{"Line":0}},{"line":8132,"address":[54888718,54888573],"length":1,"stats":{"Line":0}},{"line":8133,"address":[],"length":0,"stats":{"Line":0}},{"line":8134,"address":[],"length":0,"stats":{"Line":0}},{"line":8135,"address":[54888924],"length":1,"stats":{"Line":0}},{"line":8136,"address":[54700645],"length":1,"stats":{"Line":0}},{"line":8137,"address":[56080544],"length":1,"stats":{"Line":0}},{"line":8141,"address":[53868712],"length":1,"stats":{"Line":0}},{"line":8142,"address":[54488526],"length":1,"stats":{"Line":0}},{"line":8144,"address":[54889368],"length":1,"stats":{"Line":0}},{"line":8146,"address":[],"length":0,"stats":{"Line":0}},{"line":8147,"address":[54580316],"length":1,"stats":{"Line":0}},{"line":8148,"address":[56439909],"length":1,"stats":{"Line":0}},{"line":8149,"address":[54887762],"length":1,"stats":{"Line":0}},{"line":8152,"address":[56440008,56439863],"length":1,"stats":{"Line":0}},{"line":8153,"address":[54699685,54700089,54700005,54699834,54699918],"length":1,"stats":{"Line":0}},{"line":8154,"address":[],"length":0,"stats":{"Line":0}},{"line":8155,"address":[56440214],"length":1,"stats":{"Line":0}},{"line":8156,"address":[54699812],"length":1,"stats":{"Line":0}},{"line":8157,"address":[54485328],"length":1,"stats":{"Line":0}},{"line":8161,"address":[56440497],"length":1,"stats":{"Line":0}},{"line":8162,"address":[54488430],"length":1,"stats":{"Line":0}},{"line":8164,"address":[54700155],"length":1,"stats":{"Line":0}},{"line":8167,"address":[],"length":0,"stats":{"Line":0}},{"line":8168,"address":[53748274],"length":1,"stats":{"Line":0}},{"line":8169,"address":[53866720],"length":1,"stats":{"Line":0}},{"line":8170,"address":[54698798],"length":1,"stats":{"Line":0}},{"line":8173,"address":[56439770,56439443,56439520,56439603,56439687],"length":1,"stats":{"Line":0}},{"line":8174,"address":[],"length":0,"stats":{"Line":0}},{"line":8175,"address":[56439453],"length":1,"stats":{"Line":0}},{"line":8176,"address":[53094624],"length":1,"stats":{"Line":0}},{"line":8177,"address":[54493920],"length":1,"stats":{"Line":0}},{"line":8178,"address":[],"length":0,"stats":{"Line":0}},{"line":8179,"address":[],"length":0,"stats":{"Line":0}},{"line":8184,"address":[56439674],"length":1,"stats":{"Line":0}},{"line":8185,"address":[],"length":0,"stats":{"Line":0}},{"line":8187,"address":[54699322],"length":1,"stats":{"Line":0}},{"line":8189,"address":[],"length":0,"stats":{"Line":0}},{"line":8190,"address":[56321715],"length":1,"stats":{"Line":0}},{"line":8191,"address":[56438549],"length":1,"stats":{"Line":0}},{"line":8192,"address":[54886402],"length":1,"stats":{"Line":0}},{"line":8195,"address":[54886535,54886390],"length":1,"stats":{"Line":0}},{"line":8196,"address":[56438836,56439066,56439233,56439150,56438983],"length":1,"stats":{"Line":0}},{"line":8197,"address":[],"length":0,"stats":{"Line":0}},{"line":8199,"address":[53866214],"length":1,"stats":{"Line":0}},{"line":8200,"address":[56438869],"length":1,"stats":{"Line":0}},{"line":8203,"address":[54491856],"length":1,"stats":{"Line":0}},{"line":8204,"address":[],"length":0,"stats":{"Line":0}},{"line":8205,"address":[],"length":0,"stats":{"Line":0}},{"line":8206,"address":[],"length":0,"stats":{"Line":0}},{"line":8211,"address":[56084496],"length":1,"stats":{"Line":0}},{"line":8212,"address":[53996238],"length":1,"stats":{"Line":0}},{"line":8214,"address":[54698778],"length":1,"stats":{"Line":0}},{"line":8217,"address":[54580421],"length":1,"stats":{"Line":0}},{"line":8218,"address":[53865596,53865683,53865767,53748487,53748409],"length":1,"stats":{"Line":0}},{"line":8219,"address":[],"length":0,"stats":{"Line":0}},{"line":8220,"address":[54769682],"length":1,"stats":{"Line":0}},{"line":8221,"address":[56321840],"length":1,"stats":{"Line":0}},{"line":8222,"address":[54485008],"length":1,"stats":{"Line":0}},{"line":8226,"address":[],"length":0,"stats":{"Line":0}},{"line":8227,"address":[56085822],"length":1,"stats":{"Line":0}},{"line":8229,"address":[],"length":0,"stats":{"Line":0}},{"line":8231,"address":[],"length":0,"stats":{"Line":0}},{"line":8232,"address":[54769854],"length":1,"stats":{"Line":0}},{"line":8233,"address":[53864783],"length":1,"stats":{"Line":0}},{"line":8234,"address":[54696861],"length":1,"stats":{"Line":0}},{"line":8237,"address":[56437539,56437394],"length":1,"stats":{"Line":0}},{"line":8238,"address":[],"length":0,"stats":{"Line":0}},{"line":8239,"address":[],"length":0,"stats":{"Line":0}},{"line":8240,"address":[54697202],"length":1,"stats":{"Line":0}},{"line":8241,"address":[],"length":0,"stats":{"Line":0}},{"line":8242,"address":[56083936],"length":1,"stats":{"Line":0}},{"line":8246,"address":[54487200],"length":1,"stats":{"Line":0}},{"line":8247,"address":[53095374],"length":1,"stats":{"Line":0}},{"line":8249,"address":[],"length":0,"stats":{"Line":0}},{"line":8251,"address":[],"length":0,"stats":{"Line":0}},{"line":8252,"address":[54580767],"length":1,"stats":{"Line":0}},{"line":8253,"address":[56436274],"length":1,"stats":{"Line":0}},{"line":8254,"address":[53863570],"length":1,"stats":{"Line":0}},{"line":8257,"address":[],"length":0,"stats":{"Line":0}},{"line":8258,"address":[56436577],"length":1,"stats":{"Line":0}},{"line":8259,"address":[53864472,53864643,53864559,53864388,53864162],"length":1,"stats":{"Line":0}},{"line":8260,"address":[],"length":0,"stats":{"Line":0}},{"line":8261,"address":[56436846],"length":1,"stats":{"Line":0}},{"line":8262,"address":[],"length":0,"stats":{"Line":0}},{"line":8263,"address":[],"length":0,"stats":{"Line":0}},{"line":8267,"address":[54696657],"length":1,"stats":{"Line":0}},{"line":8268,"address":[53990286],"length":1,"stats":{"Line":0}},{"line":8270,"address":[54885253],"length":1,"stats":{"Line":0}},{"line":8272,"address":[54580736],"length":1,"stats":{"Line":0}},{"line":8273,"address":[],"length":0,"stats":{"Line":0}},{"line":8274,"address":[],"length":0,"stats":{"Line":0}},{"line":8275,"address":[53862391],"length":1,"stats":{"Line":0}},{"line":8278,"address":[54882949,54883094],"length":1,"stats":{"Line":0}},{"line":8279,"address":[],"length":0,"stats":{"Line":0}},{"line":8280,"address":[54695095,54695576,54695405,54695492,54695321],"length":1,"stats":{"Line":0}},{"line":8281,"address":[],"length":0,"stats":{"Line":0}},{"line":8282,"address":[53863001],"length":1,"stats":{"Line":0}},{"line":8283,"address":[53991296],"length":1,"stats":{"Line":0}},{"line":8284,"address":[54493408],"length":1,"stats":{"Line":0}},{"line":8288,"address":[53863366],"length":1,"stats":{"Line":0}},{"line":8289,"address":[],"length":0,"stats":{"Line":0}},{"line":8291,"address":[],"length":0,"stats":{"Line":0}},{"line":8293,"address":[],"length":0,"stats":{"Line":0}},{"line":8294,"address":[54770040],"length":1,"stats":{"Line":0}},{"line":8296,"address":[54881732,54881684],"length":1,"stats":{"Line":0}},{"line":8297,"address":[54693467],"length":1,"stats":{"Line":0}},{"line":8298,"address":[53861918,53861608,53862005,53862089,53861834],"length":1,"stats":{"Line":0}},{"line":8299,"address":[],"length":0,"stats":{"Line":0}},{"line":8301,"address":[54693738],"length":1,"stats":{"Line":0}},{"line":8302,"address":[54693753],"length":1,"stats":{"Line":0}},{"line":8305,"address":[54693924],"length":1,"stats":{"Line":0}},{"line":8306,"address":[],"length":0,"stats":{"Line":0}},{"line":8310,"address":[53861991],"length":1,"stats":{"Line":0}},{"line":8311,"address":[54492830],"length":1,"stats":{"Line":0}},{"line":8313,"address":[54694267],"length":1,"stats":{"Line":0}},{"line":8314,"address":[53861118],"length":1,"stats":{"Line":0}},{"line":8316,"address":[],"length":0,"stats":{"Line":0}},{"line":8318,"address":[54694341],"length":1,"stats":{"Line":0}},{"line":8319,"address":[56434878],"length":1,"stats":{"Line":0}},{"line":8323,"address":[54580860],"length":1,"stats":{"Line":0}},{"line":8324,"address":[],"length":0,"stats":{"Line":0}},{"line":8325,"address":[54692426],"length":1,"stats":{"Line":0}},{"line":8326,"address":[],"length":0,"stats":{"Line":0}},{"line":8329,"address":[],"length":0,"stats":{"Line":0}},{"line":8330,"address":[56433621,56433307,56433537,56433704,56433454],"length":1,"stats":{"Line":0}},{"line":8331,"address":[],"length":0,"stats":{"Line":0}},{"line":8332,"address":[53860621],"length":1,"stats":{"Line":0}},{"line":8333,"address":[56433433],"length":1,"stats":{"Line":0}},{"line":8334,"address":[53997040],"length":1,"stats":{"Line":0}},{"line":8338,"address":[54881495],"length":1,"stats":{"Line":0}},{"line":8339,"address":[53999262],"length":1,"stats":{"Line":0}},{"line":8341,"address":[56433769],"length":1,"stats":{"Line":0}},{"line":8343,"address":[],"length":0,"stats":{"Line":0}},{"line":8344,"address":[54770164],"length":1,"stats":{"Line":0}},{"line":8345,"address":[56432197],"length":1,"stats":{"Line":0}},{"line":8346,"address":[56432163],"length":1,"stats":{"Line":0}},{"line":8349,"address":[54691692,54691547],"length":1,"stats":{"Line":0}},{"line":8350,"address":[56432484,56432714,56432631,56432798,56432881],"length":1,"stats":{"Line":0}},{"line":8351,"address":[],"length":0,"stats":{"Line":0}},{"line":8352,"address":[54691900],"length":1,"stats":{"Line":0}},{"line":8353,"address":[54880497],"length":1,"stats":{"Line":0}},{"line":8354,"address":[53993680],"length":1,"stats":{"Line":0}},{"line":8358,"address":[56432785],"length":1,"stats":{"Line":0}},{"line":8359,"address":[54484462],"length":1,"stats":{"Line":0}},{"line":8361,"address":[],"length":0,"stats":{"Line":0}},{"line":8363,"address":[54581046,54580984],"length":1,"stats":{"Line":0}},{"line":8364,"address":[53748965],"length":1,"stats":{"Line":0}},{"line":8365,"address":[54690100],"length":1,"stats":{"Line":0}},{"line":8366,"address":[],"length":0,"stats":{"Line":0}},{"line":8369,"address":[54690054,54690199],"length":1,"stats":{"Line":0}},{"line":8370,"address":[54878910],"length":1,"stats":{"Line":0}},{"line":8371,"address":[54879145],"length":1,"stats":{"Line":0}},{"line":8372,"address":[53859086,53858783,53859257,53859341,53859170],"length":1,"stats":{"Line":0}},{"line":8373,"address":[],"length":0,"stats":{"Line":0}},{"line":8375,"address":[53858801],"length":1,"stats":{"Line":0}},{"line":8376,"address":[54879429],"length":1,"stats":{"Line":0}},{"line":8379,"address":[56431787],"length":1,"stats":{"Line":0}},{"line":8380,"address":[54492032],"length":1,"stats":{"Line":0}},{"line":8384,"address":[54879849],"length":1,"stats":{"Line":0}},{"line":8385,"address":[56085726],"length":1,"stats":{"Line":0}},{"line":8387,"address":[54880010],"length":1,"stats":{"Line":0}},{"line":8390,"address":[56322369],"length":1,"stats":{"Line":0}},{"line":8391,"address":[],"length":0,"stats":{"Line":0}},{"line":8392,"address":[54688838],"length":1,"stats":{"Line":0}},{"line":8393,"address":[56429437],"length":1,"stats":{"Line":0}},{"line":8396,"address":[54877449],"length":1,"stats":{"Line":0}},{"line":8397,"address":[53857046,53857638],"length":1,"stats":{"Line":0}},{"line":8398,"address":[],"length":0,"stats":{"Line":0}},{"line":8400,"address":[54689172],"length":1,"stats":{"Line":0}},{"line":8402,"address":[54689960,54689472,54689876,54689246,54689789],"length":1,"stats":{"Line":0}},{"line":8403,"address":[],"length":0,"stats":{"Line":0}},{"line":8405,"address":[56429895],"length":1,"stats":{"Line":0}},{"line":8406,"address":[54877797],"length":1,"stats":{"Line":0}},{"line":8409,"address":[54877966],"length":1,"stats":{"Line":0}},{"line":8410,"address":[54484144],"length":1,"stats":{"Line":0}},{"line":8414,"address":[54490704],"length":1,"stats":{"Line":0}},{"line":8415,"address":[56079902],"length":1,"stats":{"Line":0}},{"line":8417,"address":[53857914],"length":1,"stats":{"Line":0}},{"line":8419,"address":[56322406],"length":1,"stats":{"Line":0}},{"line":8420,"address":[56322510],"length":1,"stats":{"Line":0}},{"line":8421,"address":[54688011],"length":1,"stats":{"Line":0}},{"line":8422,"address":[54876507],"length":1,"stats":{"Line":0}},{"line":8425,"address":[53855998,53855853],"length":1,"stats":{"Line":0}},{"line":8426,"address":[54688300,54688449,54688533,54688620,54688704],"length":1,"stats":{"Line":0}},{"line":8427,"address":[],"length":0,"stats":{"Line":0}},{"line":8428,"address":[54876846],"length":1,"stats":{"Line":0}},{"line":8429,"address":[53100304],"length":1,"stats":{"Line":0}},{"line":8430,"address":[53100320],"length":1,"stats":{"Line":0}},{"line":8434,"address":[54877129],"length":1,"stats":{"Line":0}},{"line":8435,"address":[53989822],"length":1,"stats":{"Line":0}},{"line":8437,"address":[54877290],"length":1,"stats":{"Line":0}},{"line":8439,"address":[],"length":0,"stats":{"Line":0}},{"line":8440,"address":[53855675,53855588,53855759,53749207,53749285],"length":1,"stats":{"Line":0}},{"line":8441,"address":[],"length":0,"stats":{"Line":0}},{"line":8442,"address":[54770477],"length":1,"stats":{"Line":0}},{"line":8443,"address":[54770523],"length":1,"stats":{"Line":0}},{"line":8444,"address":[],"length":0,"stats":{"Line":0}},{"line":8448,"address":[54876306],"length":1,"stats":{"Line":0}},{"line":8449,"address":[54494078],"length":1,"stats":{"Line":0}},{"line":8451,"address":[],"length":0,"stats":{"Line":0}},{"line":8454,"address":[54770429,54770618],"length":1,"stats":{"Line":0}},{"line":8457,"address":[],"length":0,"stats":{"Line":0}},{"line":8458,"address":[],"length":0,"stats":{"Line":0}},{"line":8462,"address":[53749454],"length":1,"stats":{"Line":0}},{"line":8463,"address":[53749486],"length":1,"stats":{"Line":0}},{"line":8465,"address":[56322882],"length":1,"stats":{"Line":0}},{"line":8467,"address":[56322953],"length":1,"stats":{"Line":0}},{"line":8468,"address":[54770887],"length":1,"stats":{"Line":0}},{"line":8469,"address":[56428062,56323059,56428146,56323276,56428229],"length":1,"stats":{"Line":0}},{"line":8470,"address":[],"length":0,"stats":{"Line":0}},{"line":8471,"address":[],"length":0,"stats":{"Line":0}},{"line":8472,"address":[54581997],"length":1,"stats":{"Line":0}},{"line":8473,"address":[53998912],"length":1,"stats":{"Line":0}},{"line":8477,"address":[53995152],"length":1,"stats":{"Line":0}},{"line":8478,"address":[53096398],"length":1,"stats":{"Line":0}},{"line":8480,"address":[53855534],"length":1,"stats":{"Line":0}},{"line":8483,"address":[54771238],"length":1,"stats":{"Line":0}},{"line":8485,"address":[54771306],"length":1,"stats":{"Line":0}},{"line":8486,"address":[54686596],"length":1,"stats":{"Line":0}},{"line":8487,"address":[54875112],"length":1,"stats":{"Line":0}},{"line":8490,"address":[],"length":0,"stats":{"Line":0}},{"line":8491,"address":[54687289,54687205,54687034,54686885,54687118],"length":1,"stats":{"Line":0}},{"line":8492,"address":[],"length":0,"stats":{"Line":0}},{"line":8493,"address":[54875451],"length":1,"stats":{"Line":0}},{"line":8494,"address":[56081456],"length":1,"stats":{"Line":0}},{"line":8495,"address":[],"length":0,"stats":{"Line":0}},{"line":8499,"address":[56088352],"length":1,"stats":{"Line":0}},{"line":8500,"address":[],"length":0,"stats":{"Line":0}},{"line":8502,"address":[53855243],"length":1,"stats":{"Line":0}},{"line":8504,"address":[54582131],"length":1,"stats":{"Line":0}},{"line":8505,"address":[54771368],"length":1,"stats":{"Line":0}},{"line":8506,"address":[54873980],"length":1,"stats":{"Line":0}},{"line":8507,"address":[54685383],"length":1,"stats":{"Line":0}},{"line":8510,"address":[53853259,53853404],"length":1,"stats":{"Line":0}},{"line":8511,"address":[56426396],"length":1,"stats":{"Line":0}},{"line":8512,"address":[56426953,56426647,56427037,56427120,56426870],"length":1,"stats":{"Line":0}},{"line":8513,"address":[],"length":0,"stats":{"Line":0}},{"line":8514,"address":[],"length":0,"stats":{"Line":0}},{"line":8515,"address":[56079600],"length":1,"stats":{"Line":0}},{"line":8516,"address":[53992880],"length":1,"stats":{"Line":0}},{"line":8520,"address":[54874911],"length":1,"stats":{"Line":0}},{"line":8521,"address":[56087262],"length":1,"stats":{"Line":0}},{"line":8523,"address":[56427185],"length":1,"stats":{"Line":0}},{"line":8525,"address":[],"length":0,"stats":{"Line":0}},{"line":8526,"address":[54582286],"length":1,"stats":{"Line":0}},{"line":8527,"address":[54684584],"length":1,"stats":{"Line":0}},{"line":8528,"address":[56425236],"length":1,"stats":{"Line":0}},{"line":8531,"address":[54684538,54684683],"length":1,"stats":{"Line":0}},{"line":8532,"address":[56425954,56425557,56425704,56425871,56425787],"length":1,"stats":{"Line":0}},{"line":8533,"address":[],"length":0,"stats":{"Line":0}},{"line":8534,"address":[56425575],"length":1,"stats":{"Line":0}},{"line":8535,"address":[53995872],"length":1,"stats":{"Line":0}},{"line":8536,"address":[54484304],"length":1,"stats":{"Line":0}},{"line":8540,"address":[54685179],"length":1,"stats":{"Line":0}},{"line":8541,"address":[53095470],"length":1,"stats":{"Line":0}},{"line":8543,"address":[54685343],"length":1,"stats":{"Line":0}},{"line":8545,"address":[56323511],"length":1,"stats":{"Line":0}},{"line":8546,"address":[],"length":0,"stats":{"Line":0}},{"line":8547,"address":[54683751],"length":1,"stats":{"Line":0}},{"line":8548,"address":[56424413],"length":1,"stats":{"Line":0}},{"line":8551,"address":[54872433,54872288],"length":1,"stats":{"Line":0}},{"line":8552,"address":[],"length":0,"stats":{"Line":0}},{"line":8553,"address":[],"length":0,"stats":{"Line":0}},{"line":8554,"address":[53851946],"length":1,"stats":{"Line":0}},{"line":8555,"address":[56086736],"length":1,"stats":{"Line":0}},{"line":8556,"address":[],"length":0,"stats":{"Line":0}},{"line":8560,"address":[56086640],"length":1,"stats":{"Line":0}},{"line":8561,"address":[53095758],"length":1,"stats":{"Line":0}},{"line":8563,"address":[],"length":0,"stats":{"Line":0}},{"line":8565,"address":[54771461],"length":1,"stats":{"Line":0}},{"line":8566,"address":[54771554],"length":1,"stats":{"Line":0}},{"line":8567,"address":[56423624],"length":1,"stats":{"Line":0}},{"line":8568,"address":[56423590],"length":1,"stats":{"Line":0}},{"line":8571,"address":[53850760,53850905],"length":1,"stats":{"Line":0}},{"line":8572,"address":[53851328,53851244,53851095,53851415,53851499],"length":1,"stats":{"Line":0}},{"line":8573,"address":[],"length":0,"stats":{"Line":0}},{"line":8574,"address":[53851113],"length":1,"stats":{"Line":0}},{"line":8575,"address":[53989008],"length":1,"stats":{"Line":0}},{"line":8576,"address":[53989024],"length":1,"stats":{"Line":0}},{"line":8580,"address":[],"length":0,"stats":{"Line":0}},{"line":8581,"address":[53991678],"length":1,"stats":{"Line":0}},{"line":8583,"address":[],"length":0,"stats":{"Line":0}},{"line":8585,"address":[56323635],"length":1,"stats":{"Line":0}},{"line":8586,"address":[54771616],"length":1,"stats":{"Line":0}},{"line":8587,"address":[53849973],"length":1,"stats":{"Line":0}},{"line":8588,"address":[56422767],"length":1,"stats":{"Line":0}},{"line":8591,"address":[54682184,54682039],"length":1,"stats":{"Line":0}},{"line":8592,"address":[53850262,53850495,53850582,53850666,53850411],"length":1,"stats":{"Line":0}},{"line":8593,"address":[],"length":0,"stats":{"Line":0}},{"line":8594,"address":[56423106],"length":1,"stats":{"Line":0}},{"line":8595,"address":[54682501],"length":1,"stats":{"Line":0}},{"line":8596,"address":[56088208],"length":1,"stats":{"Line":0}},{"line":8600,"address":[56088000],"length":1,"stats":{"Line":0}},{"line":8601,"address":[56088014],"length":1,"stats":{"Line":0}},{"line":8603,"address":[54871437],"length":1,"stats":{"Line":0}},{"line":8605,"address":[54771647,54771585],"length":1,"stats":{"Line":0}},{"line":8607,"address":[],"length":0,"stats":{"Line":0}},{"line":8608,"address":[54870492],"length":1,"stats":{"Line":0}},{"line":8609,"address":[53849743],"length":1,"stats":{"Line":0}},{"line":8612,"address":[54870599,54870446],"length":1,"stats":{"Line":0}},{"line":8614,"address":[54771709],"length":1,"stats":{"Line":0}},{"line":8615,"address":[],"length":0,"stats":{"Line":0}},{"line":8616,"address":[],"length":0,"stats":{"Line":0}},{"line":8617,"address":[54681022],"length":1,"stats":{"Line":0}},{"line":8620,"address":[54681010,54681155],"length":1,"stats":{"Line":0}},{"line":8621,"address":[],"length":0,"stats":{"Line":0}},{"line":8622,"address":[],"length":0,"stats":{"Line":0}},{"line":8623,"address":[54681363],"length":1,"stats":{"Line":0}},{"line":8624,"address":[54870082],"length":1,"stats":{"Line":0}},{"line":8625,"address":[],"length":0,"stats":{"Line":0}},{"line":8629,"address":[54681651],"length":1,"stats":{"Line":0}},{"line":8630,"address":[],"length":0,"stats":{"Line":0}},{"line":8632,"address":[],"length":0,"stats":{"Line":0}},{"line":8634,"address":[56323920],"length":1,"stats":{"Line":0}},{"line":8635,"address":[54771876],"length":1,"stats":{"Line":0}},{"line":8636,"address":[54868846],"length":1,"stats":{"Line":0}},{"line":8637,"address":[53848077],"length":1,"stats":{"Line":0}},{"line":8640,"address":[],"length":0,"stats":{"Line":0}},{"line":8641,"address":[53848633,53848549,53848720,53848804,53848400],"length":1,"stats":{"Line":0}},{"line":8642,"address":[],"length":0,"stats":{"Line":0}},{"line":8643,"address":[53848418],"length":1,"stats":{"Line":0}},{"line":8644,"address":[54485792],"length":1,"stats":{"Line":0}},{"line":8645,"address":[],"length":0,"stats":{"Line":0}},{"line":8649,"address":[54486048],"length":1,"stats":{"Line":0}},{"line":8650,"address":[53991486],"length":1,"stats":{"Line":0}},{"line":8652,"address":[53848870],"length":1,"stats":{"Line":0}},{"line":8654,"address":[53750651],"length":1,"stats":{"Line":0}},{"line":8655,"address":[],"length":0,"stats":{"Line":0}},{"line":8656,"address":[53846932],"length":1,"stats":{"Line":0}},{"line":8657,"address":[56419759],"length":1,"stats":{"Line":0}},{"line":8660,"address":[53846886,53847031],"length":1,"stats":{"Line":0}},{"line":8661,"address":[54679349],"length":1,"stats":{"Line":0}},{"line":8662,"address":[53847490,53847800,53847971,53847887,53847716],"length":1,"stats":{"Line":0}},{"line":8663,"address":[],"length":0,"stats":{"Line":0}},{"line":8664,"address":[56420365],"length":1,"stats":{"Line":0}},{"line":8665,"address":[56420549],"length":1,"stats":{"Line":0}},{"line":8666,"address":[],"length":0,"stats":{"Line":0}},{"line":8670,"address":[56080688],"length":1,"stats":{"Line":0}},{"line":8671,"address":[53099950],"length":1,"stats":{"Line":0}},{"line":8673,"address":[],"length":0,"stats":{"Line":0}},{"line":8675,"address":[54772006],"length":1,"stats":{"Line":0}},{"line":8676,"address":[54582930],"length":1,"stats":{"Line":0}},{"line":8677,"address":[],"length":0,"stats":{"Line":0}},{"line":8678,"address":[54677831],"length":1,"stats":{"Line":0}},{"line":8681,"address":[53845707,53845852],"length":1,"stats":{"Line":0}},{"line":8682,"address":[54678170],"length":1,"stats":{"Line":0}},{"line":8683,"address":[],"length":0,"stats":{"Line":0}},{"line":8684,"address":[],"length":0,"stats":{"Line":0}},{"line":8685,"address":[54867086],"length":1,"stats":{"Line":0}},{"line":8686,"address":[53099760],"length":1,"stats":{"Line":0}},{"line":8687,"address":[53998544],"length":1,"stats":{"Line":0}},{"line":8691,"address":[],"length":0,"stats":{"Line":0}},{"line":8692,"address":[54484814],"length":1,"stats":{"Line":0}},{"line":8694,"address":[53846858],"length":1,"stats":{"Line":0}},{"line":8696,"address":[54772043],"length":1,"stats":{"Line":0}},{"line":8697,"address":[54582992],"length":1,"stats":{"Line":0}},{"line":8698,"address":[54865348],"length":1,"stats":{"Line":0}},{"line":8699,"address":[54865314],"length":1,"stats":{"Line":0}},{"line":8702,"address":[53844673,53844528],"length":1,"stats":{"Line":0}},{"line":8703,"address":[54865651],"length":1,"stats":{"Line":0}},{"line":8704,"address":[],"length":0,"stats":{"Line":0}},{"line":8705,"address":[],"length":0,"stats":{"Line":0}},{"line":8706,"address":[56418033],"length":1,"stats":{"Line":0}},{"line":8707,"address":[53845336],"length":1,"stats":{"Line":0}},{"line":8708,"address":[],"length":0,"stats":{"Line":0}},{"line":8712,"address":[56418392],"length":1,"stats":{"Line":0}},{"line":8713,"address":[56086910],"length":1,"stats":{"Line":0}},{"line":8715,"address":[],"length":0,"stats":{"Line":0}},{"line":8718,"address":[54772250,54772167,54772105],"length":1,"stats":{"Line":0}},{"line":8719,"address":[],"length":0,"stats":{"Line":0}},{"line":8721,"address":[53750942],"length":1,"stats":{"Line":0}},{"line":8723,"address":[54772447],"length":1,"stats":{"Line":0}},{"line":8725,"address":[56324627],"length":1,"stats":{"Line":0}},{"line":8726,"address":[],"length":0,"stats":{"Line":0}},{"line":8727,"address":[54675819],"length":1,"stats":{"Line":0}},{"line":8730,"address":[53843840,53843695],"length":1,"stats":{"Line":0}},{"line":8731,"address":[],"length":0,"stats":{"Line":0}},{"line":8732,"address":[],"length":0,"stats":{"Line":0}},{"line":8733,"address":[54864830],"length":1,"stats":{"Line":0}},{"line":8734,"address":[56079984],"length":1,"stats":{"Line":0}},{"line":8735,"address":[54492192],"length":1,"stats":{"Line":0}},{"line":8739,"address":[53095168],"length":1,"stats":{"Line":0}},{"line":8740,"address":[53993950],"length":1,"stats":{"Line":0}},{"line":8742,"address":[54865274],"length":1,"stats":{"Line":0}},{"line":8744,"address":[],"length":0,"stats":{"Line":0}},{"line":8746,"address":[],"length":0,"stats":{"Line":0}},{"line":8747,"address":[54863359],"length":1,"stats":{"Line":0}},{"line":8748,"address":[53842528],"length":1,"stats":{"Line":0}},{"line":8751,"address":[53842516,53842661],"length":1,"stats":{"Line":0}},{"line":8752,"address":[54674979],"length":1,"stats":{"Line":0}},{"line":8753,"address":[56416332,56416026,56416249,56416499,56416416],"length":1,"stats":{"Line":0}},{"line":8754,"address":[],"length":0,"stats":{"Line":0}},{"line":8756,"address":[54675250],"length":1,"stats":{"Line":0}},{"line":8757,"address":[54863946],"length":1,"stats":{"Line":0}},{"line":8760,"address":[54864115],"length":1,"stats":{"Line":0}},{"line":8761,"address":[],"length":0,"stats":{"Line":0}},{"line":8765,"address":[54864290],"length":1,"stats":{"Line":0}},{"line":8766,"address":[56088974],"length":1,"stats":{"Line":0}},{"line":8768,"address":[56416564],"length":1,"stats":{"Line":0}},{"line":8770,"address":[56324658],"length":1,"stats":{"Line":0}},{"line":8772,"address":[54583495],"length":1,"stats":{"Line":0}},{"line":8773,"address":[56415095],"length":1,"stats":{"Line":0}},{"line":8774,"address":[56415061],"length":1,"stats":{"Line":0}},{"line":8778,"address":[],"length":0,"stats":{"Line":0}},{"line":8779,"address":[54863269],"length":1,"stats":{"Line":0}},{"line":8781,"address":[],"length":0,"stats":{"Line":0}},{"line":8783,"address":[],"length":0,"stats":{"Line":0}},{"line":8784,"address":[54862584],"length":1,"stats":{"Line":0}},{"line":8785,"address":[56414663],"length":1,"stats":{"Line":0}},{"line":8788,"address":[],"length":0,"stats":{"Line":0}},{"line":8789,"address":[54674184],"length":1,"stats":{"Line":0}},{"line":8790,"address":[],"length":0,"stats":{"Line":0}},{"line":8792,"address":[],"length":0,"stats":{"Line":0}},{"line":8794,"address":[54583656],"length":1,"stats":{"Line":0}},{"line":8795,"address":[],"length":0,"stats":{"Line":0}},{"line":8796,"address":[54861707],"length":1,"stats":{"Line":0}},{"line":8799,"address":[54672996,54673141],"length":1,"stats":{"Line":0}},{"line":8800,"address":[54862028],"length":1,"stats":{"Line":0}},{"line":8801,"address":[54862181],"length":1,"stats":{"Line":0}},{"line":8802,"address":[54673533],"length":1,"stats":{"Line":0}},{"line":8803,"address":[],"length":0,"stats":{"Line":0}},{"line":8804,"address":[53841428],"length":1,"stats":{"Line":0}},{"line":8806,"address":[54673615],"length":1,"stats":{"Line":0}},{"line":8807,"address":[54673661],"length":1,"stats":{"Line":0}},{"line":8808,"address":[],"length":0,"stats":{"Line":0}},{"line":8809,"address":[56414474],"length":1,"stats":{"Line":0}},{"line":8811,"address":[54862430],"length":1,"stats":{"Line":0}},{"line":8812,"address":[],"length":0,"stats":{"Line":0}},{"line":8813,"address":[54862440],"length":1,"stats":{"Line":0}},{"line":8815,"address":[56414633],"length":1,"stats":{"Line":0}},{"line":8817,"address":[54772831,54772769],"length":1,"stats":{"Line":0}},{"line":8819,"address":[],"length":0,"stats":{"Line":0}},{"line":8820,"address":[54861165],"length":1,"stats":{"Line":0}},{"line":8821,"address":[54861131],"length":1,"stats":{"Line":0}},{"line":8824,"address":[],"length":0,"stats":{"Line":0}},{"line":8825,"address":[56413565],"length":1,"stats":{"Line":0}},{"line":8826,"address":[53840784],"length":1,"stats":{"Line":0}},{"line":8827,"address":[],"length":0,"stats":{"Line":0}},{"line":8830,"address":[54583749],"length":1,"stats":{"Line":0}},{"line":8832,"address":[53751709],"length":1,"stats":{"Line":0}},{"line":8833,"address":[54772975],"length":1,"stats":{"Line":0}},{"line":8837,"address":[54773025],"length":1,"stats":{"Line":0}},{"line":8838,"address":[],"length":0,"stats":{"Line":0}},{"line":8840,"address":[54583786,54584042,54583939],"length":1,"stats":{"Line":0}},{"line":8841,"address":[53751858],"length":1,"stats":{"Line":0}},{"line":8842,"address":[],"length":0,"stats":{"Line":0}},{"line":8844,"address":[53752008],"length":1,"stats":{"Line":0}},{"line":8846,"address":[],"length":0,"stats":{"Line":0}},{"line":8849,"address":[54773384],"length":1,"stats":{"Line":0}},{"line":8851,"address":[54584308],"length":1,"stats":{"Line":0}},{"line":8852,"address":[53839969],"length":1,"stats":{"Line":0}},{"line":8853,"address":[56412867],"length":1,"stats":{"Line":0}},{"line":8856,"address":[54672035,54672180],"length":1,"stats":{"Line":0}},{"line":8857,"address":[53840258],"length":1,"stats":{"Line":0}},{"line":8859,"address":[54773421],"length":1,"stats":{"Line":0}},{"line":8861,"address":[54584370],"length":1,"stats":{"Line":0}},{"line":8862,"address":[56412055],"length":1,"stats":{"Line":0}},{"line":8863,"address":[54859908],"length":1,"stats":{"Line":0}},{"line":8866,"address":[54671179,54671324],"length":1,"stats":{"Line":0}},{"line":8867,"address":[54671514],"length":1,"stats":{"Line":0}},{"line":8868,"address":[53839557],"length":1,"stats":{"Line":0}},{"line":8869,"address":[53839604],"length":1,"stats":{"Line":0}},{"line":8870,"address":[],"length":0,"stats":{"Line":0}},{"line":8871,"address":[54860436],"length":1,"stats":{"Line":0}},{"line":8873,"address":[54671798],"length":1,"stats":{"Line":0}},{"line":8874,"address":[],"length":0,"stats":{"Line":0}},{"line":8875,"address":[],"length":0,"stats":{"Line":0}},{"line":8876,"address":[],"length":0,"stats":{"Line":0}},{"line":8878,"address":[],"length":0,"stats":{"Line":0}},{"line":8879,"address":[],"length":0,"stats":{"Line":0}},{"line":8880,"address":[54671935],"length":1,"stats":{"Line":0}},{"line":8882,"address":[56412837],"length":1,"stats":{"Line":0}},{"line":8884,"address":[56325595],"length":1,"stats":{"Line":0}},{"line":8886,"address":[54773576],"length":1,"stats":{"Line":0}},{"line":8887,"address":[],"length":0,"stats":{"Line":0}},{"line":8888,"address":[53838679],"length":1,"stats":{"Line":0}},{"line":8891,"address":[],"length":0,"stats":{"Line":0}},{"line":8892,"address":[54859831],"length":1,"stats":{"Line":0}},{"line":8893,"address":[54671161],"length":1,"stats":{"Line":0}},{"line":8895,"address":[54584401],"length":1,"stats":{"Line":0}},{"line":8897,"address":[],"length":0,"stats":{"Line":0}},{"line":8898,"address":[53838350],"length":1,"stats":{"Line":0}},{"line":8899,"address":[54859149],"length":1,"stats":{"Line":0}},{"line":8902,"address":[56411395,56411250],"length":1,"stats":{"Line":0}},{"line":8903,"address":[53838639],"length":1,"stats":{"Line":0}},{"line":8905,"address":[56325781,56325719],"length":1,"stats":{"Line":0}},{"line":8907,"address":[54584556],"length":1,"stats":{"Line":0}},{"line":8908,"address":[56410276],"length":1,"stats":{"Line":0}},{"line":8909,"address":[54669398],"length":1,"stats":{"Line":0}},{"line":8912,"address":[56410230,56410375],"length":1,"stats":{"Line":0}},{"line":8913,"address":[54858466],"length":1,"stats":{"Line":0}},{"line":8914,"address":[54669990],"length":1,"stats":{"Line":0}},{"line":8915,"address":[],"length":0,"stats":{"Line":0}},{"line":8916,"address":[53838204],"length":1,"stats":{"Line":0}},{"line":8917,"address":[],"length":0,"stats":{"Line":0}},{"line":8918,"address":[56411159],"length":1,"stats":{"Line":0}},{"line":8920,"address":[54859119],"length":1,"stats":{"Line":0}},{"line":8923,"address":[54773851,54773731],"length":1,"stats":{"Line":0}},{"line":8925,"address":[53752543],"length":1,"stats":{"Line":0}},{"line":8927,"address":[54584781],"length":1,"stats":{"Line":0}},{"line":8928,"address":[56326105],"length":1,"stats":{"Line":0}},{"line":8929,"address":[54669071],"length":1,"stats":{"Line":0}},{"line":8930,"address":[53836925],"length":1,"stats":{"Line":0}},{"line":8933,"address":[],"length":0,"stats":{"Line":0}},{"line":8934,"address":[54858099],"length":1,"stats":{"Line":0}},{"line":8936,"address":[],"length":0,"stats":{"Line":0}},{"line":8937,"address":[56326167],"length":1,"stats":{"Line":0}},{"line":8938,"address":[],"length":0,"stats":{"Line":0}},{"line":8939,"address":[54668676],"length":1,"stats":{"Line":0}},{"line":8942,"address":[56409512,56409657],"length":1,"stats":{"Line":0}},{"line":8943,"address":[53836895],"length":1,"stats":{"Line":0}},{"line":8945,"address":[56326136],"length":1,"stats":{"Line":0}},{"line":8946,"address":[54774117],"length":1,"stats":{"Line":0}},{"line":8947,"address":[54857086],"length":1,"stats":{"Line":0}},{"line":8948,"address":[54668315],"length":1,"stats":{"Line":0}},{"line":8951,"address":[54857185,54857040],"length":1,"stats":{"Line":0}},{"line":8952,"address":[54668646],"length":1,"stats":{"Line":0}},{"line":8954,"address":[56326198],"length":1,"stats":{"Line":0}},{"line":8955,"address":[54774179],"length":1,"stats":{"Line":0}},{"line":8956,"address":[54667735],"length":1,"stats":{"Line":0}},{"line":8957,"address":[56408555],"length":1,"stats":{"Line":0}},{"line":8960,"address":[54856575,54856430],"length":1,"stats":{"Line":0}},{"line":8961,"address":[],"length":0,"stats":{"Line":0}},{"line":8962,"address":[53836173],"length":1,"stats":{"Line":0}},{"line":8965,"address":[54774148],"length":1,"stats":{"Line":0}},{"line":8966,"address":[54774241],"length":1,"stats":{"Line":0}},{"line":8967,"address":[54667374],"length":1,"stats":{"Line":0}},{"line":8968,"address":[],"length":0,"stats":{"Line":0}},{"line":8971,"address":[54856071,54856216],"length":1,"stats":{"Line":0}},{"line":8972,"address":[54856412],"length":1,"stats":{"Line":0}},{"line":8974,"address":[54774210],"length":1,"stats":{"Line":0}},{"line":8975,"address":[56326415],"length":1,"stats":{"Line":0}},{"line":8976,"address":[53834648],"length":1,"stats":{"Line":0}},{"line":8977,"address":[],"length":0,"stats":{"Line":0}},{"line":8980,"address":[],"length":0,"stats":{"Line":0}},{"line":8981,"address":[56407923],"length":1,"stats":{"Line":0}},{"line":8982,"address":[54856053],"length":1,"stats":{"Line":0}},{"line":8985,"address":[56326384],"length":1,"stats":{"Line":0}},{"line":8986,"address":[54585229],"length":1,"stats":{"Line":0}},{"line":8987,"address":[56407457],"length":1,"stats":{"Line":0}},{"line":8988,"address":[],"length":0,"stats":{"Line":0}},{"line":8991,"address":[],"length":0,"stats":{"Line":0}},{"line":8993,"address":[54585190],"length":1,"stats":{"Line":0}},{"line":8994,"address":[54774446],"length":1,"stats":{"Line":0}},{"line":8995,"address":[54666454],"length":1,"stats":{"Line":0}},{"line":8996,"address":[56407280],"length":1,"stats":{"Line":0}},{"line":8999,"address":[54855300],"length":1,"stats":{"Line":0}},{"line":9001,"address":[56326519],"length":1,"stats":{"Line":0}},{"line":9002,"address":[],"length":0,"stats":{"Line":0}},{"line":9003,"address":[],"length":0,"stats":{"Line":0}},{"line":9004,"address":[54666079],"length":1,"stats":{"Line":0}},{"line":9007,"address":[54854961,54854816],"length":1,"stats":{"Line":0}},{"line":9008,"address":[54666410],"length":1,"stats":{"Line":0}},{"line":9011,"address":[56326592],"length":1,"stats":{"Line":0}},{"line":9013,"address":[54585439],"length":1,"stats":{"Line":0}},{"line":9014,"address":[56406177],"length":1,"stats":{"Line":0}},{"line":9016,"address":[54854106,54854047],"length":1,"stats":{"Line":0}},{"line":9018,"address":[53833690,53833861,53833777,53833441,53833606],"length":1,"stats":{"Line":0}},{"line":9019,"address":[],"length":0,"stats":{"Line":0}},{"line":9020,"address":[54665571],"length":1,"stats":{"Line":0}},{"line":9021,"address":[54665696],"length":1,"stats":{"Line":0}},{"line":9022,"address":[56088560],"length":1,"stats":{"Line":0}},{"line":9026,"address":[54487296],"length":1,"stats":{"Line":0}},{"line":9027,"address":[53092078],"length":1,"stats":{"Line":0}},{"line":9029,"address":[54666039],"length":1,"stats":{"Line":0}},{"line":9032,"address":[],"length":0,"stats":{"Line":0}},{"line":9033,"address":[54585505],"length":1,"stats":{"Line":0}},{"line":9034,"address":[],"length":0,"stats":{"Line":0}},{"line":9035,"address":[53832574],"length":1,"stats":{"Line":0}},{"line":9038,"address":[54664819,54664674],"length":1,"stats":{"Line":0}},{"line":9039,"address":[56405899],"length":1,"stats":{"Line":0}},{"line":9040,"address":[54854029],"length":1,"stats":{"Line":0}},{"line":9042,"address":[56326727],"length":1,"stats":{"Line":0}},{"line":9043,"address":[56326820],"length":1,"stats":{"Line":0}},{"line":9044,"address":[56404986],"length":1,"stats":{"Line":0}},{"line":9045,"address":[53831960],"length":1,"stats":{"Line":0}},{"line":9048,"address":[],"length":0,"stats":{"Line":0}},{"line":9049,"address":[54664411],"length":1,"stats":{"Line":0}},{"line":9050,"address":[54664656],"length":1,"stats":{"Line":0}},{"line":9052,"address":[54585536],"length":1,"stats":{"Line":0}},{"line":9053,"address":[54774770],"length":1,"stats":{"Line":0}},{"line":9054,"address":[56404627],"length":1,"stats":{"Line":0}},{"line":9055,"address":[54663711],"length":1,"stats":{"Line":0}},{"line":9058,"address":[54663699,54663844],"length":1,"stats":{"Line":0}},{"line":9059,"address":[],"length":0,"stats":{"Line":0}},{"line":9061,"address":[],"length":0,"stats":{"Line":0}},{"line":9062,"address":[],"length":0,"stats":{"Line":0}},{"line":9063,"address":[],"length":0,"stats":{"Line":0}},{"line":9064,"address":[],"length":0,"stats":{"Line":0}},{"line":9067,"address":[],"length":0,"stats":{"Line":0}},{"line":9068,"address":[],"length":0,"stats":{"Line":0}},{"line":9071,"address":[56326851],"length":1,"stats":{"Line":0}},{"line":9072,"address":[56326944],"length":1,"stats":{"Line":0}},{"line":9073,"address":[54851904],"length":1,"stats":{"Line":0}},{"line":9074,"address":[56403983],"length":1,"stats":{"Line":0}},{"line":9077,"address":[54663085,54663230],"length":1,"stats":{"Line":0}},{"line":9078,"address":[54663436],"length":1,"stats":{"Line":0}},{"line":9079,"address":[54852450],"length":1,"stats":{"Line":0}},{"line":9081,"address":[56326913],"length":1,"stats":{"Line":0}},{"line":9082,"address":[53753641],"length":1,"stats":{"Line":0}},{"line":9083,"address":[54851294],"length":1,"stats":{"Line":0}},{"line":9084,"address":[54851260],"length":1,"stats":{"Line":0}},{"line":9087,"address":[53830359,53830504],"length":1,"stats":{"Line":0}},{"line":9088,"address":[],"length":0,"stats":{"Line":0}},{"line":9089,"address":[54851840],"length":1,"stats":{"Line":0}},{"line":9091,"address":[54774863],"length":1,"stats":{"Line":0}},{"line":9092,"address":[53753703],"length":1,"stats":{"Line":0}},{"line":9093,"address":[54661641],"length":1,"stats":{"Line":0}},{"line":9094,"address":[],"length":0,"stats":{"Line":0}},{"line":9097,"address":[54850378,54850523],"length":1,"stats":{"Line":0}},{"line":9098,"address":[],"length":0,"stats":{"Line":0}},{"line":9099,"address":[54850962],"length":1,"stats":{"Line":0}},{"line":9100,"address":[53830332],"length":1,"stats":{"Line":0}},{"line":9102,"address":[53753672],"length":1,"stats":{"Line":0}},{"line":9103,"address":[56327130],"length":1,"stats":{"Line":0}},{"line":9104,"address":[54849814],"length":1,"stats":{"Line":0}},{"line":9105,"address":[],"length":0,"stats":{"Line":0}},{"line":9108,"address":[56402026,56401881],"length":1,"stats":{"Line":0}},{"line":9109,"address":[],"length":0,"stats":{"Line":0}},{"line":9110,"address":[53829465],"length":1,"stats":{"Line":0}},{"line":9112,"address":[],"length":0,"stats":{"Line":0}},{"line":9113,"address":[],"length":0,"stats":{"Line":0}},{"line":9114,"address":[54849204],"length":1,"stats":{"Line":0}},{"line":9115,"address":[56401283],"length":1,"stats":{"Line":0}},{"line":9118,"address":[56401271,56401416],"length":1,"stats":{"Line":0}},{"line":9119,"address":[53828606],"length":1,"stats":{"Line":0}},{"line":9120,"address":[56401863],"length":1,"stats":{"Line":0}},{"line":9122,"address":[53753796],"length":1,"stats":{"Line":0}},{"line":9123,"address":[],"length":0,"stats":{"Line":0}},{"line":9124,"address":[56400707],"length":1,"stats":{"Line":0}},{"line":9125,"address":[56400673],"length":1,"stats":{"Line":0}},{"line":9128,"address":[],"length":0,"stats":{"Line":0}},{"line":9129,"address":[56401010],"length":1,"stats":{"Line":0}},{"line":9130,"address":[56401253],"length":1,"stats":{"Line":0}},{"line":9132,"address":[54775111],"length":1,"stats":{"Line":0}},{"line":9133,"address":[53753951],"length":1,"stats":{"Line":0}},{"line":9134,"address":[53827073],"length":1,"stats":{"Line":0}},{"line":9135,"address":[54659151],"length":1,"stats":{"Line":0}},{"line":9138,"address":[54659284,54659139],"length":1,"stats":{"Line":0}},{"line":9139,"address":[],"length":0,"stats":{"Line":0}},{"line":9140,"address":[54848530],"length":1,"stats":{"Line":0}},{"line":9143,"address":[53753920],"length":1,"stats":{"Line":0}},{"line":9144,"address":[56327378],"length":1,"stats":{"Line":0}},{"line":9145,"address":[54847625],"length":1,"stats":{"Line":0}},{"line":9146,"address":[],"length":0,"stats":{"Line":0}},{"line":9149,"address":[53826811,53826666],"length":1,"stats":{"Line":0}},{"line":9150,"address":[],"length":0,"stats":{"Line":0}},{"line":9152,"address":[54775235],"length":1,"stats":{"Line":0}},{"line":9153,"address":[56327440],"length":1,"stats":{"Line":0}},{"line":9154,"address":[54658463],"length":1,"stats":{"Line":0}},{"line":9155,"address":[54658429],"length":1,"stats":{"Line":0}},{"line":9158,"address":[54658417,54658562],"length":1,"stats":{"Line":0}},{"line":9159,"address":[53826648],"length":1,"stats":{"Line":0}},{"line":9161,"address":[54586156],"length":1,"stats":{"Line":0}},{"line":9163,"address":[56327502],"length":1,"stats":{"Line":0}},{"line":9164,"address":[],"length":0,"stats":{"Line":0}},{"line":9165,"address":[],"length":0,"stats":{"Line":0}},{"line":9168,"address":[56398723,56398868],"length":1,"stats":{"Line":0}},{"line":9169,"address":[],"length":0,"stats":{"Line":0}},{"line":9170,"address":[56399315],"length":1,"stats":{"Line":0}},{"line":9172,"address":[56327471],"length":1,"stats":{"Line":0}},{"line":9174,"address":[54586319],"length":1,"stats":{"Line":0}},{"line":9175,"address":[54846493],"length":1,"stats":{"Line":0}},{"line":9176,"address":[56398572],"length":1,"stats":{"Line":0}},{"line":9179,"address":[54846592],"length":1,"stats":{"Line":0}},{"line":9181,"address":[56327533],"length":1,"stats":{"Line":0}},{"line":9182,"address":[56327645],"length":1,"stats":{"Line":0}},{"line":9183,"address":[],"length":0,"stats":{"Line":0}},{"line":9184,"address":[54846316],"length":1,"stats":{"Line":0}},{"line":9187,"address":[53825530],"length":1,"stats":{"Line":0}},{"line":9189,"address":[54775494],"length":1,"stats":{"Line":0}},{"line":9190,"address":[56327718],"length":1,"stats":{"Line":0}},{"line":9191,"address":[],"length":0,"stats":{"Line":0}},{"line":9192,"address":[],"length":0,"stats":{"Line":0}},{"line":9195,"address":[54657499],"length":1,"stats":{"Line":0}},{"line":9198,"address":[],"length":0,"stats":{"Line":0}},{"line":9200,"address":[],"length":0,"stats":{"Line":0}},{"line":9201,"address":[56327836],"length":1,"stats":{"Line":0}},{"line":9203,"address":[54775640],"length":1,"stats":{"Line":0}},{"line":9204,"address":[54586643],"length":1,"stats":{"Line":0}},{"line":9205,"address":[54845868],"length":1,"stats":{"Line":0}},{"line":9206,"address":[54845834],"length":1,"stats":{"Line":0}},{"line":9209,"address":[53824901,53825046],"length":1,"stats":{"Line":0}},{"line":9210,"address":[56398276],"length":1,"stats":{"Line":0}},{"line":9212,"address":[54775750],"length":1,"stats":{"Line":0}},{"line":9214,"address":[54586705],"length":1,"stats":{"Line":0}},{"line":9215,"address":[56397622],"length":1,"stats":{"Line":0}},{"line":9216,"address":[],"length":0,"stats":{"Line":0}},{"line":9219,"address":[54656797,54656652],"length":1,"stats":{"Line":0}},{"line":9220,"address":[53824883],"length":1,"stats":{"Line":0}},{"line":9222,"address":[54775812],"length":1,"stats":{"Line":0}},{"line":9223,"address":[53754655],"length":1,"stats":{"Line":0}},{"line":9224,"address":[54656084],"length":1,"stats":{"Line":0}},{"line":9225,"address":[54656050],"length":1,"stats":{"Line":0}},{"line":9228,"address":[56396966,56397111],"length":1,"stats":{"Line":0}},{"line":9229,"address":[56397315],"length":1,"stats":{"Line":0}},{"line":9230,"address":[56397558],"length":1,"stats":{"Line":0}},{"line":9232,"address":[54775874],"length":1,"stats":{"Line":0}},{"line":9233,"address":[54775967],"length":1,"stats":{"Line":0}},{"line":9234,"address":[54844540],"length":1,"stats":{"Line":0}},{"line":9235,"address":[53823577],"length":1,"stats":{"Line":0}},{"line":9238,"address":[54655677,54655822],"length":1,"stats":{"Line":0}},{"line":9239,"address":[54844835],"length":1,"stats":{"Line":0}},{"line":9241,"address":[53754686],"length":1,"stats":{"Line":0}},{"line":9242,"address":[54586891],"length":1,"stats":{"Line":0}},{"line":9243,"address":[56396043],"length":1,"stats":{"Line":0}},{"line":9244,"address":[54655075],"length":1,"stats":{"Line":0}},{"line":9247,"address":[54655063,54655208],"length":1,"stats":{"Line":0}},{"line":9248,"address":[54655414],"length":1,"stats":{"Line":0}},{"line":9249,"address":[53823547],"length":1,"stats":{"Line":0}},{"line":9251,"address":[54775998],"length":1,"stats":{"Line":0}},{"line":9252,"address":[54776091],"length":1,"stats":{"Line":0}},{"line":9253,"address":[54654495],"length":1,"stats":{"Line":0}},{"line":9254,"address":[54654461],"length":1,"stats":{"Line":0}},{"line":9257,"address":[56395387,56395532],"length":1,"stats":{"Line":0}},{"line":9258,"address":[56395736],"length":1,"stats":{"Line":0}},{"line":9259,"address":[56395979],"length":1,"stats":{"Line":0}},{"line":9262,"address":[],"length":0,"stats":{"Line":0}},{"line":9263,"address":[],"length":0,"stats":{"Line":0}},{"line":9264,"address":[],"length":0,"stats":{"Line":0}},{"line":9265,"address":[],"length":0,"stats":{"Line":0}},{"line":9268,"address":[],"length":0,"stats":{"Line":0}},{"line":9269,"address":[],"length":0,"stats":{"Line":0}},{"line":9270,"address":[],"length":0,"stats":{"Line":0}},{"line":9271,"address":[],"length":0,"stats":{"Line":0}},{"line":9273,"address":[54776060],"length":1,"stats":{"Line":0}},{"line":9274,"address":[],"length":0,"stats":{"Line":0}},{"line":9275,"address":[],"length":0,"stats":{"Line":0}},{"line":9276,"address":[54653847],"length":1,"stats":{"Line":0}},{"line":9279,"address":[56394922,56394777],"length":1,"stats":{"Line":0}},{"line":9280,"address":[54843013],"length":1,"stats":{"Line":0}},{"line":9281,"address":[54654431],"length":1,"stats":{"Line":0}},{"line":9283,"address":[53754872],"length":1,"stats":{"Line":0}},{"line":9284,"address":[],"length":0,"stats":{"Line":0}},{"line":9285,"address":[53821155],"length":1,"stats":{"Line":0}},{"line":9286,"address":[54653233],"length":1,"stats":{"Line":0}},{"line":9289,"address":[54842054,54842199],"length":1,"stats":{"Line":0}},{"line":9290,"address":[],"length":0,"stats":{"Line":0}},{"line":9291,"address":[54842646],"length":1,"stats":{"Line":0}},{"line":9294,"address":[54587046],"length":1,"stats":{"Line":0}},{"line":9295,"address":[56328389],"length":1,"stats":{"Line":0}},{"line":9296,"address":[54841728],"length":1,"stats":{"Line":0}},{"line":9297,"address":[54652859],"length":1,"stats":{"Line":0}},{"line":9300,"address":[54841682,54841827],"length":1,"stats":{"Line":0}},{"line":9301,"address":[56394136],"length":1,"stats":{"Line":0}},{"line":9303,"address":[53754996],"length":1,"stats":{"Line":0}},{"line":9304,"address":[54587201],"length":1,"stats":{"Line":0}},{"line":9305,"address":[],"length":0,"stats":{"Line":0}},{"line":9306,"address":[53820373],"length":1,"stats":{"Line":0}},{"line":9309,"address":[54652473,54652618],"length":1,"stats":{"Line":0}},{"line":9310,"address":[54841651],"length":1,"stats":{"Line":0}},{"line":9312,"address":[54776308],"length":1,"stats":{"Line":0}},{"line":9313,"address":[54587263],"length":1,"stats":{"Line":0}},{"line":9314,"address":[54652145],"length":1,"stats":{"Line":0}},{"line":9315,"address":[53819999],"length":1,"stats":{"Line":0}},{"line":9318,"address":[54841083,54840938],"length":1,"stats":{"Line":0}},{"line":9319,"address":[56393392],"length":1,"stats":{"Line":0}},{"line":9321,"address":[],"length":0,"stats":{"Line":0}},{"line":9322,"address":[],"length":0,"stats":{"Line":0}},{"line":9323,"address":[],"length":0,"stats":{"Line":0}},{"line":9324,"address":[],"length":0,"stats":{"Line":0}},{"line":9327,"address":[],"length":0,"stats":{"Line":0}},{"line":9328,"address":[],"length":0,"stats":{"Line":0}},{"line":9330,"address":[53755120],"length":1,"stats":{"Line":0}},{"line":9331,"address":[],"length":0,"stats":{"Line":0}},{"line":9332,"address":[53819419],"length":1,"stats":{"Line":0}},{"line":9333,"address":[56392453],"length":1,"stats":{"Line":0}},{"line":9336,"address":[54840473,54840328],"length":1,"stats":{"Line":0}},{"line":9337,"address":[56392790],"length":1,"stats":{"Line":0}},{"line":9338,"address":[54840920],"length":1,"stats":{"Line":0}},{"line":9340,"address":[54776432],"length":1,"stats":{"Line":0}},{"line":9341,"address":[53755275],"length":1,"stats":{"Line":0}},{"line":9342,"address":[],"length":0,"stats":{"Line":0}},{"line":9343,"address":[56392081],"length":1,"stats":{"Line":0}},{"line":9346,"address":[54840101,54839956],"length":1,"stats":{"Line":0}},{"line":9347,"address":[56392410],"length":1,"stats":{"Line":0}},{"line":9349,"address":[54587356],"length":1,"stats":{"Line":0}},{"line":9350,"address":[56328699],"length":1,"stats":{"Line":0}},{"line":9351,"address":[54839630],"length":1,"stats":{"Line":0}},{"line":9352,"address":[56391709],"length":1,"stats":{"Line":0}},{"line":9355,"address":[54650737,54650882],"length":1,"stats":{"Line":0}},{"line":9356,"address":[54839925],"length":1,"stats":{"Line":0}},{"line":9358,"address":[54776556],"length":1,"stats":{"Line":0}},{"line":9359,"address":[],"length":0,"stats":{"Line":0}},{"line":9360,"address":[],"length":0,"stats":{"Line":0}},{"line":9361,"address":[54650375],"length":1,"stats":{"Line":0}},{"line":9364,"address":[54650363,54650508],"length":1,"stats":{"Line":0}},{"line":9365,"address":[53818594],"length":1,"stats":{"Line":0}},{"line":9367,"address":[],"length":0,"stats":{"Line":0}},{"line":9368,"address":[56328823],"length":1,"stats":{"Line":0}},{"line":9369,"address":[54650035],"length":1,"stats":{"Line":0}},{"line":9370,"address":[53817889],"length":1,"stats":{"Line":0}},{"line":9373,"address":[56391098,56390953],"length":1,"stats":{"Line":0}},{"line":9374,"address":[],"length":0,"stats":{"Line":0}},{"line":9376,"address":[53755430],"length":1,"stats":{"Line":0}},{"line":9377,"address":[54587635],"length":1,"stats":{"Line":0}},{"line":9378,"address":[],"length":0,"stats":{"Line":0}},{"line":9379,"address":[56390593],"length":1,"stats":{"Line":0}},{"line":9382,"address":[56390581,56390726],"length":1,"stats":{"Line":0}},{"line":9383,"address":[56390922],"length":1,"stats":{"Line":0}},{"line":9385,"address":[54776742],"length":1,"stats":{"Line":0}},{"line":9386,"address":[54587697],"length":1,"stats":{"Line":0}},{"line":9387,"address":[],"length":0,"stats":{"Line":0}},{"line":9388,"address":[],"length":0,"stats":{"Line":0}},{"line":9391,"address":[54649386,54649241],"length":1,"stats":{"Line":0}},{"line":9392,"address":[56390550],"length":1,"stats":{"Line":0}},{"line":9394,"address":[53755554,53755616],"length":1,"stats":{"Line":0}},{"line":9395,"address":[],"length":0,"stats":{"Line":0}},{"line":9396,"address":[],"length":0,"stats":{"Line":0}},{"line":9397,"address":[53816527],"length":1,"stats":{"Line":0}},{"line":9400,"address":[],"length":0,"stats":{"Line":0}},{"line":9401,"address":[],"length":0,"stats":{"Line":0}},{"line":9402,"address":[],"length":0,"stats":{"Line":0}},{"line":9404,"address":[54587790],"length":1,"stats":{"Line":0}},{"line":9405,"address":[54776996],"length":1,"stats":{"Line":0}},{"line":9406,"address":[54837173],"length":1,"stats":{"Line":0}},{"line":9407,"address":[53816166],"length":1,"stats":{"Line":0}},{"line":9410,"address":[],"length":0,"stats":{"Line":0}},{"line":9411,"address":[54648609],"length":1,"stats":{"Line":0}},{"line":9413,"address":[],"length":0,"stats":{"Line":0}},{"line":9415,"address":[53755816],"length":1,"stats":{"Line":0}},{"line":9417,"address":[],"length":0,"stats":{"Line":0}},{"line":9418,"address":[],"length":0,"stats":{"Line":5}},{"line":9419,"address":[56312786],"length":1,"stats":{"Line":5}},{"line":9420,"address":[53816133,53815146,53814742],"length":1,"stats":{"Line":0}},{"line":9421,"address":[],"length":0,"stats":{"Line":0}},{"line":9422,"address":[56388340],"length":1,"stats":{"Line":0}},{"line":9423,"address":[],"length":0,"stats":{"Line":0}},{"line":9424,"address":[53815259],"length":1,"stats":{"Line":0}},{"line":9431,"address":[54647590],"length":1,"stats":{"Line":0}},{"line":9432,"address":[54836533],"length":1,"stats":{"Line":0}},{"line":9433,"address":[],"length":0,"stats":{"Line":0}},{"line":9434,"address":[53815557],"length":1,"stats":{"Line":0}},{"line":9436,"address":[54647744],"length":1,"stats":{"Line":0}},{"line":9437,"address":[],"length":0,"stats":{"Line":0}},{"line":9440,"address":[54647843],"length":1,"stats":{"Line":0}},{"line":9442,"address":[54647861],"length":1,"stats":{"Line":0}},{"line":9443,"address":[],"length":0,"stats":{"Line":0}},{"line":9444,"address":[54647889],"length":1,"stats":{"Line":0}},{"line":9449,"address":[],"length":0,"stats":{"Line":0}},{"line":9450,"address":[],"length":0,"stats":{"Line":0}},{"line":9451,"address":[54836909],"length":1,"stats":{"Line":0}},{"line":9453,"address":[],"length":0,"stats":{"Line":0}},{"line":9454,"address":[54648137],"length":1,"stats":{"Line":0}},{"line":9457,"address":[54648235],"length":1,"stats":{"Line":0}},{"line":9458,"address":[53814722],"length":1,"stats":{"Line":0}},{"line":9460,"address":[53814785,53814930],"length":1,"stats":{"Line":0}},{"line":9461,"address":[53815128],"length":1,"stats":{"Line":0}},{"line":9463,"address":[56387932],"length":1,"stats":{"Line":0}},{"line":9464,"address":[],"length":0,"stats":{"Line":0}},{"line":9468,"address":[54587889],"length":1,"stats":{"Line":0}},{"line":9470,"address":[53813772,53755882],"length":1,"stats":{"Line":0}},{"line":9471,"address":[54834806],"length":1,"stats":{"Line":0}},{"line":9472,"address":[],"length":0,"stats":{"Line":0}},{"line":9475,"address":[54646015],"length":1,"stats":{"Line":0}},{"line":9476,"address":[53814132],"length":1,"stats":{"Line":0}},{"line":9477,"address":[56387510,56387472],"length":1,"stats":{"Line":0}},{"line":9478,"address":[54646540,54646495],"length":1,"stats":{"Line":0}},{"line":9480,"address":[54835385],"length":1,"stats":{"Line":0}},{"line":9482,"address":[56387780],"length":1,"stats":{"Line":0}},{"line":9484,"address":[56329212],"length":1,"stats":{"Line":0}},{"line":9486,"address":[54777193],"length":1,"stats":{"Line":0}},{"line":9487,"address":[53813457],"length":1,"stats":{"Line":0}},{"line":9488,"address":[],"length":0,"stats":{"Line":0}},{"line":9491,"address":[54645668,54645523],"length":1,"stats":{"Line":0}},{"line":9492,"address":[56386861],"length":1,"stats":{"Line":0}},{"line":9494,"address":[54777162],"length":1,"stats":{"Line":0}},{"line":9496,"address":[56329367],"length":1,"stats":{"Line":0}},{"line":9497,"address":[],"length":0,"stats":{"Line":0}},{"line":9498,"address":[54834060],"length":1,"stats":{"Line":0}},{"line":9501,"address":[],"length":0,"stats":{"Line":0}},{"line":9502,"address":[56386502],"length":1,"stats":{"Line":0}},{"line":9504,"address":[54777224],"length":1,"stats":{"Line":0}},{"line":9506,"address":[54588180],"length":1,"stats":{"Line":0}},{"line":9507,"address":[],"length":0,"stats":{"Line":0}},{"line":9508,"address":[56385563],"length":1,"stats":{"Line":0}},{"line":9511,"address":[],"length":0,"stats":{"Line":0}},{"line":9512,"address":[],"length":0,"stats":{"Line":0}},{"line":9513,"address":[56386143],"length":1,"stats":{"Line":0}},{"line":9515,"address":[],"length":0,"stats":{"Line":0}},{"line":9517,"address":[56329491],"length":1,"stats":{"Line":0}},{"line":9518,"address":[53811868],"length":1,"stats":{"Line":0}},{"line":9519,"address":[53811834],"length":1,"stats":{"Line":0}},{"line":9522,"address":[53811822,53811967],"length":1,"stats":{"Line":0}},{"line":9523,"address":[54644285],"length":1,"stats":{"Line":0}},{"line":9524,"address":[53812418],"length":1,"stats":{"Line":0}},{"line":9526,"address":[56329522,56329460],"length":1,"stats":{"Line":0}},{"line":9528,"address":[53810715,53756192],"length":1,"stats":{"Line":0}},{"line":9529,"address":[53810725],"length":1,"stats":{"Line":0}},{"line":9530,"address":[],"length":0,"stats":{"Line":0}},{"line":9531,"address":[],"length":0,"stats":{"Line":0}},{"line":9534,"address":[53810950],"length":1,"stats":{"Line":0}},{"line":9535,"address":[],"length":0,"stats":{"Line":0}},{"line":9536,"address":[56384575,56384537],"length":1,"stats":{"Line":0}},{"line":9537,"address":[54832439,54832484],"length":1,"stats":{"Line":0}},{"line":9539,"address":[54643554],"length":1,"stats":{"Line":0}},{"line":9541,"address":[53811678],"length":1,"stats":{"Line":0}},{"line":9543,"address":[54588335],"length":1,"stats":{"Line":0}},{"line":9545,"address":[],"length":0,"stats":{"Line":0}},{"line":9546,"address":[56383527],"length":1,"stats":{"Line":0}},{"line":9547,"address":[54642478],"length":1,"stats":{"Line":0}},{"line":9550,"address":[56383626,56383481],"length":1,"stats":{"Line":0}},{"line":9551,"address":[56383822],"length":1,"stats":{"Line":0}},{"line":9553,"address":[54588372],"length":1,"stats":{"Line":0}},{"line":9555,"address":[],"length":0,"stats":{"Line":0}},{"line":9556,"address":[56383168],"length":1,"stats":{"Line":0}},{"line":9557,"address":[],"length":0,"stats":{"Line":0}},{"line":9560,"address":[54642250,54642105],"length":1,"stats":{"Line":0}},{"line":9561,"address":[56383463],"length":1,"stats":{"Line":0}},{"line":9563,"address":[56329683],"length":1,"stats":{"Line":0}},{"line":9565,"address":[53756415],"length":1,"stats":{"Line":0}},{"line":9566,"address":[54830860],"length":1,"stats":{"Line":0}},{"line":9567,"address":[54830826],"length":1,"stats":{"Line":0}},{"line":9570,"address":[],"length":0,"stats":{"Line":0}},{"line":9572,"address":[53756446,53756384],"length":1,"stats":{"Line":0}},{"line":9575,"address":[54760686],"length":1,"stats":{"Line":5}},{"line":9576,"address":[],"length":0,"stats":{"Line":0}},{"line":9579,"address":[],"length":0,"stats":{"Line":0}},{"line":9581,"address":[54588703],"length":1,"stats":{"Line":0}},{"line":9582,"address":[54829151],"length":1,"stats":{"Line":0}},{"line":9583,"address":[53808080],"length":1,"stats":{"Line":0}},{"line":9586,"address":[56381362,56381217],"length":1,"stats":{"Line":0}},{"line":9587,"address":[54829454],"length":1,"stats":{"Line":0}},{"line":9588,"address":[],"length":0,"stats":{"Line":0}},{"line":9590,"address":[54641021],"length":1,"stats":{"Line":0}},{"line":9591,"address":[56382221],"length":1,"stats":{"Line":0}},{"line":9592,"address":[],"length":0,"stats":{"Line":0}},{"line":9593,"address":[56382559],"length":1,"stats":{"Line":0}},{"line":9594,"address":[],"length":0,"stats":{"Line":0}},{"line":9595,"address":[],"length":0,"stats":{"Line":0}},{"line":9597,"address":[53809524],"length":1,"stats":{"Line":0}},{"line":9598,"address":[],"length":0,"stats":{"Line":0}},{"line":9599,"address":[54641643],"length":1,"stats":{"Line":0}},{"line":9601,"address":[54830634],"length":1,"stats":{"Line":0}},{"line":9602,"address":[53809687],"length":1,"stats":{"Line":0}},{"line":9603,"address":[],"length":0,"stats":{"Line":0}},{"line":9604,"address":[54830716],"length":1,"stats":{"Line":0}},{"line":9606,"address":[53809779],"length":1,"stats":{"Line":0}},{"line":9608,"address":[54777871],"length":1,"stats":{"Line":0}},{"line":9610,"address":[54588802],"length":1,"stats":{"Line":0}},{"line":9611,"address":[54638460],"length":1,"stats":{"Line":0}},{"line":9612,"address":[56379483],"length":1,"stats":{"Line":0}},{"line":9615,"address":[54827504,54827359],"length":1,"stats":{"Line":0}},{"line":9616,"address":[],"length":0,"stats":{"Line":0}},{"line":9617,"address":[56380055],"length":1,"stats":{"Line":0}},{"line":9619,"address":[54828194],"length":1,"stats":{"Line":0}},{"line":9620,"address":[54828363],"length":1,"stats":{"Line":0}},{"line":9621,"address":[53807485],"length":1,"stats":{"Line":0}},{"line":9622,"address":[],"length":0,"stats":{"Line":0}},{"line":9623,"address":[],"length":0,"stats":{"Line":0}},{"line":9624,"address":[],"length":0,"stats":{"Line":0}},{"line":9626,"address":[],"length":0,"stats":{"Line":0}},{"line":9627,"address":[],"length":0,"stats":{"Line":0}},{"line":9628,"address":[56380915],"length":1,"stats":{"Line":0}},{"line":9631,"address":[53807857],"length":1,"stats":{"Line":0}},{"line":9632,"address":[],"length":0,"stats":{"Line":0}},{"line":9634,"address":[],"length":0,"stats":{"Line":0}},{"line":9635,"address":[],"length":0,"stats":{"Line":0}},{"line":9636,"address":[],"length":0,"stats":{"Line":0}},{"line":9640,"address":[54640066],"length":1,"stats":{"Line":0}},{"line":9641,"address":[],"length":0,"stats":{"Line":0}},{"line":9642,"address":[],"length":0,"stats":{"Line":0}},{"line":9645,"address":[56381199],"length":1,"stats":{"Line":0}},{"line":9647,"address":[54777908],"length":1,"stats":{"Line":0}},{"line":9649,"address":[],"length":0,"stats":{"Line":0}},{"line":9650,"address":[56379380],"length":1,"stats":{"Line":0}},{"line":9651,"address":[],"length":0,"stats":{"Line":0}},{"line":9655,"address":[54638253],"length":1,"stats":{"Line":0}},{"line":9657,"address":[54777970,54778032],"length":1,"stats":{"Line":0}},{"line":9659,"address":[54588926],"length":1,"stats":{"Line":0}},{"line":9660,"address":[56379160],"length":1,"stats":{"Line":0}},{"line":9661,"address":[54827014],"length":1,"stats":{"Line":0}},{"line":9665,"address":[54827155,54827002],"length":1,"stats":{"Line":0}},{"line":9667,"address":[56330206],"length":1,"stats":{"Line":0}},{"line":9669,"address":[53756913],"length":1,"stats":{"Line":0}},{"line":9670,"address":[53805481],"length":1,"stats":{"Line":0}},{"line":9671,"address":[54826508],"length":1,"stats":{"Line":0}},{"line":9674,"address":[56378608,56378753],"length":1,"stats":{"Line":0}},{"line":9676,"address":[],"length":0,"stats":{"Line":0}},{"line":9677,"address":[54826958],"length":1,"stats":{"Line":0}},{"line":9679,"address":[54778193],"length":1,"stats":{"Line":0}},{"line":9681,"address":[54589124],"length":1,"stats":{"Line":0}},{"line":9682,"address":[56378458],"length":1,"stats":{"Line":0}},{"line":9683,"address":[],"length":0,"stats":{"Line":0}},{"line":9687,"address":[],"length":0,"stats":{"Line":0}},{"line":9689,"address":[53757043],"length":1,"stats":{"Line":0}},{"line":9691,"address":[],"length":0,"stats":{"Line":0}},{"line":9692,"address":[54826150],"length":1,"stats":{"Line":0}},{"line":9693,"address":[54637167],"length":1,"stats":{"Line":0}},{"line":9696,"address":[54637308,54637155],"length":1,"stats":{"Line":0}},{"line":9698,"address":[53757142],"length":1,"stats":{"Line":0}},{"line":9700,"address":[56330571],"length":1,"stats":{"Line":0}},{"line":9701,"address":[],"length":0,"stats":{"Line":0}},{"line":9702,"address":[54825091],"length":1,"stats":{"Line":0}},{"line":9705,"address":[54636120,54636265],"length":1,"stats":{"Line":0}},{"line":9706,"address":[54825428],"length":1,"stats":{"Line":0}},{"line":9707,"address":[54636724],"length":1,"stats":{"Line":0}},{"line":9708,"address":[54825848],"length":1,"stats":{"Line":0}},{"line":9709,"address":[54826001],"length":1,"stats":{"Line":0}},{"line":9710,"address":[],"length":0,"stats":{"Line":0}},{"line":9711,"address":[56378120],"length":1,"stats":{"Line":0}},{"line":9713,"address":[],"length":0,"stats":{"Line":0}},{"line":9715,"address":[54778490],"length":1,"stats":{"Line":0}},{"line":9717,"address":[54589421],"length":1,"stats":{"Line":0}},{"line":9718,"address":[53803693],"length":1,"stats":{"Line":0}},{"line":9719,"address":[56376844],"length":1,"stats":{"Line":0}},{"line":9722,"address":[],"length":0,"stats":{"Line":0}},{"line":9723,"address":[],"length":0,"stats":{"Line":0}},{"line":9725,"address":[54589452],"length":1,"stats":{"Line":0}},{"line":9727,"address":[56330769],"length":1,"stats":{"Line":0}},{"line":9728,"address":[53803497],"length":1,"stats":{"Line":0}},{"line":9729,"address":[53803463],"length":1,"stats":{"Line":0}},{"line":9732,"address":[54635563,54635716],"length":1,"stats":{"Line":0}},{"line":9734,"address":[56330800],"length":1,"stats":{"Line":0}},{"line":9736,"address":[53757515],"length":1,"stats":{"Line":0}},{"line":9737,"address":[],"length":0,"stats":{"Line":0}},{"line":9738,"address":[53803300],"length":1,"stats":{"Line":0}},{"line":9741,"address":[54824506],"length":1,"stats":{"Line":0}},{"line":9743,"address":[54589588,54589662,54589745],"length":1,"stats":{"Line":0}},{"line":9745,"address":[56330941],"length":1,"stats":{"Line":0}},{"line":9747,"address":[56331548],"length":1,"stats":{"Line":0}},{"line":9748,"address":[],"length":0,"stats":{"Line":0}},{"line":9749,"address":[],"length":0,"stats":{"Line":0}},{"line":9750,"address":[],"length":0,"stats":{"Line":0}},{"line":9751,"address":[],"length":0,"stats":{"Line":0}},{"line":9752,"address":[],"length":0,"stats":{"Line":0}},{"line":9753,"address":[],"length":0,"stats":{"Line":0}},{"line":9754,"address":[],"length":0,"stats":{"Line":0}},{"line":9755,"address":[],"length":0,"stats":{"Line":0}},{"line":9756,"address":[],"length":0,"stats":{"Line":0}},{"line":9757,"address":[],"length":0,"stats":{"Line":0}},{"line":9758,"address":[],"length":0,"stats":{"Line":0}},{"line":9759,"address":[],"length":0,"stats":{"Line":0}},{"line":9760,"address":[],"length":0,"stats":{"Line":0}},{"line":9761,"address":[],"length":0,"stats":{"Line":0}},{"line":9762,"address":[],"length":0,"stats":{"Line":0}},{"line":9764,"address":[56331217],"length":1,"stats":{"Line":0}},{"line":9766,"address":[54590587,54590686],"length":1,"stats":{"Line":0}},{"line":9767,"address":[],"length":0,"stats":{"Line":0}},{"line":9769,"address":[53758543],"length":1,"stats":{"Line":0}},{"line":9770,"address":[],"length":0,"stats":{"Line":0}},{"line":9771,"address":[],"length":0,"stats":{"Line":0}},{"line":9772,"address":[],"length":0,"stats":{"Line":0}},{"line":9775,"address":[54635055,54634806],"length":1,"stats":{"Line":0}},{"line":9776,"address":[54824208],"length":1,"stats":{"Line":0}},{"line":9777,"address":[56376449],"length":1,"stats":{"Line":0}},{"line":9779,"address":[53758812],"length":1,"stats":{"Line":0}},{"line":9781,"address":[54590992],"length":1,"stats":{"Line":0}},{"line":9782,"address":[54823458],"length":1,"stats":{"Line":0}},{"line":9783,"address":[56375536],"length":1,"stats":{"Line":0}},{"line":9786,"address":[],"length":0,"stats":{"Line":0}},{"line":9787,"address":[54823753],"length":1,"stats":{"Line":0}},{"line":9789,"address":[],"length":0,"stats":{"Line":0}},{"line":9791,"address":[],"length":0,"stats":{"Line":0}},{"line":9793,"address":[54780196,54780279,54780341],"length":1,"stats":{"Line":0}},{"line":9795,"address":[54591174],"length":1,"stats":{"Line":0}},{"line":9796,"address":[53802242],"length":1,"stats":{"Line":0}},{"line":9797,"address":[54823287],"length":1,"stats":{"Line":0}},{"line":9800,"address":[56375343],"length":1,"stats":{"Line":0}},{"line":9801,"address":[],"length":0,"stats":{"Line":0}},{"line":9803,"address":[54780477,54780378],"length":1,"stats":{"Line":0}},{"line":9805,"address":[54591310],"length":1,"stats":{"Line":0}},{"line":9806,"address":[56374435],"length":1,"stats":{"Line":0}},{"line":9807,"address":[54633310],"length":1,"stats":{"Line":0}},{"line":9810,"address":[],"length":0,"stats":{"Line":0}},{"line":9811,"address":[56374722],"length":1,"stats":{"Line":0}},{"line":9812,"address":[54633788],"length":1,"stats":{"Line":0}},{"line":9813,"address":[],"length":0,"stats":{"Line":0}},{"line":9814,"address":[53801783],"length":1,"stats":{"Line":0}},{"line":9815,"address":[],"length":0,"stats":{"Line":0}},{"line":9816,"address":[54633902],"length":1,"stats":{"Line":0}},{"line":9818,"address":[54822967],"length":1,"stats":{"Line":0}},{"line":9819,"address":[],"length":0,"stats":{"Line":0}},{"line":9820,"address":[54822974],"length":1,"stats":{"Line":0}},{"line":9822,"address":[54823051],"length":1,"stats":{"Line":0}},{"line":9823,"address":[],"length":0,"stats":{"Line":0}},{"line":9824,"address":[53801975],"length":1,"stats":{"Line":0}},{"line":9826,"address":[53802042],"length":1,"stats":{"Line":0}},{"line":9827,"address":[],"length":0,"stats":{"Line":0}},{"line":9828,"address":[54634164],"length":1,"stats":{"Line":0}},{"line":9830,"address":[53802134],"length":1,"stats":{"Line":0}},{"line":9832,"address":[53759303],"length":1,"stats":{"Line":0}},{"line":9834,"address":[54780619],"length":1,"stats":{"Line":0}},{"line":9835,"address":[54821650],"length":1,"stats":{"Line":0}},{"line":9836,"address":[56373728],"length":1,"stats":{"Line":0}},{"line":9839,"address":[54632764,54632619],"length":1,"stats":{"Line":0}},{"line":9841,"address":[54632954],"length":1,"stats":{"Line":0}},{"line":9842,"address":[54822090],"length":1,"stats":{"Line":0}},{"line":9843,"address":[54633156],"length":1,"stats":{"Line":0}},{"line":9844,"address":[],"length":0,"stats":{"Line":0}},{"line":9845,"address":[54822144],"length":1,"stats":{"Line":0}},{"line":9848,"address":[56374325],"length":1,"stats":{"Line":0}},{"line":9849,"address":[54822259],"length":1,"stats":{"Line":0}},{"line":9851,"address":[54780650],"length":1,"stats":{"Line":0}},{"line":9853,"address":[54780718],"length":1,"stats":{"Line":0}},{"line":9854,"address":[53800416],"length":1,"stats":{"Line":0}},{"line":9855,"address":[54821479],"length":1,"stats":{"Line":0}},{"line":9858,"address":[54821423],"length":1,"stats":{"Line":0}},{"line":9859,"address":[56373581],"length":1,"stats":{"Line":0}},{"line":9861,"address":[56332799,56332861],"length":1,"stats":{"Line":0}},{"line":9863,"address":[],"length":0,"stats":{"Line":0}},{"line":9864,"address":[],"length":0,"stats":{"Line":0}},{"line":9865,"address":[54820387],"length":1,"stats":{"Line":0}},{"line":9868,"address":[],"length":0,"stats":{"Line":0}},{"line":9869,"address":[53799601],"length":1,"stats":{"Line":0}},{"line":9870,"address":[54631868],"length":1,"stats":{"Line":0}},{"line":9871,"address":[],"length":0,"stats":{"Line":0}},{"line":9872,"address":[],"length":0,"stats":{"Line":0}},{"line":9873,"address":[54820922],"length":1,"stats":{"Line":0}},{"line":9875,"address":[54632024],"length":1,"stats":{"Line":0}},{"line":9876,"address":[],"length":0,"stats":{"Line":0}},{"line":9877,"address":[54632031],"length":1,"stats":{"Line":0}},{"line":9879,"address":[],"length":0,"stats":{"Line":0}},{"line":9880,"address":[54821154],"length":1,"stats":{"Line":0}},{"line":9881,"address":[53800108],"length":1,"stats":{"Line":0}},{"line":9882,"address":[],"length":0,"stats":{"Line":0}},{"line":9883,"address":[56373328],"length":1,"stats":{"Line":0}},{"line":9886,"address":[56373423],"length":1,"stats":{"Line":0}},{"line":9887,"address":[],"length":0,"stats":{"Line":0}},{"line":9888,"address":[54821318],"length":1,"stats":{"Line":0}},{"line":9891,"address":[56373517],"length":1,"stats":{"Line":0}},{"line":9893,"address":[54780811],"length":1,"stats":{"Line":0}},{"line":9895,"address":[56332991],"length":1,"stats":{"Line":0}},{"line":9896,"address":[54631228],"length":1,"stats":{"Line":0}},{"line":9897,"address":[53799082],"length":1,"stats":{"Line":0}},{"line":9900,"address":[53799070,53799223],"length":1,"stats":{"Line":0}},{"line":9902,"address":[53759662],"length":1,"stats":{"Line":0}},{"line":9904,"address":[54591842],"length":1,"stats":{"Line":0}},{"line":9905,"address":[54631091],"length":1,"stats":{"Line":0}},{"line":9906,"address":[53798945],"length":1,"stats":{"Line":0}},{"line":9909,"address":[56372144],"length":1,"stats":{"Line":0}},{"line":9911,"address":[53759860,53759761],"length":1,"stats":{"Line":0}},{"line":9913,"address":[56333189],"length":1,"stats":{"Line":0}},{"line":9914,"address":[],"length":0,"stats":{"Line":0}},{"line":9915,"address":[56371431],"length":1,"stats":{"Line":0}},{"line":9918,"address":[54630302,54630447],"length":1,"stats":{"Line":0}},{"line":9919,"address":[54630637],"length":1,"stats":{"Line":0}},{"line":9920,"address":[53798680],"length":1,"stats":{"Line":0}},{"line":9921,"address":[54630839],"length":1,"stats":{"Line":0}},{"line":9922,"address":[],"length":0,"stats":{"Line":0}},{"line":9923,"address":[56371959],"length":1,"stats":{"Line":0}},{"line":9925,"address":[56372028],"length":1,"stats":{"Line":0}},{"line":9926,"address":[],"length":0,"stats":{"Line":0}},{"line":9927,"address":[54819926],"length":1,"stats":{"Line":0}},{"line":9929,"address":[54631009],"length":1,"stats":{"Line":0}},{"line":9931,"address":[],"length":0,"stats":{"Line":0}},{"line":9933,"address":[],"length":0,"stats":{"Line":0}},{"line":9934,"address":[],"length":0,"stats":{"Line":0}},{"line":9935,"address":[53798006],"length":1,"stats":{"Line":0}},{"line":9938,"address":[],"length":0,"stats":{"Line":0}},{"line":9940,"address":[56333482,56333356],"length":1,"stats":{"Line":0}},{"line":9942,"address":[54592168,54630016],"length":1,"stats":{"Line":0}},{"line":9943,"address":[53797906],"length":1,"stats":{"Line":0}},{"line":9945,"address":[53797892],"length":1,"stats":{"Line":0}},{"line":9947,"address":[],"length":0,"stats":{"Line":0}},{"line":9948,"address":[53797976],"length":1,"stats":{"Line":0}},{"line":9950,"address":[56333556],"length":1,"stats":{"Line":0}},{"line":9952,"address":[],"length":0,"stats":{"Line":0}},{"line":9953,"address":[],"length":0,"stats":{"Line":0}},{"line":9954,"address":[],"length":0,"stats":{"Line":0}},{"line":9957,"address":[54629830],"length":1,"stats":{"Line":0}},{"line":9958,"address":[53797765],"length":1,"stats":{"Line":0}},{"line":9960,"address":[56333593],"length":1,"stats":{"Line":0}},{"line":9962,"address":[],"length":0,"stats":{"Line":0}},{"line":9963,"address":[54817861],"length":1,"stats":{"Line":0}},{"line":9964,"address":[54817827],"length":1,"stats":{"Line":0}},{"line":9967,"address":[53796688,53796833],"length":1,"stats":{"Line":0}},{"line":9968,"address":[56370276],"length":1,"stats":{"Line":0}},{"line":9969,"address":[56370527],"length":1,"stats":{"Line":0}},{"line":9970,"address":[],"length":0,"stats":{"Line":0}},{"line":9971,"address":[54629730],"length":1,"stats":{"Line":0}},{"line":9972,"address":[],"length":0,"stats":{"Line":0}},{"line":9974,"address":[54781543,54781605],"length":1,"stats":{"Line":0}},{"line":9976,"address":[],"length":0,"stats":{"Line":0}},{"line":9977,"address":[54817665],"length":1,"stats":{"Line":0}},{"line":9978,"address":[54817631],"length":1,"stats":{"Line":0}},{"line":9981,"address":[54817619,54817772],"length":1,"stats":{"Line":0}},{"line":9983,"address":[56333779],"length":1,"stats":{"Line":0}},{"line":9985,"address":[54592599],"length":1,"stats":{"Line":0}},{"line":9987,"address":[],"length":0,"stats":{"Line":0}},{"line":9989,"address":[],"length":0,"stats":{"Line":0}},{"line":9991,"address":[53760659],"length":1,"stats":{"Line":0}},{"line":9993,"address":[],"length":0,"stats":{"Line":0}},{"line":9994,"address":[53796401],"length":1,"stats":{"Line":0}},{"line":9995,"address":[56369606],"length":1,"stats":{"Line":0}},{"line":9998,"address":[],"length":0,"stats":{"Line":0}},{"line":10000,"address":[54782006,54782105],"length":1,"stats":{"Line":0}},{"line":10002,"address":[53760826],"length":1,"stats":{"Line":0}},{"line":10003,"address":[56368301],"length":1,"stats":{"Line":0}},{"line":10004,"address":[],"length":0,"stats":{"Line":0}},{"line":10005,"address":[],"length":0,"stats":{"Line":0}},{"line":10008,"address":[56368534,56368285],"length":1,"stats":{"Line":0}},{"line":10009,"address":[54627577],"length":1,"stats":{"Line":0}},{"line":10010,"address":[],"length":0,"stats":{"Line":0}},{"line":10011,"address":[56369002,56368910],"length":1,"stats":{"Line":0}},{"line":10012,"address":[54816882],"length":1,"stats":{"Line":0}},{"line":10013,"address":[],"length":0,"stats":{"Line":0}},{"line":10014,"address":[53795759],"length":1,"stats":{"Line":0}},{"line":10016,"address":[54627861],"length":1,"stats":{"Line":0}},{"line":10018,"address":[54627887],"length":1,"stats":{"Line":0}},{"line":10019,"address":[],"length":0,"stats":{"Line":0}},{"line":10020,"address":[54816932],"length":1,"stats":{"Line":0}},{"line":10022,"address":[54628385],"length":1,"stats":{"Line":0}},{"line":10023,"address":[],"length":0,"stats":{"Line":0}},{"line":10024,"address":[56369467,56369186],"length":1,"stats":{"Line":0}},{"line":10026,"address":[54817446],"length":1,"stats":{"Line":0}},{"line":10028,"address":[54782142,54782241],"length":1,"stats":{"Line":0}},{"line":10030,"address":[53760962],"length":1,"stats":{"Line":0}},{"line":10031,"address":[],"length":0,"stats":{"Line":0}},{"line":10032,"address":[],"length":0,"stats":{"Line":0}},{"line":10035,"address":[],"length":0,"stats":{"Line":0}},{"line":10037,"address":[53761030,53761170],"length":1,"stats":{"Line":0}},{"line":10039,"address":[53761098],"length":1,"stats":{"Line":0}},{"line":10040,"address":[53761144],"length":1,"stats":{"Line":0}},{"line":10042,"address":[54782496,54782616],"length":1,"stats":{"Line":0}},{"line":10044,"address":[56334676],"length":1,"stats":{"Line":0}},{"line":10046,"address":[],"length":0,"stats":{"Line":0}},{"line":10048,"address":[54782766],"length":1,"stats":{"Line":0}},{"line":10050,"address":[54782804],"length":1,"stats":{"Line":0}},{"line":10052,"address":[56334984],"length":1,"stats":{"Line":0}},{"line":10053,"address":[],"length":0,"stats":{"Line":0}},{"line":10054,"address":[53794705],"length":1,"stats":{"Line":0}},{"line":10057,"address":[54815796],"length":1,"stats":{"Line":0}},{"line":10058,"address":[54815842],"length":1,"stats":{"Line":0}},{"line":10060,"address":[],"length":0,"stats":{"Line":0}},{"line":10062,"address":[54593835],"length":1,"stats":{"Line":0}},{"line":10063,"address":[56367817],"length":1,"stats":{"Line":0}},{"line":10064,"address":[54815671],"length":1,"stats":{"Line":0}},{"line":10067,"address":[54626580],"length":1,"stats":{"Line":0}},{"line":10068,"address":[54815661],"length":1,"stats":{"Line":0}},{"line":10070,"address":[56335234,56335114],"length":1,"stats":{"Line":0}},{"line":10072,"address":[53761822],"length":1,"stats":{"Line":0}},{"line":10074,"address":[53761911],"length":1,"stats":{"Line":0}},{"line":10076,"address":[56335339],"length":1,"stats":{"Line":0}},{"line":10077,"address":[56367636],"length":1,"stats":{"Line":0}},{"line":10078,"address":[54626455],"length":1,"stats":{"Line":0}},{"line":10082,"address":[54815454],"length":1,"stats":{"Line":0}},{"line":10084,"address":[54594122,54594060],"length":1,"stats":{"Line":0}},{"line":10086,"address":[56335401],"length":1,"stats":{"Line":0}},{"line":10087,"address":[],"length":0,"stats":{"Line":0}},{"line":10088,"address":[54626294],"length":1,"stats":{"Line":0}},{"line":10091,"address":[53794146],"length":1,"stats":{"Line":0}},{"line":10093,"address":[54594184],"length":1,"stats":{"Line":0}},{"line":10095,"address":[53762140],"length":1,"stats":{"Line":0}},{"line":10097,"address":[],"length":0,"stats":{"Line":0}},{"line":10099,"address":[54594380],"length":1,"stats":{"Line":0}},{"line":10101,"address":[54594517,54594418],"length":1,"stats":{"Line":0}},{"line":10103,"address":[54783622],"length":1,"stats":{"Line":0}},{"line":10104,"address":[56367255],"length":1,"stats":{"Line":0}},{"line":10105,"address":[54626074],"length":1,"stats":{"Line":0}},{"line":10108,"address":[54815097,54815250],"length":1,"stats":{"Line":0}},{"line":10110,"address":[53762442],"length":1,"stats":{"Line":0}},{"line":10112,"address":[54783758],"length":1,"stats":{"Line":0}},{"line":10113,"address":[],"length":0,"stats":{"Line":0}},{"line":10114,"address":[],"length":0,"stats":{"Line":0}},{"line":10117,"address":[],"length":0,"stats":{"Line":0}},{"line":10119,"address":[54783789,54783909],"length":1,"stats":{"Line":0}},{"line":10121,"address":[56335969],"length":1,"stats":{"Line":0}},{"line":10123,"address":[54594810],"length":1,"stats":{"Line":0}},{"line":10125,"address":[],"length":0,"stats":{"Line":0}},{"line":10127,"address":[56336095,56336178],"length":1,"stats":{"Line":0}},{"line":10129,"address":[56336209],"length":1,"stats":{"Line":0}},{"line":10130,"address":[54625716],"length":1,"stats":{"Line":0}},{"line":10131,"address":[56366829],"length":1,"stats":{"Line":0}},{"line":10134,"address":[54625670,54625823],"length":1,"stats":{"Line":0}},{"line":10136,"address":[],"length":0,"stats":{"Line":0}},{"line":10138,"address":[54595060],"length":1,"stats":{"Line":0}},{"line":10139,"address":[53793408],"length":1,"stats":{"Line":0}},{"line":10140,"address":[56366633],"length":1,"stats":{"Line":0}},{"line":10143,"address":[53793362,53793515],"length":1,"stats":{"Line":0}},{"line":10145,"address":[53762979],"length":1,"stats":{"Line":0}},{"line":10147,"address":[54784295],"length":1,"stats":{"Line":0}},{"line":10148,"address":[56366530],"length":1,"stats":{"Line":0}},{"line":10149,"address":[53793237],"length":1,"stats":{"Line":0}},{"line":10152,"address":[54625292],"length":1,"stats":{"Line":0}},{"line":10153,"address":[54625339],"length":1,"stats":{"Line":0}},{"line":10155,"address":[54784326],"length":1,"stats":{"Line":0}},{"line":10157,"address":[],"length":0,"stats":{"Line":0}},{"line":10158,"address":[],"length":0,"stats":{"Line":0}},{"line":10159,"address":[53793055],"length":1,"stats":{"Line":0}},{"line":10162,"address":[56366257],"length":1,"stats":{"Line":0}},{"line":10163,"address":[54814192],"length":1,"stats":{"Line":0}},{"line":10165,"address":[56336537],"length":1,"stats":{"Line":0}},{"line":10167,"address":[54784493],"length":1,"stats":{"Line":0}},{"line":10168,"address":[54625019],"length":1,"stats":{"Line":0}},{"line":10169,"address":[54814020],"length":1,"stats":{"Line":0}},{"line":10172,"address":[56366076],"length":1,"stats":{"Line":0}},{"line":10173,"address":[56366122],"length":1,"stats":{"Line":0}},{"line":10175,"address":[54784524,54784644],"length":1,"stats":{"Line":0}},{"line":10177,"address":[53763344],"length":1,"stats":{"Line":0}},{"line":10179,"address":[],"length":0,"stats":{"Line":0}},{"line":10181,"address":[54784827,54813691],"length":1,"stats":{"Line":0}},{"line":10182,"address":[54624696],"length":1,"stats":{"Line":0}},{"line":10183,"address":[53792550],"length":1,"stats":{"Line":0}},{"line":10186,"address":[],"length":0,"stats":{"Line":0}},{"line":10188,"address":[56365948,56366028],"length":1,"stats":{"Line":0}},{"line":10190,"address":[53792709],"length":1,"stats":{"Line":0}},{"line":10192,"address":[56336970],"length":1,"stats":{"Line":0}},{"line":10194,"address":[56337038],"length":1,"stats":{"Line":0}},{"line":10195,"address":[56365712],"length":1,"stats":{"Line":0}},{"line":10196,"address":[],"length":0,"stats":{"Line":0}},{"line":10199,"address":[],"length":0,"stats":{"Line":0}},{"line":10201,"address":[54784957],"length":1,"stats":{"Line":0}},{"line":10203,"address":[54595889],"length":1,"stats":{"Line":0}},{"line":10204,"address":[56365551],"length":1,"stats":{"Line":0}},{"line":10205,"address":[56365517],"length":1,"stats":{"Line":0}},{"line":10208,"address":[54624334],"length":1,"stats":{"Line":0}},{"line":10210,"address":[56337106,56337168],"length":1,"stats":{"Line":0}},{"line":10212,"address":[54785095],"length":1,"stats":{"Line":0}},{"line":10214,"address":[53763885],"length":1,"stats":{"Line":0}},{"line":10216,"address":[],"length":0,"stats":{"Line":0}},{"line":10218,"address":[54596111],"length":1,"stats":{"Line":0}},{"line":10220,"address":[54596179],"length":1,"stats":{"Line":0}},{"line":10221,"address":[54624184],"length":1,"stats":{"Line":0}},{"line":10222,"address":[53792038],"length":1,"stats":{"Line":0}},{"line":10225,"address":[54813326,54813173],"length":1,"stats":{"Line":0}},{"line":10227,"address":[54596210],"length":1,"stats":{"Line":0}},{"line":10229,"address":[],"length":0,"stats":{"Line":0}},{"line":10231,"address":[54785466],"length":1,"stats":{"Line":0}},{"line":10233,"address":[54785542],"length":1,"stats":{"Line":0}},{"line":10234,"address":[54813084],"length":1,"stats":{"Line":0}},{"line":10236,"address":[56365171,56365242],"length":1,"stats":{"Line":0}},{"line":10238,"address":[53764329],"length":1,"stats":{"Line":0}},{"line":10240,"address":[54785652],"length":1,"stats":{"Line":0}},{"line":10241,"address":[],"length":0,"stats":{"Line":0}},{"line":10243,"address":[53791798,53791869],"length":1,"stats":{"Line":0}},{"line":10245,"address":[54596552],"length":1,"stats":{"Line":0}},{"line":10247,"address":[54596628],"length":1,"stats":{"Line":0}},{"line":10249,"address":[54785800,54785899],"length":1,"stats":{"Line":0}},{"line":10251,"address":[54596734],"length":1,"stats":{"Line":0}},{"line":10252,"address":[],"length":0,"stats":{"Line":0}},{"line":10253,"address":[53791614],"length":1,"stats":{"Line":0}},{"line":10256,"address":[56365014,56364861],"length":1,"stats":{"Line":0}},{"line":10258,"address":[54596802],"length":1,"stats":{"Line":0}},{"line":10260,"address":[54786004],"length":1,"stats":{"Line":0}},{"line":10261,"address":[54812599],"length":1,"stats":{"Line":0}},{"line":10262,"address":[54812565],"length":1,"stats":{"Line":0}},{"line":10266,"address":[54812553,54812706],"length":1,"stats":{"Line":0}},{"line":10268,"address":[],"length":0,"stats":{"Line":0}},{"line":10270,"address":[54596977],"length":1,"stats":{"Line":0}},{"line":10272,"address":[54786149],"length":1,"stats":{"Line":0}},{"line":10274,"address":[53764971],"length":1,"stats":{"Line":0}},{"line":10276,"address":[],"length":0,"stats":{"Line":0}},{"line":10278,"address":[56338449],"length":1,"stats":{"Line":0}},{"line":10279,"address":[],"length":0,"stats":{"Line":0}},{"line":10280,"address":[53791222],"length":1,"stats":{"Line":0}},{"line":10283,"address":[54623475,54623322],"length":1,"stats":{"Line":0}},{"line":10285,"address":[53765122],"length":1,"stats":{"Line":0}},{"line":10287,"address":[54786444],"length":1,"stats":{"Line":0}},{"line":10289,"address":[53765236],"length":1,"stats":{"Line":0}},{"line":10291,"address":[54597416],"length":1,"stats":{"Line":0}},{"line":10292,"address":[54812207],"length":1,"stats":{"Line":0}},{"line":10293,"address":[53791026],"length":1,"stats":{"Line":0}},{"line":10296,"address":[54812161,54812314],"length":1,"stats":{"Line":0}},{"line":10298,"address":[54597447],"length":1,"stats":{"Line":0}},{"line":10300,"address":[56338761],"length":1,"stats":{"Line":0}},{"line":10301,"address":[53790923],"length":1,"stats":{"Line":0}},{"line":10302,"address":[54623001],"length":1,"stats":{"Line":0}},{"line":10305,"address":[54811974],"length":1,"stats":{"Line":0}},{"line":10306,"address":[54622991],"length":1,"stats":{"Line":0}},{"line":10308,"address":[],"length":0,"stats":{"Line":0}},{"line":10310,"address":[54597614],"length":1,"stats":{"Line":0}},{"line":10311,"address":[54786795],"length":1,"stats":{"Line":0}},{"line":10313,"address":[54597807,54597687],"length":1,"stats":{"Line":0}},{"line":10315,"address":[54786889],"length":1,"stats":{"Line":0}},{"line":10317,"address":[],"length":0,"stats":{"Line":0}},{"line":10319,"address":[56339158],"length":1,"stats":{"Line":0}},{"line":10320,"address":[54622789],"length":1,"stats":{"Line":0}},{"line":10321,"address":[54811790],"length":1,"stats":{"Line":0}},{"line":10324,"address":[54811778,54811931],"length":1,"stats":{"Line":0}},{"line":10326,"address":[54597943],"length":1,"stats":{"Line":0}},{"line":10328,"address":[54598011],"length":1,"stats":{"Line":0}},{"line":10330,"address":[54598063],"length":1,"stats":{"Line":0}},{"line":10332,"address":[54787265],"length":1,"stats":{"Line":0}},{"line":10333,"address":[],"length":0,"stats":{"Line":0}},{"line":10335,"address":[56339346],"length":1,"stats":{"Line":0}},{"line":10337,"address":[53766122],"length":1,"stats":{"Line":0}},{"line":10339,"address":[54787420,54787337,54787493],"length":1,"stats":{"Line":0}},{"line":10341,"address":[53766213],"length":1,"stats":{"Line":0}},{"line":10342,"address":[53790511,53790588],"length":1,"stats":{"Line":0}},{"line":10344,"address":[],"length":0,"stats":{"Line":0}},{"line":10346,"address":[56339642],"length":1,"stats":{"Line":0}},{"line":10348,"address":[54787598],"length":1,"stats":{"Line":0}},{"line":10349,"address":[56363620],"length":1,"stats":{"Line":0}},{"line":10350,"address":[],"length":0,"stats":{"Line":0}},{"line":10353,"address":[53790315,53790468],"length":1,"stats":{"Line":0}},{"line":10355,"address":[54598434],"length":1,"stats":{"Line":0}},{"line":10357,"address":[54787660],"length":1,"stats":{"Line":0}},{"line":10358,"address":[54787706],"length":1,"stats":{"Line":0}},{"line":10360,"address":[56339741],"length":1,"stats":{"Line":0}},{"line":10362,"address":[54787763],"length":1,"stats":{"Line":0}},{"line":10363,"address":[56363424],"length":1,"stats":{"Line":0}},{"line":10364,"address":[53790131],"length":1,"stats":{"Line":0}},{"line":10367,"address":[53790272,53790119],"length":1,"stats":{"Line":0}},{"line":10369,"address":[56339844],"length":1,"stats":{"Line":0}},{"line":10371,"address":[54598692],"length":1,"stats":{"Line":0}},{"line":10373,"address":[54787794,54787877],"length":1,"stats":{"Line":0}},{"line":10375,"address":[53766663],"length":1,"stats":{"Line":0}},{"line":10377,"address":[],"length":0,"stats":{"Line":0}},{"line":10379,"address":[54598903],"length":1,"stats":{"Line":0}},{"line":10380,"address":[56363258,56363335],"length":1,"stats":{"Line":0}},{"line":10382,"address":[54811163],"length":1,"stats":{"Line":0}},{"line":10384,"address":[53767011,53766900],"length":1,"stats":{"Line":0}},{"line":10386,"address":[56340332],"length":1,"stats":{"Line":0}},{"line":10387,"address":[53789605,53789674],"length":1,"stats":{"Line":0}},{"line":10388,"address":[56363125],"length":1,"stats":{"Line":0}},{"line":10390,"address":[54621734],"length":1,"stats":{"Line":0}},{"line":10392,"address":[54788328,54788438],"length":1,"stats":{"Line":0}},{"line":10393,"address":[],"length":0,"stats":{"Line":0}},{"line":10395,"address":[53767161],"length":1,"stats":{"Line":0}},{"line":10396,"address":[54810636,54810713],"length":1,"stats":{"Line":0}},{"line":10398,"address":[56362765],"length":1,"stats":{"Line":0}},{"line":10400,"address":[54599423,54599543],"length":1,"stats":{"Line":0}},{"line":10402,"address":[56340733],"length":1,"stats":{"Line":0}},{"line":10404,"address":[56340859,56340979],"length":1,"stats":{"Line":0}},{"line":10406,"address":[54788815],"length":1,"stats":{"Line":0}},{"line":10408,"address":[56341016],"length":1,"stats":{"Line":0}},{"line":10410,"address":[53767730],"length":1,"stats":{"Line":0}},{"line":10412,"address":[54599811,54599894,54599977],"length":1,"stats":{"Line":0}},{"line":10414,"address":[54789055],"length":1,"stats":{"Line":0}},{"line":10416,"address":[56341293,56341403],"length":1,"stats":{"Line":0}},{"line":10418,"address":[53768015],"length":1,"stats":{"Line":0}},{"line":10419,"address":[],"length":0,"stats":{"Line":0}},{"line":10421,"address":[],"length":0,"stats":{"Line":0}},{"line":10423,"address":[54600236,54600377],"length":1,"stats":{"Line":0}},{"line":10425,"address":[53768192],"length":1,"stats":{"Line":0}},{"line":10426,"address":[54600351],"length":1,"stats":{"Line":0}},{"line":10428,"address":[54600414],"length":1,"stats":{"Line":0}},{"line":10430,"address":[56341723],"length":1,"stats":{"Line":0}},{"line":10432,"address":[],"length":0,"stats":{"Line":0}},{"line":10434,"address":[],"length":0,"stats":{"Line":0}},{"line":10435,"address":[56362508,56362585],"length":1,"stats":{"Line":0}},{"line":10437,"address":[53789262],"length":1,"stats":{"Line":0}},{"line":10439,"address":[],"length":0,"stats":{"Line":0}},{"line":10441,"address":[53768572],"length":1,"stats":{"Line":0}},{"line":10443,"address":[],"length":0,"stats":{"Line":0}},{"line":10445,"address":[53768678],"length":1,"stats":{"Line":0}},{"line":10447,"address":[53768730],"length":1,"stats":{"Line":0}},{"line":10449,"address":[54600910],"length":1,"stats":{"Line":0}},{"line":10451,"address":[56342202],"length":1,"stats":{"Line":0}},{"line":10453,"address":[54601038],"length":1,"stats":{"Line":0}},{"line":10455,"address":[54600999],"length":1,"stats":{"Line":0}},{"line":10457,"address":[56342355],"length":1,"stats":{"Line":0}},{"line":10459,"address":[54790204],"length":1,"stats":{"Line":0}},{"line":10461,"address":[],"length":0,"stats":{"Line":0}},{"line":10463,"address":[54601153],"length":1,"stats":{"Line":0}},{"line":10465,"address":[54601267],"length":1,"stats":{"Line":0}},{"line":10467,"address":[54790364],"length":1,"stats":{"Line":0}},{"line":10469,"address":[],"length":0,"stats":{"Line":0}},{"line":10471,"address":[56342559],"length":1,"stats":{"Line":0}},{"line":10473,"address":[54790569],"length":1,"stats":{"Line":0}},{"line":10475,"address":[54790607,54790530],"length":1,"stats":{"Line":0}},{"line":10477,"address":[],"length":0,"stats":{"Line":0}},{"line":10478,"address":[54601557],"length":1,"stats":{"Line":0}},{"line":10480,"address":[],"length":0,"stats":{"Line":0}},{"line":10482,"address":[53769539],"length":1,"stats":{"Line":0}},{"line":10484,"address":[56342943,56342860],"length":1,"stats":{"Line":0}},{"line":10486,"address":[54601734],"length":1,"stats":{"Line":0}},{"line":10488,"address":[54601786],"length":1,"stats":{"Line":0}},{"line":10490,"address":[],"length":0,"stats":{"Line":0}},{"line":10492,"address":[],"length":0,"stats":{"Line":0}},{"line":10494,"address":[53769862],"length":1,"stats":{"Line":0}},{"line":10496,"address":[56343266],"length":1,"stats":{"Line":0}},{"line":10498,"address":[],"length":0,"stats":{"Line":0}},{"line":10500,"address":[54791274,54791191],"length":1,"stats":{"Line":0}},{"line":10502,"address":[54602177],"length":1,"stats":{"Line":0}},{"line":10504,"address":[],"length":0,"stats":{"Line":0}},{"line":10506,"address":[56343545],"length":1,"stats":{"Line":0}},{"line":10507,"address":[54621237,54621314],"length":1,"stats":{"Line":0}},{"line":10509,"address":[53789142],"length":1,"stats":{"Line":0}},{"line":10511,"address":[56343579],"length":1,"stats":{"Line":0}},{"line":10513,"address":[],"length":0,"stats":{"Line":0}},{"line":10515,"address":[56343699],"length":1,"stats":{"Line":0}},{"line":10517,"address":[54791655],"length":1,"stats":{"Line":0}},{"line":10519,"address":[56343819],"length":1,"stats":{"Line":0}},{"line":10521,"address":[54791775],"length":1,"stats":{"Line":0}},{"line":10523,"address":[54602700,54602820],"length":1,"stats":{"Line":0}},{"line":10525,"address":[54791895],"length":1,"stats":{"Line":0}},{"line":10527,"address":[],"length":0,"stats":{"Line":0}},{"line":10529,"address":[],"length":0,"stats":{"Line":0}},{"line":10530,"address":[54810233,54810156],"length":1,"stats":{"Line":0}},{"line":10532,"address":[],"length":0,"stats":{"Line":0}},{"line":10534,"address":[54602968],"length":1,"stats":{"Line":0}},{"line":10536,"address":[56344274],"length":1,"stats":{"Line":0}},{"line":10538,"address":[56344326],"length":1,"stats":{"Line":0}},{"line":10540,"address":[56344394],"length":1,"stats":{"Line":0}},{"line":10542,"address":[54603208],"length":1,"stats":{"Line":0}},{"line":10544,"address":[54792410],"length":1,"stats":{"Line":0}},{"line":10546,"address":[54792445],"length":1,"stats":{"Line":0}},{"line":10548,"address":[],"length":0,"stats":{"Line":0}},{"line":10550,"address":[54603439],"length":1,"stats":{"Line":0}},{"line":10552,"address":[],"length":0,"stats":{"Line":0}},{"line":10554,"address":[],"length":0,"stats":{"Line":0}},{"line":10556,"address":[],"length":0,"stats":{"Line":0}},{"line":10558,"address":[53771567],"length":1,"stats":{"Line":0}},{"line":10560,"address":[53771635],"length":1,"stats":{"Line":0}},{"line":10562,"address":[],"length":0,"stats":{"Line":0}},{"line":10564,"address":[54603867],"length":1,"stats":{"Line":0}},{"line":10566,"address":[56345194,56345314],"length":1,"stats":{"Line":0}},{"line":10568,"address":[54793150],"length":1,"stats":{"Line":0}},{"line":10570,"address":[56345351],"length":1,"stats":{"Line":0}},{"line":10572,"address":[56345427],"length":1,"stats":{"Line":0}},{"line":10574,"address":[54604227],"length":1,"stats":{"Line":0}},{"line":10576,"address":[53772191],"length":1,"stats":{"Line":0}},{"line":10578,"address":[53772229],"length":1,"stats":{"Line":0}},{"line":10580,"address":[54793543],"length":1,"stats":{"Line":0}},{"line":10582,"address":[54604455],"length":1,"stats":{"Line":0}},{"line":10584,"address":[54604523],"length":1,"stats":{"Line":0}},{"line":10586,"address":[54604575],"length":1,"stats":{"Line":0}},{"line":10588,"address":[56345881],"length":1,"stats":{"Line":0}},{"line":10590,"address":[54793821],"length":1,"stats":{"Line":0}},{"line":10592,"address":[56346001],"length":1,"stats":{"Line":0}},{"line":10594,"address":[53772703],"length":1,"stats":{"Line":0}},{"line":10596,"address":[54794017],"length":1,"stats":{"Line":0}},{"line":10597,"address":[56362148,56362225],"length":1,"stats":{"Line":0}},{"line":10599,"address":[53788902],"length":1,"stats":{"Line":0}},{"line":10601,"address":[54794051],"length":1,"stats":{"Line":0}},{"line":10603,"address":[54794119],"length":1,"stats":{"Line":0}},{"line":10605,"address":[],"length":0,"stats":{"Line":0}},{"line":10607,"address":[54605114],"length":1,"stats":{"Line":0}},{"line":10609,"address":[53773054],"length":1,"stats":{"Line":0}},{"line":10611,"address":[56346471],"length":1,"stats":{"Line":0}},{"line":10613,"address":[56346523],"length":1,"stats":{"Line":0}},{"line":10615,"address":[54605354],"length":1,"stats":{"Line":0}},{"line":10617,"address":[53773294,53773414],"length":1,"stats":{"Line":0}},{"line":10619,"address":[],"length":0,"stats":{"Line":0}},{"line":10621,"address":[],"length":0,"stats":{"Line":0}},{"line":10623,"address":[56346868],"length":1,"stats":{"Line":0}},{"line":10624,"address":[53788794],"length":1,"stats":{"Line":0}},{"line":10625,"address":[],"length":0,"stats":{"Line":0}},{"line":10629,"address":[56361967],"length":1,"stats":{"Line":0}},{"line":10630,"address":[54620862],"length":1,"stats":{"Line":0}},{"line":10632,"address":[54605699],"length":1,"stats":{"Line":0}},{"line":10634,"address":[53773655],"length":1,"stats":{"Line":0}},{"line":10635,"address":[53773701],"length":1,"stats":{"Line":0}},{"line":10637,"address":[56347076],"length":1,"stats":{"Line":0}},{"line":10639,"address":[56347152],"length":1,"stats":{"Line":0}},{"line":10641,"address":[53773838],"length":1,"stats":{"Line":0}},{"line":10643,"address":[53773906],"length":1,"stats":{"Line":0}},{"line":10645,"address":[54795112],"length":1,"stats":{"Line":0}},{"line":10647,"address":[54606101],"length":1,"stats":{"Line":0}},{"line":10649,"address":[56347307,56347390],"length":1,"stats":{"Line":0}},{"line":10651,"address":[56347429],"length":1,"stats":{"Line":0}},{"line":10653,"address":[56347464],"length":1,"stats":{"Line":0}},{"line":10655,"address":[],"length":0,"stats":{"Line":0}},{"line":10657,"address":[],"length":0,"stats":{"Line":0}},{"line":10659,"address":[54606414],"length":1,"stats":{"Line":0}},{"line":10660,"address":[53788593,53788661],"length":1,"stats":{"Line":0}},{"line":10662,"address":[54620730],"length":1,"stats":{"Line":0}},{"line":10664,"address":[56347685],"length":1,"stats":{"Line":0}},{"line":10666,"address":[54606525],"length":1,"stats":{"Line":0}},{"line":10667,"address":[54620594,54620662],"length":1,"stats":{"Line":0}},{"line":10669,"address":[53788507],"length":1,"stats":{"Line":0}},{"line":10671,"address":[],"length":0,"stats":{"Line":0}},{"line":10673,"address":[56347871],"length":1,"stats":{"Line":0}},{"line":10675,"address":[56347906],"length":1,"stats":{"Line":0}},{"line":10677,"address":[56347982],"length":1,"stats":{"Line":0}},{"line":10679,"address":[54606782,54606893],"length":1,"stats":{"Line":0}},{"line":10681,"address":[54606858],"length":1,"stats":{"Line":0}},{"line":10682,"address":[],"length":0,"stats":{"Line":0}},{"line":10684,"address":[],"length":0,"stats":{"Line":0}},{"line":10686,"address":[54796089,54796199],"length":1,"stats":{"Line":0}},{"line":10688,"address":[54607043],"length":1,"stats":{"Line":0}},{"line":10689,"address":[54809411,54809479],"length":1,"stats":{"Line":0}},{"line":10691,"address":[53788285],"length":1,"stats":{"Line":0}},{"line":10693,"address":[54607115],"length":1,"stats":{"Line":0}},{"line":10695,"address":[54796312],"length":1,"stats":{"Line":0}},{"line":10696,"address":[56361412,56361480],"length":1,"stats":{"Line":0}},{"line":10698,"address":[54620286],"length":1,"stats":{"Line":0}},{"line":10700,"address":[54796346],"length":1,"stats":{"Line":0}},{"line":10702,"address":[54607302],"length":1,"stats":{"Line":0}},{"line":10703,"address":[53788106,53788038],"length":1,"stats":{"Line":0}},{"line":10705,"address":[54809214],"length":1,"stats":{"Line":0}},{"line":10707,"address":[],"length":0,"stats":{"Line":0}},{"line":10709,"address":[],"length":0,"stats":{"Line":0}},{"line":10710,"address":[54809146,54809078],"length":1,"stats":{"Line":0}},{"line":10712,"address":[53787952],"length":1,"stats":{"Line":0}},{"line":10714,"address":[54607448],"length":1,"stats":{"Line":0}},{"line":10716,"address":[54607524],"length":1,"stats":{"Line":0}},{"line":10717,"address":[56361147,56361079],"length":1,"stats":{"Line":0}},{"line":10719,"address":[56361104],"length":1,"stats":{"Line":0}},{"line":10721,"address":[54607559],"length":1,"stats":{"Line":0}},{"line":10723,"address":[54607635],"length":1,"stats":{"Line":0}},{"line":10724,"address":[56360968,56361036],"length":1,"stats":{"Line":0}},{"line":10726,"address":[54808881],"length":1,"stats":{"Line":0}},{"line":10728,"address":[56348898],"length":1,"stats":{"Line":0}},{"line":10730,"address":[54796862],"length":1,"stats":{"Line":0}},{"line":10731,"address":[53787594,53787662],"length":1,"stats":{"Line":0}},{"line":10733,"address":[53787619],"length":1,"stats":{"Line":0}},{"line":10735,"address":[54607781],"length":1,"stats":{"Line":0}},{"line":10738,"address":[],"length":0,"stats":{"Line":0}},{"line":10739,"address":[54607895],"length":1,"stats":{"Line":0}},{"line":10741,"address":[53775809],"length":1,"stats":{"Line":0}},{"line":10744,"address":[53775877],"length":1,"stats":{"Line":0}},{"line":10745,"address":[54797150],"length":1,"stats":{"Line":0}},{"line":10747,"address":[56349288],"length":1,"stats":{"Line":0}},{"line":10750,"address":[54797244],"length":1,"stats":{"Line":0}},{"line":10751,"address":[54797290],"length":1,"stats":{"Line":0}},{"line":10753,"address":[54797213],"length":1,"stats":{"Line":0}},{"line":10756,"address":[56349459],"length":1,"stats":{"Line":0}},{"line":10757,"address":[],"length":0,"stats":{"Line":0}},{"line":10759,"address":[56349531,56349428],"length":1,"stats":{"Line":0}},{"line":10762,"address":[54797450],"length":1,"stats":{"Line":0}},{"line":10763,"address":[54608381],"length":1,"stats":{"Line":0}},{"line":10765,"address":[56349634,56349733],"length":1,"stats":{"Line":0}},{"line":10767,"address":[53776363],"length":1,"stats":{"Line":0}},{"line":10768,"address":[],"length":0,"stats":{"Line":0}},{"line":10769,"address":[53786882],"length":1,"stats":{"Line":0}},{"line":10772,"address":[],"length":0,"stats":{"Line":0}},{"line":10773,"address":[56360474],"length":1,"stats":{"Line":0}},{"line":10774,"address":[56360627],"length":1,"stats":{"Line":0}},{"line":10775,"address":[54619518],"length":1,"stats":{"Line":0}},{"line":10776,"address":[],"length":0,"stats":{"Line":0}},{"line":10777,"address":[],"length":0,"stats":{"Line":0}},{"line":10779,"address":[53787484],"length":1,"stats":{"Line":0}},{"line":10780,"address":[],"length":0,"stats":{"Line":0}},{"line":10781,"address":[54808647],"length":1,"stats":{"Line":0}},{"line":10783,"address":[],"length":0,"stats":{"Line":0}},{"line":10785,"address":[],"length":0,"stats":{"Line":0}},{"line":10787,"address":[54608656],"length":1,"stats":{"Line":0}},{"line":10788,"address":[54807918,54807986],"length":1,"stats":{"Line":0}},{"line":10790,"address":[54807943],"length":1,"stats":{"Line":0}},{"line":10792,"address":[56349917,56350057],"length":1,"stats":{"Line":0}},{"line":10794,"address":[56349985],"length":1,"stats":{"Line":0}},{"line":10795,"address":[54797919],"length":1,"stats":{"Line":0}},{"line":10797,"address":[54608868],"length":1,"stats":{"Line":0}},{"line":10799,"address":[54608936],"length":1,"stats":{"Line":0}},{"line":10800,"address":[54798102],"length":1,"stats":{"Line":0}},{"line":10802,"address":[56350240],"length":1,"stats":{"Line":0}},{"line":10804,"address":[],"length":0,"stats":{"Line":0}},{"line":10805,"address":[54798248],"length":1,"stats":{"Line":0}},{"line":10807,"address":[56350386],"length":1,"stats":{"Line":0}},{"line":10809,"address":[53777124],"length":1,"stats":{"Line":0}},{"line":10810,"address":[56359910,56359987],"length":1,"stats":{"Line":0}},{"line":10812,"address":[53786656],"length":1,"stats":{"Line":0}},{"line":10814,"address":[],"length":0,"stats":{"Line":0}},{"line":10816,"address":[],"length":0,"stats":{"Line":0}},{"line":10817,"address":[],"length":0,"stats":{"Line":0}},{"line":10819,"address":[],"length":0,"stats":{"Line":0}},{"line":10821,"address":[54609271,54609417],"length":1,"stats":{"Line":0}},{"line":10823,"address":[56350564],"length":1,"stats":{"Line":0}},{"line":10824,"address":[54609391],"length":1,"stats":{"Line":0}},{"line":10826,"address":[54798567],"length":1,"stats":{"Line":0}},{"line":10828,"address":[56350747],"length":1,"stats":{"Line":0}},{"line":10829,"address":[53777456],"length":1,"stats":{"Line":0}},{"line":10831,"address":[54609705,54609594],"length":1,"stats":{"Line":0}},{"line":10833,"address":[],"length":0,"stats":{"Line":0}},{"line":10834,"address":[54618708,54618631],"length":1,"stats":{"Line":0}},{"line":10836,"address":[54618648],"length":1,"stats":{"Line":0}},{"line":10838,"address":[54609853,54609742],"length":1,"stats":{"Line":0}},{"line":10840,"address":[56351042],"length":1,"stats":{"Line":0}},{"line":10841,"address":[53786476,53786399],"length":1,"stats":{"Line":0}},{"line":10843,"address":[54807575],"length":1,"stats":{"Line":0}},{"line":10845,"address":[],"length":0,"stats":{"Line":0}},{"line":10847,"address":[54609966],"length":1,"stats":{"Line":0}},{"line":10848,"address":[54807515,54807438],"length":1,"stats":{"Line":0}},{"line":10850,"address":[54807455],"length":1,"stats":{"Line":0}},{"line":10852,"address":[54610001],"length":1,"stats":{"Line":0}},{"line":10854,"address":[54799187],"length":1,"stats":{"Line":0}},{"line":10855,"address":[56359507,56359430],"length":1,"stats":{"Line":0}},{"line":10857,"address":[53786176],"length":1,"stats":{"Line":0}},{"line":10859,"address":[54610112],"length":1,"stats":{"Line":0}},{"line":10861,"address":[],"length":0,"stats":{"Line":0}},{"line":10863,"address":[56351573,56351453],"length":1,"stats":{"Line":0}},{"line":10865,"address":[53778188],"length":1,"stats":{"Line":0}},{"line":10867,"address":[],"length":0,"stats":{"Line":0}},{"line":10869,"address":[53778345],"length":1,"stats":{"Line":0}},{"line":10871,"address":[53778397,53778496],"length":1,"stats":{"Line":0}},{"line":10873,"address":[54610577],"length":1,"stats":{"Line":0}},{"line":10874,"address":[],"length":0,"stats":{"Line":0}},{"line":10875,"address":[54617556],"length":1,"stats":{"Line":0}},{"line":10878,"address":[54806744,54806599],"length":1,"stats":{"Line":0}},{"line":10879,"address":[56359044],"length":1,"stats":{"Line":0}},{"line":10880,"address":[53785922],"length":1,"stats":{"Line":0}},{"line":10881,"address":[56359243],"length":1,"stats":{"Line":0}},{"line":10882,"address":[],"length":0,"stats":{"Line":0}},{"line":10883,"address":[56359250],"length":1,"stats":{"Line":0}},{"line":10885,"address":[56359322],"length":1,"stats":{"Line":0}},{"line":10886,"address":[],"length":0,"stats":{"Line":0}},{"line":10887,"address":[56359332],"length":1,"stats":{"Line":0}},{"line":10889,"address":[54618253],"length":1,"stats":{"Line":0}},{"line":10891,"address":[54799754,54799864],"length":1,"stats":{"Line":0}},{"line":10893,"address":[56351942],"length":1,"stats":{"Line":0}},{"line":10894,"address":[],"length":0,"stats":{"Line":0}},{"line":10896,"address":[53785346],"length":1,"stats":{"Line":0}},{"line":10898,"address":[],"length":0,"stats":{"Line":0}},{"line":10900,"address":[54799977],"length":1,"stats":{"Line":0}},{"line":10901,"address":[56358489,56358557],"length":1,"stats":{"Line":0}},{"line":10903,"address":[],"length":0,"stats":{"Line":0}},{"line":10905,"address":[56352160],"length":1,"stats":{"Line":0}},{"line":10907,"address":[53778905],"length":1,"stats":{"Line":0}},{"line":10909,"address":[54611052,54610978],"length":1,"stats":{"Line":0}},{"line":10911,"address":[53778979],"length":1,"stats":{"Line":0}},{"line":10912,"address":[56358446,56358378],"length":1,"stats":{"Line":0}},{"line":10914,"address":[],"length":0,"stats":{"Line":0}},{"line":10916,"address":[54800232],"length":1,"stats":{"Line":0}},{"line":10918,"address":[],"length":0,"stats":{"Line":0}},{"line":10920,"address":[56352381],"length":1,"stats":{"Line":0}},{"line":10922,"address":[56352486],"length":1,"stats":{"Line":0}},{"line":10923,"address":[53779202],"length":1,"stats":{"Line":0}},{"line":10925,"address":[53779125],"length":1,"stats":{"Line":0}},{"line":10927,"address":[],"length":0,"stats":{"Line":0}},{"line":10929,"address":[54800446,54800520],"length":1,"stats":{"Line":0}},{"line":10931,"address":[53779341],"length":1,"stats":{"Line":0}},{"line":10932,"address":[54617168,54617071],"length":1,"stats":{"Line":0}},{"line":10934,"address":[54806143],"length":1,"stats":{"Line":0}},{"line":10935,"address":[56358301],"length":1,"stats":{"Line":0}},{"line":10937,"address":[54611488],"length":1,"stats":{"Line":0}},{"line":10939,"address":[53779452],"length":1,"stats":{"Line":0}},{"line":10940,"address":[54616931,54617028],"length":1,"stats":{"Line":0}},{"line":10942,"address":[],"length":0,"stats":{"Line":0}},{"line":10943,"address":[54616994],"length":1,"stats":{"Line":0}},{"line":10945,"address":[],"length":0,"stats":{"Line":0}},{"line":10947,"address":[54800734],"length":1,"stats":{"Line":0}},{"line":10948,"address":[56352892],"length":1,"stats":{"Line":0}},{"line":10950,"address":[],"length":0,"stats":{"Line":0}},{"line":10952,"address":[54611733],"length":1,"stats":{"Line":0}},{"line":10953,"address":[54611779],"length":1,"stats":{"Line":0}},{"line":10955,"address":[],"length":0,"stats":{"Line":0}},{"line":10957,"address":[53779761],"length":1,"stats":{"Line":0}},{"line":10958,"address":[54801024],"length":1,"stats":{"Line":0}},{"line":10960,"address":[54801050],"length":1,"stats":{"Line":0}},{"line":10962,"address":[54801126],"length":1,"stats":{"Line":0}},{"line":10964,"address":[54801087,54801164],"length":1,"stats":{"Line":0}},{"line":10966,"address":[],"length":0,"stats":{"Line":0}},{"line":10967,"address":[56357987,56358055],"length":1,"stats":{"Line":0}},{"line":10969,"address":[53784733],"length":1,"stats":{"Line":0}},{"line":10971,"address":[],"length":0,"stats":{"Line":0}},{"line":10973,"address":[],"length":0,"stats":{"Line":0}},{"line":10975,"address":[53780022],"length":1,"stats":{"Line":0}},{"line":10977,"address":[56353417],"length":1,"stats":{"Line":0}},{"line":10979,"address":[53780142,53780241],"length":1,"stats":{"Line":0}},{"line":10981,"address":[53780210],"length":1,"stats":{"Line":0}},{"line":10982,"address":[53783703,53783851],"length":1,"stats":{"Line":0}},{"line":10983,"address":[54616169],"length":1,"stats":{"Line":0}},{"line":10984,"address":[56357497],"length":1,"stats":{"Line":0}},{"line":10985,"address":[],"length":0,"stats":{"Line":0}},{"line":10986,"address":[],"length":0,"stats":{"Line":0}},{"line":10987,"address":[56357550],"length":1,"stats":{"Line":0}},{"line":10989,"address":[53784341],"length":1,"stats":{"Line":0}},{"line":10990,"address":[54616698],"length":1,"stats":{"Line":0}},{"line":10991,"address":[],"length":0,"stats":{"Line":0}},{"line":10992,"address":[56357874],"length":1,"stats":{"Line":0}},{"line":10994,"address":[53784680],"length":1,"stats":{"Line":0}},{"line":10996,"address":[],"length":0,"stats":{"Line":0}},{"line":10997,"address":[53783800,53783723],"length":1,"stats":{"Line":0}},{"line":10999,"address":[56357029],"length":1,"stats":{"Line":0}},{"line":11001,"address":[54612390],"length":1,"stats":{"Line":0}},{"line":11003,"address":[54612458],"length":1,"stats":{"Line":0}},{"line":11004,"address":[56353719],"length":1,"stats":{"Line":0}},{"line":11006,"address":[54801732,54801633],"length":1,"stats":{"Line":0}},{"line":11008,"address":[],"length":0,"stats":{"Line":0}},{"line":11009,"address":[54804771],"length":1,"stats":{"Line":0}},{"line":11011,"address":[54804727],"length":1,"stats":{"Line":0}},{"line":11013,"address":[53780554,53780674],"length":1,"stats":{"Line":0}},{"line":11015,"address":[56353949],"length":1,"stats":{"Line":0}},{"line":11017,"address":[54612823],"length":1,"stats":{"Line":0}},{"line":11019,"address":[],"length":0,"stats":{"Line":0}},{"line":11020,"address":[54615541,54615618],"length":1,"stats":{"Line":0}},{"line":11022,"address":[54615558],"length":1,"stats":{"Line":0}},{"line":11024,"address":[53780822],"length":1,"stats":{"Line":0}},{"line":11026,"address":[],"length":0,"stats":{"Line":0}},{"line":11027,"address":[56356599,56356676],"length":1,"stats":{"Line":0}},{"line":11029,"address":[54615438],"length":1,"stats":{"Line":0}},{"line":11031,"address":[54802146],"length":1,"stats":{"Line":0}},{"line":11033,"address":[],"length":0,"stats":{"Line":0}},{"line":11034,"address":[54804367,54804444],"length":1,"stats":{"Line":0}},{"line":11036,"address":[53783206],"length":1,"stats":{"Line":0}},{"line":11038,"address":[54613082,54613156],"length":1,"stats":{"Line":0}},{"line":11040,"address":[54613195],"length":1,"stats":{"Line":0}},{"line":11041,"address":[54615258,54615181],"length":1,"stats":{"Line":0}},{"line":11043,"address":[],"length":0,"stats":{"Line":0}},{"line":11045,"address":[],"length":0,"stats":{"Line":0}},{"line":11047,"address":[],"length":0,"stats":{"Line":0}},{"line":11048,"address":[],"length":0,"stats":{"Line":0}},{"line":11050,"address":[53782943],"length":1,"stats":{"Line":0}},{"line":11052,"address":[54613329],"length":1,"stats":{"Line":0}},{"line":11054,"address":[53781285],"length":1,"stats":{"Line":0}},{"line":11055,"address":[53781332],"length":1,"stats":{"Line":0}},{"line":11057,"address":[53781358],"length":1,"stats":{"Line":0}},{"line":11059,"address":[53781426],"length":1,"stats":{"Line":0}},{"line":11060,"address":[54613584],"length":1,"stats":{"Line":0}},{"line":11062,"address":[53781498],"length":1,"stats":{"Line":0}},{"line":11064,"address":[53781566],"length":1,"stats":{"Line":0}},{"line":11065,"address":[54613724],"length":1,"stats":{"Line":0}},{"line":11067,"address":[54613647],"length":1,"stats":{"Line":0}},{"line":11069,"address":[54613781],"length":1,"stats":{"Line":0}},{"line":11070,"address":[],"length":0,"stats":{"Line":0}},{"line":11072,"address":[54802849],"length":1,"stats":{"Line":0}},{"line":11074,"address":[54802983],"length":1,"stats":{"Line":0}},{"line":11075,"address":[54803029],"length":1,"stats":{"Line":0}},{"line":11077,"address":[56355064],"length":1,"stats":{"Line":0}},{"line":11079,"address":[],"length":0,"stats":{"Line":0}},{"line":11080,"address":[56355244],"length":1,"stats":{"Line":0}},{"line":11082,"address":[54803055,54803158],"length":1,"stats":{"Line":0}},{"line":11084,"address":[54614090],"length":1,"stats":{"Line":0}},{"line":11085,"address":[56355347],"length":1,"stats":{"Line":0}},{"line":11087,"address":[],"length":0,"stats":{"Line":0}},{"line":11091,"address":[53782042],"length":1,"stats":{"Line":0}},{"line":11092,"address":[53782196,53782130,53782280],"length":1,"stats":{"Line":0}},{"line":11093,"address":[],"length":0,"stats":{"Line":0}},{"line":11094,"address":[54614252],"length":1,"stats":{"Line":0}},{"line":11095,"address":[56083760,56083776],"length":1,"stats":{"Line":0}},{"line":11098,"address":[54614466],"length":1,"stats":{"Line":0}},{"line":11099,"address":[56355784,56355701],"length":1,"stats":{"Line":0}},{"line":11100,"address":[53782714,53782596],"length":1,"stats":{"Line":0}},{"line":11103,"address":[56355917],"length":1,"stats":{"Line":0}},{"line":11108,"address":[54571712,54722111],"length":1,"stats":{"Line":0}},{"line":11109,"address":[53890101],"length":1,"stats":{"Line":0}},{"line":11110,"address":[54722321,54722246],"length":1,"stats":{"Line":0}},{"line":11111,"address":[56462734,56462844],"length":1,"stats":{"Line":0}},{"line":11113,"address":[54910636],"length":1,"stats":{"Line":0}},{"line":11116,"address":[56218224],"length":1,"stats":{"Line":4}},{"line":11122,"address":[54475501],"length":1,"stats":{"Line":4}},{"line":11124,"address":[54475716,54475544,54476338],"length":1,"stats":{"Line":10}},{"line":11125,"address":[54475711],"length":1,"stats":{"Line":5}},{"line":11127,"address":[54476103,54475728],"length":1,"stats":{"Line":1}},{"line":11128,"address":[54666863],"length":1,"stats":{"Line":1}},{"line":11131,"address":[54666479],"length":1,"stats":{"Line":5}},{"line":11132,"address":[54475857],"length":1,"stats":{"Line":5}},{"line":11133,"address":[],"length":0,"stats":{"Line":5}},{"line":11135,"address":[54666620],"length":1,"stats":{"Line":5}},{"line":11136,"address":[54666627],"length":1,"stats":{"Line":4}},{"line":11140,"address":[54476008],"length":1,"stats":{"Line":4}},{"line":11141,"address":[56219119,56218811],"length":1,"stats":{"Line":4}},{"line":11142,"address":[53644364,53644293],"length":1,"stats":{"Line":8}},{"line":11143,"address":[],"length":0,"stats":{"Line":0}},{"line":11149,"address":[],"length":0,"stats":{"Line":4}},{"line":11150,"address":[53644440],"length":1,"stats":{"Line":4}},{"line":11155,"address":[56219263],"length":1,"stats":{"Line":4}},{"line":11156,"address":[53644390,53644482],"length":1,"stats":{"Line":8}},{"line":11157,"address":[],"length":0,"stats":{"Line":4}},{"line":11159,"address":[54476746,54476675],"length":1,"stats":{"Line":8}},{"line":11160,"address":[],"length":0,"stats":{"Line":0}},{"line":11166,"address":[],"length":0,"stats":{"Line":4}},{"line":11167,"address":[],"length":0,"stats":{"Line":6}},{"line":11171,"address":[],"length":0,"stats":{"Line":4}},{"line":11172,"address":[56219615],"length":1,"stats":{"Line":6}},{"line":11175,"address":[56582608],"length":1,"stats":{"Line":4}},{"line":11176,"address":[55030552],"length":1,"stats":{"Line":4}},{"line":11178,"address":[54844209],"length":1,"stats":{"Line":4}},{"line":11179,"address":[56582752],"length":1,"stats":{"Line":4}},{"line":11180,"address":[],"length":0,"stats":{"Line":4}},{"line":11182,"address":[54844350],"length":1,"stats":{"Line":4}},{"line":11183,"address":[],"length":0,"stats":{"Line":0}},{"line":11184,"address":[],"length":0,"stats":{"Line":0}},{"line":11187,"address":[55030760],"length":1,"stats":{"Line":4}},{"line":11189,"address":[55030805],"length":1,"stats":{"Line":4}},{"line":11191,"address":[55030828,55031004,55031510],"length":1,"stats":{"Line":8}},{"line":11192,"address":[],"length":0,"stats":{"Line":4}},{"line":11195,"address":[54844636,54844901],"length":1,"stats":{"Line":0}},{"line":11196,"address":[55031371],"length":1,"stats":{"Line":0}},{"line":11198,"address":[],"length":0,"stats":{"Line":4}},{"line":11199,"address":[55031109],"length":1,"stats":{"Line":4}},{"line":11202,"address":[56583270],"length":1,"stats":{"Line":4}},{"line":11204,"address":[56583293],"length":1,"stats":{"Line":4}},{"line":11205,"address":[54012710],"length":1,"stats":{"Line":4}},{"line":11206,"address":[],"length":0,"stats":{"Line":4}},{"line":11207,"address":[54013095],"length":1,"stats":{"Line":4}},{"line":11208,"address":[56583770,56583700],"length":1,"stats":{"Line":8}},{"line":11209,"address":[],"length":0,"stats":{"Line":0}},{"line":11215,"address":[56583839],"length":1,"stats":{"Line":4}},{"line":11218,"address":[56583779],"length":1,"stats":{"Line":4}},{"line":11219,"address":[56583806],"length":1,"stats":{"Line":4}},{"line":11223,"address":[54845340],"length":1,"stats":{"Line":4}},{"line":11224,"address":[55031775,55031851],"length":1,"stats":{"Line":4}},{"line":11227,"address":[54013361],"length":1,"stats":{"Line":4}},{"line":11230,"address":[54518448],"length":1,"stats":{"Line":0}},{"line":11236,"address":[56260818],"length":1,"stats":{"Line":0}},{"line":11237,"address":[54708717],"length":1,"stats":{"Line":0}},{"line":11238,"address":[],"length":0,"stats":{"Line":0}},{"line":11239,"address":[54518608],"length":1,"stats":{"Line":0}},{"line":11240,"address":[],"length":0,"stats":{"Line":0}},{"line":11241,"address":[],"length":0,"stats":{"Line":0}},{"line":11243,"address":[54518694,54518628],"length":1,"stats":{"Line":0}},{"line":11246,"address":[54518679],"length":1,"stats":{"Line":0}},{"line":11249,"address":[56674064],"length":1,"stats":{"Line":0}},{"line":11255,"address":[54104999],"length":1,"stats":{"Line":0}},{"line":11258,"address":[54105051],"length":1,"stats":{"Line":0}},{"line":11261,"address":[56674372],"length":1,"stats":{"Line":0}},{"line":11262,"address":[55122237],"length":1,"stats":{"Line":0}},{"line":11263,"address":[],"length":0,"stats":{"Line":0}},{"line":11264,"address":[54937350],"length":1,"stats":{"Line":0}},{"line":11267,"address":[54105327],"length":1,"stats":{"Line":0}},{"line":11268,"address":[],"length":0,"stats":{"Line":0}},{"line":11270,"address":[54937453],"length":1,"stats":{"Line":0}},{"line":11271,"address":[56674548],"length":1,"stats":{"Line":0}},{"line":11272,"address":[],"length":0,"stats":{"Line":0}},{"line":11273,"address":[],"length":0,"stats":{"Line":0}},{"line":11274,"address":[54937508],"length":1,"stats":{"Line":0}},{"line":11275,"address":[54937558],"length":1,"stats":{"Line":0}},{"line":11276,"address":[],"length":0,"stats":{"Line":0}},{"line":11277,"address":[54937565],"length":1,"stats":{"Line":0}},{"line":11281,"address":[55122535],"length":1,"stats":{"Line":0}},{"line":11282,"address":[],"length":0,"stats":{"Line":0}},{"line":11283,"address":[55122542],"length":1,"stats":{"Line":0}},{"line":11286,"address":[56674772],"length":1,"stats":{"Line":0}},{"line":11288,"address":[55122627],"length":1,"stats":{"Line":0}},{"line":11289,"address":[],"length":0,"stats":{"Line":0}},{"line":11290,"address":[],"length":0,"stats":{"Line":0}},{"line":11295,"address":[55122768],"length":1,"stats":{"Line":0}},{"line":11296,"address":[],"length":0,"stats":{"Line":0}},{"line":11297,"address":[],"length":0,"stats":{"Line":0}},{"line":11302,"address":[54937999],"length":1,"stats":{"Line":0}},{"line":11303,"address":[54938047],"length":1,"stats":{"Line":0}},{"line":11306,"address":[56675148],"length":1,"stats":{"Line":0}},{"line":11307,"address":[],"length":0,"stats":{"Line":0}},{"line":11308,"address":[54106003],"length":1,"stats":{"Line":0}},{"line":11310,"address":[55123075],"length":1,"stats":{"Line":0}},{"line":11311,"address":[56675278],"length":1,"stats":{"Line":0}},{"line":11313,"address":[55123174],"length":1,"stats":{"Line":0}},{"line":11314,"address":[55123227],"length":1,"stats":{"Line":0}},{"line":11315,"address":[],"length":0,"stats":{"Line":0}},{"line":11316,"address":[],"length":0,"stats":{"Line":0}},{"line":11318,"address":[54938510],"length":1,"stats":{"Line":0}},{"line":11319,"address":[],"length":0,"stats":{"Line":0}},{"line":11320,"address":[],"length":0,"stats":{"Line":0}},{"line":11323,"address":[55123418],"length":1,"stats":{"Line":0}},{"line":11326,"address":[54938595],"length":1,"stats":{"Line":0}},{"line":11327,"address":[54938621],"length":1,"stats":{"Line":0}},{"line":11328,"address":[],"length":0,"stats":{"Line":0}},{"line":11329,"address":[54938631],"length":1,"stats":{"Line":0}},{"line":11332,"address":[54106621],"length":1,"stats":{"Line":0}},{"line":11333,"address":[],"length":0,"stats":{"Line":0}},{"line":11334,"address":[54938740],"length":1,"stats":{"Line":0}},{"line":11336,"address":[55123703],"length":1,"stats":{"Line":0}},{"line":11337,"address":[54938837],"length":1,"stats":{"Line":0}},{"line":11341,"address":[54938888],"length":1,"stats":{"Line":0}},{"line":11344,"address":[55123781],"length":1,"stats":{"Line":0}},{"line":11345,"address":[55123828],"length":1,"stats":{"Line":0}},{"line":11346,"address":[],"length":0,"stats":{"Line":0}},{"line":11347,"address":[],"length":0,"stats":{"Line":0}},{"line":11349,"address":[],"length":0,"stats":{"Line":0}},{"line":11350,"address":[56676052],"length":1,"stats":{"Line":0}},{"line":11351,"address":[54939027],"length":1,"stats":{"Line":0}},{"line":11352,"address":[55123925],"length":1,"stats":{"Line":0}},{"line":11359,"address":[54939169],"length":1,"stats":{"Line":0}},{"line":11360,"address":[55124055],"length":1,"stats":{"Line":0}},{"line":11363,"address":[],"length":0,"stats":{"Line":0}},{"line":11364,"address":[],"length":0,"stats":{"Line":0}},{"line":11366,"address":[],"length":0,"stats":{"Line":0}},{"line":11367,"address":[56676371],"length":1,"stats":{"Line":0}},{"line":11368,"address":[],"length":0,"stats":{"Line":0}},{"line":11369,"address":[],"length":0,"stats":{"Line":0}},{"line":11373,"address":[54939468],"length":1,"stats":{"Line":0}},{"line":11374,"address":[],"length":0,"stats":{"Line":0}},{"line":11375,"address":[56676502],"length":1,"stats":{"Line":0}},{"line":11379,"address":[54939571],"length":1,"stats":{"Line":0}},{"line":11382,"address":[55124489],"length":1,"stats":{"Line":0}},{"line":11383,"address":[],"length":0,"stats":{"Line":0}},{"line":11384,"address":[],"length":0,"stats":{"Line":0}},{"line":11390,"address":[54940284],"length":1,"stats":{"Line":0}},{"line":11394,"address":[54939852],"length":1,"stats":{"Line":0}},{"line":11396,"address":[],"length":0,"stats":{"Line":0}},{"line":11397,"address":[],"length":0,"stats":{"Line":0}},{"line":11398,"address":[56676905],"length":1,"stats":{"Line":0}},{"line":11401,"address":[54107867],"length":1,"stats":{"Line":0}},{"line":11402,"address":[54107911],"length":1,"stats":{"Line":0}},{"line":11403,"address":[],"length":0,"stats":{"Line":0}},{"line":11404,"address":[],"length":0,"stats":{"Line":0}},{"line":11406,"address":[54940102],"length":1,"stats":{"Line":0}},{"line":11407,"address":[55125008],"length":1,"stats":{"Line":0}},{"line":11409,"address":[54108095],"length":1,"stats":{"Line":0}},{"line":11410,"address":[54940241],"length":1,"stats":{"Line":0}},{"line":11411,"address":[],"length":0,"stats":{"Line":0}},{"line":11414,"address":[56707808],"length":1,"stats":{"Line":0}},{"line":11422,"address":[56707950],"length":1,"stats":{"Line":0}},{"line":11424,"address":[],"length":0,"stats":{"Line":0}},{"line":11425,"address":[56708187],"length":1,"stats":{"Line":0}},{"line":11427,"address":[],"length":0,"stats":{"Line":0}},{"line":11428,"address":[54139900],"length":1,"stats":{"Line":0}},{"line":11431,"address":[54972180],"length":1,"stats":{"Line":0}},{"line":11432,"address":[],"length":0,"stats":{"Line":0}},{"line":11433,"address":[55156737],"length":1,"stats":{"Line":0}},{"line":11434,"address":[55156801],"length":1,"stats":{"Line":0}},{"line":11437,"address":[],"length":0,"stats":{"Line":0}},{"line":11438,"address":[],"length":0,"stats":{"Line":0}},{"line":11439,"address":[54140398],"length":1,"stats":{"Line":0}},{"line":11441,"address":[],"length":0,"stats":{"Line":0}},{"line":11442,"address":[54140489],"length":1,"stats":{"Line":0}},{"line":11445,"address":[54140540],"length":1,"stats":{"Line":0}},{"line":11446,"address":[54140593],"length":1,"stats":{"Line":0}},{"line":11447,"address":[56709269],"length":1,"stats":{"Line":0}},{"line":11448,"address":[54140699],"length":1,"stats":{"Line":0}},{"line":11450,"address":[55157212],"length":1,"stats":{"Line":0}},{"line":11451,"address":[],"length":0,"stats":{"Line":0}},{"line":11452,"address":[],"length":0,"stats":{"Line":0}},{"line":11455,"address":[55157241],"length":1,"stats":{"Line":0}},{"line":11458,"address":[56709455],"length":1,"stats":{"Line":0}},{"line":11459,"address":[54972972],"length":1,"stats":{"Line":0}},{"line":11460,"address":[],"length":0,"stats":{"Line":0}},{"line":11461,"address":[54140870],"length":1,"stats":{"Line":0}},{"line":11464,"address":[54973072],"length":1,"stats":{"Line":0}},{"line":11465,"address":[],"length":0,"stats":{"Line":0}},{"line":11466,"address":[54973162],"length":1,"stats":{"Line":0}},{"line":11468,"address":[56709601],"length":1,"stats":{"Line":0}},{"line":11469,"address":[],"length":0,"stats":{"Line":0}},{"line":11472,"address":[],"length":0,"stats":{"Line":0}},{"line":11473,"address":[],"length":0,"stats":{"Line":0}},{"line":11477,"address":[54141189],"length":1,"stats":{"Line":0}},{"line":11478,"address":[56709833],"length":1,"stats":{"Line":0}},{"line":11479,"address":[],"length":0,"stats":{"Line":0}},{"line":11480,"address":[],"length":0,"stats":{"Line":0}},{"line":11486,"address":[],"length":0,"stats":{"Line":0}},{"line":11490,"address":[],"length":0,"stats":{"Line":0}},{"line":11492,"address":[56710079],"length":1,"stats":{"Line":0}},{"line":11493,"address":[],"length":0,"stats":{"Line":0}},{"line":11494,"address":[54141477],"length":1,"stats":{"Line":0}},{"line":11497,"address":[],"length":0,"stats":{"Line":0}},{"line":11498,"address":[56710222],"length":1,"stats":{"Line":0}},{"line":11499,"address":[],"length":0,"stats":{"Line":0}},{"line":11500,"address":[54141619],"length":1,"stats":{"Line":0}},{"line":11502,"address":[55158144],"length":1,"stats":{"Line":0}},{"line":11504,"address":[54141751,54141876],"length":1,"stats":{"Line":0}},{"line":11505,"address":[54141981],"length":1,"stats":{"Line":0}},{"line":11507,"address":[54142036],"length":1,"stats":{"Line":0}},{"line":11509,"address":[],"length":0,"stats":{"Line":0}},{"line":11510,"address":[56710716],"length":1,"stats":{"Line":0}},{"line":11511,"address":[54142138],"length":1,"stats":{"Line":0}},{"line":11514,"address":[56683358,56677360,56680073],"length":1,"stats":{"Line":7}},{"line":11522,"address":[56677498,56677567],"length":1,"stats":{"Line":14}},{"line":11523,"address":[],"length":0,"stats":{"Line":7}},{"line":11524,"address":[54114502],"length":1,"stats":{"Line":0}},{"line":11525,"address":[56683422],"length":1,"stats":{"Line":0}},{"line":11526,"address":[54946654],"length":1,"stats":{"Line":0}},{"line":11527,"address":[],"length":0,"stats":{"Line":0}},{"line":11528,"address":[],"length":0,"stats":{"Line":0}},{"line":11530,"address":[55131291],"length":1,"stats":{"Line":0}},{"line":11532,"address":[],"length":0,"stats":{"Line":0}},{"line":11533,"address":[54946936,54947084],"length":1,"stats":{"Line":0}},{"line":11534,"address":[56683551],"length":1,"stats":{"Line":0}},{"line":11535,"address":[56683637],"length":1,"stats":{"Line":0}},{"line":11536,"address":[],"length":0,"stats":{"Line":0}},{"line":11542,"address":[56107680],"length":1,"stats":{"Line":7}},{"line":11543,"address":[],"length":0,"stats":{"Line":0}},{"line":11544,"address":[54019656],"length":1,"stats":{"Line":0}},{"line":11547,"address":[],"length":0,"stats":{"Line":7}},{"line":11549,"address":[55125795],"length":1,"stats":{"Line":7}},{"line":11550,"address":[56677994],"length":1,"stats":{"Line":7}},{"line":11551,"address":[],"length":0,"stats":{"Line":7}},{"line":11552,"address":[],"length":0,"stats":{"Line":14}},{"line":11553,"address":[54941153,54941225],"length":1,"stats":{"Line":14}},{"line":11554,"address":[56678222,56678290],"length":1,"stats":{"Line":14}},{"line":11555,"address":[55126138,55126206],"length":1,"stats":{"Line":14}},{"line":11556,"address":[],"length":0,"stats":{"Line":14}},{"line":11557,"address":[55126298],"length":1,"stats":{"Line":7}},{"line":11559,"address":[54941501],"length":1,"stats":{"Line":7}},{"line":11560,"address":[56678566],"length":1,"stats":{"Line":7}},{"line":11561,"address":[54109488],"length":1,"stats":{"Line":7}},{"line":11566,"address":[54109495],"length":1,"stats":{"Line":7}},{"line":11567,"address":[54945136,54945263,54946308],"length":1,"stats":{"Line":7}},{"line":11568,"address":[55126691],"length":1,"stats":{"Line":7}},{"line":11569,"address":[55129900,55129834],"length":1,"stats":{"Line":7}},{"line":11570,"address":[],"length":0,"stats":{"Line":7}},{"line":11571,"address":[54113338],"length":1,"stats":{"Line":6}},{"line":11572,"address":[54945518],"length":1,"stats":{"Line":4}},{"line":11577,"address":[54945599],"length":1,"stats":{"Line":6}},{"line":11578,"address":[56682746,56683132],"length":1,"stats":{"Line":4}},{"line":11579,"address":[56682930],"length":1,"stats":{"Line":6}},{"line":11580,"address":[54946153],"length":1,"stats":{"Line":4}},{"line":11583,"address":[54114123],"length":1,"stats":{"Line":6}},{"line":11587,"address":[54109818],"length":1,"stats":{"Line":4}},{"line":11588,"address":[],"length":0,"stats":{"Line":0}},{"line":11589,"address":[],"length":0,"stats":{"Line":0}},{"line":11590,"address":[],"length":0,"stats":{"Line":0}},{"line":11591,"address":[54110388,54110447],"length":1,"stats":{"Line":0}},{"line":11592,"address":[54019456],"length":1,"stats":{"Line":0}},{"line":11593,"address":[56107432],"length":1,"stats":{"Line":0}},{"line":11594,"address":[],"length":0,"stats":{"Line":0}},{"line":11595,"address":[],"length":0,"stats":{"Line":0}},{"line":11598,"address":[55127624],"length":1,"stats":{"Line":0}},{"line":11599,"address":[],"length":0,"stats":{"Line":0}},{"line":11600,"address":[56679954],"length":1,"stats":{"Line":0}},{"line":11605,"address":[54942135,54943174],"length":1,"stats":{"Line":9}},{"line":11606,"address":[54111184,54112827],"length":1,"stats":{"Line":10}},{"line":11610,"address":[],"length":0,"stats":{"Line":12}},{"line":11611,"address":[],"length":0,"stats":{"Line":0}},{"line":11617,"address":[54943609],"length":1,"stats":{"Line":1}},{"line":11621,"address":[56680433],"length":1,"stats":{"Line":4}},{"line":11622,"address":[],"length":0,"stats":{"Line":4}},{"line":11623,"address":[56680844,56680766],"length":1,"stats":{"Line":4}},{"line":11624,"address":[56680949,56681027],"length":1,"stats":{"Line":4}},{"line":11625,"address":[54112123,54112205],"length":1,"stats":{"Line":4}},{"line":11626,"address":[54112310,54112392],"length":1,"stats":{"Line":4}},{"line":11627,"address":[54112497,54112579],"length":1,"stats":{"Line":4}},{"line":11628,"address":[54944791],"length":1,"stats":{"Line":4}},{"line":11631,"address":[56681685],"length":1,"stats":{"Line":4}},{"line":11632,"address":[54112726,54112809],"length":1,"stats":{"Line":8}},{"line":11635,"address":[55129581],"length":1,"stats":{"Line":4}},{"line":11638,"address":[55109936],"length":1,"stats":{"Line":0}},{"line":11644,"address":[55110005],"length":1,"stats":{"Line":0}},{"line":11646,"address":[54925088],"length":1,"stats":{"Line":0}},{"line":11647,"address":[54925236],"length":1,"stats":{"Line":0}},{"line":11649,"address":[56662503],"length":1,"stats":{"Line":0}},{"line":11650,"address":[],"length":0,"stats":{"Line":0}},{"line":11651,"address":[54093369],"length":1,"stats":{"Line":0}},{"line":11653,"address":[],"length":0,"stats":{"Line":0}},{"line":11654,"address":[56662658],"length":1,"stats":{"Line":0}},{"line":11657,"address":[54093475],"length":1,"stats":{"Line":0}},{"line":11658,"address":[],"length":0,"stats":{"Line":0}},{"line":11659,"address":[56662896],"length":1,"stats":{"Line":0}},{"line":11660,"address":[54093726],"length":1,"stats":{"Line":0}},{"line":11661,"address":[56662958],"length":1,"stats":{"Line":0}},{"line":11664,"address":[54925890],"length":1,"stats":{"Line":0}},{"line":11665,"address":[],"length":0,"stats":{"Line":0}},{"line":11666,"address":[54093974],"length":1,"stats":{"Line":0}},{"line":11667,"address":[56663251],"length":1,"stats":{"Line":0}},{"line":11668,"address":[],"length":0,"stats":{"Line":0}},{"line":11671,"address":[],"length":0,"stats":{"Line":0}},{"line":11672,"address":[],"length":0,"stats":{"Line":0}},{"line":11673,"address":[],"length":0,"stats":{"Line":0}},{"line":11674,"address":[54094109],"length":1,"stats":{"Line":0}},{"line":11676,"address":[54926302],"length":1,"stats":{"Line":0}},{"line":11678,"address":[54094388],"length":1,"stats":{"Line":0}},{"line":11681,"address":[55293773,55293779,55293376],"length":1,"stats":{"Line":7}},{"line":11682,"address":[54279489],"length":1,"stats":{"Line":7}},{"line":11683,"address":[54279523],"length":1,"stats":{"Line":7}},{"line":11685,"address":[],"length":0,"stats":{"Line":7}},{"line":11686,"address":[56845715,56845787],"length":1,"stats":{"Line":14}},{"line":11687,"address":[56845808,56845901],"length":1,"stats":{"Line":8}},{"line":11688,"address":[],"length":0,"stats":{"Line":7}},{"line":11691,"address":[56845903,56845877],"length":1,"stats":{"Line":14}},{"line":11695,"address":[55152043,55151632,55152037],"length":1,"stats":{"Line":11}},{"line":11696,"address":[56884977],"length":1,"stats":{"Line":8}},{"line":11697,"address":[],"length":0,"stats":{"Line":11}},{"line":11699,"address":[56885068],"length":1,"stats":{"Line":8}},{"line":11700,"address":[55332915,55332987],"length":1,"stats":{"Line":19}},{"line":11701,"address":[54319873,54319776],"length":1,"stats":{"Line":19}},{"line":11702,"address":[54319812],"length":1,"stats":{"Line":0}},{"line":11705,"address":[56885253,56885279],"length":1,"stats":{"Line":19}},{"line":11710,"address":[],"length":0,"stats":{"Line":1}},{"line":11712,"address":[54742933],"length":1,"stats":{"Line":3}},{"line":11714,"address":[54742981],"length":1,"stats":{"Line":1}},{"line":11716,"address":[56483113],"length":1,"stats":{"Line":0}},{"line":11719,"address":[53910881],"length":1,"stats":{"Line":1}},{"line":11724,"address":[54743001],"length":1,"stats":{"Line":1}},{"line":11725,"address":[56482941],"length":1,"stats":{"Line":1}},{"line":11726,"address":[54742921],"length":1,"stats":{"Line":1}},{"line":11727,"address":[53910916,53911285,53910989],"length":1,"stats":{"Line":2}},{"line":11730,"address":[],"length":0,"stats":{"Line":1}},{"line":11731,"address":[],"length":0,"stats":{"Line":3}},{"line":11732,"address":[],"length":0,"stats":{"Line":0}},{"line":11733,"address":[56483244],"length":1,"stats":{"Line":1}},{"line":11734,"address":[],"length":0,"stats":{"Line":1}},{"line":11737,"address":[],"length":0,"stats":{"Line":1}},{"line":11741,"address":[54743706],"length":1,"stats":{"Line":1}},{"line":11742,"address":[56483930,56483847,56483793],"length":1,"stats":{"Line":2}},{"line":11743,"address":[],"length":0,"stats":{"Line":0}},{"line":11744,"address":[53911665],"length":1,"stats":{"Line":1}},{"line":11745,"address":[],"length":0,"stats":{"Line":1}},{"line":11748,"address":[53911864],"length":1,"stats":{"Line":1}},{"line":11749,"address":[],"length":0,"stats":{"Line":0}},{"line":11750,"address":[],"length":0,"stats":{"Line":0}},{"line":11751,"address":[56484002],"length":1,"stats":{"Line":1}},{"line":11752,"address":[56484078,56484037,56484161],"length":1,"stats":{"Line":2}},{"line":11753,"address":[53911913],"length":1,"stats":{"Line":1}},{"line":11754,"address":[53911927,53911999],"length":1,"stats":{"Line":1}},{"line":11758,"address":[54932334,54932098,54932251],"length":1,"stats":{"Line":2}},{"line":11760,"address":[53912101],"length":1,"stats":{"Line":1}},{"line":11761,"address":[],"length":0,"stats":{"Line":0}},{"line":11762,"address":[56484243],"length":1,"stats":{"Line":1}},{"line":11765,"address":[56484412,56484342],"length":1,"stats":{"Line":1}},{"line":11767,"address":[],"length":0,"stats":{"Line":1}},{"line":11768,"address":[54744542,54744585,54744669],"length":1,"stats":{"Line":2}},{"line":11769,"address":[56484560],"length":1,"stats":{"Line":1}},{"line":11770,"address":[56484573,56484643],"length":1,"stats":{"Line":1}},{"line":11773,"address":[],"length":0,"stats":{"Line":1}},{"line":11775,"address":[],"length":0,"stats":{"Line":2}},{"line":11777,"address":[54744789],"length":1,"stats":{"Line":1}},{"line":11778,"address":[],"length":0,"stats":{"Line":0}},{"line":11779,"address":[54744804],"length":1,"stats":{"Line":1}},{"line":11782,"address":[54499024],"length":1,"stats":{"Line":1}},{"line":11783,"address":[],"length":0,"stats":{"Line":0}},{"line":11786,"address":[54745202,54745062,54745118],"length":1,"stats":{"Line":2}},{"line":11787,"address":[],"length":0,"stats":{"Line":0}},{"line":11788,"address":[54745069],"length":1,"stats":{"Line":1}},{"line":11789,"address":[53106160],"length":1,"stats":{"Line":1}},{"line":11790,"address":[56094096],"length":1,"stats":{"Line":0}},{"line":11794,"address":[53914297,53913153],"length":1,"stats":{"Line":2}},{"line":11795,"address":[],"length":0,"stats":{"Line":1}},{"line":11799,"address":[56485669,56486027,56486134],"length":1,"stats":{"Line":2}},{"line":11801,"address":[],"length":0,"stats":{"Line":1}},{"line":11802,"address":[],"length":0,"stats":{"Line":0}},{"line":11803,"address":[53913591],"length":1,"stats":{"Line":1}},{"line":11804,"address":[],"length":0,"stats":{"Line":1}},{"line":11806,"address":[54933892],"length":1,"stats":{"Line":1}},{"line":11807,"address":[54004528],"length":1,"stats":{"Line":0}},{"line":11808,"address":[],"length":0,"stats":{"Line":0}},{"line":11809,"address":[],"length":0,"stats":{"Line":0}},{"line":11815,"address":[53105392],"length":1,"stats":{"Line":1}},{"line":11816,"address":[54004176],"length":1,"stats":{"Line":0}},{"line":11821,"address":[54933430],"length":1,"stats":{"Line":1}},{"line":11826,"address":[],"length":0,"stats":{"Line":0}},{"line":11827,"address":[55284382],"length":1,"stats":{"Line":0}},{"line":11828,"address":[],"length":0,"stats":{"Line":0}},{"line":11829,"address":[54270290],"length":1,"stats":{"Line":0}},{"line":11830,"address":[55102756,55102426],"length":1,"stats":{"Line":0}},{"line":11833,"address":[],"length":0,"stats":{"Line":0}},{"line":11834,"address":[54270592,54270778,54270691,54270862,54270443],"length":1,"stats":{"Line":0}},{"line":11835,"address":[],"length":0,"stats":{"Line":0}},{"line":11836,"address":[54270461],"length":1,"stats":{"Line":0}},{"line":11837,"address":[53134768,53134784],"length":1,"stats":{"Line":0}},{"line":11840,"address":[56120560,56120574],"length":1,"stats":{"Line":0}},{"line":11843,"address":[54270953],"length":1,"stats":{"Line":0}},{"line":11844,"address":[],"length":0,"stats":{"Line":0}},{"line":11845,"address":[],"length":0,"stats":{"Line":0}},{"line":11846,"address":[56837281],"length":1,"stats":{"Line":0}},{"line":11847,"address":[54033376,54033360],"length":1,"stats":{"Line":0}},{"line":11850,"address":[55285292],"length":1,"stats":{"Line":0}},{"line":11851,"address":[],"length":0,"stats":{"Line":0}},{"line":11855,"address":[],"length":0,"stats":{"Line":0}},{"line":11856,"address":[55285405],"length":1,"stats":{"Line":0}},{"line":11861,"address":[],"length":0,"stats":{"Line":0}},{"line":11863,"address":[55103677],"length":1,"stats":{"Line":0}},{"line":11864,"address":[54271583],"length":1,"stats":{"Line":0}},{"line":11867,"address":[56837985],"length":1,"stats":{"Line":0}},{"line":11870,"address":[55103940],"length":1,"stats":{"Line":0}},{"line":11871,"address":[55104032],"length":1,"stats":{"Line":0}},{"line":11873,"address":[55104131],"length":1,"stats":{"Line":0}},{"line":11875,"address":[],"length":0,"stats":{"Line":0}},{"line":11876,"address":[55104282,55104552],"length":1,"stats":{"Line":0}},{"line":11878,"address":[55286625,55286506],"length":1,"stats":{"Line":0}},{"line":11879,"address":[55104940],"length":1,"stats":{"Line":0}},{"line":11880,"address":[55287045],"length":1,"stats":{"Line":0}},{"line":11883,"address":[55287198],"length":1,"stats":{"Line":0}},{"line":11884,"address":[],"length":0,"stats":{"Line":0}},{"line":11885,"address":[56839533],"length":1,"stats":{"Line":0}},{"line":11886,"address":[56839630],"length":1,"stats":{"Line":0}},{"line":11889,"address":[55105612],"length":1,"stats":{"Line":0}},{"line":11890,"address":[56839770],"length":1,"stats":{"Line":0}},{"line":11891,"address":[],"length":0,"stats":{"Line":0}},{"line":11893,"address":[],"length":0,"stats":{"Line":0}},{"line":11896,"address":[56839952],"length":1,"stats":{"Line":0}},{"line":11899,"address":[],"length":0,"stats":{"Line":0}},{"line":11901,"address":[55105970],"length":1,"stats":{"Line":0}},{"line":11903,"address":[55106143],"length":1,"stats":{"Line":0}},{"line":11906,"address":[],"length":0,"stats":{"Line":0}},{"line":11907,"address":[54274199],"length":1,"stats":{"Line":0}},{"line":11908,"address":[55106367],"length":1,"stats":{"Line":0}},{"line":11911,"address":[],"length":0,"stats":{"Line":0}},{"line":11912,"address":[56840600],"length":1,"stats":{"Line":0}},{"line":11913,"address":[55288529],"length":1,"stats":{"Line":0}},{"line":11915,"address":[55288586],"length":1,"stats":{"Line":0}},{"line":11916,"address":[56840791],"length":1,"stats":{"Line":0}},{"line":11917,"address":[],"length":0,"stats":{"Line":0}},{"line":11918,"address":[54274798],"length":1,"stats":{"Line":0}},{"line":11920,"address":[55288877],"length":1,"stats":{"Line":0}},{"line":11922,"address":[54274893],"length":1,"stats":{"Line":0}},{"line":11924,"address":[55289093],"length":1,"stats":{"Line":0}},{"line":11927,"address":[55107292],"length":1,"stats":{"Line":0}},{"line":11929,"address":[55289318],"length":1,"stats":{"Line":0}},{"line":11931,"address":[54275353],"length":1,"stats":{"Line":0}},{"line":11932,"address":[56841594],"length":1,"stats":{"Line":0}},{"line":11933,"address":[],"length":0,"stats":{"Line":0}},{"line":11934,"address":[55107659],"length":1,"stats":{"Line":0}},{"line":11935,"address":[],"length":0,"stats":{"Line":0}},{"line":11936,"address":[54275687],"length":1,"stats":{"Line":0}},{"line":11938,"address":[55107857],"length":1,"stats":{"Line":0}},{"line":11939,"address":[],"length":0,"stats":{"Line":0}},{"line":11943,"address":[55107944],"length":1,"stats":{"Line":0}},{"line":11947,"address":[56842032],"length":1,"stats":{"Line":0}},{"line":11948,"address":[55108104],"length":1,"stats":{"Line":0}},{"line":11952,"address":[56842411],"length":1,"stats":{"Line":0}},{"line":11953,"address":[55290291],"length":1,"stats":{"Line":0}},{"line":11954,"address":[55108461],"length":1,"stats":{"Line":0}},{"line":11956,"address":[55290395],"length":1,"stats":{"Line":0}},{"line":11957,"address":[55108601],"length":1,"stats":{"Line":0}},{"line":11958,"address":[55108708],"length":1,"stats":{"Line":0}},{"line":11960,"address":[54276654],"length":1,"stats":{"Line":0}},{"line":11961,"address":[55108795],"length":1,"stats":{"Line":0}},{"line":11962,"address":[55108907],"length":1,"stats":{"Line":0}},{"line":11963,"address":[56843057],"length":1,"stats":{"Line":0}},{"line":11965,"address":[54276950],"length":1,"stats":{"Line":0}},{"line":11968,"address":[55109083],"length":1,"stats":{"Line":0}},{"line":11970,"address":[55291115],"length":1,"stats":{"Line":0}},{"line":11973,"address":[54277262],"length":1,"stats":{"Line":0}},{"line":11974,"address":[55291285],"length":1,"stats":{"Line":0}},{"line":11976,"address":[55109658],"length":1,"stats":{"Line":0}},{"line":11977,"address":[55291575],"length":1,"stats":{"Line":0}},{"line":11978,"address":[55109902],"length":1,"stats":{"Line":0}},{"line":11981,"address":[54277902],"length":1,"stats":{"Line":0}},{"line":11984,"address":[],"length":0,"stats":{"Line":0}},{"line":11986,"address":[54278189],"length":1,"stats":{"Line":0}},{"line":11988,"address":[55110424],"length":1,"stats":{"Line":0}},{"line":11991,"address":[54278362],"length":1,"stats":{"Line":0}},{"line":11992,"address":[55292381],"length":1,"stats":{"Line":0}},{"line":11993,"address":[56844637],"length":1,"stats":{"Line":0}},{"line":11994,"address":[55292519],"length":1,"stats":{"Line":0}},{"line":11995,"address":[55110750],"length":1,"stats":{"Line":0}},{"line":11996,"address":[55292655],"length":1,"stats":{"Line":0}},{"line":11998,"address":[55292712],"length":1,"stats":{"Line":0}},{"line":11999,"address":[54278783],"length":1,"stats":{"Line":0}},{"line":12002,"address":[55292798],"length":1,"stats":{"Line":0}},{"line":12005,"address":[54272495,54278859],"length":1,"stats":{"Line":0}},{"line":12006,"address":[54278977],"length":1,"stats":{"Line":0}},{"line":12008,"address":[55111195],"length":1,"stats":{"Line":0}},{"line":12010,"address":[54279206],"length":1,"stats":{"Line":0}},{"line":12012,"address":[56845382],"length":1,"stats":{"Line":0}},{"line":12013,"address":[],"length":0,"stats":{"Line":0}},{"line":12014,"address":[56845506],"length":1,"stats":{"Line":0}},{"line":12019,"address":[56838473],"length":1,"stats":{"Line":0}},{"line":12020,"address":[55286398],"length":1,"stats":{"Line":0}},{"line":12022,"address":[55104523],"length":1,"stats":{"Line":0}},{"line":12027,"address":[54916005,54910944,54916011],"length":1,"stats":{"Line":0}},{"line":12031,"address":[53890773],"length":1,"stats":{"Line":0}},{"line":12034,"address":[53890781],"length":1,"stats":{"Line":0}},{"line":12035,"address":[54911033],"length":1,"stats":{"Line":0}},{"line":12036,"address":[54722905,54723230],"length":1,"stats":{"Line":0}},{"line":12039,"address":[56463267],"length":1,"stats":{"Line":0}},{"line":12040,"address":[],"length":0,"stats":{"Line":0}},{"line":12041,"address":[],"length":0,"stats":{"Line":0}},{"line":12042,"address":[54723047],"length":1,"stats":{"Line":0}},{"line":12043,"address":[54723156,54723243],"length":1,"stats":{"Line":0}},{"line":12046,"address":[54911506,54911568],"length":1,"stats":{"Line":0}},{"line":12050,"address":[],"length":0,"stats":{"Line":0}},{"line":12051,"address":[54911756,54911810,54911893],"length":1,"stats":{"Line":0}},{"line":12052,"address":[],"length":0,"stats":{"Line":0}},{"line":12053,"address":[56463875],"length":1,"stats":{"Line":0}},{"line":12054,"address":[53102608,53102624],"length":1,"stats":{"Line":0}},{"line":12057,"address":[53891697],"length":1,"stats":{"Line":0}},{"line":12058,"address":[],"length":0,"stats":{"Line":0}},{"line":12059,"address":[54912007],"length":1,"stats":{"Line":0}},{"line":12060,"address":[],"length":0,"stats":{"Line":0}},{"line":12063,"address":[54724028],"length":1,"stats":{"Line":0}},{"line":12065,"address":[],"length":0,"stats":{"Line":0}},{"line":12067,"address":[54912257],"length":1,"stats":{"Line":0}},{"line":12068,"address":[],"length":0,"stats":{"Line":0}},{"line":12069,"address":[54724127],"length":1,"stats":{"Line":0}},{"line":12072,"address":[56089696],"length":1,"stats":{"Line":0}},{"line":12073,"address":[53101568],"length":1,"stats":{"Line":0}},{"line":12078,"address":[],"length":0,"stats":{"Line":0}},{"line":12079,"address":[56464983,56464874],"length":1,"stats":{"Line":0}},{"line":12080,"address":[],"length":0,"stats":{"Line":0}},{"line":12083,"address":[53892923],"length":1,"stats":{"Line":0}},{"line":12084,"address":[],"length":0,"stats":{"Line":0}},{"line":12085,"address":[],"length":0,"stats":{"Line":0}},{"line":12086,"address":[56465295,56465696],"length":1,"stats":{"Line":0}},{"line":12090,"address":[54725626,54725137,54725753],"length":1,"stats":{"Line":0}},{"line":12092,"address":[54913288],"length":1,"stats":{"Line":0}},{"line":12093,"address":[],"length":0,"stats":{"Line":0}},{"line":12094,"address":[53893084],"length":1,"stats":{"Line":0}},{"line":12095,"address":[53893130],"length":1,"stats":{"Line":0}},{"line":12096,"address":[],"length":0,"stats":{"Line":0}},{"line":12097,"address":[],"length":0,"stats":{"Line":0}},{"line":12099,"address":[56465848],"length":1,"stats":{"Line":0}},{"line":12100,"address":[56089392],"length":1,"stats":{"Line":0}},{"line":12105,"address":[54913940,54914321,54914428],"length":1,"stats":{"Line":0}},{"line":12106,"address":[],"length":0,"stats":{"Line":0}},{"line":12108,"address":[],"length":0,"stats":{"Line":0}},{"line":12109,"address":[53893737],"length":1,"stats":{"Line":0}},{"line":12110,"address":[56466121],"length":1,"stats":{"Line":0}},{"line":12112,"address":[53894065],"length":1,"stats":{"Line":0}},{"line":12113,"address":[54495648],"length":1,"stats":{"Line":0}},{"line":12115,"address":[],"length":0,"stats":{"Line":0}},{"line":12116,"address":[56466642],"length":1,"stats":{"Line":0}},{"line":12117,"address":[54495952,54495968],"length":1,"stats":{"Line":0}},{"line":12120,"address":[56466808],"length":1,"stats":{"Line":0}},{"line":12122,"address":[54726654,54727142,54727015],"length":1,"stats":{"Line":0}},{"line":12124,"address":[54726669],"length":1,"stats":{"Line":0}},{"line":12125,"address":[],"length":0,"stats":{"Line":0}},{"line":12126,"address":[56466892],"length":1,"stats":{"Line":0}},{"line":12127,"address":[53894587],"length":1,"stats":{"Line":0}},{"line":12129,"address":[54495152],"length":1,"stats":{"Line":0}},{"line":12130,"address":[54495168],"length":1,"stats":{"Line":0}},{"line":12133,"address":[],"length":0,"stats":{"Line":0}},{"line":12134,"address":[],"length":0,"stats":{"Line":0}},{"line":12136,"address":[],"length":0,"stats":{"Line":0}},{"line":12137,"address":[54915305],"length":1,"stats":{"Line":0}},{"line":12138,"address":[54915347],"length":1,"stats":{"Line":0}},{"line":12140,"address":[54915597],"length":1,"stats":{"Line":0}},{"line":12141,"address":[],"length":0,"stats":{"Line":0}},{"line":12143,"address":[56467928,56467969,56468052],"length":1,"stats":{"Line":0}},{"line":12144,"address":[53895654],"length":1,"stats":{"Line":0}},{"line":12145,"address":[53895668,53895740],"length":1,"stats":{"Line":0}},{"line":12149,"address":[56464962],"length":1,"stats":{"Line":0}},{"line":12153,"address":[54004192],"length":1,"stats":{"Line":0}},{"line":12160,"address":[55022957],"length":1,"stats":{"Line":0}},{"line":12161,"address":[56575097],"length":1,"stats":{"Line":0}},{"line":12163,"address":[56575213,56575109],"length":1,"stats":{"Line":0}},{"line":12165,"address":[],"length":0,"stats":{"Line":0}},{"line":12168,"address":[],"length":0,"stats":{"Line":0}},{"line":12169,"address":[56575404],"length":1,"stats":{"Line":0}},{"line":12172,"address":[54836929],"length":1,"stats":{"Line":0}},{"line":12173,"address":[54837097],"length":1,"stats":{"Line":0}},{"line":12176,"address":[55023818,55023798,55023901],"length":1,"stats":{"Line":0}},{"line":12177,"address":[],"length":0,"stats":{"Line":0}},{"line":12178,"address":[56102000,56102014],"length":1,"stats":{"Line":0}},{"line":12179,"address":[55023955],"length":1,"stats":{"Line":0}},{"line":12180,"address":[54005347],"length":1,"stats":{"Line":0}},{"line":12181,"address":[56576167],"length":1,"stats":{"Line":0}},{"line":12182,"address":[54837559],"length":1,"stats":{"Line":0}},{"line":12183,"address":[54005497],"length":1,"stats":{"Line":0}},{"line":12186,"address":[54837654],"length":1,"stats":{"Line":0}},{"line":12187,"address":[],"length":0,"stats":{"Line":0}},{"line":12188,"address":[],"length":0,"stats":{"Line":0}},{"line":12189,"address":[],"length":0,"stats":{"Line":0}},{"line":12190,"address":[56576376,56576434,56576517],"length":1,"stats":{"Line":0}},{"line":12191,"address":[],"length":0,"stats":{"Line":0}},{"line":12192,"address":[],"length":0,"stats":{"Line":0}},{"line":12193,"address":[],"length":0,"stats":{"Line":0}},{"line":12195,"address":[],"length":0,"stats":{"Line":0}},{"line":12196,"address":[],"length":0,"stats":{"Line":0}},{"line":12197,"address":[54013840,54013856],"length":1,"stats":{"Line":0}},{"line":12200,"address":[56576755],"length":1,"stats":{"Line":0}},{"line":12201,"address":[54006027],"length":1,"stats":{"Line":0}},{"line":12202,"address":[54838291],"length":1,"stats":{"Line":0}},{"line":12203,"address":[54838470],"length":1,"stats":{"Line":0}},{"line":12204,"address":[54838528],"length":1,"stats":{"Line":0}},{"line":12205,"address":[55025069],"length":1,"stats":{"Line":0}},{"line":12209,"address":[56577228],"length":1,"stats":{"Line":0}},{"line":12210,"address":[54838604],"length":1,"stats":{"Line":0}},{"line":12211,"address":[],"length":0,"stats":{"Line":0}},{"line":12212,"address":[],"length":0,"stats":{"Line":0}},{"line":12213,"address":[55025149],"length":1,"stats":{"Line":0}},{"line":12214,"address":[54006617,54006701,54006557],"length":1,"stats":{"Line":0}},{"line":12215,"address":[],"length":0,"stats":{"Line":0}},{"line":12216,"address":[54838676],"length":1,"stats":{"Line":0}},{"line":12217,"address":[56102256,56102272],"length":1,"stats":{"Line":0}},{"line":12219,"address":[],"length":0,"stats":{"Line":0}},{"line":12220,"address":[55025408],"length":1,"stats":{"Line":0}},{"line":12224,"address":[55025455],"length":1,"stats":{"Line":0}},{"line":12225,"address":[],"length":0,"stats":{"Line":0}},{"line":12226,"address":[54007034],"length":1,"stats":{"Line":0}},{"line":12227,"address":[54839204],"length":1,"stats":{"Line":0}},{"line":12228,"address":[55025736],"length":1,"stats":{"Line":0}},{"line":12232,"address":[54839259],"length":1,"stats":{"Line":0}},{"line":12233,"address":[55025817],"length":1,"stats":{"Line":0}},{"line":12234,"address":[],"length":0,"stats":{"Line":0}},{"line":12235,"address":[56578256],"length":1,"stats":{"Line":0}},{"line":12236,"address":[55026202],"length":1,"stats":{"Line":0}},{"line":12237,"address":[],"length":0,"stats":{"Line":0}},{"line":12241,"address":[54839737],"length":1,"stats":{"Line":0}},{"line":12242,"address":[54839758],"length":1,"stats":{"Line":0}},{"line":12243,"address":[],"length":0,"stats":{"Line":0}},{"line":12244,"address":[],"length":0,"stats":{"Line":0}},{"line":12246,"address":[54007859],"length":1,"stats":{"Line":0}},{"line":12247,"address":[],"length":0,"stats":{"Line":0}},{"line":12248,"address":[54007781],"length":1,"stats":{"Line":0}},{"line":12249,"address":[55026449],"length":1,"stats":{"Line":0}},{"line":12252,"address":[54840139],"length":1,"stats":{"Line":0}},{"line":12256,"address":[54175136],"length":1,"stats":{"Line":0}},{"line":12263,"address":[55007310],"length":1,"stats":{"Line":0}},{"line":12264,"address":[55007430,55007511,55007374],"length":1,"stats":{"Line":0}},{"line":12265,"address":[],"length":0,"stats":{"Line":0}},{"line":12266,"address":[],"length":0,"stats":{"Line":0}},{"line":12267,"address":[56743391],"length":1,"stats":{"Line":0}},{"line":12268,"address":[54024496],"length":1,"stats":{"Line":0}},{"line":12273,"address":[54175454,54175594,54175675],"length":1,"stats":{"Line":0}},{"line":12275,"address":[54175469],"length":1,"stats":{"Line":0}},{"line":12276,"address":[],"length":0,"stats":{"Line":0}},{"line":12277,"address":[55191413],"length":1,"stats":{"Line":0}},{"line":12280,"address":[56743663,56743733],"length":1,"stats":{"Line":0}},{"line":12284,"address":[54175872,54175791,54175725],"length":1,"stats":{"Line":0}},{"line":12285,"address":[],"length":0,"stats":{"Line":0}},{"line":12286,"address":[56743823],"length":1,"stats":{"Line":0}},{"line":12287,"address":[54023952,54023968],"length":1,"stats":{"Line":0}},{"line":12291,"address":[54175960],"length":1,"stats":{"Line":0}},{"line":12292,"address":[55192068,55191927,55191988],"length":1,"stats":{"Line":0}},{"line":12293,"address":[],"length":0,"stats":{"Line":0}},{"line":12294,"address":[56744094],"length":1,"stats":{"Line":0}},{"line":12295,"address":[56744127,56744197],"length":1,"stats":{"Line":0}},{"line":12297,"address":[55192132,55192186,55192266],"length":1,"stats":{"Line":0}},{"line":12298,"address":[],"length":0,"stats":{"Line":0}},{"line":12299,"address":[55192139],"length":1,"stats":{"Line":0}},{"line":12300,"address":[55008358,55008430],"length":1,"stats":{"Line":0}},{"line":12302,"address":[55008521,55008660,55008579],"length":1,"stats":{"Line":0}},{"line":12303,"address":[],"length":0,"stats":{"Line":0}},{"line":12304,"address":[],"length":0,"stats":{"Line":0}},{"line":12305,"address":[],"length":0,"stats":{"Line":0}},{"line":12309,"address":[],"length":0,"stats":{"Line":0}},{"line":12311,"address":[55192603,55192741,55192821],"length":1,"stats":{"Line":0}},{"line":12313,"address":[],"length":0,"stats":{"Line":0}},{"line":12314,"address":[],"length":0,"stats":{"Line":0}},{"line":12315,"address":[55008830],"length":1,"stats":{"Line":0}},{"line":12318,"address":[54518080],"length":1,"stats":{"Line":0}},{"line":12319,"address":[54024144],"length":1,"stats":{"Line":0}},{"line":12322,"address":[55009079,55009216,55009135],"length":1,"stats":{"Line":0}},{"line":12323,"address":[],"length":0,"stats":{"Line":0}},{"line":12324,"address":[55009086],"length":1,"stats":{"Line":0}},{"line":12325,"address":[54177073,54177001],"length":1,"stats":{"Line":0}},{"line":12329,"address":[],"length":0,"stats":{"Line":0}},{"line":12331,"address":[54177169],"length":1,"stats":{"Line":0}},{"line":12332,"address":[],"length":0,"stats":{"Line":0}},{"line":12333,"address":[],"length":0,"stats":{"Line":0}},{"line":12336,"address":[55193135],"length":1,"stats":{"Line":0}},{"line":12337,"address":[53125552],"length":1,"stats":{"Line":0}},{"line":12342,"address":[56745445,56745509,56745589],"length":1,"stats":{"Line":0}},{"line":12343,"address":[],"length":0,"stats":{"Line":0}},{"line":12344,"address":[54177395],"length":1,"stats":{"Line":0}},{"line":12345,"address":[53126080,53126064],"length":1,"stats":{"Line":0}},{"line":12347,"address":[55009704],"length":1,"stats":{"Line":0}},{"line":12352,"address":[56826640],"length":1,"stats":{"Line":0}},{"line":12358,"address":[],"length":0,"stats":{"Line":0}},{"line":12359,"address":[55093281,55092647,55092509],"length":1,"stats":{"Line":0}},{"line":12361,"address":[54260551,54260617,54260776],"length":1,"stats":{"Line":0}},{"line":12362,"address":[],"length":0,"stats":{"Line":0}},{"line":12363,"address":[54031488],"length":1,"stats":{"Line":0}},{"line":12364,"address":[53132736],"length":1,"stats":{"Line":0}},{"line":12368,"address":[],"length":0,"stats":{"Line":0}},{"line":12369,"address":[56827387],"length":1,"stats":{"Line":0}},{"line":12372,"address":[54261174,54260458],"length":1,"stats":{"Line":0}},{"line":12373,"address":[54261268],"length":1,"stats":{"Line":0}},{"line":12377,"address":[54261541,54261414,54260852,54262035],"length":1,"stats":{"Line":0}},{"line":12378,"address":[55275710],"length":1,"stats":{"Line":0}},{"line":12380,"address":[54261553,54261797],"length":1,"stats":{"Line":0}},{"line":12381,"address":[55094003],"length":1,"stats":{"Line":0}},{"line":12385,"address":[55275806],"length":1,"stats":{"Line":0}},{"line":12386,"address":[55093850,55094183,55093789],"length":1,"stats":{"Line":0}},{"line":12387,"address":[],"length":0,"stats":{"Line":0}},{"line":12388,"address":[54261684],"length":1,"stats":{"Line":0}},{"line":12389,"address":[54523744],"length":1,"stats":{"Line":0}},{"line":12390,"address":[],"length":0,"stats":{"Line":0}},{"line":12394,"address":[56828468],"length":1,"stats":{"Line":0}},{"line":12396,"address":[55276344,55276562,55276482],"length":1,"stats":{"Line":0}},{"line":12398,"address":[54262190],"length":1,"stats":{"Line":0}},{"line":12399,"address":[],"length":0,"stats":{"Line":0}},{"line":12400,"address":[],"length":0,"stats":{"Line":0}},{"line":12403,"address":[53133072],"length":1,"stats":{"Line":0}},{"line":12404,"address":[54031856],"length":1,"stats":{"Line":0}},{"line":12407,"address":[55276667,55276747,55276613],"length":1,"stats":{"Line":0}},{"line":12408,"address":[],"length":0,"stats":{"Line":0}},{"line":12409,"address":[],"length":0,"stats":{"Line":0}},{"line":12410,"address":[56118384,56118400],"length":1,"stats":{"Line":0}},{"line":12414,"address":[55094744,55094847,55094928],"length":1,"stats":{"Line":0}},{"line":12416,"address":[56828979],"length":1,"stats":{"Line":0}},{"line":12417,"address":[],"length":0,"stats":{"Line":0}},{"line":12418,"address":[56828986],"length":1,"stats":{"Line":0}},{"line":12421,"address":[],"length":0,"stats":{"Line":0}},{"line":12422,"address":[56119200],"length":1,"stats":{"Line":0}},{"line":12427,"address":[55277084,55277020,55277164],"length":1,"stats":{"Line":0}},{"line":12428,"address":[],"length":0,"stats":{"Line":0}},{"line":12429,"address":[55094985],"length":1,"stats":{"Line":0}},{"line":12430,"address":[54262979,54262907],"length":1,"stats":{"Line":0}},{"line":12432,"address":[],"length":0,"stats":{"Line":0}},{"line":12437,"address":[55002816],"length":1,"stats":{"Line":0}},{"line":12442,"address":[55002903],"length":1,"stats":{"Line":0}},{"line":12445,"address":[55002947],"length":1,"stats":{"Line":0}},{"line":12446,"address":[55186898],"length":1,"stats":{"Line":0}},{"line":12447,"address":[54170975,54171031,54171115],"length":1,"stats":{"Line":0}},{"line":12448,"address":[],"length":0,"stats":{"Line":0}},{"line":12449,"address":[],"length":0,"stats":{"Line":0}},{"line":12450,"address":[54023600],"length":1,"stats":{"Line":0}},{"line":12451,"address":[56111296],"length":1,"stats":{"Line":0}},{"line":12455,"address":[54171181],"length":1,"stats":{"Line":0}},{"line":12456,"address":[],"length":0,"stats":{"Line":0}},{"line":12457,"address":[56739344],"length":1,"stats":{"Line":0}},{"line":12459,"address":[],"length":0,"stats":{"Line":0}},{"line":12460,"address":[],"length":0,"stats":{"Line":0}},{"line":12461,"address":[54171265],"length":1,"stats":{"Line":0}},{"line":12466,"address":[55003484],"length":1,"stats":{"Line":0}},{"line":12467,"address":[54171543],"length":1,"stats":{"Line":0}},{"line":12470,"address":[55003807],"length":1,"stats":{"Line":0}},{"line":12471,"address":[],"length":0,"stats":{"Line":0}},{"line":12472,"address":[],"length":0,"stats":{"Line":0}},{"line":12474,"address":[],"length":0,"stats":{"Line":0}},{"line":12475,"address":[55187781],"length":1,"stats":{"Line":0}},{"line":12479,"address":[55003971],"length":1,"stats":{"Line":0}},{"line":12480,"address":[55187886],"length":1,"stats":{"Line":0}},{"line":12481,"address":[54171946],"length":1,"stats":{"Line":0}},{"line":12482,"address":[55004105],"length":1,"stats":{"Line":0}},{"line":12483,"address":[56740184],"length":1,"stats":{"Line":0}},{"line":12485,"address":[54172084],"length":1,"stats":{"Line":0}},{"line":12486,"address":[],"length":0,"stats":{"Line":0}},{"line":12487,"address":[56740238],"length":1,"stats":{"Line":0}},{"line":12489,"address":[54172181],"length":1,"stats":{"Line":0}},{"line":12491,"address":[56740379],"length":1,"stats":{"Line":0}},{"line":12492,"address":[],"length":0,"stats":{"Line":0}},{"line":12493,"address":[54172243],"length":1,"stats":{"Line":0}},{"line":12494,"address":[],"length":0,"stats":{"Line":0}},{"line":12495,"address":[],"length":0,"stats":{"Line":0}},{"line":12496,"address":[56740439],"length":1,"stats":{"Line":0}},{"line":12497,"address":[],"length":0,"stats":{"Line":0}},{"line":12498,"address":[55188387],"length":1,"stats":{"Line":0}},{"line":12499,"address":[56740603],"length":1,"stats":{"Line":0}},{"line":12500,"address":[],"length":0,"stats":{"Line":0}},{"line":12501,"address":[56740607],"length":1,"stats":{"Line":0}},{"line":12503,"address":[],"length":0,"stats":{"Line":0}},{"line":12504,"address":[55004686],"length":1,"stats":{"Line":0}},{"line":12506,"address":[56740742],"length":1,"stats":{"Line":0}},{"line":12507,"address":[],"length":0,"stats":{"Line":0}},{"line":12508,"address":[54172613],"length":1,"stats":{"Line":0}},{"line":12511,"address":[55004827],"length":1,"stats":{"Line":0}},{"line":12512,"address":[],"length":0,"stats":{"Line":0}},{"line":12513,"address":[],"length":0,"stats":{"Line":0}},{"line":12515,"address":[55188787],"length":1,"stats":{"Line":0}},{"line":12516,"address":[55004931],"length":1,"stats":{"Line":0}},{"line":12519,"address":[55004982],"length":1,"stats":{"Line":0}},{"line":12522,"address":[55005019],"length":1,"stats":{"Line":0}},{"line":12523,"address":[],"length":0,"stats":{"Line":0}},{"line":12525,"address":[],"length":0,"stats":{"Line":0}},{"line":12526,"address":[],"length":0,"stats":{"Line":0}},{"line":12527,"address":[56741065],"length":1,"stats":{"Line":0}},{"line":12528,"address":[55188931],"length":1,"stats":{"Line":0}},{"line":12533,"address":[],"length":0,"stats":{"Line":0}},{"line":12535,"address":[56741221],"length":1,"stats":{"Line":0}},{"line":12536,"address":[],"length":0,"stats":{"Line":0}},{"line":12537,"address":[],"length":0,"stats":{"Line":0}},{"line":12542,"address":[56741359],"length":1,"stats":{"Line":0}},{"line":12543,"address":[],"length":0,"stats":{"Line":0}},{"line":12545,"address":[],"length":0,"stats":{"Line":0}},{"line":12546,"address":[55005361],"length":1,"stats":{"Line":0}},{"line":12550,"address":[56741498],"length":1,"stats":{"Line":0}},{"line":12551,"address":[],"length":0,"stats":{"Line":0}},{"line":12552,"address":[55005494],"length":1,"stats":{"Line":0}},{"line":12556,"address":[],"length":0,"stats":{"Line":0}},{"line":12557,"address":[55189618],"length":1,"stats":{"Line":0}},{"line":12559,"address":[54173821],"length":1,"stats":{"Line":0}},{"line":12560,"address":[],"length":0,"stats":{"Line":0}},{"line":12561,"address":[56741948],"length":1,"stats":{"Line":0}},{"line":12563,"address":[54173911],"length":1,"stats":{"Line":0}},{"line":12564,"address":[],"length":0,"stats":{"Line":0}},{"line":12565,"address":[55006030],"length":1,"stats":{"Line":0}},{"line":12567,"address":[56742110],"length":1,"stats":{"Line":0}},{"line":12568,"address":[],"length":0,"stats":{"Line":0}},{"line":12569,"address":[55006113],"length":1,"stats":{"Line":0}},{"line":12572,"address":[55190038],"length":1,"stats":{"Line":0}},{"line":12573,"address":[],"length":0,"stats":{"Line":0}},{"line":12577,"address":[54174142],"length":1,"stats":{"Line":0}},{"line":12578,"address":[54174176],"length":1,"stats":{"Line":0}},{"line":12579,"address":[],"length":0,"stats":{"Line":0}},{"line":12580,"address":[54174183],"length":1,"stats":{"Line":0}},{"line":12583,"address":[55006367],"length":1,"stats":{"Line":0}},{"line":12585,"address":[55006382],"length":1,"stats":{"Line":0}},{"line":12586,"address":[],"length":0,"stats":{"Line":0}},{"line":12587,"address":[55006412],"length":1,"stats":{"Line":0}},{"line":12592,"address":[54174401],"length":1,"stats":{"Line":0}},{"line":12593,"address":[],"length":0,"stats":{"Line":0}},{"line":12595,"address":[],"length":0,"stats":{"Line":0}},{"line":12596,"address":[55006528],"length":1,"stats":{"Line":0}},{"line":12600,"address":[55190474],"length":1,"stats":{"Line":0}},{"line":12601,"address":[],"length":0,"stats":{"Line":0}},{"line":12602,"address":[55006649],"length":1,"stats":{"Line":0}},{"line":12604,"address":[54174627],"length":1,"stats":{"Line":0}},{"line":12605,"address":[],"length":0,"stats":{"Line":0}},{"line":12608,"address":[55190685],"length":1,"stats":{"Line":0}},{"line":12609,"address":[54174777],"length":1,"stats":{"Line":0}},{"line":12610,"address":[55190799],"length":1,"stats":{"Line":0}},{"line":12611,"address":[55007029],"length":1,"stats":{"Line":0}},{"line":12614,"address":[54174975],"length":1,"stats":{"Line":0}},{"line":12615,"address":[55190938],"length":1,"stats":{"Line":0}},{"line":12616,"address":[],"length":0,"stats":{"Line":0}},{"line":12617,"address":[56743108],"length":1,"stats":{"Line":0}},{"line":12619,"address":[56743188],"length":1,"stats":{"Line":0}},{"line":12623,"address":[55158608],"length":1,"stats":{"Line":0}},{"line":12631,"address":[56710877],"length":1,"stats":{"Line":0}},{"line":12632,"address":[55158745],"length":1,"stats":{"Line":0}},{"line":12634,"address":[54974437,54974545],"length":1,"stats":{"Line":0}},{"line":12635,"address":[55158930],"length":1,"stats":{"Line":0}},{"line":12639,"address":[],"length":0,"stats":{"Line":0}},{"line":12640,"address":[],"length":0,"stats":{"Line":0}},{"line":12641,"address":[56711408],"length":1,"stats":{"Line":0}},{"line":12644,"address":[55159441],"length":1,"stats":{"Line":0}},{"line":12647,"address":[],"length":0,"stats":{"Line":0}},{"line":12650,"address":[55159757],"length":1,"stats":{"Line":0}},{"line":12651,"address":[54975502,54975642,54975558],"length":1,"stats":{"Line":0}},{"line":12652,"address":[],"length":0,"stats":{"Line":0}},{"line":12653,"address":[55159819],"length":1,"stats":{"Line":0}},{"line":12654,"address":[56712005],"length":1,"stats":{"Line":0}},{"line":12655,"address":[56109664],"length":1,"stats":{"Line":0}},{"line":12660,"address":[54143725,54143585,54143809],"length":1,"stats":{"Line":0}},{"line":12662,"address":[54143600],"length":1,"stats":{"Line":0}},{"line":12663,"address":[],"length":0,"stats":{"Line":0}},{"line":12664,"address":[56712190],"length":1,"stats":{"Line":0}},{"line":12667,"address":[56712350,56712280],"length":1,"stats":{"Line":0}},{"line":12671,"address":[55160273,55160420,55160337],"length":1,"stats":{"Line":0}},{"line":12672,"address":[],"length":0,"stats":{"Line":0}},{"line":12673,"address":[55160283],"length":1,"stats":{"Line":0}},{"line":12674,"address":[54022736,54022720],"length":1,"stats":{"Line":0}},{"line":12678,"address":[56712667],"length":1,"stats":{"Line":0}},{"line":12679,"address":[56712771,56712854,56712710],"length":1,"stats":{"Line":0}},{"line":12680,"address":[],"length":0,"stats":{"Line":0}},{"line":12681,"address":[55160557],"length":1,"stats":{"Line":0}},{"line":12682,"address":[55160590,55160660],"length":1,"stats":{"Line":0}},{"line":12684,"address":[54144352,54144492,54144408],"length":1,"stats":{"Line":0}},{"line":12685,"address":[],"length":0,"stats":{"Line":0}},{"line":12686,"address":[54976471],"length":1,"stats":{"Line":0}},{"line":12687,"address":[54976570,54976498],"length":1,"stats":{"Line":0}},{"line":12689,"address":[],"length":0,"stats":{"Line":0}},{"line":12690,"address":[],"length":0,"stats":{"Line":0}},{"line":12691,"address":[56713121],"length":1,"stats":{"Line":0}},{"line":12692,"address":[55160989,55161059],"length":1,"stats":{"Line":0}},{"line":12696,"address":[],"length":0,"stats":{"Line":0}},{"line":12698,"address":[54976949,54977173,54977089],"length":1,"stats":{"Line":0}},{"line":12700,"address":[55161250],"length":1,"stats":{"Line":0}},{"line":12701,"address":[],"length":0,"stats":{"Line":0}},{"line":12702,"address":[55161262],"length":1,"stats":{"Line":0}},{"line":12705,"address":[55161352],"length":1,"stats":{"Line":0}},{"line":12706,"address":[],"length":0,"stats":{"Line":0}},{"line":12709,"address":[55161564,55161510,55161647],"length":1,"stats":{"Line":0}},{"line":12710,"address":[],"length":0,"stats":{"Line":0}},{"line":12711,"address":[56713677],"length":1,"stats":{"Line":0}},{"line":12712,"address":[56713703,56713773],"length":1,"stats":{"Line":0}},{"line":12716,"address":[54977423,54977518,54977602],"length":1,"stats":{"Line":0}},{"line":12718,"address":[54145321],"length":1,"stats":{"Line":0}},{"line":12719,"address":[],"length":0,"stats":{"Line":0}},{"line":12720,"address":[54145328],"length":1,"stats":{"Line":0}},{"line":12723,"address":[54515168],"length":1,"stats":{"Line":0}},{"line":12724,"address":[54022208],"length":1,"stats":{"Line":0}},{"line":12729,"address":[55161983,55161942,55162066],"length":1,"stats":{"Line":0}},{"line":12730,"address":[],"length":0,"stats":{"Line":0}},{"line":12731,"address":[54515344,54515328],"length":1,"stats":{"Line":0}},{"line":12734,"address":[],"length":0,"stats":{"Line":0}},{"line":12738,"address":[55142320],"length":1,"stats":{"Line":0}},{"line":12745,"address":[56877027,56875879],"length":1,"stats":{"Line":0}},{"line":12746,"address":[56876105,56876778,56875954],"length":1,"stats":{"Line":0}},{"line":12748,"address":[55142720,55142654,55142897],"length":1,"stats":{"Line":0}},{"line":12749,"address":[],"length":0,"stats":{"Line":0}},{"line":12750,"address":[],"length":0,"stats":{"Line":0}},{"line":12751,"address":[54527056],"length":1,"stats":{"Line":0}},{"line":12755,"address":[55143073,55142791],"length":1,"stats":{"Line":0}},{"line":12756,"address":[54311058],"length":1,"stats":{"Line":0}},{"line":12759,"address":[55143322,55142555],"length":1,"stats":{"Line":0}},{"line":12760,"address":[55324706],"length":1,"stats":{"Line":0}},{"line":12764,"address":[54311462,54310873,54311592,54312116],"length":1,"stats":{"Line":0}},{"line":12765,"address":[54311584],"length":1,"stats":{"Line":0}},{"line":12767,"address":[55325258,55325003],"length":1,"stats":{"Line":0}},{"line":12768,"address":[55325357],"length":1,"stats":{"Line":0}},{"line":12772,"address":[55143802],"length":1,"stats":{"Line":0}},{"line":12773,"address":[55325200,55325541,55325138],"length":1,"stats":{"Line":0}},{"line":12774,"address":[],"length":0,"stats":{"Line":0}},{"line":12775,"address":[],"length":0,"stats":{"Line":0}},{"line":12776,"address":[55143900],"length":1,"stats":{"Line":0}},{"line":12777,"address":[53136384],"length":1,"stats":{"Line":0}},{"line":12782,"address":[55325639,55325695],"length":1,"stats":{"Line":0}},{"line":12783,"address":[],"length":0,"stats":{"Line":0}},{"line":12784,"address":[],"length":0,"stats":{"Line":0}},{"line":12785,"address":[],"length":0,"stats":{"Line":0}},{"line":12791,"address":[55325825],"length":1,"stats":{"Line":0}},{"line":12792,"address":[56878045],"length":1,"stats":{"Line":0}},{"line":12794,"address":[56878102],"length":1,"stats":{"Line":0}},{"line":12795,"address":[55144664],"length":1,"stats":{"Line":0}},{"line":12798,"address":[54312662],"length":1,"stats":{"Line":0}},{"line":12799,"address":[],"length":0,"stats":{"Line":0}},{"line":12800,"address":[],"length":0,"stats":{"Line":0}},{"line":12802,"address":[55326129],"length":1,"stats":{"Line":0}},{"line":12803,"address":[],"length":0,"stats":{"Line":0}},{"line":12804,"address":[56878312],"length":1,"stats":{"Line":0}},{"line":12807,"address":[],"length":0,"stats":{"Line":0}},{"line":12808,"address":[],"length":0,"stats":{"Line":0}},{"line":12812,"address":[55326327],"length":1,"stats":{"Line":0}},{"line":12813,"address":[55145152],"length":1,"stats":{"Line":0}},{"line":12815,"address":[55326552],"length":1,"stats":{"Line":0}},{"line":12816,"address":[55326469,55326517],"length":1,"stats":{"Line":0}},{"line":12817,"address":[],"length":0,"stats":{"Line":0}},{"line":12818,"address":[54313107,54313151],"length":1,"stats":{"Line":0}},{"line":12823,"address":[54312332,54313188],"length":1,"stats":{"Line":0}},{"line":12826,"address":[55326671],"length":1,"stats":{"Line":0}},{"line":12828,"address":[56879043,56879126,56878902],"length":1,"stats":{"Line":0}},{"line":12830,"address":[],"length":0,"stats":{"Line":0}},{"line":12831,"address":[],"length":0,"stats":{"Line":0}},{"line":12832,"address":[],"length":0,"stats":{"Line":0}},{"line":12835,"address":[54527200],"length":1,"stats":{"Line":0}},{"line":12836,"address":[54527216],"length":1,"stats":{"Line":0}},{"line":12839,"address":[54313775,54313691,54313635],"length":1,"stats":{"Line":0}},{"line":12840,"address":[],"length":0,"stats":{"Line":0}},{"line":12841,"address":[54313642],"length":1,"stats":{"Line":0}},{"line":12842,"address":[56879213,56879283],"length":1,"stats":{"Line":0}},{"line":12846,"address":[55146040,55145937,55146124],"length":1,"stats":{"Line":0}},{"line":12848,"address":[55327200],"length":1,"stats":{"Line":0}},{"line":12849,"address":[],"length":0,"stats":{"Line":0}},{"line":12850,"address":[55327207],"length":1,"stats":{"Line":0}},{"line":12853,"address":[54035312],"length":1,"stats":{"Line":0}},{"line":12854,"address":[],"length":0,"stats":{"Line":0}},{"line":12859,"address":[55146227,55146184,55146311],"length":1,"stats":{"Line":0}},{"line":12860,"address":[54314079],"length":1,"stats":{"Line":0}},{"line":12861,"address":[54314165,54314093],"length":1,"stats":{"Line":0}},{"line":12864,"address":[55327616],"length":1,"stats":{"Line":0}},{"line":12868,"address":[55066000],"length":1,"stats":{"Line":0}},{"line":12874,"address":[],"length":0,"stats":{"Line":0}},{"line":12875,"address":[55066277,55066193,55066137],"length":1,"stats":{"Line":0}},{"line":12876,"address":[],"length":0,"stats":{"Line":0}},{"line":12877,"address":[55248464],"length":1,"stats":{"Line":0}},{"line":12878,"address":[55066171],"length":1,"stats":{"Line":0}},{"line":12879,"address":[54521200],"length":1,"stats":{"Line":0}},{"line":12883,"address":[54234363,54234447,54234534,54234618,54234220],"length":1,"stats":{"Line":0}},{"line":12884,"address":[],"length":0,"stats":{"Line":0}},{"line":12885,"address":[],"length":0,"stats":{"Line":0}},{"line":12886,"address":[56116416,56116400],"length":1,"stats":{"Line":0}},{"line":12889,"address":[54030272,54030286],"length":1,"stats":{"Line":0}},{"line":12893,"address":[],"length":0,"stats":{"Line":0}},{"line":12894,"address":[],"length":0,"stats":{"Line":0}},{"line":12895,"address":[],"length":0,"stats":{"Line":0}},{"line":12896,"address":[55249180],"length":1,"stats":{"Line":0}},{"line":12897,"address":[53130640,53130624],"length":1,"stats":{"Line":0}},{"line":12899,"address":[55067135,55067219,55067079],"length":1,"stats":{"Line":0}},{"line":12900,"address":[],"length":0,"stats":{"Line":0}},{"line":12901,"address":[56801567],"length":1,"stats":{"Line":0}},{"line":12902,"address":[54028688,54028704],"length":1,"stats":{"Line":0}},{"line":12904,"address":[55249639,55249722,55249583],"length":1,"stats":{"Line":0}},{"line":12905,"address":[],"length":0,"stats":{"Line":0}},{"line":12906,"address":[56801766],"length":1,"stats":{"Line":0}},{"line":12907,"address":[56801864,56801794],"length":1,"stats":{"Line":0}},{"line":12911,"address":[55067512],"length":1,"stats":{"Line":0}},{"line":12912,"address":[54235576,54235831,54235747,54235660,54235439],"length":1,"stats":{"Line":0}},{"line":12913,"address":[],"length":0,"stats":{"Line":0}},{"line":12914,"address":[],"length":0,"stats":{"Line":0}},{"line":12915,"address":[56802139,56802209],"length":1,"stats":{"Line":0}},{"line":12918,"address":[54235733,54235797],"length":1,"stats":{"Line":0}},{"line":12923,"address":[55250321,55250439,55250522],"length":1,"stats":{"Line":0}},{"line":12924,"address":[],"length":0,"stats":{"Line":0}},{"line":12925,"address":[54521664],"length":1,"stats":{"Line":0}},{"line":12926,"address":[54028256],"length":1,"stats":{"Line":0}},{"line":12931,"address":[54236178,54236264,54236348],"length":1,"stats":{"Line":0}},{"line":12932,"address":[],"length":0,"stats":{"Line":0}},{"line":12933,"address":[54236193],"length":1,"stats":{"Line":0}},{"line":12934,"address":[56115824,56115840],"length":1,"stats":{"Line":0}},{"line":12937,"address":[56803030,56803113,56802989],"length":1,"stats":{"Line":0}},{"line":12938,"address":[55068538],"length":1,"stats":{"Line":0}},{"line":12939,"address":[54521344,54521360],"length":1,"stats":{"Line":0}},{"line":12943,"address":[54236749,54236833,54236596],"length":1,"stats":{"Line":0}},{"line":12945,"address":[56803177],"length":1,"stats":{"Line":0}},{"line":12946,"address":[],"length":0,"stats":{"Line":0}},{"line":12947,"address":[55068748],"length":1,"stats":{"Line":0}},{"line":12950,"address":[54236727],"length":1,"stats":{"Line":0}},{"line":12951,"address":[54029760],"length":1,"stats":{"Line":0}},{"line":12954,"address":[55251274],"length":1,"stats":{"Line":0}},{"line":12955,"address":[54237063,54236936,54236979],"length":1,"stats":{"Line":0}},{"line":12956,"address":[55251329],"length":1,"stats":{"Line":0}},{"line":12957,"address":[54029920,54029936],"length":1,"stats":{"Line":0}},{"line":12960,"address":[55069235],"length":1,"stats":{"Line":0}},{"line":12966,"address":[56246960],"length":1,"stats":{"Line":0}},{"line":12968,"address":[54695001,54694887],"length":1,"stats":{"Line":0}},{"line":12969,"address":[54504544],"length":1,"stats":{"Line":0}},{"line":12973,"address":[],"length":0,"stats":{"Line":0}},{"line":12974,"address":[],"length":0,"stats":{"Line":0}},{"line":12975,"address":[54504700],"length":1,"stats":{"Line":0}},{"line":12979,"address":[56247231],"length":1,"stats":{"Line":0}},{"line":12982,"address":[],"length":0,"stats":{"Line":0}},{"line":12983,"address":[],"length":0,"stats":{"Line":0}},{"line":12985,"address":[],"length":0,"stats":{"Line":0}},{"line":12986,"address":[54504828],"length":1,"stats":{"Line":0}},{"line":12992,"address":[],"length":0,"stats":{"Line":0}},{"line":12994,"address":[56247422],"length":1,"stats":{"Line":0}},{"line":12995,"address":[53672862],"length":1,"stats":{"Line":0}},{"line":13001,"address":[53673043],"length":1,"stats":{"Line":0}},{"line":13002,"address":[],"length":0,"stats":{"Line":0}},{"line":13003,"address":[54695509],"length":1,"stats":{"Line":0}},{"line":13005,"address":[56247691],"length":1,"stats":{"Line":0}},{"line":13006,"address":[],"length":0,"stats":{"Line":0}},{"line":13007,"address":[54505244],"length":1,"stats":{"Line":0}},{"line":13012,"address":[54505342],"length":1,"stats":{"Line":0}},{"line":13013,"address":[],"length":0,"stats":{"Line":0}},{"line":13014,"address":[56247804],"length":1,"stats":{"Line":0}},{"line":13016,"address":[54695765],"length":1,"stats":{"Line":0}},{"line":13017,"address":[],"length":0,"stats":{"Line":0}},{"line":13018,"address":[],"length":0,"stats":{"Line":0}},{"line":13023,"address":[],"length":0,"stats":{"Line":0}},{"line":13024,"address":[56248020],"length":1,"stats":{"Line":0}},{"line":13026,"address":[54505626],"length":1,"stats":{"Line":0}},{"line":13027,"address":[],"length":0,"stats":{"Line":0}},{"line":13028,"address":[54505633],"length":1,"stats":{"Line":0}},{"line":13030,"address":[54696058],"length":1,"stats":{"Line":0}},{"line":13031,"address":[],"length":0,"stats":{"Line":0}},{"line":13032,"address":[54696065],"length":1,"stats":{"Line":0}},{"line":13034,"address":[53673691],"length":1,"stats":{"Line":0}},{"line":13035,"address":[],"length":0,"stats":{"Line":0}},{"line":13036,"address":[53673698],"length":1,"stats":{"Line":0}},{"line":13039,"address":[54696218],"length":1,"stats":{"Line":0}},{"line":13043,"address":[],"length":0,"stats":{"Line":0}},{"line":13045,"address":[56307511,56307625],"length":1,"stats":{"Line":0}},{"line":13046,"address":[56307520],"length":1,"stats":{"Line":0}},{"line":13050,"address":[54755557],"length":1,"stats":{"Line":0}},{"line":13051,"address":[],"length":0,"stats":{"Line":0}},{"line":13052,"address":[],"length":0,"stats":{"Line":0}},{"line":13056,"address":[54566145],"length":1,"stats":{"Line":0}},{"line":13059,"address":[56307789],"length":1,"stats":{"Line":0}},{"line":13060,"address":[],"length":0,"stats":{"Line":0}},{"line":13062,"address":[],"length":0,"stats":{"Line":0}},{"line":13063,"address":[],"length":0,"stats":{"Line":0}},{"line":13069,"address":[54566325],"length":1,"stats":{"Line":0}},{"line":13071,"address":[54755823],"length":1,"stats":{"Line":0}},{"line":13072,"address":[54755835],"length":1,"stats":{"Line":0}},{"line":13078,"address":[53734420],"length":1,"stats":{"Line":0}},{"line":13079,"address":[],"length":0,"stats":{"Line":0}},{"line":13080,"address":[53734427],"length":1,"stats":{"Line":0}},{"line":13082,"address":[54566611],"length":1,"stats":{"Line":0}},{"line":13083,"address":[],"length":0,"stats":{"Line":0}},{"line":13084,"address":[53734509],"length":1,"stats":{"Line":0}},{"line":13089,"address":[],"length":0,"stats":{"Line":0}},{"line":13090,"address":[],"length":0,"stats":{"Line":0}},{"line":13091,"address":[56308317],"length":1,"stats":{"Line":0}},{"line":13093,"address":[],"length":0,"stats":{"Line":0}},{"line":13094,"address":[],"length":0,"stats":{"Line":0}},{"line":13095,"address":[53734699],"length":1,"stats":{"Line":0}},{"line":13100,"address":[],"length":0,"stats":{"Line":0}},{"line":13101,"address":[],"length":0,"stats":{"Line":0}},{"line":13102,"address":[],"length":0,"stats":{"Line":0}},{"line":13103,"address":[54756428],"length":1,"stats":{"Line":0}},{"line":13105,"address":[54567028],"length":1,"stats":{"Line":0}},{"line":13106,"address":[],"length":0,"stats":{"Line":0}},{"line":13107,"address":[],"length":0,"stats":{"Line":0}},{"line":13110,"address":[54567110],"length":1,"stats":{"Line":0}},{"line":13114,"address":[56262160],"length":1,"stats":{"Line":0}},{"line":13119,"address":[53687889],"length":1,"stats":{"Line":0}},{"line":13120,"address":[],"length":0,"stats":{"Line":0}},{"line":13121,"address":[],"length":0,"stats":{"Line":0}},{"line":13122,"address":[54710161],"length":1,"stats":{"Line":0}},{"line":13127,"address":[54520233,54520119],"length":1,"stats":{"Line":0}},{"line":13128,"address":[54710254],"length":1,"stats":{"Line":0}},{"line":13132,"address":[54710403],"length":1,"stats":{"Line":0}},{"line":13137,"address":[56262589],"length":1,"stats":{"Line":0}},{"line":13138,"address":[56262630],"length":1,"stats":{"Line":0}},{"line":13140,"address":[54520445],"length":1,"stats":{"Line":0}},{"line":13141,"address":[],"length":0,"stats":{"Line":0}},{"line":13142,"address":[54520452],"length":1,"stats":{"Line":0}},{"line":13144,"address":[53688419],"length":1,"stats":{"Line":0}},{"line":13145,"address":[],"length":0,"stats":{"Line":0}},{"line":13146,"address":[54520538],"length":1,"stats":{"Line":0}},{"line":13148,"address":[],"length":0,"stats":{"Line":0}},{"line":13149,"address":[],"length":0,"stats":{"Line":0}},{"line":13150,"address":[54520617],"length":1,"stats":{"Line":0}},{"line":13154,"address":[],"length":0,"stats":{"Line":0}},{"line":13155,"address":[],"length":0,"stats":{"Line":0}},{"line":13156,"address":[54520703],"length":1,"stats":{"Line":0}},{"line":13158,"address":[54710896],"length":1,"stats":{"Line":0}},{"line":13160,"address":[54710954],"length":1,"stats":{"Line":0}},{"line":13161,"address":[],"length":0,"stats":{"Line":0}},{"line":13162,"address":[54520847],"length":1,"stats":{"Line":0}},{"line":13164,"address":[],"length":0,"stats":{"Line":0}},{"line":13167,"address":[54711087],"length":1,"stats":{"Line":0}},{"line":13168,"address":[],"length":0,"stats":{"Line":0}},{"line":13170,"address":[],"length":0,"stats":{"Line":0}},{"line":13171,"address":[53688879],"length":1,"stats":{"Line":0}},{"line":13177,"address":[56263329],"length":1,"stats":{"Line":0}},{"line":13178,"address":[],"length":0,"stats":{"Line":0}},{"line":13180,"address":[56263346],"length":1,"stats":{"Line":0}},{"line":13184,"address":[56263409],"length":1,"stats":{"Line":0}},{"line":13186,"address":[54711314],"length":1,"stats":{"Line":0}},{"line":13187,"address":[56263441],"length":1,"stats":{"Line":0}},{"line":13193,"address":[],"length":0,"stats":{"Line":0}},{"line":13199,"address":[53967344],"length":1,"stats":{"Line":0}},{"line":13204,"address":[54986663],"length":1,"stats":{"Line":0}},{"line":13206,"address":[53967463],"length":1,"stats":{"Line":0}},{"line":13207,"address":[54799600],"length":1,"stats":{"Line":0}},{"line":13208,"address":[],"length":0,"stats":{"Line":0}},{"line":13209,"address":[54799607],"length":1,"stats":{"Line":0}},{"line":13212,"address":[],"length":0,"stats":{"Line":0}},{"line":13213,"address":[54799765],"length":1,"stats":{"Line":0}},{"line":13214,"address":[],"length":0,"stats":{"Line":0}},{"line":13215,"address":[],"length":0,"stats":{"Line":0}},{"line":13219,"address":[],"length":0,"stats":{"Line":0}},{"line":13220,"address":[54799875],"length":1,"stats":{"Line":0}},{"line":13222,"address":[53967781],"length":1,"stats":{"Line":0}},{"line":13223,"address":[54799908],"length":1,"stats":{"Line":0}},{"line":13230,"address":[53967988],"length":1,"stats":{"Line":0}},{"line":13231,"address":[54987286],"length":1,"stats":{"Line":0}},{"line":13232,"address":[],"length":0,"stats":{"Line":0}},{"line":13233,"address":[],"length":0,"stats":{"Line":0}},{"line":13241,"address":[54987609,54987520],"length":1,"stats":{"Line":0}},{"line":13242,"address":[],"length":0,"stats":{"Line":0}},{"line":13243,"address":[54800441],"length":1,"stats":{"Line":0}},{"line":13246,"address":[56539763],"length":1,"stats":{"Line":0}},{"line":13249,"address":[54800527],"length":1,"stats":{"Line":0}},{"line":13250,"address":[],"length":0,"stats":{"Line":0}},{"line":13252,"address":[],"length":0,"stats":{"Line":0}},{"line":13253,"address":[56539855],"length":1,"stats":{"Line":0}},{"line":13260,"address":[],"length":0,"stats":{"Line":0}},{"line":13261,"address":[53968660],"length":1,"stats":{"Line":0}},{"line":13262,"address":[],"length":0,"stats":{"Line":0}},{"line":13264,"address":[],"length":0,"stats":{"Line":0}},{"line":13265,"address":[53968693],"length":1,"stats":{"Line":0}},{"line":13275,"address":[54988285],"length":1,"stats":{"Line":0}},{"line":13276,"address":[],"length":0,"stats":{"Line":0}},{"line":13278,"address":[53969052],"length":1,"stats":{"Line":0}},{"line":13280,"address":[54801222],"length":1,"stats":{"Line":0}},{"line":13281,"address":[],"length":0,"stats":{"Line":0}},{"line":13282,"address":[54988367],"length":1,"stats":{"Line":0}},{"line":13285,"address":[54801308],"length":1,"stats":{"Line":0}},{"line":13286,"address":[54988491],"length":1,"stats":{"Line":0}},{"line":13287,"address":[53969299],"length":1,"stats":{"Line":0}},{"line":13288,"address":[54988603],"length":1,"stats":{"Line":0}},{"line":13290,"address":[56540784],"length":1,"stats":{"Line":0}},{"line":13291,"address":[53969431],"length":1,"stats":{"Line":0}},{"line":13295,"address":[56540841],"length":1,"stats":{"Line":0}},{"line":13296,"address":[54801615],"length":1,"stats":{"Line":0}},{"line":13297,"address":[],"length":0,"stats":{"Line":0}},{"line":13300,"address":[],"length":0,"stats":{"Line":0}},{"line":13301,"address":[56541138],"length":1,"stats":{"Line":0}},{"line":13302,"address":[53969832],"length":1,"stats":{"Line":0}},{"line":13305,"address":[],"length":0,"stats":{"Line":0}},{"line":13308,"address":[56541277],"length":1,"stats":{"Line":0}},{"line":13309,"address":[],"length":0,"stats":{"Line":0}},{"line":13310,"address":[53969937],"length":1,"stats":{"Line":0}},{"line":13318,"address":[],"length":0,"stats":{"Line":0}},{"line":13319,"address":[54989428],"length":1,"stats":{"Line":0}},{"line":13321,"address":[54802379],"length":1,"stats":{"Line":0}},{"line":13322,"address":[53970282],"length":1,"stats":{"Line":0}},{"line":13325,"address":[54802525],"length":1,"stats":{"Line":0}},{"line":13326,"address":[],"length":0,"stats":{"Line":0}},{"line":13327,"address":[56541776],"length":1,"stats":{"Line":0}},{"line":13330,"address":[53970534],"length":1,"stats":{"Line":0}},{"line":13331,"address":[56541929],"length":1,"stats":{"Line":0}},{"line":13332,"address":[],"length":0,"stats":{"Line":0}},{"line":13333,"address":[],"length":0,"stats":{"Line":0}},{"line":13336,"address":[54802786],"length":1,"stats":{"Line":0}},{"line":13337,"address":[54989959],"length":1,"stats":{"Line":0}},{"line":13339,"address":[53970785],"length":1,"stats":{"Line":0}},{"line":13340,"address":[54802904],"length":1,"stats":{"Line":0}},{"line":13344,"address":[54990071],"length":1,"stats":{"Line":0}},{"line":13345,"address":[54990092],"length":1,"stats":{"Line":0}},{"line":13346,"address":[54803021],"length":1,"stats":{"Line":0}},{"line":13347,"address":[54990196],"length":1,"stats":{"Line":0}},{"line":13348,"address":[54803086],"length":1,"stats":{"Line":0}},{"line":13352,"address":[53971025],"length":1,"stats":{"Line":0}},{"line":13353,"address":[54990282],"length":1,"stats":{"Line":0}},{"line":13354,"address":[54803353],"length":1,"stats":{"Line":0}},{"line":13355,"address":[54990516],"length":1,"stats":{"Line":0}},{"line":13358,"address":[54803464],"length":1,"stats":{"Line":0}},{"line":13359,"address":[],"length":0,"stats":{"Line":0}},{"line":13360,"address":[],"length":0,"stats":{"Line":0}},{"line":13361,"address":[54803495],"length":1,"stats":{"Line":0}},{"line":13363,"address":[56542799],"length":1,"stats":{"Line":0}},{"line":13365,"address":[54990885],"length":1,"stats":{"Line":0}},{"line":13371,"address":[54803824],"length":1,"stats":{"Line":0}},{"line":13376,"address":[53971845],"length":1,"stats":{"Line":0}},{"line":13379,"address":[56543241],"length":1,"stats":{"Line":0}},{"line":13380,"address":[54991154],"length":1,"stats":{"Line":0}},{"line":13381,"address":[],"length":0,"stats":{"Line":0}},{"line":13382,"address":[54804041],"length":1,"stats":{"Line":0}},{"line":13385,"address":[56543360],"length":1,"stats":{"Line":0}},{"line":13386,"address":[54991322],"length":1,"stats":{"Line":0}},{"line":13387,"address":[],"length":0,"stats":{"Line":0}},{"line":13388,"address":[],"length":0,"stats":{"Line":0}},{"line":13391,"address":[54991407],"length":1,"stats":{"Line":0}},{"line":13392,"address":[],"length":0,"stats":{"Line":0}},{"line":13393,"address":[],"length":0,"stats":{"Line":0}},{"line":13394,"address":[56543551],"length":1,"stats":{"Line":0}},{"line":13397,"address":[54991529],"length":1,"stats":{"Line":0}},{"line":13398,"address":[],"length":0,"stats":{"Line":0}},{"line":13399,"address":[54991536],"length":1,"stats":{"Line":0}},{"line":13403,"address":[54991609],"length":1,"stats":{"Line":0}},{"line":13404,"address":[],"length":0,"stats":{"Line":0}},{"line":13405,"address":[],"length":0,"stats":{"Line":0}},{"line":13413,"address":[53972626],"length":1,"stats":{"Line":0}},{"line":13414,"address":[],"length":0,"stats":{"Line":0}},{"line":13415,"address":[56543976],"length":1,"stats":{"Line":0}},{"line":13424,"address":[56544189],"length":1,"stats":{"Line":0}},{"line":13425,"address":[],"length":0,"stats":{"Line":0}},{"line":13426,"address":[56544292],"length":1,"stats":{"Line":0}},{"line":13427,"address":[],"length":0,"stats":{"Line":0}},{"line":13428,"address":[56544299],"length":1,"stats":{"Line":0}},{"line":13432,"address":[56544389],"length":1,"stats":{"Line":0}},{"line":13433,"address":[],"length":0,"stats":{"Line":0}},{"line":13434,"address":[],"length":0,"stats":{"Line":0}},{"line":13437,"address":[56544481],"length":1,"stats":{"Line":0}},{"line":13438,"address":[54992425],"length":1,"stats":{"Line":0}},{"line":13439,"address":[],"length":0,"stats":{"Line":0}},{"line":13440,"address":[53973215],"length":1,"stats":{"Line":0}},{"line":13441,"address":[53973267],"length":1,"stats":{"Line":0}},{"line":13442,"address":[54805435],"length":1,"stats":{"Line":0}},{"line":13445,"address":[56544718],"length":1,"stats":{"Line":0}},{"line":13446,"address":[54992613],"length":1,"stats":{"Line":0}},{"line":13450,"address":[53973450],"length":1,"stats":{"Line":0}},{"line":13453,"address":[56544796],"length":1,"stats":{"Line":0}},{"line":13454,"address":[],"length":0,"stats":{"Line":0}},{"line":13455,"address":[53973488],"length":1,"stats":{"Line":0}},{"line":13460,"address":[],"length":0,"stats":{"Line":0}},{"line":13461,"address":[53973667],"length":1,"stats":{"Line":0}},{"line":13462,"address":[54992934],"length":1,"stats":{"Line":0}},{"line":13463,"address":[56545102],"length":1,"stats":{"Line":0}},{"line":13464,"address":[],"length":0,"stats":{"Line":0}},{"line":13465,"address":[53973891],"length":1,"stats":{"Line":0}},{"line":13466,"address":[54993158],"length":1,"stats":{"Line":0}},{"line":13468,"address":[54993227],"length":1,"stats":{"Line":0}},{"line":13469,"address":[56545346],"length":1,"stats":{"Line":0}},{"line":13474,"address":[],"length":0,"stats":{"Line":0}},{"line":13475,"address":[54993305],"length":1,"stats":{"Line":0}},{"line":13476,"address":[],"length":0,"stats":{"Line":0}},{"line":13477,"address":[54806217],"length":1,"stats":{"Line":0}},{"line":13479,"address":[56545507],"length":1,"stats":{"Line":0}},{"line":13480,"address":[],"length":0,"stats":{"Line":0}},{"line":13481,"address":[53974197],"length":1,"stats":{"Line":0}},{"line":13483,"address":[],"length":0,"stats":{"Line":0}},{"line":13484,"address":[54806448],"length":1,"stats":{"Line":0}},{"line":13485,"address":[54806514],"length":1,"stats":{"Line":0}},{"line":13486,"address":[54993662],"length":1,"stats":{"Line":0}},{"line":13487,"address":[56545781],"length":1,"stats":{"Line":0}},{"line":13491,"address":[53974518],"length":1,"stats":{"Line":0}},{"line":13492,"address":[54993748],"length":1,"stats":{"Line":0}},{"line":13493,"address":[],"length":0,"stats":{"Line":0}},{"line":13494,"address":[],"length":0,"stats":{"Line":0}},{"line":13497,"address":[53974659],"length":1,"stats":{"Line":0}},{"line":13498,"address":[],"length":0,"stats":{"Line":0}},{"line":13499,"address":[53974666],"length":1,"stats":{"Line":0}},{"line":13503,"address":[54806868],"length":1,"stats":{"Line":0}},{"line":13504,"address":[],"length":0,"stats":{"Line":0}},{"line":13505,"address":[56546136],"length":1,"stats":{"Line":0}},{"line":13509,"address":[54994074],"length":1,"stats":{"Line":0}},{"line":13511,"address":[53974899],"length":1,"stats":{"Line":0}},{"line":13512,"address":[],"length":0,"stats":{"Line":0}},{"line":13515,"address":[54807165],"length":1,"stats":{"Line":0}},{"line":13516,"address":[],"length":0,"stats":{"Line":0}},{"line":13517,"address":[53975070],"length":1,"stats":{"Line":0}},{"line":13520,"address":[],"length":0,"stats":{"Line":0}},{"line":13521,"address":[],"length":0,"stats":{"Line":0}},{"line":13522,"address":[56546496],"length":1,"stats":{"Line":0}},{"line":13526,"address":[56546581],"length":1,"stats":{"Line":0}},{"line":13527,"address":[],"length":0,"stats":{"Line":0}},{"line":13528,"address":[56546591],"length":1,"stats":{"Line":0}},{"line":13531,"address":[54807503],"length":1,"stats":{"Line":0}},{"line":13532,"address":[],"length":0,"stats":{"Line":0}},{"line":13533,"address":[56546698],"length":1,"stats":{"Line":0}},{"line":13535,"address":[54807593],"length":1,"stats":{"Line":0}},{"line":13536,"address":[],"length":0,"stats":{"Line":0}},{"line":13537,"address":[],"length":0,"stats":{"Line":0}},{"line":13540,"address":[53975577],"length":1,"stats":{"Line":0}},{"line":13541,"address":[56546880],"length":1,"stats":{"Line":0}},{"line":13545,"address":[56546937],"length":1,"stats":{"Line":0}},{"line":13546,"address":[],"length":0,"stats":{"Line":0}},{"line":13547,"address":[53975650],"length":1,"stats":{"Line":0}},{"line":13549,"address":[],"length":0,"stats":{"Line":0}},{"line":13550,"address":[],"length":0,"stats":{"Line":0}},{"line":13551,"address":[54807902],"length":1,"stats":{"Line":0}},{"line":13555,"address":[],"length":0,"stats":{"Line":0}},{"line":13556,"address":[],"length":0,"stats":{"Line":0}},{"line":13557,"address":[],"length":0,"stats":{"Line":0}},{"line":13558,"address":[54995057],"length":1,"stats":{"Line":0}},{"line":13561,"address":[],"length":0,"stats":{"Line":0}},{"line":13562,"address":[],"length":0,"stats":{"Line":0}},{"line":13563,"address":[56547268],"length":1,"stats":{"Line":0}},{"line":13566,"address":[56547338],"length":1,"stats":{"Line":0}},{"line":13567,"address":[56547382],"length":1,"stats":{"Line":0}},{"line":13568,"address":[54995325],"length":1,"stats":{"Line":0}},{"line":13569,"address":[],"length":0,"stats":{"Line":0}},{"line":13571,"address":[],"length":0,"stats":{"Line":0}},{"line":13572,"address":[53976169],"length":1,"stats":{"Line":0}},{"line":13573,"address":[],"length":0,"stats":{"Line":0}},{"line":13574,"address":[54995375],"length":1,"stats":{"Line":0}},{"line":13579,"address":[56547591],"length":1,"stats":{"Line":0}},{"line":13580,"address":[],"length":0,"stats":{"Line":0}},{"line":13581,"address":[53976327],"length":1,"stats":{"Line":0}},{"line":13589,"address":[54808655],"length":1,"stats":{"Line":0}},{"line":13590,"address":[54808719],"length":1,"stats":{"Line":0}},{"line":13591,"address":[],"length":0,"stats":{"Line":0}},{"line":13592,"address":[54995780],"length":1,"stats":{"Line":0}},{"line":13594,"address":[53976689],"length":1,"stats":{"Line":0}},{"line":13597,"address":[53976739],"length":1,"stats":{"Line":0}},{"line":13598,"address":[],"length":0,"stats":{"Line":0}},{"line":13599,"address":[],"length":0,"stats":{"Line":0}},{"line":13601,"address":[56548103],"length":1,"stats":{"Line":0}},{"line":13602,"address":[],"length":0,"stats":{"Line":0}},{"line":13603,"address":[56548113],"length":1,"stats":{"Line":0}},{"line":13605,"address":[54996081],"length":1,"stats":{"Line":0}},{"line":13606,"address":[],"length":0,"stats":{"Line":0}},{"line":13607,"address":[54809045],"length":1,"stats":{"Line":0}},{"line":13609,"address":[54809140],"length":1,"stats":{"Line":0}},{"line":13610,"address":[54809206],"length":1,"stats":{"Line":0}},{"line":13611,"address":[54996312],"length":1,"stats":{"Line":0}},{"line":13612,"address":[54809330],"length":1,"stats":{"Line":0}},{"line":13613,"address":[54996375],"length":1,"stats":{"Line":0}},{"line":13617,"address":[54996425],"length":1,"stats":{"Line":0}},{"line":13618,"address":[],"length":0,"stats":{"Line":0}},{"line":13619,"address":[],"length":0,"stats":{"Line":0}},{"line":13620,"address":[56548576],"length":1,"stats":{"Line":0}},{"line":13623,"address":[54996564],"length":1,"stats":{"Line":0}},{"line":13624,"address":[],"length":0,"stats":{"Line":0}},{"line":13625,"address":[54996571],"length":1,"stats":{"Line":0}},{"line":13627,"address":[54809626],"length":1,"stats":{"Line":0}},{"line":13628,"address":[],"length":0,"stats":{"Line":0}},{"line":13632,"address":[54809684],"length":1,"stats":{"Line":0}},{"line":13634,"address":[],"length":0,"stats":{"Line":0}},{"line":13635,"address":[53977610],"length":1,"stats":{"Line":0}},{"line":13638,"address":[56549001],"length":1,"stats":{"Line":0}},{"line":13639,"address":[],"length":0,"stats":{"Line":0}},{"line":13640,"address":[54996906],"length":1,"stats":{"Line":0}},{"line":13643,"address":[],"length":0,"stats":{"Line":0}},{"line":13644,"address":[],"length":0,"stats":{"Line":0}},{"line":13645,"address":[56549138],"length":1,"stats":{"Line":0}},{"line":13649,"address":[53977978],"length":1,"stats":{"Line":0}},{"line":13650,"address":[],"length":0,"stats":{"Line":0}},{"line":13651,"address":[54810097],"length":1,"stats":{"Line":0}},{"line":13653,"address":[53978060],"length":1,"stats":{"Line":0}},{"line":13655,"address":[54997268],"length":1,"stats":{"Line":0}},{"line":13656,"address":[53978141],"length":1,"stats":{"Line":0}},{"line":13662,"address":[],"length":0,"stats":{"Line":0}},{"line":13663,"address":[54810333],"length":1,"stats":{"Line":0}},{"line":13664,"address":[],"length":0,"stats":{"Line":0}},{"line":13665,"address":[56549476],"length":1,"stats":{"Line":0}},{"line":13668,"address":[54997464],"length":1,"stats":{"Line":0}},{"line":13669,"address":[],"length":0,"stats":{"Line":0}},{"line":13670,"address":[],"length":0,"stats":{"Line":0}},{"line":13672,"address":[56549664],"length":1,"stats":{"Line":0}},{"line":13673,"address":[],"length":0,"stats":{"Line":0}},{"line":13674,"address":[],"length":0,"stats":{"Line":0}},{"line":13677,"address":[],"length":0,"stats":{"Line":0}},{"line":13678,"address":[],"length":0,"stats":{"Line":0}},{"line":13679,"address":[54997669],"length":1,"stats":{"Line":0}},{"line":13683,"address":[53978625],"length":1,"stats":{"Line":0}},{"line":13684,"address":[],"length":0,"stats":{"Line":0}},{"line":13685,"address":[56549869],"length":1,"stats":{"Line":0}},{"line":13687,"address":[53978699],"length":1,"stats":{"Line":0}},{"line":13688,"address":[],"length":0,"stats":{"Line":0}},{"line":13689,"address":[54810828],"length":1,"stats":{"Line":0}},{"line":13698,"address":[54811044],"length":1,"stats":{"Line":0}},{"line":13700,"address":[56550181],"length":1,"stats":{"Line":0}},{"line":13701,"address":[],"length":0,"stats":{"Line":0}},{"line":13702,"address":[53978985],"length":1,"stats":{"Line":0}},{"line":13707,"address":[],"length":0,"stats":{"Line":0}},{"line":13709,"address":[53979111],"length":1,"stats":{"Line":0}},{"line":13710,"address":[56550356],"length":1,"stats":{"Line":0}},{"line":13717,"address":[54998505],"length":1,"stats":{"Line":0}},{"line":13719,"address":[56550634],"length":1,"stats":{"Line":0}},{"line":13720,"address":[],"length":0,"stats":{"Line":0}},{"line":13721,"address":[54811553],"length":1,"stats":{"Line":0}},{"line":13726,"address":[53979542],"length":1,"stats":{"Line":0}},{"line":13727,"address":[56550786],"length":1,"stats":{"Line":0}},{"line":13731,"address":[],"length":0,"stats":{"Line":0}},{"line":13734,"address":[],"length":0,"stats":{"Line":0}},{"line":13735,"address":[],"length":0,"stats":{"Line":0}},{"line":13736,"address":[56551073],"length":1,"stats":{"Line":0}},{"line":13739,"address":[],"length":0,"stats":{"Line":0}},{"line":13740,"address":[],"length":0,"stats":{"Line":0}},{"line":13742,"address":[],"length":0,"stats":{"Line":0}},{"line":13743,"address":[54999078],"length":1,"stats":{"Line":0}},{"line":13744,"address":[],"length":0,"stats":{"Line":0}},{"line":13745,"address":[54999111],"length":1,"stats":{"Line":0}},{"line":13750,"address":[54999223],"length":1,"stats":{"Line":0}},{"line":13752,"address":[56551353],"length":1,"stats":{"Line":0}},{"line":13753,"address":[],"length":0,"stats":{"Line":0}},{"line":13754,"address":[56551389],"length":1,"stats":{"Line":0}},{"line":13759,"address":[54999379],"length":1,"stats":{"Line":0}},{"line":13760,"address":[],"length":0,"stats":{"Line":0}},{"line":13762,"address":[],"length":0,"stats":{"Line":0}},{"line":13763,"address":[53980294],"length":1,"stats":{"Line":0}},{"line":13767,"address":[54812545],"length":1,"stats":{"Line":0}},{"line":13768,"address":[],"length":0,"stats":{"Line":0}},{"line":13773,"address":[54999598],"length":1,"stats":{"Line":0}},{"line":13774,"address":[],"length":0,"stats":{"Line":0}},{"line":13776,"address":[54812677],"length":1,"stats":{"Line":0}},{"line":13777,"address":[],"length":0,"stats":{"Line":0}},{"line":13778,"address":[53980572],"length":1,"stats":{"Line":0}},{"line":13780,"address":[53980647],"length":1,"stats":{"Line":0}},{"line":13781,"address":[],"length":0,"stats":{"Line":0}},{"line":13784,"address":[],"length":0,"stats":{"Line":0}},{"line":13785,"address":[],"length":0,"stats":{"Line":0}},{"line":13789,"address":[],"length":0,"stats":{"Line":0}},{"line":13790,"address":[],"length":0,"stats":{"Line":0}},{"line":13791,"address":[],"length":0,"stats":{"Line":0}},{"line":13792,"address":[53980802],"length":1,"stats":{"Line":0}},{"line":13795,"address":[54813016],"length":1,"stats":{"Line":0}},{"line":13796,"address":[],"length":0,"stats":{"Line":0}},{"line":13797,"address":[55000001],"length":1,"stats":{"Line":0}},{"line":13801,"address":[55000082],"length":1,"stats":{"Line":0}},{"line":13802,"address":[],"length":0,"stats":{"Line":0}},{"line":13803,"address":[55000089],"length":1,"stats":{"Line":0}},{"line":13805,"address":[56552266],"length":1,"stats":{"Line":0}},{"line":13806,"address":[],"length":0,"stats":{"Line":0}},{"line":13807,"address":[56552284],"length":1,"stats":{"Line":0}},{"line":13816,"address":[],"length":0,"stats":{"Line":0}},{"line":13818,"address":[54813435],"length":1,"stats":{"Line":0}},{"line":13819,"address":[],"length":0,"stats":{"Line":0}},{"line":13820,"address":[56552554],"length":1,"stats":{"Line":0}},{"line":13825,"address":[],"length":0,"stats":{"Line":0}},{"line":13827,"address":[55000570],"length":1,"stats":{"Line":0}},{"line":13828,"address":[],"length":0,"stats":{"Line":0}},{"line":13829,"address":[56552697],"length":1,"stats":{"Line":0}},{"line":13830,"address":[54813653],"length":1,"stats":{"Line":0}},{"line":13831,"address":[55000659],"length":1,"stats":{"Line":0}},{"line":13839,"address":[56552958],"length":1,"stats":{"Line":0}},{"line":13841,"address":[54813896],"length":1,"stats":{"Line":0}},{"line":13842,"address":[],"length":0,"stats":{"Line":0}},{"line":13843,"address":[56553012],"length":1,"stats":{"Line":0}},{"line":13848,"address":[53981924],"length":1,"stats":{"Line":0}},{"line":13849,"address":[],"length":0,"stats":{"Line":0}},{"line":13853,"address":[53982036],"length":1,"stats":{"Line":0}},{"line":13856,"address":[54814335],"length":1,"stats":{"Line":0}},{"line":13857,"address":[],"length":0,"stats":{"Line":0}},{"line":13858,"address":[53982233],"length":1,"stats":{"Line":0}},{"line":13861,"address":[56553511],"length":1,"stats":{"Line":0}},{"line":13862,"address":[],"length":0,"stats":{"Line":0}},{"line":13864,"address":[],"length":0,"stats":{"Line":0}},{"line":13865,"address":[53982344],"length":1,"stats":{"Line":0}},{"line":13866,"address":[56553535],"length":1,"stats":{"Line":0}},{"line":13867,"address":[55001449],"length":1,"stats":{"Line":0}},{"line":13872,"address":[56553673],"length":1,"stats":{"Line":0}},{"line":13874,"address":[53982511],"length":1,"stats":{"Line":0}},{"line":13875,"address":[],"length":0,"stats":{"Line":0}},{"line":13876,"address":[],"length":0,"stats":{"Line":0}},{"line":13881,"address":[54814763],"length":1,"stats":{"Line":0}},{"line":13882,"address":[],"length":0,"stats":{"Line":0}},{"line":13884,"address":[],"length":0,"stats":{"Line":0}},{"line":13885,"address":[56553847],"length":1,"stats":{"Line":0}},{"line":13889,"address":[55001872],"length":1,"stats":{"Line":0}},{"line":13890,"address":[56553991],"length":1,"stats":{"Line":0}},{"line":13894,"address":[56554040],"length":1,"stats":{"Line":0}},{"line":13895,"address":[54815165],"length":1,"stats":{"Line":0}},{"line":13896,"address":[],"length":0,"stats":{"Line":0}},{"line":13898,"address":[55002162],"length":1,"stats":{"Line":0}},{"line":13901,"address":[55002226],"length":1,"stats":{"Line":0}},{"line":13902,"address":[53983188],"length":1,"stats":{"Line":0}},{"line":13903,"address":[55002431],"length":1,"stats":{"Line":0}},{"line":13904,"address":[],"length":0,"stats":{"Line":0}},{"line":13905,"address":[],"length":0,"stats":{"Line":0}},{"line":13906,"address":[],"length":0,"stats":{"Line":0}},{"line":13908,"address":[54815632],"length":1,"stats":{"Line":0}},{"line":13909,"address":[53983538],"length":1,"stats":{"Line":0}},{"line":13912,"address":[],"length":0,"stats":{"Line":0}},{"line":13914,"address":[53983667],"length":1,"stats":{"Line":0}},{"line":13916,"address":[53983685],"length":1,"stats":{"Line":0}},{"line":13917,"address":[],"length":0,"stats":{"Line":0}},{"line":13918,"address":[55002774],"length":1,"stats":{"Line":0}},{"line":13923,"address":[55002876],"length":1,"stats":{"Line":0}},{"line":13924,"address":[],"length":0,"stats":{"Line":0}},{"line":13926,"address":[],"length":0,"stats":{"Line":0}},{"line":13927,"address":[],"length":0,"stats":{"Line":0}},{"line":13931,"address":[],"length":0,"stats":{"Line":0}},{"line":13932,"address":[],"length":0,"stats":{"Line":0}},{"line":13933,"address":[],"length":0,"stats":{"Line":0}},{"line":13934,"address":[56555391],"length":1,"stats":{"Line":0}},{"line":13936,"address":[55003321],"length":1,"stats":{"Line":0}},{"line":13939,"address":[53984341],"length":1,"stats":{"Line":0}},{"line":13943,"address":[56555518],"length":1,"stats":{"Line":0}},{"line":13944,"address":[],"length":0,"stats":{"Line":0}},{"line":13945,"address":[55003500],"length":1,"stats":{"Line":0}},{"line":13946,"address":[54816615],"length":1,"stats":{"Line":0}},{"line":13947,"address":[],"length":0,"stats":{"Line":0}},{"line":13949,"address":[],"length":0,"stats":{"Line":0}},{"line":13950,"address":[56555676],"length":1,"stats":{"Line":0}},{"line":13951,"address":[],"length":0,"stats":{"Line":0}},{"line":13952,"address":[54816666],"length":1,"stats":{"Line":0}},{"line":13957,"address":[56555813],"length":1,"stats":{"Line":0}},{"line":13958,"address":[],"length":0,"stats":{"Line":0}},{"line":13959,"address":[53984679],"length":1,"stats":{"Line":0}},{"line":13967,"address":[55003935],"length":1,"stats":{"Line":0}},{"line":13968,"address":[56556119],"length":1,"stats":{"Line":0}},{"line":13969,"address":[],"length":0,"stats":{"Line":0}},{"line":13970,"address":[56556126],"length":1,"stats":{"Line":0}},{"line":13972,"address":[55004087],"length":1,"stats":{"Line":0}},{"line":13973,"address":[],"length":0,"stats":{"Line":0}},{"line":13977,"address":[55004184],"length":1,"stats":{"Line":0}},{"line":13978,"address":[],"length":0,"stats":{"Line":0}},{"line":13979,"address":[53985161],"length":1,"stats":{"Line":0}},{"line":13981,"address":[53985243],"length":1,"stats":{"Line":0}},{"line":13982,"address":[],"length":0,"stats":{"Line":0}},{"line":13983,"address":[55004284],"length":1,"stats":{"Line":0}},{"line":13985,"address":[55004364],"length":1,"stats":{"Line":0}},{"line":13986,"address":[54817465],"length":1,"stats":{"Line":0}},{"line":13988,"address":[53985434],"length":1,"stats":{"Line":0}},{"line":13989,"address":[54817564],"length":1,"stats":{"Line":0}},{"line":13993,"address":[],"length":0,"stats":{"Line":0}},{"line":13994,"address":[],"length":0,"stats":{"Line":0}},{"line":13995,"address":[],"length":0,"stats":{"Line":0}},{"line":13997,"address":[56556766],"length":1,"stats":{"Line":0}},{"line":14000,"address":[56556822],"length":1,"stats":{"Line":0}},{"line":14001,"address":[54817857],"length":1,"stats":{"Line":0}},{"line":14002,"address":[55004822],"length":1,"stats":{"Line":0}},{"line":14003,"address":[55004878],"length":1,"stats":{"Line":0}},{"line":14004,"address":[56557046],"length":1,"stats":{"Line":0}},{"line":14006,"address":[53985966],"length":1,"stats":{"Line":0}},{"line":14007,"address":[],"length":0,"stats":{"Line":0}},{"line":14010,"address":[56557185],"length":1,"stats":{"Line":0}},{"line":14011,"address":[],"length":0,"stats":{"Line":0}},{"line":14012,"address":[53986063],"length":1,"stats":{"Line":0}},{"line":14017,"address":[53986165],"length":1,"stats":{"Line":0}},{"line":14018,"address":[],"length":0,"stats":{"Line":0}},{"line":14019,"address":[],"length":0,"stats":{"Line":0}},{"line":14021,"address":[55005278],"length":1,"stats":{"Line":0}},{"line":14022,"address":[56557397],"length":1,"stats":{"Line":0}},{"line":14026,"address":[56557447],"length":1,"stats":{"Line":0}},{"line":14028,"address":[56557468],"length":1,"stats":{"Line":0}},{"line":14029,"address":[55005374],"length":1,"stats":{"Line":0}},{"line":14032,"address":[54818611],"length":1,"stats":{"Line":0}},{"line":14033,"address":[],"length":0,"stats":{"Line":0}},{"line":14035,"address":[54818629],"length":1,"stats":{"Line":0}},{"line":14036,"address":[53986532],"length":1,"stats":{"Line":0}},{"line":14045,"address":[55005812],"length":1,"stats":{"Line":0}},{"line":14046,"address":[53986835],"length":1,"stats":{"Line":0}},{"line":14047,"address":[],"length":0,"stats":{"Line":0}},{"line":14048,"address":[54818954],"length":1,"stats":{"Line":0}},{"line":14050,"address":[53986932],"length":1,"stats":{"Line":0}},{"line":14051,"address":[],"length":0,"stats":{"Line":0}},{"line":14055,"address":[55005997],"length":1,"stats":{"Line":0}},{"line":14056,"address":[54819131],"length":1,"stats":{"Line":0}},{"line":14057,"address":[],"length":0,"stats":{"Line":0}},{"line":14058,"address":[53987029],"length":1,"stats":{"Line":0}},{"line":14060,"address":[56558236],"length":1,"stats":{"Line":0}},{"line":14061,"address":[],"length":0,"stats":{"Line":0}},{"line":14062,"address":[55006134],"length":1,"stats":{"Line":0}},{"line":14064,"address":[55006214],"length":1,"stats":{"Line":0}},{"line":14065,"address":[],"length":0,"stats":{"Line":0}},{"line":14066,"address":[54819330],"length":1,"stats":{"Line":0}},{"line":14070,"address":[55006294],"length":1,"stats":{"Line":0}},{"line":14071,"address":[],"length":0,"stats":{"Line":0}},{"line":14073,"address":[],"length":0,"stats":{"Line":0}},{"line":14074,"address":[54819423],"length":1,"stats":{"Line":0}},{"line":14078,"address":[],"length":0,"stats":{"Line":0}},{"line":14079,"address":[],"length":0,"stats":{"Line":0}},{"line":14080,"address":[56558546],"length":1,"stats":{"Line":0}},{"line":14088,"address":[56558762],"length":1,"stats":{"Line":0}},{"line":14090,"address":[53987672],"length":1,"stats":{"Line":0}},{"line":14091,"address":[53987687],"length":1,"stats":{"Line":0}},{"line":14098,"address":[54820060],"length":1,"stats":{"Line":0}},{"line":14099,"address":[54820078],"length":1,"stats":{"Line":0}},{"line":14102,"address":[56559211],"length":1,"stats":{"Line":0}},{"line":14103,"address":[55007117],"length":1,"stats":{"Line":0}},{"line":14107,"address":[53988218],"length":1,"stats":{"Line":0}},{"line":14110,"address":[56559506],"length":1,"stats":{"Line":0}},{"line":14111,"address":[],"length":0,"stats":{"Line":0}},{"line":14112,"address":[],"length":0,"stats":{"Line":0}},{"line":14115,"address":[54820634],"length":1,"stats":{"Line":0}},{"line":14116,"address":[],"length":0,"stats":{"Line":0}},{"line":14117,"address":[],"length":0,"stats":{"Line":0}},{"line":14122,"address":[],"length":0,"stats":{"Line":0}},{"line":14123,"address":[],"length":0,"stats":{"Line":0}},{"line":14125,"address":[],"length":0,"stats":{"Line":0}},{"line":14126,"address":[56559743],"length":1,"stats":{"Line":0}},{"line":14127,"address":[56559750],"length":1,"stats":{"Line":0}},{"line":14128,"address":[54820792],"length":1,"stats":{"Line":0}},{"line":14133,"address":[56559888],"length":1,"stats":{"Line":0}},{"line":14135,"address":[56559906],"length":1,"stats":{"Line":0}},{"line":14136,"address":[],"length":0,"stats":{"Line":0}},{"line":14137,"address":[55007830],"length":1,"stats":{"Line":0}},{"line":14142,"address":[53988953],"length":1,"stats":{"Line":0}},{"line":14143,"address":[],"length":0,"stats":{"Line":0}},{"line":14145,"address":[],"length":0,"stats":{"Line":0}},{"line":14146,"address":[53988971],"length":1,"stats":{"Line":0}},{"line":14150,"address":[55008087],"length":1,"stats":{"Line":0}},{"line":14153,"address":[54821272],"length":1,"stats":{"Line":0}},{"line":14154,"address":[],"length":0,"stats":{"Line":0}},{"line":14155,"address":[55008153],"length":1,"stats":{"Line":0}},{"line":14157,"address":[55008265],"length":1,"stats":{"Line":0}},{"line":14160,"address":[54821470],"length":1,"stats":{"Line":0}},{"line":14161,"address":[],"length":0,"stats":{"Line":0}},{"line":14162,"address":[54821477],"length":1,"stats":{"Line":0}},{"line":14164,"address":[55008409],"length":1,"stats":{"Line":0}},{"line":14165,"address":[],"length":0,"stats":{"Line":0}},{"line":14166,"address":[55008416],"length":1,"stats":{"Line":0}},{"line":14168,"address":[53989522],"length":1,"stats":{"Line":0}},{"line":14170,"address":[],"length":0,"stats":{"Line":0}},{"line":14173,"address":[],"length":0,"stats":{"Line":0}},{"line":14175,"address":[],"length":0,"stats":{"Line":0}},{"line":14176,"address":[53989677],"length":1,"stats":{"Line":0}},{"line":14181,"address":[55008771],"length":1,"stats":{"Line":0}},{"line":14182,"address":[],"length":0,"stats":{"Line":0}},{"line":14183,"address":[54821939],"length":1,"stats":{"Line":0}},{"line":14190,"address":[56561109],"length":1,"stats":{"Line":0}},{"line":14193,"address":[],"length":0,"stats":{"Line":0}},{"line":14194,"address":[],"length":0,"stats":{"Line":0}},{"line":14195,"address":[55009186],"length":1,"stats":{"Line":0}},{"line":14198,"address":[55009288],"length":1,"stats":{"Line":0}},{"line":14199,"address":[],"length":0,"stats":{"Line":0}},{"line":14200,"address":[54822452],"length":1,"stats":{"Line":0}},{"line":14205,"address":[56561499],"length":1,"stats":{"Line":0}},{"line":14206,"address":[],"length":0,"stats":{"Line":0}},{"line":14208,"address":[],"length":0,"stats":{"Line":0}},{"line":14209,"address":[56561513],"length":1,"stats":{"Line":0}},{"line":14210,"address":[56561520],"length":1,"stats":{"Line":0}},{"line":14211,"address":[],"length":0,"stats":{"Line":0}},{"line":14216,"address":[],"length":0,"stats":{"Line":0}},{"line":14218,"address":[],"length":0,"stats":{"Line":0}},{"line":14219,"address":[],"length":0,"stats":{"Line":0}},{"line":14220,"address":[55009582],"length":1,"stats":{"Line":0}},{"line":14225,"address":[55009681],"length":1,"stats":{"Line":0}},{"line":14226,"address":[],"length":0,"stats":{"Line":0}},{"line":14228,"address":[],"length":0,"stats":{"Line":0}},{"line":14229,"address":[54822861],"length":1,"stats":{"Line":0}},{"line":14233,"address":[54822982],"length":1,"stats":{"Line":0}},{"line":14234,"address":[53990877],"length":1,"stats":{"Line":0}},{"line":14238,"address":[],"length":0,"stats":{"Line":0}},{"line":14239,"address":[],"length":0,"stats":{"Line":0}},{"line":14241,"address":[],"length":0,"stats":{"Line":0}},{"line":14242,"address":[],"length":0,"stats":{"Line":0}},{"line":14246,"address":[53991043],"length":1,"stats":{"Line":0}},{"line":14248,"address":[54823213],"length":1,"stats":{"Line":0}},{"line":14251,"address":[54823271],"length":1,"stats":{"Line":0}},{"line":14252,"address":[],"length":0,"stats":{"Line":0}},{"line":14253,"address":[],"length":0,"stats":{"Line":0}},{"line":14254,"address":[55010141],"length":1,"stats":{"Line":0}},{"line":14257,"address":[53991298],"length":1,"stats":{"Line":0}},{"line":14258,"address":[],"length":0,"stats":{"Line":0}},{"line":14259,"address":[56562356],"length":1,"stats":{"Line":0}},{"line":14264,"address":[],"length":0,"stats":{"Line":0}},{"line":14265,"address":[],"length":0,"stats":{"Line":0}},{"line":14266,"address":[],"length":0,"stats":{"Line":0}},{"line":14268,"address":[53991497],"length":1,"stats":{"Line":0}},{"line":14271,"address":[56562597],"length":1,"stats":{"Line":0}},{"line":14272,"address":[56562782],"length":1,"stats":{"Line":0}},{"line":14273,"address":[53991749],"length":1,"stats":{"Line":0}},{"line":14275,"address":[54823904],"length":1,"stats":{"Line":0}},{"line":14278,"address":[56562892],"length":1,"stats":{"Line":0}},{"line":14279,"address":[],"length":0,"stats":{"Line":0}},{"line":14280,"address":[],"length":0,"stats":{"Line":0}},{"line":14281,"address":[55010811],"length":1,"stats":{"Line":0}},{"line":14283,"address":[54824205],"length":1,"stats":{"Line":0}},{"line":14284,"address":[54824088],"length":1,"stats":{"Line":0}},{"line":14285,"address":[56563052],"length":1,"stats":{"Line":0}},{"line":14286,"address":[54824166],"length":1,"stats":{"Line":0}},{"line":14288,"address":[54824373],"length":1,"stats":{"Line":0}},{"line":14292,"address":[53703632],"length":1,"stats":{"Line":0}},{"line":14297,"address":[54725795],"length":1,"stats":{"Line":0}},{"line":14300,"address":[54725847],"length":1,"stats":{"Line":0}},{"line":14301,"address":[53703824],"length":1,"stats":{"Line":0}},{"line":14302,"address":[],"length":0,"stats":{"Line":0}},{"line":14303,"address":[56277991],"length":1,"stats":{"Line":0}},{"line":14306,"address":[54725966],"length":1,"stats":{"Line":0}},{"line":14307,"address":[54536095],"length":1,"stats":{"Line":0}},{"line":14308,"address":[],"length":0,"stats":{"Line":0}},{"line":14309,"address":[],"length":0,"stats":{"Line":0}},{"line":14310,"address":[54536179],"length":1,"stats":{"Line":0}},{"line":14314,"address":[53704147],"length":1,"stats":{"Line":0}},{"line":14315,"address":[],"length":0,"stats":{"Line":0}},{"line":14316,"address":[],"length":0,"stats":{"Line":0}},{"line":14317,"address":[53704179],"length":1,"stats":{"Line":0}},{"line":14320,"address":[],"length":0,"stats":{"Line":0}},{"line":14321,"address":[],"length":0,"stats":{"Line":0}},{"line":14322,"address":[54536390],"length":1,"stats":{"Line":0}},{"line":14326,"address":[54536465],"length":1,"stats":{"Line":0}},{"line":14327,"address":[],"length":0,"stats":{"Line":0}},{"line":14328,"address":[56278522],"length":1,"stats":{"Line":0}},{"line":14336,"address":[56278751],"length":1,"stats":{"Line":0}},{"line":14337,"address":[],"length":0,"stats":{"Line":0}},{"line":14338,"address":[],"length":0,"stats":{"Line":0}},{"line":14341,"address":[],"length":0,"stats":{"Line":0}},{"line":14343,"address":[53704698],"length":1,"stats":{"Line":0}},{"line":14344,"address":[],"length":0,"stats":{"Line":0}},{"line":14345,"address":[54726748],"length":1,"stats":{"Line":0}},{"line":14350,"address":[54536965],"length":1,"stats":{"Line":0}},{"line":14351,"address":[],"length":0,"stats":{"Line":0}},{"line":14352,"address":[56279008],"length":1,"stats":{"Line":0}},{"line":14357,"address":[],"length":0,"stats":{"Line":0}},{"line":14358,"address":[54537120],"length":1,"stats":{"Line":0}},{"line":14359,"address":[],"length":0,"stats":{"Line":0}},{"line":14360,"address":[56279158],"length":1,"stats":{"Line":0}},{"line":14363,"address":[53705102],"length":1,"stats":{"Line":0}},{"line":14364,"address":[53705158],"length":1,"stats":{"Line":0}},{"line":14365,"address":[53705214],"length":1,"stats":{"Line":0}},{"line":14367,"address":[54727312],"length":1,"stats":{"Line":0}},{"line":14368,"address":[53705290],"length":1,"stats":{"Line":0}},{"line":14372,"address":[54727369],"length":1,"stats":{"Line":0}},{"line":14373,"address":[],"length":0,"stats":{"Line":0}},{"line":14374,"address":[],"length":0,"stats":{"Line":0}},{"line":14377,"address":[],"length":0,"stats":{"Line":0}},{"line":14378,"address":[54537753],"length":1,"stats":{"Line":0}},{"line":14379,"address":[56279827],"length":1,"stats":{"Line":0}},{"line":14382,"address":[],"length":0,"stats":{"Line":0}},{"line":14385,"address":[54537885],"length":1,"stats":{"Line":0}},{"line":14386,"address":[],"length":0,"stats":{"Line":0}},{"line":14387,"address":[54727807],"length":1,"stats":{"Line":0}},{"line":14389,"address":[54537985],"length":1,"stats":{"Line":0}},{"line":14391,"address":[53705923],"length":1,"stats":{"Line":0}},{"line":14392,"address":[],"length":0,"stats":{"Line":0}},{"line":14393,"address":[],"length":0,"stats":{"Line":0}},{"line":14395,"address":[56280153],"length":1,"stats":{"Line":0}},{"line":14397,"address":[53706081],"length":1,"stats":{"Line":0}},{"line":14398,"address":[56280265],"length":1,"stats":{"Line":0}},{"line":14399,"address":[],"length":0,"stats":{"Line":0}},{"line":14401,"address":[],"length":0,"stats":{"Line":0}},{"line":14402,"address":[54728316],"length":1,"stats":{"Line":0}},{"line":14404,"address":[54728345],"length":1,"stats":{"Line":0}},{"line":14405,"address":[],"length":0,"stats":{"Line":0}},{"line":14406,"address":[54728355],"length":1,"stats":{"Line":0}},{"line":14409,"address":[53706442],"length":1,"stats":{"Line":0}},{"line":14410,"address":[],"length":0,"stats":{"Line":0}},{"line":14411,"address":[54728462],"length":1,"stats":{"Line":0}},{"line":14413,"address":[56280659],"length":1,"stats":{"Line":0}},{"line":14414,"address":[],"length":0,"stats":{"Line":0}},{"line":14417,"address":[56280713],"length":1,"stats":{"Line":0}},{"line":14420,"address":[],"length":0,"stats":{"Line":0}},{"line":14421,"address":[56280781],"length":1,"stats":{"Line":0}},{"line":14422,"address":[],"length":0,"stats":{"Line":0}},{"line":14423,"address":[],"length":0,"stats":{"Line":0}},{"line":14425,"address":[],"length":0,"stats":{"Line":0}},{"line":14426,"address":[],"length":0,"stats":{"Line":0}},{"line":14427,"address":[],"length":0,"stats":{"Line":0}},{"line":14428,"address":[54728776],"length":1,"stats":{"Line":0}},{"line":14433,"address":[56280994],"length":1,"stats":{"Line":0}},{"line":14434,"address":[54728897],"length":1,"stats":{"Line":0}},{"line":14437,"address":[54539134],"length":1,"stats":{"Line":0}},{"line":14438,"address":[],"length":0,"stats":{"Line":0}},{"line":14440,"address":[],"length":0,"stats":{"Line":0}},{"line":14441,"address":[54729041],"length":1,"stats":{"Line":0}},{"line":14445,"address":[],"length":0,"stats":{"Line":0}},{"line":14446,"address":[],"length":0,"stats":{"Line":0}},{"line":14447,"address":[56281272],"length":1,"stats":{"Line":0}},{"line":14451,"address":[54539355],"length":1,"stats":{"Line":0}},{"line":14452,"address":[],"length":0,"stats":{"Line":0}},{"line":14453,"address":[],"length":0,"stats":{"Line":0}},{"line":14456,"address":[53707360],"length":1,"stats":{"Line":0}},{"line":14457,"address":[],"length":0,"stats":{"Line":0}},{"line":14458,"address":[53707367],"length":1,"stats":{"Line":0}},{"line":14462,"address":[53707434],"length":1,"stats":{"Line":0}},{"line":14463,"address":[],"length":0,"stats":{"Line":0}},{"line":14464,"address":[54729445],"length":1,"stats":{"Line":0}},{"line":14472,"address":[54729660],"length":1,"stats":{"Line":0}},{"line":14473,"address":[],"length":0,"stats":{"Line":0}},{"line":14474,"address":[53707677],"length":1,"stats":{"Line":0}},{"line":14477,"address":[],"length":0,"stats":{"Line":0}},{"line":14478,"address":[],"length":0,"stats":{"Line":0}},{"line":14479,"address":[56281881],"length":1,"stats":{"Line":0}},{"line":14483,"address":[],"length":0,"stats":{"Line":0}},{"line":14484,"address":[54540020],"length":1,"stats":{"Line":0}},{"line":14485,"address":[],"length":0,"stats":{"Line":0}},{"line":14486,"address":[53707915],"length":1,"stats":{"Line":0}},{"line":14488,"address":[],"length":0,"stats":{"Line":0}},{"line":14489,"address":[],"length":0,"stats":{"Line":0}},{"line":14490,"address":[54540109],"length":1,"stats":{"Line":0}},{"line":14492,"address":[54730072],"length":1,"stats":{"Line":0}},{"line":14493,"address":[],"length":0,"stats":{"Line":0}},{"line":14494,"address":[],"length":0,"stats":{"Line":0}},{"line":14497,"address":[56282278],"length":1,"stats":{"Line":0}},{"line":14498,"address":[],"length":0,"stats":{"Line":0}},{"line":14499,"address":[54540302],"length":1,"stats":{"Line":0}},{"line":14501,"address":[54730246],"length":1,"stats":{"Line":0}},{"line":14504,"address":[54540443],"length":1,"stats":{"Line":0}},{"line":14505,"address":[54730390],"length":1,"stats":{"Line":0}},{"line":14506,"address":[54730446],"length":1,"stats":{"Line":0}},{"line":14509,"address":[],"length":0,"stats":{"Line":0}},{"line":14510,"address":[],"length":0,"stats":{"Line":0}},{"line":14511,"address":[],"length":0,"stats":{"Line":0}},{"line":14512,"address":[56282654],"length":1,"stats":{"Line":0}},{"line":14515,"address":[54730634],"length":1,"stats":{"Line":0}},{"line":14516,"address":[],"length":0,"stats":{"Line":0}},{"line":14517,"address":[56282753],"length":1,"stats":{"Line":0}},{"line":14520,"address":[54730706],"length":1,"stats":{"Line":0}},{"line":14521,"address":[],"length":0,"stats":{"Line":0}},{"line":14522,"address":[],"length":0,"stats":{"Line":0}},{"line":14531,"address":[54730953],"length":1,"stats":{"Line":0}},{"line":14534,"address":[54541148],"length":1,"stats":{"Line":0}},{"line":14535,"address":[],"length":0,"stats":{"Line":0}},{"line":14536,"address":[56283123],"length":1,"stats":{"Line":0}},{"line":14538,"address":[56283211],"length":1,"stats":{"Line":0}},{"line":14540,"address":[54541306],"length":1,"stats":{"Line":0}},{"line":14541,"address":[54731211],"length":1,"stats":{"Line":0}},{"line":14542,"address":[54541418],"length":1,"stats":{"Line":0}},{"line":14544,"address":[54731320],"length":1,"stats":{"Line":0}},{"line":14545,"address":[54731327],"length":1,"stats":{"Line":0}},{"line":14547,"address":[53709417],"length":1,"stats":{"Line":0}},{"line":14549,"address":[54541558],"length":1,"stats":{"Line":0}},{"line":14550,"address":[],"length":0,"stats":{"Line":0}},{"line":14551,"address":[54731416],"length":1,"stats":{"Line":0}},{"line":14554,"address":[56283628],"length":1,"stats":{"Line":0}},{"line":14555,"address":[],"length":0,"stats":{"Line":0}},{"line":14556,"address":[56283635],"length":1,"stats":{"Line":0}},{"line":14558,"address":[],"length":0,"stats":{"Line":0}},{"line":14559,"address":[53709662],"length":1,"stats":{"Line":0}},{"line":14562,"address":[54731668],"length":1,"stats":{"Line":0}},{"line":14565,"address":[],"length":0,"stats":{"Line":0}},{"line":14566,"address":[],"length":0,"stats":{"Line":0}},{"line":14568,"address":[],"length":0,"stats":{"Line":0}},{"line":14569,"address":[53709767],"length":1,"stats":{"Line":0}},{"line":14570,"address":[],"length":0,"stats":{"Line":0}},{"line":14571,"address":[53709801],"length":1,"stats":{"Line":0}},{"line":14576,"address":[54731867],"length":1,"stats":{"Line":0}},{"line":14578,"address":[53709934],"length":1,"stats":{"Line":0}},{"line":14579,"address":[],"length":0,"stats":{"Line":0}},{"line":14580,"address":[53709970],"length":1,"stats":{"Line":0}},{"line":14585,"address":[54732023],"length":1,"stats":{"Line":0}},{"line":14586,"address":[],"length":0,"stats":{"Line":0}},{"line":14588,"address":[],"length":0,"stats":{"Line":0}},{"line":14589,"address":[53710092],"length":1,"stats":{"Line":0}},{"line":14593,"address":[54732162],"length":1,"stats":{"Line":0}},{"line":14594,"address":[],"length":0,"stats":{"Line":0}},{"line":14595,"address":[53710225],"length":1,"stats":{"Line":0}},{"line":14598,"address":[54732255],"length":1,"stats":{"Line":0}},{"line":14599,"address":[],"length":0,"stats":{"Line":0}},{"line":14600,"address":[54542436],"length":1,"stats":{"Line":0}},{"line":14603,"address":[54542545],"length":1,"stats":{"Line":0}},{"line":14604,"address":[],"length":0,"stats":{"Line":0}},{"line":14605,"address":[],"length":0,"stats":{"Line":0}},{"line":14609,"address":[56284568],"length":1,"stats":{"Line":0}},{"line":14610,"address":[],"length":0,"stats":{"Line":0}},{"line":14611,"address":[],"length":0,"stats":{"Line":0}},{"line":14619,"address":[54542872],"length":1,"stats":{"Line":0}},{"line":14620,"address":[],"length":0,"stats":{"Line":0}},{"line":14621,"address":[54732708],"length":1,"stats":{"Line":0}},{"line":14627,"address":[56284912],"length":1,"stats":{"Line":0}},{"line":14628,"address":[],"length":0,"stats":{"Line":0}},{"line":14631,"address":[54732948],"length":1,"stats":{"Line":0}},{"line":14633,"address":[],"length":0,"stats":{"Line":0}},{"line":14634,"address":[54543159],"length":1,"stats":{"Line":0}},{"line":14640,"address":[54543437],"length":1,"stats":{"Line":0}},{"line":14641,"address":[],"length":0,"stats":{"Line":0}},{"line":14642,"address":[53711332],"length":1,"stats":{"Line":0}},{"line":14646,"address":[54733330],"length":1,"stats":{"Line":0}},{"line":14647,"address":[53711446],"length":1,"stats":{"Line":0}},{"line":14648,"address":[],"length":0,"stats":{"Line":0}},{"line":14649,"address":[53711453],"length":1,"stats":{"Line":0}},{"line":14651,"address":[54733457],"length":1,"stats":{"Line":0}},{"line":14652,"address":[],"length":0,"stats":{"Line":0}},{"line":14653,"address":[53711535],"length":1,"stats":{"Line":0}},{"line":14656,"address":[54733552],"length":1,"stats":{"Line":0}},{"line":14657,"address":[],"length":0,"stats":{"Line":0}},{"line":14659,"address":[56285784],"length":1,"stats":{"Line":0}},{"line":14660,"address":[],"length":0,"stats":{"Line":0}},{"line":14664,"address":[],"length":0,"stats":{"Line":0}},{"line":14666,"address":[56285862],"length":1,"stats":{"Line":0}},{"line":14668,"address":[54733768],"length":1,"stats":{"Line":0}},{"line":14669,"address":[],"length":0,"stats":{"Line":0}},{"line":14670,"address":[54543982],"length":1,"stats":{"Line":0}},{"line":14675,"address":[56286010],"length":1,"stats":{"Line":0}},{"line":14677,"address":[56286028],"length":1,"stats":{"Line":0}},{"line":14678,"address":[],"length":0,"stats":{"Line":0}},{"line":14682,"address":[],"length":0,"stats":{"Line":0}},{"line":14683,"address":[],"length":0,"stats":{"Line":0}},{"line":14684,"address":[54544404],"length":1,"stats":{"Line":0}},{"line":14686,"address":[54544476],"length":1,"stats":{"Line":0}},{"line":14687,"address":[54544491],"length":1,"stats":{"Line":0}},{"line":14689,"address":[54734349],"length":1,"stats":{"Line":0}},{"line":14690,"address":[],"length":0,"stats":{"Line":0}},{"line":14693,"address":[],"length":0,"stats":{"Line":0}},{"line":14695,"address":[53712509],"length":1,"stats":{"Line":0}},{"line":14696,"address":[],"length":0,"stats":{"Line":0}},{"line":14697,"address":[],"length":0,"stats":{"Line":0}},{"line":14699,"address":[],"length":0,"stats":{"Line":0}},{"line":14700,"address":[56286637],"length":1,"stats":{"Line":0}},{"line":14701,"address":[56286676],"length":1,"stats":{"Line":0}},{"line":14703,"address":[53712818],"length":1,"stats":{"Line":0}},{"line":14704,"address":[56286860],"length":1,"stats":{"Line":0}},{"line":14707,"address":[56286954],"length":1,"stats":{"Line":0}},{"line":14708,"address":[56287034],"length":1,"stats":{"Line":0}},{"line":14709,"address":[53713068],"length":1,"stats":{"Line":0}},{"line":14710,"address":[54545187],"length":1,"stats":{"Line":0}},{"line":14714,"address":[53713126],"length":1,"stats":{"Line":0}},{"line":14715,"address":[54545267],"length":1,"stats":{"Line":0}},{"line":14716,"address":[],"length":0,"stats":{"Line":0}},{"line":14717,"address":[53713165],"length":1,"stats":{"Line":0}},{"line":14721,"address":[54735166],"length":1,"stats":{"Line":0}},{"line":14722,"address":[54545389],"length":1,"stats":{"Line":0}},{"line":14725,"address":[],"length":0,"stats":{"Line":0}},{"line":14726,"address":[53713435],"length":1,"stats":{"Line":0}},{"line":14729,"address":[56287544],"length":1,"stats":{"Line":0}},{"line":14730,"address":[],"length":0,"stats":{"Line":0}},{"line":14731,"address":[54735666],"length":1,"stats":{"Line":0}},{"line":14734,"address":[54545939],"length":1,"stats":{"Line":0}},{"line":14735,"address":[56287860],"length":1,"stats":{"Line":0}},{"line":14736,"address":[],"length":0,"stats":{"Line":0}},{"line":14737,"address":[54545970],"length":1,"stats":{"Line":0}},{"line":14739,"address":[53714017],"length":1,"stats":{"Line":0}},{"line":14740,"address":[53713939],"length":1,"stats":{"Line":0}},{"line":14741,"address":[54546090],"length":1,"stats":{"Line":0}},{"line":14744,"address":[54736035],"length":1,"stats":{"Line":0}},{"line":14748,"address":[56297232],"length":1,"stats":{"Line":0}},{"line":14752,"address":[54745185],"length":1,"stats":{"Line":0}},{"line":14755,"address":[53723471],"length":1,"stats":{"Line":0}},{"line":14756,"address":[54745256],"length":1,"stats":{"Line":0}},{"line":14757,"address":[],"length":0,"stats":{"Line":0}},{"line":14758,"address":[],"length":0,"stats":{"Line":0}},{"line":14761,"address":[54555701],"length":1,"stats":{"Line":0}},{"line":14762,"address":[53723643],"length":1,"stats":{"Line":0}},{"line":14763,"address":[54745463],"length":1,"stats":{"Line":0}},{"line":14764,"address":[],"length":0,"stats":{"Line":0}},{"line":14765,"address":[53723712],"length":1,"stats":{"Line":0}},{"line":14769,"address":[54745545],"length":1,"stats":{"Line":0}},{"line":14770,"address":[],"length":0,"stats":{"Line":0}},{"line":14771,"address":[54555908],"length":1,"stats":{"Line":0}},{"line":14774,"address":[54555977],"length":1,"stats":{"Line":0}},{"line":14776,"address":[54745633],"length":1,"stats":{"Line":0}},{"line":14777,"address":[],"length":0,"stats":{"Line":0}},{"line":14778,"address":[53723891],"length":1,"stats":{"Line":0}},{"line":14783,"address":[],"length":0,"stats":{"Line":0}},{"line":14784,"address":[],"length":0,"stats":{"Line":0}},{"line":14785,"address":[],"length":0,"stats":{"Line":0}},{"line":14790,"address":[53724123],"length":1,"stats":{"Line":0}},{"line":14791,"address":[56298029],"length":1,"stats":{"Line":0}},{"line":14792,"address":[56298084],"length":1,"stats":{"Line":0}},{"line":14793,"address":[],"length":0,"stats":{"Line":0}},{"line":14794,"address":[54745979],"length":1,"stats":{"Line":0}},{"line":14796,"address":[],"length":0,"stats":{"Line":0}},{"line":14797,"address":[],"length":0,"stats":{"Line":0}},{"line":14798,"address":[53724311],"length":1,"stats":{"Line":0}},{"line":14802,"address":[54746132],"length":1,"stats":{"Line":0}},{"line":14803,"address":[],"length":0,"stats":{"Line":0}},{"line":14804,"address":[53724400],"length":1,"stats":{"Line":0}},{"line":14812,"address":[53724610],"length":1,"stats":{"Line":0}},{"line":14814,"address":[53724627],"length":1,"stats":{"Line":0}},{"line":14815,"address":[56298497],"length":1,"stats":{"Line":0}},{"line":14821,"address":[],"length":0,"stats":{"Line":0}},{"line":14822,"address":[54746685],"length":1,"stats":{"Line":0}},{"line":14824,"address":[54746732],"length":1,"stats":{"Line":0}},{"line":14825,"address":[54746830],"length":1,"stats":{"Line":0}},{"line":14827,"address":[],"length":0,"stats":{"Line":0}},{"line":14828,"address":[54557316],"length":1,"stats":{"Line":0}},{"line":14829,"address":[54746998],"length":1,"stats":{"Line":0}},{"line":14830,"address":[54747054],"length":1,"stats":{"Line":0}},{"line":14831,"address":[],"length":0,"stats":{"Line":0}},{"line":14832,"address":[56299278],"length":1,"stats":{"Line":0}},{"line":14834,"address":[54747219],"length":1,"stats":{"Line":0}},{"line":14835,"address":[56299388],"length":1,"stats":{"Line":0}},{"line":14837,"address":[],"length":0,"stats":{"Line":0}},{"line":14838,"address":[],"length":0,"stats":{"Line":0}},{"line":14839,"address":[54557690],"length":1,"stats":{"Line":0}},{"line":14842,"address":[53725685],"length":1,"stats":{"Line":0}},{"line":14843,"address":[],"length":0,"stats":{"Line":0}},{"line":14844,"address":[53725692],"length":1,"stats":{"Line":0}},{"line":14846,"address":[56299620],"length":1,"stats":{"Line":0}},{"line":14847,"address":[],"length":0,"stats":{"Line":0}},{"line":14848,"address":[53725782],"length":1,"stats":{"Line":0}},{"line":14850,"address":[56299715],"length":1,"stats":{"Line":0}},{"line":14851,"address":[56299722],"length":1,"stats":{"Line":0}},{"line":14854,"address":[],"length":0,"stats":{"Line":0}},{"line":14855,"address":[56299793],"length":1,"stats":{"Line":0}},{"line":14856,"address":[54747779],"length":1,"stats":{"Line":0}},{"line":14858,"address":[56299947],"length":1,"stats":{"Line":0}},{"line":14859,"address":[54747892],"length":1,"stats":{"Line":0}},{"line":14861,"address":[53726196],"length":1,"stats":{"Line":0}},{"line":14862,"address":[],"length":0,"stats":{"Line":0}},{"line":14863,"address":[54747931],"length":1,"stats":{"Line":0}},{"line":14866,"address":[54748036],"length":1,"stats":{"Line":0}},{"line":14867,"address":[],"length":0,"stats":{"Line":0}},{"line":14868,"address":[54558432],"length":1,"stats":{"Line":0}},{"line":14870,"address":[56300228],"length":1,"stats":{"Line":0}},{"line":14871,"address":[],"length":0,"stats":{"Line":0}},{"line":14872,"address":[56300235],"length":1,"stats":{"Line":0}},{"line":14874,"address":[53726492],"length":1,"stats":{"Line":0}},{"line":14875,"address":[54558611],"length":1,"stats":{"Line":0}},{"line":14878,"address":[54558662],"length":1,"stats":{"Line":0}},{"line":14881,"address":[54558699],"length":1,"stats":{"Line":0}},{"line":14882,"address":[],"length":0,"stats":{"Line":0}},{"line":14884,"address":[],"length":0,"stats":{"Line":0}},{"line":14885,"address":[54748322],"length":1,"stats":{"Line":0}},{"line":14890,"address":[54748464],"length":1,"stats":{"Line":0}},{"line":14892,"address":[54558879],"length":1,"stats":{"Line":0}},{"line":14893,"address":[],"length":0,"stats":{"Line":0}},{"line":14894,"address":[],"length":0,"stats":{"Line":0}},{"line":14899,"address":[53726904],"length":1,"stats":{"Line":0}},{"line":14900,"address":[],"length":0,"stats":{"Line":0}},{"line":14902,"address":[],"length":0,"stats":{"Line":0}},{"line":14903,"address":[54559033],"length":1,"stats":{"Line":0}},{"line":14907,"address":[56300874],"length":1,"stats":{"Line":0}},{"line":14908,"address":[],"length":0,"stats":{"Line":0}},{"line":14909,"address":[],"length":0,"stats":{"Line":0}},{"line":14913,"address":[],"length":0,"stats":{"Line":0}},{"line":14914,"address":[53727261],"length":1,"stats":{"Line":0}},{"line":14915,"address":[],"length":0,"stats":{"Line":0}},{"line":14917,"address":[],"length":0,"stats":{"Line":0}},{"line":14918,"address":[],"length":0,"stats":{"Line":0}},{"line":14919,"address":[53727285],"length":1,"stats":{"Line":0}},{"line":14920,"address":[54559424],"length":1,"stats":{"Line":0}},{"line":14925,"address":[],"length":0,"stats":{"Line":0}},{"line":14927,"address":[53727441],"length":1,"stats":{"Line":0}},{"line":14928,"address":[],"length":0,"stats":{"Line":0}},{"line":14929,"address":[54559589],"length":1,"stats":{"Line":0}},{"line":14934,"address":[53727578],"length":1,"stats":{"Line":0}},{"line":14935,"address":[],"length":0,"stats":{"Line":0}},{"line":14937,"address":[],"length":0,"stats":{"Line":0}},{"line":14938,"address":[56301407],"length":1,"stats":{"Line":0}},{"line":14942,"address":[],"length":0,"stats":{"Line":0}},{"line":14943,"address":[],"length":0,"stats":{"Line":0}},{"line":14944,"address":[54749434],"length":1,"stats":{"Line":0}},{"line":14948,"address":[53727850],"length":1,"stats":{"Line":0}},{"line":14949,"address":[],"length":0,"stats":{"Line":0}},{"line":14950,"address":[54559976],"length":1,"stats":{"Line":0}},{"line":14953,"address":[],"length":0,"stats":{"Line":0}},{"line":14954,"address":[],"length":0,"stats":{"Line":0}},{"line":14955,"address":[54749697],"length":1,"stats":{"Line":0}},{"line":14960,"address":[54749804],"length":1,"stats":{"Line":0}},{"line":14961,"address":[],"length":0,"stats":{"Line":0}},{"line":14962,"address":[54560231],"length":1,"stats":{"Line":0}},{"line":14965,"address":[54749899],"length":1,"stats":{"Line":0}},{"line":14966,"address":[53728265],"length":1,"stats":{"Line":0}},{"line":14968,"address":[],"length":0,"stats":{"Line":0}},{"line":14969,"address":[54560448],"length":1,"stats":{"Line":0}},{"line":14972,"address":[53728387],"length":1,"stats":{"Line":0}},{"line":14974,"address":[],"length":0,"stats":{"Line":0}},{"line":14975,"address":[53728506],"length":1,"stats":{"Line":0}},{"line":14976,"address":[56302361],"length":1,"stats":{"Line":0}},{"line":14977,"address":[54560683],"length":1,"stats":{"Line":0}},{"line":14980,"address":[54560734],"length":1,"stats":{"Line":0}},{"line":14981,"address":[],"length":0,"stats":{"Line":0}},{"line":14982,"address":[],"length":0,"stats":{"Line":0}},{"line":14983,"address":[53728799],"length":1,"stats":{"Line":0}},{"line":14985,"address":[56302648],"length":1,"stats":{"Line":0}},{"line":14986,"address":[53728894],"length":1,"stats":{"Line":0}},{"line":14987,"address":[53728976],"length":1,"stats":{"Line":0}},{"line":14988,"address":[],"length":0,"stats":{"Line":0}},{"line":14990,"address":[53729092],"length":1,"stats":{"Line":0}},{"line":14993,"address":[56302907],"length":1,"stats":{"Line":0}},{"line":14994,"address":[],"length":0,"stats":{"Line":0}},{"line":14995,"address":[56302917],"length":1,"stats":{"Line":0}},{"line":14997,"address":[54561322],"length":1,"stats":{"Line":0}},{"line":14998,"address":[],"length":0,"stats":{"Line":0}},{"line":14999,"address":[],"length":0,"stats":{"Line":0}},{"line":15000,"address":[56303009],"length":1,"stats":{"Line":0}},{"line":15001,"address":[54561393],"length":1,"stats":{"Line":0}},{"line":15002,"address":[56303104],"length":1,"stats":{"Line":0}},{"line":15003,"address":[],"length":0,"stats":{"Line":0}},{"line":15004,"address":[54561440],"length":1,"stats":{"Line":0}},{"line":15006,"address":[],"length":0,"stats":{"Line":0}},{"line":15007,"address":[],"length":0,"stats":{"Line":0}},{"line":15008,"address":[54751108],"length":1,"stats":{"Line":0}},{"line":15010,"address":[],"length":0,"stats":{"Line":0}},{"line":15014,"address":[55091360],"length":1,"stats":{"Line":0}},{"line":15018,"address":[54074129],"length":1,"stats":{"Line":0}},{"line":15021,"address":[],"length":0,"stats":{"Line":0}},{"line":15022,"address":[54074200],"length":1,"stats":{"Line":0}},{"line":15023,"address":[],"length":0,"stats":{"Line":0}},{"line":15024,"address":[54906319],"length":1,"stats":{"Line":0}},{"line":15027,"address":[56643747],"length":1,"stats":{"Line":0}},{"line":15028,"address":[55091644],"length":1,"stats":{"Line":0}},{"line":15029,"address":[],"length":0,"stats":{"Line":0}},{"line":15030,"address":[],"length":0,"stats":{"Line":0}},{"line":15031,"address":[],"length":0,"stats":{"Line":0}},{"line":15035,"address":[54906611],"length":1,"stats":{"Line":0}},{"line":15036,"address":[],"length":0,"stats":{"Line":0}},{"line":15037,"address":[56643958],"length":1,"stats":{"Line":0}},{"line":15040,"address":[54074575],"length":1,"stats":{"Line":0}},{"line":15042,"address":[56644039],"length":1,"stats":{"Line":0}},{"line":15043,"address":[],"length":0,"stats":{"Line":0}},{"line":15044,"address":[],"length":0,"stats":{"Line":0}},{"line":15049,"address":[],"length":0,"stats":{"Line":0}},{"line":15050,"address":[],"length":0,"stats":{"Line":0}},{"line":15051,"address":[54906854],"length":1,"stats":{"Line":0}},{"line":15056,"address":[56644279],"length":1,"stats":{"Line":0}},{"line":15057,"address":[54906989],"length":1,"stats":{"Line":0}},{"line":15058,"address":[54907044],"length":1,"stats":{"Line":0}},{"line":15059,"address":[],"length":0,"stats":{"Line":0}},{"line":15060,"address":[55092225],"length":1,"stats":{"Line":0}},{"line":15062,"address":[55092298],"length":1,"stats":{"Line":0}},{"line":15063,"address":[],"length":0,"stats":{"Line":0}},{"line":15064,"address":[],"length":0,"stats":{"Line":0}},{"line":15068,"address":[],"length":0,"stats":{"Line":0}},{"line":15069,"address":[],"length":0,"stats":{"Line":0}},{"line":15070,"address":[54907219],"length":1,"stats":{"Line":0}},{"line":15078,"address":[56644756],"length":1,"stats":{"Line":0}},{"line":15080,"address":[55092613],"length":1,"stats":{"Line":0}},{"line":15081,"address":[54075349],"length":1,"stats":{"Line":0}},{"line":15087,"address":[54075598],"length":1,"stats":{"Line":0}},{"line":15088,"address":[56645061],"length":1,"stats":{"Line":0}},{"line":15089,"address":[],"length":0,"stats":{"Line":0}},{"line":15090,"address":[],"length":0,"stats":{"Line":0}},{"line":15096,"address":[55093131],"length":1,"stats":{"Line":0}},{"line":15097,"address":[],"length":0,"stats":{"Line":0}},{"line":15098,"address":[54907985],"length":1,"stats":{"Line":0}},{"line":15100,"address":[56645401],"length":1,"stats":{"Line":0}},{"line":15101,"address":[54908097],"length":1,"stats":{"Line":0}},{"line":15105,"address":[55093395],"length":1,"stats":{"Line":0}},{"line":15106,"address":[54908278],"length":1,"stats":{"Line":0}},{"line":15108,"address":[55093493],"length":1,"stats":{"Line":0}},{"line":15109,"address":[],"length":0,"stats":{"Line":0}},{"line":15110,"address":[56645660],"length":1,"stats":{"Line":0}},{"line":15112,"address":[56645733],"length":1,"stats":{"Line":0}},{"line":15113,"address":[],"length":0,"stats":{"Line":0}},{"line":15115,"address":[54908573],"length":1,"stats":{"Line":0}},{"line":15116,"address":[],"length":0,"stats":{"Line":0}},{"line":15117,"address":[56645999],"length":1,"stats":{"Line":0}},{"line":15119,"address":[],"length":0,"stats":{"Line":0}},{"line":15120,"address":[54908745],"length":1,"stats":{"Line":0}},{"line":15122,"address":[54908796],"length":1,"stats":{"Line":0}},{"line":15124,"address":[],"length":0,"stats":{"Line":0}},{"line":15125,"address":[],"length":0,"stats":{"Line":0}},{"line":15126,"address":[],"length":0,"stats":{"Line":0}},{"line":15129,"address":[],"length":0,"stats":{"Line":0}},{"line":15130,"address":[],"length":0,"stats":{"Line":0}},{"line":15131,"address":[56646255],"length":1,"stats":{"Line":0}},{"line":15133,"address":[54076922],"length":1,"stats":{"Line":0}},{"line":15134,"address":[54909041],"length":1,"stats":{"Line":0}},{"line":15137,"address":[],"length":0,"stats":{"Line":0}},{"line":15140,"address":[],"length":0,"stats":{"Line":0}},{"line":15141,"address":[],"length":0,"stats":{"Line":0}},{"line":15142,"address":[54077011],"length":1,"stats":{"Line":0}},{"line":15148,"address":[55094416],"length":1,"stats":{"Line":0}},{"line":15149,"address":[],"length":0,"stats":{"Line":0}},{"line":15150,"address":[56646586],"length":1,"stats":{"Line":0}},{"line":15152,"address":[56646679],"length":1,"stats":{"Line":0}},{"line":15153,"address":[54909458],"length":1,"stats":{"Line":0}},{"line":15154,"address":[],"length":0,"stats":{"Line":0}},{"line":15155,"address":[56646766],"length":1,"stats":{"Line":0}},{"line":15159,"address":[54909553],"length":1,"stats":{"Line":0}},{"line":15160,"address":[],"length":0,"stats":{"Line":0}},{"line":15162,"address":[],"length":0,"stats":{"Line":0}},{"line":15163,"address":[56646869],"length":1,"stats":{"Line":0}},{"line":15168,"address":[54909716],"length":1,"stats":{"Line":0}},{"line":15170,"address":[54909733],"length":1,"stats":{"Line":0}},{"line":15171,"address":[],"length":0,"stats":{"Line":0}},{"line":15172,"address":[54077657],"length":1,"stats":{"Line":0}},{"line":15177,"address":[54909870],"length":1,"stats":{"Line":0}},{"line":15178,"address":[],"length":0,"stats":{"Line":0}},{"line":15180,"address":[],"length":0,"stats":{"Line":0}},{"line":15181,"address":[54909887],"length":1,"stats":{"Line":0}},{"line":15185,"address":[54077906],"length":1,"stats":{"Line":0}},{"line":15186,"address":[],"length":0,"stats":{"Line":0}},{"line":15187,"address":[],"length":0,"stats":{"Line":0}},{"line":15191,"address":[55095274],"length":1,"stats":{"Line":0}},{"line":15192,"address":[],"length":0,"stats":{"Line":0}},{"line":15194,"address":[],"length":0,"stats":{"Line":0}},{"line":15195,"address":[54078050],"length":1,"stats":{"Line":0}},{"line":15200,"address":[54078196],"length":1,"stats":{"Line":0}},{"line":15202,"address":[56647610],"length":1,"stats":{"Line":0}},{"line":15203,"address":[],"length":0,"stats":{"Line":0}},{"line":15204,"address":[54910361],"length":1,"stats":{"Line":0}},{"line":15209,"address":[],"length":0,"stats":{"Line":0}},{"line":15210,"address":[],"length":0,"stats":{"Line":0}},{"line":15212,"address":[],"length":0,"stats":{"Line":0}},{"line":15213,"address":[56647762],"length":1,"stats":{"Line":0}},{"line":15217,"address":[55095731],"length":1,"stats":{"Line":0}},{"line":15218,"address":[],"length":0,"stats":{"Line":0}},{"line":15219,"address":[54910620],"length":1,"stats":{"Line":0}},{"line":15223,"address":[55095832],"length":1,"stats":{"Line":0}},{"line":15224,"address":[54078675],"length":1,"stats":{"Line":0}},{"line":15227,"address":[56648128],"length":1,"stats":{"Line":0}},{"line":15228,"address":[54078823],"length":1,"stats":{"Line":0}},{"line":15229,"address":[54078881],"length":1,"stats":{"Line":0}},{"line":15230,"address":[54078888],"length":1,"stats":{"Line":0}},{"line":15233,"address":[54078939],"length":1,"stats":{"Line":0}},{"line":15236,"address":[54911080],"length":1,"stats":{"Line":0}},{"line":15237,"address":[],"length":0,"stats":{"Line":0}},{"line":15238,"address":[54911090],"length":1,"stats":{"Line":0}},{"line":15240,"address":[56648437],"length":1,"stats":{"Line":0}},{"line":15241,"address":[],"length":0,"stats":{"Line":0}},{"line":15242,"address":[],"length":0,"stats":{"Line":0}},{"line":15243,"address":[54911184],"length":1,"stats":{"Line":0}},{"line":15244,"address":[54079128],"length":1,"stats":{"Line":0}},{"line":15245,"address":[54079168],"length":1,"stats":{"Line":0}},{"line":15246,"address":[],"length":0,"stats":{"Line":0}},{"line":15247,"address":[56648554],"length":1,"stats":{"Line":0}},{"line":15249,"address":[],"length":0,"stats":{"Line":0}},{"line":15250,"address":[],"length":0,"stats":{"Line":0}},{"line":15251,"address":[54911398],"length":1,"stats":{"Line":0}},{"line":15253,"address":[],"length":0,"stats":{"Line":0}},{"line":15259,"address":[54229584,54229749,54229743],"length":1,"stats":{"Line":0}},{"line":15260,"address":[],"length":0,"stats":{"Line":0}},{"line":15261,"address":[55244161],"length":1,"stats":{"Line":0}},{"line":15262,"address":[55061827],"length":1,"stats":{"Line":0}},{"line":15266,"address":[56706756,56701520,56706762],"length":1,"stats":{"Line":0}},{"line":15267,"address":[56701591],"length":1,"stats":{"Line":0}},{"line":15268,"address":[55149520],"length":1,"stats":{"Line":0}},{"line":15269,"address":[],"length":0,"stats":{"Line":0}},{"line":15270,"address":[55151049],"length":1,"stats":{"Line":0}},{"line":15273,"address":[55149639],"length":1,"stats":{"Line":0}},{"line":15274,"address":[],"length":0,"stats":{"Line":0}},{"line":15275,"address":[54134915,54134959],"length":1,"stats":{"Line":0}},{"line":15277,"address":[54965318],"length":1,"stats":{"Line":0}},{"line":15278,"address":[55149731,55151560],"length":1,"stats":{"Line":0}},{"line":15280,"address":[],"length":0,"stats":{"Line":0}},{"line":15281,"address":[54967283,54965410,54967394],"length":1,"stats":{"Line":0}},{"line":15282,"address":[],"length":0,"stats":{"Line":0}},{"line":15284,"address":[],"length":0,"stats":{"Line":0}},{"line":15285,"address":[],"length":0,"stats":{"Line":0}},{"line":15286,"address":[],"length":0,"stats":{"Line":0}},{"line":15287,"address":[55152015,55151904,55149885],"length":1,"stats":{"Line":0}},{"line":15288,"address":[54135497,54135534],"length":1,"stats":{"Line":0}},{"line":15289,"address":[56704288],"length":1,"stats":{"Line":0}},{"line":15292,"address":[55149924],"length":1,"stats":{"Line":0}},{"line":15293,"address":[55152139,55149939],"length":1,"stats":{"Line":0}},{"line":15295,"address":[54965580],"length":1,"stats":{"Line":0}},{"line":15296,"address":[55152245,55152353,55150016],"length":1,"stats":{"Line":0}},{"line":15297,"address":[55152371,55152333],"length":1,"stats":{"Line":0}},{"line":15299,"address":[],"length":0,"stats":{"Line":0}},{"line":15300,"address":[55150093,55152579,55152471],"length":1,"stats":{"Line":0}},{"line":15301,"address":[54968178,54968216],"length":1,"stats":{"Line":0}},{"line":15303,"address":[55150170],"length":1,"stats":{"Line":0}},{"line":15304,"address":[],"length":0,"stats":{"Line":0}},{"line":15305,"address":[],"length":0,"stats":{"Line":0}},{"line":15306,"address":[],"length":0,"stats":{"Line":0}},{"line":15307,"address":[],"length":0,"stats":{"Line":0}},{"line":15308,"address":[],"length":0,"stats":{"Line":0}},{"line":15309,"address":[],"length":0,"stats":{"Line":0}},{"line":15310,"address":[],"length":0,"stats":{"Line":0}},{"line":15311,"address":[55152905,55152943],"length":1,"stats":{"Line":0}},{"line":15313,"address":[54966543],"length":1,"stats":{"Line":0}},{"line":15314,"address":[],"length":0,"stats":{"Line":0}},{"line":15315,"address":[],"length":0,"stats":{"Line":0}},{"line":15316,"address":[],"length":0,"stats":{"Line":0}},{"line":15317,"address":[],"length":0,"stats":{"Line":0}},{"line":15318,"address":[],"length":0,"stats":{"Line":0}},{"line":15319,"address":[54138821,54134477,54138929],"length":1,"stats":{"Line":0}},{"line":15320,"address":[54138947,54138909,54139048],"length":1,"stats":{"Line":0}},{"line":15321,"address":[55155546,55155510],"length":1,"stats":{"Line":0}},{"line":15323,"address":[56702515],"length":1,"stats":{"Line":0}},{"line":15324,"address":[54137148,54133857],"length":1,"stats":{"Line":0}},{"line":15325,"address":[54969357],"length":1,"stats":{"Line":0}},{"line":15328,"address":[],"length":0,"stats":{"Line":0}},{"line":15329,"address":[],"length":0,"stats":{"Line":0}},{"line":15330,"address":[],"length":0,"stats":{"Line":0}},{"line":15331,"address":[],"length":0,"stats":{"Line":0}},{"line":15334,"address":[56702746],"length":1,"stats":{"Line":0}},{"line":15335,"address":[],"length":0,"stats":{"Line":0}},{"line":15336,"address":[54137810,54134146],"length":1,"stats":{"Line":0}},{"line":15337,"address":[54137910,54138078],"length":1,"stats":{"Line":0}},{"line":15339,"address":[54137947],"length":1,"stats":{"Line":0}},{"line":15341,"address":[55149570],"length":1,"stats":{"Line":0}},{"line":15342,"address":[54133102,54134615],"length":1,"stats":{"Line":0}},{"line":15343,"address":[54134668],"length":1,"stats":{"Line":0}},{"line":15345,"address":[54966833,54966749],"length":1,"stats":{"Line":0}},{"line":15347,"address":[54133783],"length":1,"stats":{"Line":0}},{"line":15348,"address":[],"length":0,"stats":{"Line":0}},{"line":15349,"address":[],"length":0,"stats":{"Line":0}},{"line":15350,"address":[],"length":0,"stats":{"Line":0}},{"line":15351,"address":[],"length":0,"stats":{"Line":0}},{"line":15352,"address":[],"length":0,"stats":{"Line":0}},{"line":15353,"address":[],"length":0,"stats":{"Line":0}},{"line":15354,"address":[54965918,54968662,54968778],"length":1,"stats":{"Line":0}},{"line":15355,"address":[55153180,55153131],"length":1,"stats":{"Line":0}},{"line":15356,"address":[55153252,55153188],"length":1,"stats":{"Line":0}},{"line":15358,"address":[54136723,54136856],"length":1,"stats":{"Line":0}},{"line":15359,"address":[54969040,54968976],"length":1,"stats":{"Line":0}},{"line":15361,"address":[56705549,56705682],"length":1,"stats":{"Line":0}},{"line":15362,"address":[54137033],"length":1,"stats":{"Line":0}},{"line":15365,"address":[],"length":0,"stats":{"Line":0}},{"line":15366,"address":[],"length":0,"stats":{"Line":0}},{"line":15367,"address":[54138313],"length":1,"stats":{"Line":0}},{"line":15368,"address":[],"length":0,"stats":{"Line":0}},{"line":15372,"address":[54966051],"length":1,"stats":{"Line":0}},{"line":15373,"address":[55153917,55154025,55150485],"length":1,"stats":{"Line":0}},{"line":15374,"address":[54969626,54969664],"length":1,"stats":{"Line":0}},{"line":15376,"address":[54134339],"length":1,"stats":{"Line":0}},{"line":15377,"address":[56707348,56703040,56707240],"length":1,"stats":{"Line":0}},{"line":15378,"address":[55155202,55155164],"length":1,"stats":{"Line":0}},{"line":15380,"address":[],"length":0,"stats":{"Line":0}},{"line":15381,"address":[],"length":0,"stats":{"Line":0}},{"line":15383,"address":[55150784],"length":1,"stats":{"Line":0}},{"line":15384,"address":[56702963,56707134],"length":1,"stats":{"Line":0}},{"line":15386,"address":[56702848],"length":1,"stats":{"Line":0}},{"line":15387,"address":[55150699,55154619],"length":1,"stats":{"Line":0}},{"line":15390,"address":[],"length":0,"stats":{"Line":0}},{"line":15395,"address":[55111504],"length":1,"stats":{"Line":0}},{"line":15396,"address":[],"length":0,"stats":{"Line":0}},{"line":15397,"address":[55112750],"length":1,"stats":{"Line":0}},{"line":15398,"address":[54926648],"length":1,"stats":{"Line":0}},{"line":15399,"address":[56663843],"length":1,"stats":{"Line":0}},{"line":15400,"address":[54926761,54928233],"length":1,"stats":{"Line":0}},{"line":15402,"address":[54094742],"length":1,"stats":{"Line":0}},{"line":15403,"address":[55111852,55113505],"length":1,"stats":{"Line":0}},{"line":15405,"address":[54926800,54928455],"length":1,"stats":{"Line":0}},{"line":15406,"address":[56106544,56106558],"length":1,"stats":{"Line":0}},{"line":15407,"address":[],"length":0,"stats":{"Line":0}},{"line":15408,"address":[],"length":0,"stats":{"Line":0}},{"line":15409,"address":[55111968,55113906],"length":1,"stats":{"Line":0}},{"line":15410,"address":[54094950],"length":1,"stats":{"Line":0}},{"line":15411,"address":[55112060,55114005],"length":1,"stats":{"Line":0}},{"line":15413,"address":[],"length":0,"stats":{"Line":0}},{"line":15414,"address":[54097167,54095065],"length":1,"stats":{"Line":0}},{"line":15416,"address":[54095104],"length":1,"stats":{"Line":0}},{"line":15417,"address":[],"length":0,"stats":{"Line":0}},{"line":15418,"address":[],"length":0,"stats":{"Line":0}},{"line":15419,"address":[],"length":0,"stats":{"Line":0}},{"line":15420,"address":[],"length":0,"stats":{"Line":0}},{"line":15421,"address":[],"length":0,"stats":{"Line":0}},{"line":15422,"address":[],"length":0,"stats":{"Line":0}},{"line":15423,"address":[],"length":0,"stats":{"Line":0}},{"line":15424,"address":[54929715],"length":1,"stats":{"Line":0}},{"line":15426,"address":[],"length":0,"stats":{"Line":0}},{"line":15427,"address":[],"length":0,"stats":{"Line":0}},{"line":15428,"address":[],"length":0,"stats":{"Line":0}},{"line":15429,"address":[],"length":0,"stats":{"Line":0}},{"line":15430,"address":[],"length":0,"stats":{"Line":0}},{"line":15431,"address":[],"length":0,"stats":{"Line":0}},{"line":15432,"address":[54928084,54930775,54930877],"length":1,"stats":{"Line":0}},{"line":15433,"address":[56667959,56667997],"length":1,"stats":{"Line":0}},{"line":15434,"address":[],"length":0,"stats":{"Line":0}},{"line":15436,"address":[54511600,54511614],"length":1,"stats":{"Line":0}},{"line":15437,"address":[54095417],"length":1,"stats":{"Line":0}},{"line":15439,"address":[54511394,54511376],"length":1,"stats":{"Line":0}},{"line":15440,"address":[],"length":0,"stats":{"Line":0}},{"line":15441,"address":[56665231,56663789],"length":1,"stats":{"Line":0}},{"line":15442,"address":[56664497],"length":1,"stats":{"Line":0}},{"line":15443,"address":[],"length":0,"stats":{"Line":0}},{"line":15444,"address":[],"length":0,"stats":{"Line":0}},{"line":15445,"address":[],"length":0,"stats":{"Line":0}},{"line":15446,"address":[],"length":0,"stats":{"Line":0}},{"line":15447,"address":[],"length":0,"stats":{"Line":0}},{"line":15448,"address":[],"length":0,"stats":{"Line":0}},{"line":15449,"address":[55114899,55112360,55114779],"length":1,"stats":{"Line":0}},{"line":15450,"address":[53119523,53119504],"length":1,"stats":{"Line":0}},{"line":15451,"address":[53120032,53120051],"length":1,"stats":{"Line":0}},{"line":15452,"address":[54930011],"length":1,"stats":{"Line":0}},{"line":15454,"address":[55112573],"length":1,"stats":{"Line":0}},{"line":15455,"address":[56664771,56667160],"length":1,"stats":{"Line":0}},{"line":15457,"address":[56665069],"length":1,"stats":{"Line":0}},{"line":15458,"address":[54927993,54930565],"length":1,"stats":{"Line":0}},{"line":15460,"address":[56664931],"length":1,"stats":{"Line":0}},{"line":15461,"address":[56106360,56106448],"length":1,"stats":{"Line":0}},{"line":15462,"address":[53119943,53119902],"length":1,"stats":{"Line":0}},{"line":15464,"address":[],"length":0,"stats":{"Line":0}},{"line":15467,"address":[55115222,55112650],"length":1,"stats":{"Line":0}},{"line":15468,"address":[56667577,56665018],"length":1,"stats":{"Line":0}},{"line":15473,"address":[55328328,55328299,55327648],"length":1,"stats":{"Line":0}},{"line":15478,"address":[54035699,54035664],"length":1,"stats":{"Line":0}},{"line":15479,"address":[55327791],"length":1,"stats":{"Line":0}},{"line":15481,"address":[55327845,55327918],"length":1,"stats":{"Line":0}},{"line":15482,"address":[55328305,55328032],"length":1,"stats":{"Line":0}},{"line":15486,"address":[55328042],"length":1,"stats":{"Line":0}},{"line":15487,"address":[55147013,55146932],"length":1,"stats":{"Line":0}},{"line":15488,"address":[54314917],"length":1,"stats":{"Line":0}},{"line":15492,"address":[54239280,54242064,54242070],"length":1,"stats":{"Line":0}},{"line":15498,"address":[55071463],"length":1,"stats":{"Line":0}},{"line":15499,"address":[55072325],"length":1,"stats":{"Line":0}},{"line":15500,"address":[],"length":0,"stats":{"Line":0}},{"line":15502,"address":[],"length":0,"stats":{"Line":0}},{"line":15503,"address":[55253886],"length":1,"stats":{"Line":0}},{"line":15505,"address":[],"length":0,"stats":{"Line":0}},{"line":15506,"address":[],"length":0,"stats":{"Line":0}},{"line":15507,"address":[],"length":0,"stats":{"Line":0}},{"line":15508,"address":[55253800,55255100],"length":1,"stats":{"Line":0}},{"line":15509,"address":[55255108],"length":1,"stats":{"Line":0}},{"line":15511,"address":[55255121],"length":1,"stats":{"Line":0}},{"line":15513,"address":[54239685],"length":1,"stats":{"Line":0}},{"line":15514,"address":[],"length":0,"stats":{"Line":0}},{"line":15515,"address":[],"length":0,"stats":{"Line":0}},{"line":15516,"address":[],"length":0,"stats":{"Line":0}},{"line":15517,"address":[],"length":0,"stats":{"Line":0}},{"line":15518,"address":[],"length":0,"stats":{"Line":0}},{"line":15519,"address":[55254024],"length":1,"stats":{"Line":0}},{"line":15520,"address":[],"length":0,"stats":{"Line":0}},{"line":15521,"address":[],"length":0,"stats":{"Line":0}},{"line":15522,"address":[55073227],"length":1,"stats":{"Line":0}},{"line":15525,"address":[56806080],"length":1,"stats":{"Line":0}},{"line":15526,"address":[54240855,54239596],"length":1,"stats":{"Line":0}},{"line":15527,"address":[55255264],"length":1,"stats":{"Line":0}},{"line":15530,"address":[],"length":0,"stats":{"Line":0}},{"line":15531,"address":[],"length":0,"stats":{"Line":0}},{"line":15532,"address":[],"length":0,"stats":{"Line":0}},{"line":15533,"address":[],"length":0,"stats":{"Line":0}},{"line":15534,"address":[55254140,55255547],"length":1,"stats":{"Line":0}},{"line":15536,"address":[56806396],"length":1,"stats":{"Line":0}},{"line":15537,"address":[],"length":0,"stats":{"Line":0}},{"line":15538,"address":[],"length":0,"stats":{"Line":0}},{"line":15539,"address":[],"length":0,"stats":{"Line":0}},{"line":15540,"address":[],"length":0,"stats":{"Line":0}},{"line":15541,"address":[],"length":0,"stats":{"Line":0}},{"line":15542,"address":[56806423],"length":1,"stats":{"Line":0}},{"line":15543,"address":[55254265],"length":1,"stats":{"Line":0}},{"line":15544,"address":[55254288],"length":1,"stats":{"Line":0}},{"line":15545,"address":[55255732,55255644,55254338],"length":1,"stats":{"Line":0}},{"line":15546,"address":[56807898],"length":1,"stats":{"Line":0}},{"line":15547,"address":[56807934],"length":1,"stats":{"Line":0}},{"line":15550,"address":[55254438],"length":1,"stats":{"Line":0}},{"line":15551,"address":[55255797,55254458],"length":1,"stats":{"Line":0}},{"line":15552,"address":[56807981],"length":1,"stats":{"Line":0}},{"line":15555,"address":[56806953],"length":1,"stats":{"Line":0}},{"line":15556,"address":[],"length":0,"stats":{"Line":0}},{"line":15557,"address":[],"length":0,"stats":{"Line":0}},{"line":15558,"address":[55254805],"length":1,"stats":{"Line":0}},{"line":15559,"address":[54242112,54240503],"length":1,"stats":{"Line":0}},{"line":15560,"address":[55074232],"length":1,"stats":{"Line":0}},{"line":15563,"address":[55072473],"length":1,"stats":{"Line":0}},{"line":15564,"address":[],"length":0,"stats":{"Line":0}},{"line":15565,"address":[54241834,54240403],"length":1,"stats":{"Line":0}},{"line":15567,"address":[55074031],"length":1,"stats":{"Line":0}},{"line":15568,"address":[],"length":0,"stats":{"Line":0}},{"line":15570,"address":[55256325],"length":1,"stats":{"Line":0}},{"line":15573,"address":[],"length":0,"stats":{"Line":0}},{"line":15576,"address":[55254386],"length":1,"stats":{"Line":0}},{"line":15578,"address":[55254562],"length":1,"stats":{"Line":0}},{"line":15579,"address":[],"length":0,"stats":{"Line":0}},{"line":15580,"address":[],"length":0,"stats":{"Line":0}},{"line":15581,"address":[],"length":0,"stats":{"Line":0}},{"line":15582,"address":[],"length":0,"stats":{"Line":0}},{"line":15583,"address":[],"length":0,"stats":{"Line":0}},{"line":15584,"address":[55073621,55073803,55072413],"length":1,"stats":{"Line":0}},{"line":15585,"address":[54241599],"length":1,"stats":{"Line":0}},{"line":15586,"address":[],"length":0,"stats":{"Line":0}},{"line":15587,"address":[55073909,55073821,55073783],"length":1,"stats":{"Line":0}},{"line":15588,"address":[55073899],"length":1,"stats":{"Line":0}},{"line":15589,"address":[55256132],"length":1,"stats":{"Line":0}},{"line":15592,"address":[56807068],"length":1,"stats":{"Line":0}},{"line":15593,"address":[],"length":0,"stats":{"Line":0}},{"line":15594,"address":[],"length":0,"stats":{"Line":0}},{"line":15595,"address":[55072721],"length":1,"stats":{"Line":0}},{"line":15596,"address":[56807110,56808604],"length":1,"stats":{"Line":0}},{"line":15597,"address":[],"length":0,"stats":{"Line":0}},{"line":15600,"address":[],"length":0,"stats":{"Line":0}},{"line":15601,"address":[],"length":0,"stats":{"Line":0}},{"line":15603,"address":[54240732],"length":1,"stats":{"Line":0}},{"line":15604,"address":[55255058],"length":1,"stats":{"Line":0}},{"line":15607,"address":[],"length":0,"stats":{"Line":0}},{"line":15608,"address":[],"length":0,"stats":{"Line":0}},{"line":15609,"address":[],"length":0,"stats":{"Line":0}},{"line":15610,"address":[],"length":0,"stats":{"Line":0}},{"line":15611,"address":[],"length":0,"stats":{"Line":0}},{"line":15616,"address":[54263456],"length":1,"stats":{"Line":0}},{"line":15617,"address":[55277629],"length":1,"stats":{"Line":0}},{"line":15618,"address":[],"length":0,"stats":{"Line":0}},{"line":15619,"address":[54263542],"length":1,"stats":{"Line":0}},{"line":15621,"address":[],"length":0,"stats":{"Line":0}},{"line":15624,"address":[],"length":0,"stats":{"Line":0}},{"line":15629,"address":[55332576],"length":1,"stats":{"Line":0}},{"line":15634,"address":[56884781],"length":1,"stats":{"Line":0}},{"line":15635,"address":[54319410],"length":1,"stats":{"Line":0}},{"line":15636,"address":[],"length":0,"stats":{"Line":0}},{"line":15638,"address":[55332691],"length":1,"stats":{"Line":0}},{"line":15639,"address":[55151581],"length":1,"stats":{"Line":0}},{"line":15641,"address":[],"length":0,"stats":{"Line":0}},{"line":15650,"address":[56614738,56621051,56609264],"length":1,"stats":{"Line":0}},{"line":15656,"address":[56609366],"length":1,"stats":{"Line":0}},{"line":15657,"address":[54039363,54039449],"length":1,"stats":{"Line":0}},{"line":15660,"address":[55057593,55057486],"length":1,"stats":{"Line":0}},{"line":15661,"address":[56609807],"length":1,"stats":{"Line":0}},{"line":15664,"address":[],"length":0,"stats":{"Line":0}},{"line":15666,"address":[56104160,56104174],"length":1,"stats":{"Line":0}},{"line":15671,"address":[],"length":0,"stats":{"Line":0}},{"line":15672,"address":[54872103,54872040],"length":1,"stats":{"Line":0}},{"line":15673,"address":[55058068,55058000],"length":1,"stats":{"Line":0}},{"line":15674,"address":[54872390],"length":1,"stats":{"Line":0}},{"line":15678,"address":[54040002],"length":1,"stats":{"Line":0}},{"line":15680,"address":[],"length":0,"stats":{"Line":0}},{"line":15681,"address":[55058478],"length":1,"stats":{"Line":0}},{"line":15684,"address":[54040508],"length":1,"stats":{"Line":0}},{"line":15685,"address":[],"length":0,"stats":{"Line":0}},{"line":15686,"address":[54872765,54872695],"length":1,"stats":{"Line":0}},{"line":15692,"address":[54872857,54872786,54872630],"length":1,"stats":{"Line":0}},{"line":15693,"address":[],"length":0,"stats":{"Line":0}},{"line":15694,"address":[54872829],"length":1,"stats":{"Line":0}},{"line":15696,"address":[56610927,56611037],"length":1,"stats":{"Line":0}},{"line":15697,"address":[],"length":0,"stats":{"Line":0}},{"line":15700,"address":[55059080],"length":1,"stats":{"Line":0}},{"line":15701,"address":[54873241],"length":1,"stats":{"Line":0}},{"line":15702,"address":[54873355,54873280],"length":1,"stats":{"Line":0}},{"line":15703,"address":[55059301,55059233],"length":1,"stats":{"Line":0}},{"line":15704,"address":[],"length":0,"stats":{"Line":0}},{"line":15705,"address":[],"length":0,"stats":{"Line":0}},{"line":15706,"address":[56611589,56611657],"length":1,"stats":{"Line":0}},{"line":15707,"address":[55059537,55059641],"length":1,"stats":{"Line":0}},{"line":15708,"address":[54873803],"length":1,"stats":{"Line":0}},{"line":15711,"address":[],"length":0,"stats":{"Line":0}},{"line":15712,"address":[54873854],"length":1,"stats":{"Line":0}},{"line":15713,"address":[54873909],"length":1,"stats":{"Line":0}},{"line":15716,"address":[55059789],"length":1,"stats":{"Line":0}},{"line":15717,"address":[55059808],"length":1,"stats":{"Line":0}},{"line":15718,"address":[54041872],"length":1,"stats":{"Line":0}},{"line":15719,"address":[56611980],"length":1,"stats":{"Line":0}},{"line":15720,"address":[55059874],"length":1,"stats":{"Line":0}},{"line":15721,"address":[54041950],"length":1,"stats":{"Line":0}},{"line":15722,"address":[54874088],"length":1,"stats":{"Line":0}},{"line":15725,"address":[54874096],"length":1,"stats":{"Line":0}},{"line":15726,"address":[54882996,54874430],"length":1,"stats":{"Line":0}},{"line":15727,"address":[],"length":0,"stats":{"Line":0}},{"line":15728,"address":[54882925,54874448],"length":1,"stats":{"Line":0}},{"line":15730,"address":[55068502],"length":1,"stats":{"Line":0}},{"line":15731,"address":[56620750],"length":1,"stats":{"Line":0}},{"line":15732,"address":[56620802],"length":1,"stats":{"Line":0}},{"line":15735,"address":[55068718,55068782],"length":1,"stats":{"Line":0}},{"line":15736,"address":[55068770],"length":1,"stats":{"Line":0}},{"line":15741,"address":[56612455],"length":1,"stats":{"Line":0}},{"line":15742,"address":[56612514],"length":1,"stats":{"Line":0}},{"line":15743,"address":[],"length":0,"stats":{"Line":0}},{"line":15744,"address":[],"length":0,"stats":{"Line":0}},{"line":15745,"address":[56612823,56620205],"length":1,"stats":{"Line":0}},{"line":15747,"address":[54882600],"length":1,"stats":{"Line":0}},{"line":15748,"address":[56620423],"length":1,"stats":{"Line":0}},{"line":15749,"address":[56620483],"length":1,"stats":{"Line":0}},{"line":15753,"address":[54874930],"length":1,"stats":{"Line":0}},{"line":15754,"address":[55060955],"length":1,"stats":{"Line":0}},{"line":15757,"address":[56613186],"length":1,"stats":{"Line":0}},{"line":15758,"address":[54043214,54043135],"length":1,"stats":{"Line":0}},{"line":15759,"address":[54043313,54043395],"length":1,"stats":{"Line":0}},{"line":15760,"address":[54875612,54875694],"length":1,"stats":{"Line":0}},{"line":15761,"address":[54875799,54875881],"length":1,"stats":{"Line":0}},{"line":15762,"address":[54876068,54875986],"length":1,"stats":{"Line":0}},{"line":15763,"address":[54876173,54876255],"length":1,"stats":{"Line":0}},{"line":15764,"address":[54044252],"length":1,"stats":{"Line":0}},{"line":15765,"address":[56614294],"length":1,"stats":{"Line":0}},{"line":15766,"address":[55062262,55062188],"length":1,"stats":{"Line":0}},{"line":15770,"address":[54876502,54876436],"length":1,"stats":{"Line":0}},{"line":15773,"address":[54044409],"length":1,"stats":{"Line":0}},{"line":15774,"address":[55062338,55062503],"length":1,"stats":{"Line":0}},{"line":15775,"address":[54876582,54876688,54876646,54876741],"length":1,"stats":{"Line":0}},{"line":15779,"address":[55062394,55062604],"length":1,"stats":{"Line":0}},{"line":15780,"address":[54876885,54876984],"length":1,"stats":{"Line":0}},{"line":15781,"address":[],"length":0,"stats":{"Line":0}},{"line":15782,"address":[54044783],"length":1,"stats":{"Line":0}},{"line":15784,"address":[56614894,56614985],"length":1,"stats":{"Line":0}},{"line":15785,"address":[],"length":0,"stats":{"Line":0}},{"line":15786,"address":[],"length":0,"stats":{"Line":0}},{"line":15787,"address":[],"length":0,"stats":{"Line":0}},{"line":15788,"address":[],"length":0,"stats":{"Line":0}},{"line":15789,"address":[55063015,55062903],"length":1,"stats":{"Line":0}},{"line":15790,"address":[],"length":0,"stats":{"Line":0}},{"line":15791,"address":[54045048],"length":1,"stats":{"Line":0}},{"line":15793,"address":[55063031,55063161],"length":1,"stats":{"Line":0}},{"line":15794,"address":[],"length":0,"stats":{"Line":0}},{"line":15795,"address":[54045184],"length":1,"stats":{"Line":0}},{"line":15801,"address":[],"length":0,"stats":{"Line":0}},{"line":15803,"address":[56615391,56619815],"length":1,"stats":{"Line":0}},{"line":15807,"address":[54045362,54045442,54045523],"length":1,"stats":{"Line":0}},{"line":15808,"address":[56615470],"length":1,"stats":{"Line":0}},{"line":15809,"address":[],"length":0,"stats":{"Line":0}},{"line":15810,"address":[],"length":0,"stats":{"Line":0}},{"line":15812,"address":[54045617,54045682],"length":1,"stats":{"Line":0}},{"line":15813,"address":[54045690,54046052],"length":1,"stats":{"Line":0}},{"line":15814,"address":[],"length":0,"stats":{"Line":0}},{"line":15815,"address":[54045708],"length":1,"stats":{"Line":0}},{"line":15823,"address":[56616133,56616042],"length":1,"stats":{"Line":0}},{"line":15824,"address":[],"length":0,"stats":{"Line":0}},{"line":15825,"address":[],"length":0,"stats":{"Line":0}},{"line":15826,"address":[54046075],"length":1,"stats":{"Line":0}},{"line":15827,"address":[],"length":0,"stats":{"Line":0}},{"line":15828,"address":[],"length":0,"stats":{"Line":0}},{"line":15829,"address":[55063996],"length":1,"stats":{"Line":0}},{"line":15831,"address":[],"length":0,"stats":{"Line":0}},{"line":15832,"address":[56616298],"length":1,"stats":{"Line":0}},{"line":15834,"address":[54878707,54878496],"length":1,"stats":{"Line":0}},{"line":15836,"address":[],"length":0,"stats":{"Line":0}},{"line":15837,"address":[],"length":0,"stats":{"Line":0}},{"line":15838,"address":[56616383],"length":1,"stats":{"Line":0}},{"line":15843,"address":[56616561],"length":1,"stats":{"Line":0}},{"line":15844,"address":[54046663],"length":1,"stats":{"Line":0}},{"line":15847,"address":[],"length":0,"stats":{"Line":0}},{"line":15849,"address":[54878835,54879057],"length":1,"stats":{"Line":0}},{"line":15851,"address":[54878853],"length":1,"stats":{"Line":0}},{"line":15852,"address":[],"length":0,"stats":{"Line":0}},{"line":15853,"address":[],"length":0,"stats":{"Line":0}},{"line":15858,"address":[54879264,54879065],"length":1,"stats":{"Line":0}},{"line":15859,"address":[],"length":0,"stats":{"Line":0}},{"line":15861,"address":[],"length":0,"stats":{"Line":0}},{"line":15862,"address":[56616913],"length":1,"stats":{"Line":0}},{"line":15863,"address":[],"length":0,"stats":{"Line":0}},{"line":15864,"address":[54046986],"length":1,"stats":{"Line":0}},{"line":15868,"address":[56617094],"length":1,"stats":{"Line":0}},{"line":15871,"address":[55064994],"length":1,"stats":{"Line":0}},{"line":15872,"address":[56617448,56618491],"length":1,"stats":{"Line":0}},{"line":15873,"address":[],"length":0,"stats":{"Line":0}},{"line":15875,"address":[54047556],"length":1,"stats":{"Line":0}},{"line":15876,"address":[55065329],"length":1,"stats":{"Line":0}},{"line":15877,"address":[54048329,54047582],"length":1,"stats":{"Line":0}},{"line":15880,"address":[],"length":0,"stats":{"Line":0}},{"line":15882,"address":[54880943,54881453],"length":1,"stats":{"Line":0}},{"line":15884,"address":[54880961],"length":1,"stats":{"Line":0}},{"line":15885,"address":[],"length":0,"stats":{"Line":0}},{"line":15886,"address":[54048905],"length":1,"stats":{"Line":0}},{"line":15887,"address":[56618819],"length":1,"stats":{"Line":0}},{"line":15891,"address":[54881488,54881941],"length":1,"stats":{"Line":0}},{"line":15892,"address":[],"length":0,"stats":{"Line":0}},{"line":15894,"address":[],"length":0,"stats":{"Line":0}},{"line":15895,"address":[54049394],"length":1,"stats":{"Line":0}},{"line":15896,"address":[],"length":0,"stats":{"Line":0}},{"line":15897,"address":[],"length":0,"stats":{"Line":0}},{"line":15898,"address":[54049461],"length":1,"stats":{"Line":0}},{"line":15901,"address":[54882000],"length":1,"stats":{"Line":0}},{"line":15905,"address":[54047628,54047727],"length":1,"stats":{"Line":0}},{"line":15906,"address":[],"length":0,"stats":{"Line":0}},{"line":15907,"address":[54879750],"length":1,"stats":{"Line":0}},{"line":15909,"address":[54879942,54879847],"length":1,"stats":{"Line":0}},{"line":15910,"address":[],"length":0,"stats":{"Line":0}},{"line":15911,"address":[],"length":0,"stats":{"Line":0}},{"line":15912,"address":[55065505],"length":1,"stats":{"Line":0}},{"line":15913,"address":[54047838],"length":1,"stats":{"Line":0}},{"line":15914,"address":[],"length":0,"stats":{"Line":0}},{"line":15915,"address":[],"length":0,"stats":{"Line":0}},{"line":15916,"address":[],"length":0,"stats":{"Line":0}},{"line":15918,"address":[56617922,56618025],"length":1,"stats":{"Line":0}},{"line":15919,"address":[],"length":0,"stats":{"Line":0}},{"line":15920,"address":[54880151],"length":1,"stats":{"Line":0}},{"line":15922,"address":[56618041],"length":1,"stats":{"Line":0}},{"line":15929,"address":[55032944,55041820,55041767],"length":1,"stats":{"Line":0}},{"line":15934,"address":[55216487],"length":1,"stats":{"Line":0}},{"line":15937,"address":[54201001],"length":1,"stats":{"Line":0}},{"line":15938,"address":[54201048],"length":1,"stats":{"Line":0}},{"line":15939,"address":[],"length":0,"stats":{"Line":0}},{"line":15940,"address":[55033175],"length":1,"stats":{"Line":0}},{"line":15945,"address":[],"length":0,"stats":{"Line":0}},{"line":15946,"address":[],"length":0,"stats":{"Line":0}},{"line":15948,"address":[],"length":0,"stats":{"Line":0}},{"line":15949,"address":[],"length":0,"stats":{"Line":0}},{"line":15950,"address":[55216725],"length":1,"stats":{"Line":0}},{"line":15951,"address":[],"length":0,"stats":{"Line":0}},{"line":15952,"address":[56768922],"length":1,"stats":{"Line":0}},{"line":15958,"address":[],"length":0,"stats":{"Line":0}},{"line":15959,"address":[55216971],"length":1,"stats":{"Line":0}},{"line":15960,"address":[55033634],"length":1,"stats":{"Line":0}},{"line":15962,"address":[],"length":0,"stats":{"Line":0}},{"line":15963,"address":[55033706],"length":1,"stats":{"Line":0}},{"line":15967,"address":[55033771],"length":1,"stats":{"Line":0}},{"line":15968,"address":[],"length":0,"stats":{"Line":0}},{"line":15969,"address":[],"length":0,"stats":{"Line":0}},{"line":15970,"address":[54201692],"length":1,"stats":{"Line":0}},{"line":15973,"address":[],"length":0,"stats":{"Line":0}},{"line":15974,"address":[],"length":0,"stats":{"Line":0}},{"line":15975,"address":[54201898,54202008],"length":1,"stats":{"Line":0}},{"line":15976,"address":[54202045],"length":1,"stats":{"Line":0}},{"line":15977,"address":[55217615,55217704],"length":1,"stats":{"Line":0}},{"line":15978,"address":[],"length":0,"stats":{"Line":0}},{"line":15979,"address":[54202136],"length":1,"stats":{"Line":0}},{"line":15981,"address":[],"length":0,"stats":{"Line":0}},{"line":15982,"address":[55217817,55218152],"length":1,"stats":{"Line":0}},{"line":15983,"address":[],"length":0,"stats":{"Line":0}},{"line":15984,"address":[56769999,56770106],"length":1,"stats":{"Line":0}},{"line":15989,"address":[],"length":0,"stats":{"Line":0}},{"line":15990,"address":[56770335],"length":1,"stats":{"Line":0}},{"line":15992,"address":[54202774],"length":1,"stats":{"Line":0}},{"line":15995,"address":[],"length":0,"stats":{"Line":0}},{"line":15996,"address":[55218366,55218495],"length":1,"stats":{"Line":0}},{"line":15997,"address":[],"length":0,"stats":{"Line":0}},{"line":15998,"address":[55035035],"length":1,"stats":{"Line":0}},{"line":16001,"address":[54203061],"length":1,"stats":{"Line":0}},{"line":16002,"address":[54203253,54203164],"length":1,"stats":{"Line":0}},{"line":16003,"address":[],"length":0,"stats":{"Line":0}},{"line":16004,"address":[],"length":0,"stats":{"Line":0}},{"line":16008,"address":[],"length":0,"stats":{"Line":0}},{"line":16009,"address":[54203449,54203360],"length":1,"stats":{"Line":0}},{"line":16010,"address":[],"length":0,"stats":{"Line":0}},{"line":16011,"address":[55035479],"length":1,"stats":{"Line":0}},{"line":16014,"address":[56771238,56771043],"length":1,"stats":{"Line":0}},{"line":16016,"address":[54203475],"length":1,"stats":{"Line":0}},{"line":16017,"address":[],"length":0,"stats":{"Line":0}},{"line":16018,"address":[56771076],"length":1,"stats":{"Line":0}},{"line":16023,"address":[55219086,55219220],"length":1,"stats":{"Line":0}},{"line":16024,"address":[],"length":0,"stats":{"Line":0}},{"line":16025,"address":[55035790],"length":1,"stats":{"Line":0}},{"line":16030,"address":[],"length":0,"stats":{"Line":0}},{"line":16031,"address":[],"length":0,"stats":{"Line":0}},{"line":16032,"address":[],"length":0,"stats":{"Line":0}},{"line":16033,"address":[55036002],"length":1,"stats":{"Line":0}},{"line":16037,"address":[55036092],"length":1,"stats":{"Line":0}},{"line":16038,"address":[54203992],"length":1,"stats":{"Line":0}},{"line":16040,"address":[54204226,54204004],"length":1,"stats":{"Line":0}},{"line":16042,"address":[55219424],"length":1,"stats":{"Line":0}},{"line":16043,"address":[],"length":0,"stats":{"Line":0}},{"line":16044,"address":[54204049],"length":1,"stats":{"Line":0}},{"line":16049,"address":[],"length":0,"stats":{"Line":0}},{"line":16050,"address":[],"length":0,"stats":{"Line":0}},{"line":16052,"address":[],"length":0,"stats":{"Line":0}},{"line":16053,"address":[55219646],"length":1,"stats":{"Line":0}},{"line":16057,"address":[55219953,55219819],"length":1,"stats":{"Line":0}},{"line":16058,"address":[],"length":0,"stats":{"Line":0}},{"line":16059,"address":[56771989],"length":1,"stats":{"Line":0}},{"line":16062,"address":[55220098,55219961],"length":1,"stats":{"Line":0}},{"line":16063,"address":[],"length":0,"stats":{"Line":0}},{"line":16064,"address":[],"length":0,"stats":{"Line":0}},{"line":16074,"address":[55220106],"length":1,"stats":{"Line":0}},{"line":16075,"address":[54204799],"length":1,"stats":{"Line":0}},{"line":16076,"address":[55036974],"length":1,"stats":{"Line":0}},{"line":16077,"address":[],"length":0,"stats":{"Line":0}},{"line":16080,"address":[56772510],"length":1,"stats":{"Line":0}},{"line":16081,"address":[54205042,54205153],"length":1,"stats":{"Line":0}},{"line":16082,"address":[],"length":0,"stats":{"Line":0}},{"line":16083,"address":[56772579],"length":1,"stats":{"Line":0}},{"line":16085,"address":[55037273,55037368],"length":1,"stats":{"Line":0}},{"line":16086,"address":[],"length":0,"stats":{"Line":0}},{"line":16087,"address":[55037280],"length":1,"stats":{"Line":0}},{"line":16089,"address":[55220618],"length":1,"stats":{"Line":0}},{"line":16090,"address":[54205329,54205448],"length":1,"stats":{"Line":0}},{"line":16091,"address":[],"length":0,"stats":{"Line":0}},{"line":16092,"address":[54205336],"length":1,"stats":{"Line":0}},{"line":16095,"address":[55037568],"length":1,"stats":{"Line":0}},{"line":16096,"address":[56772969],"length":1,"stats":{"Line":0}},{"line":16100,"address":[],"length":0,"stats":{"Line":0}},{"line":16101,"address":[55220892],"length":1,"stats":{"Line":0}},{"line":16102,"address":[56773264,56773183],"length":1,"stats":{"Line":0}},{"line":16103,"address":[],"length":0,"stats":{"Line":0}},{"line":16104,"address":[55221030],"length":1,"stats":{"Line":0}},{"line":16106,"address":[55221112,55221403],"length":1,"stats":{"Line":0}},{"line":16107,"address":[],"length":0,"stats":{"Line":0}},{"line":16108,"address":[55037908],"length":1,"stats":{"Line":0}},{"line":16113,"address":[54206105],"length":1,"stats":{"Line":0}},{"line":16114,"address":[],"length":0,"stats":{"Line":0}},{"line":16116,"address":[55221475],"length":1,"stats":{"Line":0}},{"line":16119,"address":[54206273],"length":1,"stats":{"Line":0}},{"line":16120,"address":[],"length":0,"stats":{"Line":0}},{"line":16121,"address":[56773800],"length":1,"stats":{"Line":0}},{"line":16126,"address":[56773857],"length":1,"stats":{"Line":0}},{"line":16127,"address":[56773899],"length":1,"stats":{"Line":0}},{"line":16128,"address":[],"length":0,"stats":{"Line":0}},{"line":16132,"address":[56773966],"length":1,"stats":{"Line":0}},{"line":16138,"address":[55038634],"length":1,"stats":{"Line":0}},{"line":16140,"address":[55222060,55221846],"length":1,"stats":{"Line":0}},{"line":16142,"address":[],"length":0,"stats":{"Line":0}},{"line":16143,"address":[],"length":0,"stats":{"Line":0}},{"line":16144,"address":[54206589],"length":1,"stats":{"Line":0}},{"line":16149,"address":[55222251,55222068],"length":1,"stats":{"Line":0}},{"line":16150,"address":[],"length":0,"stats":{"Line":0}},{"line":16152,"address":[],"length":0,"stats":{"Line":0}},{"line":16153,"address":[55222086],"length":1,"stats":{"Line":0}},{"line":16157,"address":[],"length":0,"stats":{"Line":0}},{"line":16158,"address":[],"length":0,"stats":{"Line":0}},{"line":16159,"address":[55222269],"length":1,"stats":{"Line":0}},{"line":16163,"address":[55039343,55039208],"length":1,"stats":{"Line":0}},{"line":16165,"address":[55039306,55039549],"length":1,"stats":{"Line":0}},{"line":16167,"address":[56774650],"length":1,"stats":{"Line":0}},{"line":16168,"address":[],"length":0,"stats":{"Line":0}},{"line":16169,"address":[56774703],"length":1,"stats":{"Line":0}},{"line":16174,"address":[55222898,55222715],"length":1,"stats":{"Line":0}},{"line":16175,"address":[],"length":0,"stats":{"Line":0}},{"line":16177,"address":[],"length":0,"stats":{"Line":0}},{"line":16178,"address":[54207463],"length":1,"stats":{"Line":0}},{"line":16182,"address":[55039863,55039756],"length":1,"stats":{"Line":0}},{"line":16183,"address":[],"length":0,"stats":{"Line":0}},{"line":16184,"address":[55222916],"length":1,"stats":{"Line":0}},{"line":16188,"address":[55039901],"length":1,"stats":{"Line":0}},{"line":16189,"address":[54207918,54207824],"length":1,"stats":{"Line":0}},{"line":16197,"address":[],"length":0,"stats":{"Line":0}},{"line":16198,"address":[55040164],"length":1,"stats":{"Line":0}},{"line":16199,"address":[55223431,55224848],"length":1,"stats":{"Line":0}},{"line":16203,"address":[56775639,56775707],"length":1,"stats":{"Line":0}},{"line":16204,"address":[],"length":0,"stats":{"Line":0}},{"line":16205,"address":[55223521],"length":1,"stats":{"Line":0}},{"line":16207,"address":[56775759,56775869],"length":1,"stats":{"Line":0}},{"line":16208,"address":[56775906],"length":1,"stats":{"Line":0}},{"line":16209,"address":[],"length":0,"stats":{"Line":0}},{"line":16210,"address":[],"length":0,"stats":{"Line":0}},{"line":16211,"address":[55040737],"length":1,"stats":{"Line":0}},{"line":16214,"address":[56776328,56776079],"length":1,"stats":{"Line":0}},{"line":16215,"address":[],"length":0,"stats":{"Line":0}},{"line":16217,"address":[],"length":0,"stats":{"Line":0}},{"line":16218,"address":[],"length":0,"stats":{"Line":0}},{"line":16219,"address":[],"length":0,"stats":{"Line":0}},{"line":16226,"address":[55224184],"length":1,"stats":{"Line":0}},{"line":16227,"address":[55041115],"length":1,"stats":{"Line":0}},{"line":16229,"address":[],"length":0,"stats":{"Line":0}},{"line":16232,"address":[54209146],"length":1,"stats":{"Line":0}},{"line":16233,"address":[56776614,56776516],"length":1,"stats":{"Line":0}},{"line":16234,"address":[],"length":0,"stats":{"Line":0}},{"line":16235,"address":[55224366],"length":1,"stats":{"Line":0}},{"line":16237,"address":[56776725],"length":1,"stats":{"Line":0}},{"line":16238,"address":[54209294],"length":1,"stats":{"Line":0}},{"line":16239,"address":[],"length":0,"stats":{"Line":0}},{"line":16240,"address":[55224541],"length":1,"stats":{"Line":0}},{"line":16243,"address":[54209514],"length":1,"stats":{"Line":0}},{"line":16247,"address":[54526480],"length":1,"stats":{"Line":0}},{"line":16252,"address":[53694462],"length":1,"stats":{"Line":0}},{"line":16255,"address":[53694511],"length":1,"stats":{"Line":0}},{"line":16256,"address":[54716696],"length":1,"stats":{"Line":0}},{"line":16257,"address":[],"length":0,"stats":{"Line":0}},{"line":16258,"address":[53694543],"length":1,"stats":{"Line":0}},{"line":16261,"address":[54716790],"length":1,"stats":{"Line":0}},{"line":16262,"address":[54716853],"length":1,"stats":{"Line":0}},{"line":16263,"address":[56269042],"length":1,"stats":{"Line":0}},{"line":16264,"address":[],"length":0,"stats":{"Line":0}},{"line":16265,"address":[53694779],"length":1,"stats":{"Line":0}},{"line":16268,"address":[],"length":0,"stats":{"Line":0}},{"line":16269,"address":[],"length":0,"stats":{"Line":0}},{"line":16270,"address":[56269137],"length":1,"stats":{"Line":0}},{"line":16273,"address":[54717095],"length":1,"stats":{"Line":0}},{"line":16275,"address":[53694958],"length":1,"stats":{"Line":0}},{"line":16276,"address":[],"length":0,"stats":{"Line":0}},{"line":16277,"address":[],"length":0,"stats":{"Line":0}},{"line":16282,"address":[54527225],"length":1,"stats":{"Line":0}},{"line":16283,"address":[],"length":0,"stats":{"Line":0}},{"line":16284,"address":[54717275],"length":1,"stats":{"Line":0}},{"line":16289,"address":[54527326],"length":1,"stats":{"Line":0}},{"line":16290,"address":[53695258],"length":1,"stats":{"Line":0}},{"line":16291,"address":[54527425],"length":1,"stats":{"Line":0}},{"line":16292,"address":[],"length":0,"stats":{"Line":0}},{"line":16293,"address":[53695320],"length":1,"stats":{"Line":0}},{"line":16295,"address":[54527507],"length":1,"stats":{"Line":0}},{"line":16296,"address":[],"length":0,"stats":{"Line":0}},{"line":16297,"address":[53695402],"length":1,"stats":{"Line":0}},{"line":16300,"address":[56269727],"length":1,"stats":{"Line":0}},{"line":16301,"address":[],"length":0,"stats":{"Line":0}},{"line":16302,"address":[54717632],"length":1,"stats":{"Line":0}},{"line":16310,"address":[],"length":0,"stats":{"Line":0}},{"line":16311,"address":[],"length":0,"stats":{"Line":0}},{"line":16312,"address":[54717863],"length":1,"stats":{"Line":0}},{"line":16314,"address":[54717936],"length":1,"stats":{"Line":0}},{"line":16317,"address":[56270096],"length":1,"stats":{"Line":0}},{"line":16318,"address":[],"length":0,"stats":{"Line":0}},{"line":16319,"address":[56270106],"length":1,"stats":{"Line":0}},{"line":16321,"address":[56270202],"length":1,"stats":{"Line":0}},{"line":16324,"address":[],"length":0,"stats":{"Line":0}},{"line":16325,"address":[56270293],"length":1,"stats":{"Line":0}},{"line":16326,"address":[],"length":0,"stats":{"Line":0}},{"line":16327,"address":[],"length":0,"stats":{"Line":0}},{"line":16328,"address":[56270350],"length":1,"stats":{"Line":0}},{"line":16330,"address":[56270438],"length":1,"stats":{"Line":0}},{"line":16332,"address":[53696251],"length":1,"stats":{"Line":0}},{"line":16333,"address":[54718438],"length":1,"stats":{"Line":0}},{"line":16334,"address":[54528475],"length":1,"stats":{"Line":0}},{"line":16336,"address":[56270659],"length":1,"stats":{"Line":0}},{"line":16337,"address":[54528586],"length":1,"stats":{"Line":0}},{"line":16339,"address":[53696503],"length":1,"stats":{"Line":0}},{"line":16340,"address":[],"length":0,"stats":{"Line":0}},{"line":16341,"address":[54718643],"length":1,"stats":{"Line":0}},{"line":16344,"address":[54718743],"length":1,"stats":{"Line":0}},{"line":16345,"address":[],"length":0,"stats":{"Line":0}},{"line":16346,"address":[56270862],"length":1,"stats":{"Line":0}},{"line":16348,"address":[],"length":0,"stats":{"Line":0}},{"line":16349,"address":[],"length":0,"stats":{"Line":0}},{"line":16352,"address":[54718895],"length":1,"stats":{"Line":0}},{"line":16355,"address":[54528919],"length":1,"stats":{"Line":0}},{"line":16356,"address":[],"length":0,"stats":{"Line":0}},{"line":16358,"address":[],"length":0,"stats":{"Line":0}},{"line":16359,"address":[54718949],"length":1,"stats":{"Line":0}},{"line":16360,"address":[54718956],"length":1,"stats":{"Line":0}},{"line":16361,"address":[54528970],"length":1,"stats":{"Line":0}},{"line":16366,"address":[54529082],"length":1,"stats":{"Line":0}},{"line":16367,"address":[],"length":0,"stats":{"Line":0}},{"line":16370,"address":[],"length":0,"stats":{"Line":0}},{"line":16371,"address":[],"length":0,"stats":{"Line":0}},{"line":16373,"address":[],"length":0,"stats":{"Line":0}},{"line":16374,"address":[],"length":0,"stats":{"Line":0}},{"line":16378,"address":[53697264],"length":1,"stats":{"Line":0}},{"line":16379,"address":[],"length":0,"stats":{"Line":0}},{"line":16380,"address":[54529386],"length":1,"stats":{"Line":0}},{"line":16384,"address":[53697380],"length":1,"stats":{"Line":0}},{"line":16385,"address":[],"length":0,"stats":{"Line":0}},{"line":16386,"address":[53697390],"length":1,"stats":{"Line":0}},{"line":16388,"address":[],"length":0,"stats":{"Line":0}},{"line":16392,"address":[54529819],"length":1,"stats":{"Line":0}},{"line":16394,"address":[54529834],"length":1,"stats":{"Line":0}},{"line":16395,"address":[],"length":0,"stats":{"Line":0}},{"line":16396,"address":[56271978],"length":1,"stats":{"Line":0}},{"line":16401,"address":[54719965],"length":1,"stats":{"Line":0}},{"line":16402,"address":[],"length":0,"stats":{"Line":0}},{"line":16404,"address":[],"length":0,"stats":{"Line":0}},{"line":16405,"address":[56272092],"length":1,"stats":{"Line":0}},{"line":16409,"address":[53697992],"length":1,"stats":{"Line":0}},{"line":16412,"address":[56272275],"length":1,"stats":{"Line":0}},{"line":16413,"address":[54720243],"length":1,"stats":{"Line":0}},{"line":16414,"address":[53698198],"length":1,"stats":{"Line":0}},{"line":16416,"address":[53698256],"length":1,"stats":{"Line":0}},{"line":16419,"address":[],"length":0,"stats":{"Line":0}},{"line":16420,"address":[],"length":0,"stats":{"Line":0}},{"line":16421,"address":[54530407],"length":1,"stats":{"Line":0}},{"line":16423,"address":[53698374],"length":1,"stats":{"Line":0}},{"line":16424,"address":[],"length":0,"stats":{"Line":0}},{"line":16425,"address":[],"length":0,"stats":{"Line":0}},{"line":16426,"address":[56272596],"length":1,"stats":{"Line":0}},{"line":16427,"address":[54530551],"length":1,"stats":{"Line":0}},{"line":16428,"address":[],"length":0,"stats":{"Line":0}},{"line":16429,"address":[],"length":0,"stats":{"Line":0}},{"line":16430,"address":[53698483],"length":1,"stats":{"Line":0}},{"line":16432,"address":[56272785],"length":1,"stats":{"Line":0}},{"line":16433,"address":[],"length":0,"stats":{"Line":0}},{"line":16434,"address":[54530697],"length":1,"stats":{"Line":0}},{"line":16436,"address":[],"length":0,"stats":{"Line":0}},{"line":16440,"address":[56530160],"length":1,"stats":{"Line":0}},{"line":16445,"address":[53958756],"length":1,"stats":{"Line":0}},{"line":16448,"address":[54978200],"length":1,"stats":{"Line":0}},{"line":16449,"address":[54790945],"length":1,"stats":{"Line":0}},{"line":16450,"address":[],"length":0,"stats":{"Line":0}},{"line":16451,"address":[],"length":0,"stats":{"Line":0}},{"line":16454,"address":[],"length":0,"stats":{"Line":0}},{"line":16455,"address":[54978382],"length":1,"stats":{"Line":0}},{"line":16456,"address":[],"length":0,"stats":{"Line":0}},{"line":16457,"address":[],"length":0,"stats":{"Line":0}},{"line":16458,"address":[53959076],"length":1,"stats":{"Line":0}},{"line":16461,"address":[54978547],"length":1,"stats":{"Line":0}},{"line":16462,"address":[],"length":0,"stats":{"Line":0}},{"line":16463,"address":[54978554],"length":1,"stats":{"Line":0}},{"line":16466,"address":[56530736],"length":1,"stats":{"Line":0}},{"line":16468,"address":[],"length":0,"stats":{"Line":0}},{"line":16469,"address":[],"length":0,"stats":{"Line":0}},{"line":16470,"address":[56530768],"length":1,"stats":{"Line":0}},{"line":16475,"address":[54978794],"length":1,"stats":{"Line":0}},{"line":16476,"address":[],"length":0,"stats":{"Line":0}},{"line":16477,"address":[54978804],"length":1,"stats":{"Line":0}},{"line":16482,"address":[53959511],"length":1,"stats":{"Line":0}},{"line":16483,"address":[56531049],"length":1,"stats":{"Line":0}},{"line":16484,"address":[54791722],"length":1,"stats":{"Line":0}},{"line":16485,"address":[],"length":0,"stats":{"Line":0}},{"line":16486,"address":[54791729],"length":1,"stats":{"Line":0}},{"line":16488,"address":[54979072],"length":1,"stats":{"Line":0}},{"line":16489,"address":[],"length":0,"stats":{"Line":0}},{"line":16490,"address":[],"length":0,"stats":{"Line":0}},{"line":16493,"address":[54979144],"length":1,"stats":{"Line":0}},{"line":16494,"address":[],"length":0,"stats":{"Line":0}},{"line":16495,"address":[54979161],"length":1,"stats":{"Line":0}},{"line":16503,"address":[54792114],"length":1,"stats":{"Line":0}},{"line":16504,"address":[],"length":0,"stats":{"Line":0}},{"line":16505,"address":[56531499],"length":1,"stats":{"Line":0}},{"line":16507,"address":[53960110],"length":1,"stats":{"Line":0}},{"line":16510,"address":[54979531],"length":1,"stats":{"Line":0}},{"line":16511,"address":[56531686],"length":1,"stats":{"Line":0}},{"line":16512,"address":[],"length":0,"stats":{"Line":0}},{"line":16513,"address":[],"length":0,"stats":{"Line":0}},{"line":16514,"address":[53960260],"length":1,"stats":{"Line":0}},{"line":16516,"address":[],"length":0,"stats":{"Line":0}},{"line":16517,"address":[],"length":0,"stats":{"Line":0}},{"line":16518,"address":[54792464],"length":1,"stats":{"Line":0}},{"line":16520,"address":[56531926],"length":1,"stats":{"Line":0}},{"line":16521,"address":[56531990],"length":1,"stats":{"Line":0}},{"line":16523,"address":[54792683],"length":1,"stats":{"Line":0}},{"line":16524,"address":[54792739],"length":1,"stats":{"Line":0}},{"line":16525,"address":[],"length":0,"stats":{"Line":0}},{"line":16526,"address":[53960739],"length":1,"stats":{"Line":0}},{"line":16527,"address":[],"length":0,"stats":{"Line":0}},{"line":16529,"address":[54980211],"length":1,"stats":{"Line":0}},{"line":16530,"address":[56532380],"length":1,"stats":{"Line":0}},{"line":16532,"address":[54980297],"length":1,"stats":{"Line":0}},{"line":16533,"address":[],"length":0,"stats":{"Line":0}},{"line":16534,"address":[54980307],"length":1,"stats":{"Line":0}},{"line":16537,"address":[54980407],"length":1,"stats":{"Line":0}},{"line":16538,"address":[],"length":0,"stats":{"Line":0}},{"line":16539,"address":[54980414],"length":1,"stats":{"Line":0}},{"line":16541,"address":[54793256],"length":1,"stats":{"Line":0}},{"line":16542,"address":[53961151],"length":1,"stats":{"Line":0}},{"line":16545,"address":[54793314],"length":1,"stats":{"Line":0}},{"line":16548,"address":[56532708],"length":1,"stats":{"Line":0}},{"line":16549,"address":[],"length":0,"stats":{"Line":0}},{"line":16551,"address":[],"length":0,"stats":{"Line":0}},{"line":16552,"address":[54980613],"length":1,"stats":{"Line":0}},{"line":16553,"address":[],"length":0,"stats":{"Line":0}},{"line":16554,"address":[54980646],"length":1,"stats":{"Line":0}},{"line":16559,"address":[54793514],"length":1,"stats":{"Line":0}},{"line":16560,"address":[56532884],"length":1,"stats":{"Line":0}},{"line":16563,"address":[54980907],"length":1,"stats":{"Line":0}},{"line":16564,"address":[],"length":0,"stats":{"Line":0}},{"line":16566,"address":[],"length":0,"stats":{"Line":0}},{"line":16567,"address":[53961573],"length":1,"stats":{"Line":0}},{"line":16571,"address":[53961696],"length":1,"stats":{"Line":0}},{"line":16572,"address":[],"length":0,"stats":{"Line":0}},{"line":16573,"address":[53961706],"length":1,"stats":{"Line":0}},{"line":16577,"address":[53961804],"length":1,"stats":{"Line":0}},{"line":16578,"address":[],"length":0,"stats":{"Line":0}},{"line":16579,"address":[53961814],"length":1,"stats":{"Line":0}},{"line":16581,"address":[54794024],"length":1,"stats":{"Line":0}},{"line":16584,"address":[53961970],"length":1,"stats":{"Line":0}},{"line":16585,"address":[],"length":0,"stats":{"Line":0}},{"line":16586,"address":[],"length":0,"stats":{"Line":0}},{"line":16588,"address":[54794209],"length":1,"stats":{"Line":0}},{"line":16591,"address":[54794399],"length":1,"stats":{"Line":0}},{"line":16592,"address":[56533896],"length":1,"stats":{"Line":0}},{"line":16593,"address":[54981791],"length":1,"stats":{"Line":0}},{"line":16597,"address":[54981841],"length":1,"stats":{"Line":0}},{"line":16598,"address":[54794646],"length":1,"stats":{"Line":0}},{"line":16599,"address":[],"length":0,"stats":{"Line":0}},{"line":16600,"address":[54981880],"length":1,"stats":{"Line":0}},{"line":16603,"address":[],"length":0,"stats":{"Line":0}},{"line":16604,"address":[],"length":0,"stats":{"Line":0}},{"line":16606,"address":[],"length":0,"stats":{"Line":0}},{"line":16607,"address":[56534103],"length":1,"stats":{"Line":0}},{"line":16608,"address":[54794776],"length":1,"stats":{"Line":0}},{"line":16609,"address":[53962691],"length":1,"stats":{"Line":0}},{"line":16614,"address":[54794912],"length":1,"stats":{"Line":0}},{"line":16616,"address":[56534257],"length":1,"stats":{"Line":0}},{"line":16617,"address":[],"length":0,"stats":{"Line":0}},{"line":16618,"address":[54982175],"length":1,"stats":{"Line":0}},{"line":16623,"address":[54795058],"length":1,"stats":{"Line":0}},{"line":16624,"address":[],"length":0,"stats":{"Line":0}},{"line":16626,"address":[],"length":0,"stats":{"Line":0}},{"line":16627,"address":[],"length":0,"stats":{"Line":0}},{"line":16631,"address":[54795197],"length":1,"stats":{"Line":0}},{"line":16632,"address":[],"length":0,"stats":{"Line":0}},{"line":16633,"address":[],"length":0,"stats":{"Line":0}},{"line":16635,"address":[],"length":0,"stats":{"Line":0}},{"line":16636,"address":[53963192],"length":1,"stats":{"Line":0}},{"line":16638,"address":[56534682],"length":1,"stats":{"Line":0}},{"line":16639,"address":[],"length":0,"stats":{"Line":0}},{"line":16640,"address":[],"length":0,"stats":{"Line":0}},{"line":16642,"address":[54795442],"length":1,"stats":{"Line":0}},{"line":16643,"address":[53963388],"length":1,"stats":{"Line":0}},{"line":16646,"address":[54982763],"length":1,"stats":{"Line":0}},{"line":16647,"address":[56534912],"length":1,"stats":{"Line":0}},{"line":16648,"address":[54795677],"length":1,"stats":{"Line":0}},{"line":16649,"address":[54982936],"length":1,"stats":{"Line":0}},{"line":16651,"address":[56535105],"length":1,"stats":{"Line":0}},{"line":16654,"address":[53963710],"length":1,"stats":{"Line":0}},{"line":16655,"address":[],"length":0,"stats":{"Line":0}},{"line":16656,"address":[54983032],"length":1,"stats":{"Line":0}},{"line":16659,"address":[],"length":0,"stats":{"Line":0}},{"line":16660,"address":[],"length":0,"stats":{"Line":0}},{"line":16661,"address":[],"length":0,"stats":{"Line":0}},{"line":16663,"address":[],"length":0,"stats":{"Line":0}},{"line":16666,"address":[54796073],"length":1,"stats":{"Line":0}},{"line":16667,"address":[],"length":0,"stats":{"Line":0}},{"line":16668,"address":[53963971],"length":1,"stats":{"Line":0}},{"line":16670,"address":[54796162],"length":1,"stats":{"Line":0}},{"line":16671,"address":[],"length":0,"stats":{"Line":0}},{"line":16672,"address":[],"length":0,"stats":{"Line":0}},{"line":16673,"address":[54796174],"length":1,"stats":{"Line":0}},{"line":16674,"address":[56535530],"length":1,"stats":{"Line":0}},{"line":16675,"address":[54983455],"length":1,"stats":{"Line":0}},{"line":16676,"address":[],"length":0,"stats":{"Line":0}},{"line":16677,"address":[56535574],"length":1,"stats":{"Line":0}},{"line":16679,"address":[56535667],"length":1,"stats":{"Line":0}},{"line":16680,"address":[],"length":0,"stats":{"Line":0}},{"line":16681,"address":[56535674],"length":1,"stats":{"Line":0}},{"line":16683,"address":[53964344],"length":1,"stats":{"Line":0}},{"line":16687,"address":[56592224],"length":1,"stats":{"Line":0}},{"line":16693,"address":[56592376],"length":1,"stats":{"Line":0}},{"line":16696,"address":[54021910],"length":1,"stats":{"Line":0}},{"line":16697,"address":[54854047],"length":1,"stats":{"Line":0}},{"line":16698,"address":[],"length":0,"stats":{"Line":0}},{"line":16699,"address":[56592454],"length":1,"stats":{"Line":0}},{"line":16702,"address":[55040426],"length":1,"stats":{"Line":0}},{"line":16703,"address":[55040480],"length":1,"stats":{"Line":0}},{"line":16704,"address":[55040542],"length":1,"stats":{"Line":0}},{"line":16705,"address":[],"length":0,"stats":{"Line":0}},{"line":16706,"address":[54022151],"length":1,"stats":{"Line":0}},{"line":16709,"address":[54854343],"length":1,"stats":{"Line":0}},{"line":16710,"address":[],"length":0,"stats":{"Line":0}},{"line":16711,"address":[55040634],"length":1,"stats":{"Line":0}},{"line":16714,"address":[],"length":0,"stats":{"Line":0}},{"line":16716,"address":[],"length":0,"stats":{"Line":0}},{"line":16717,"address":[],"length":0,"stats":{"Line":0}},{"line":16718,"address":[54854445],"length":1,"stats":{"Line":0}},{"line":16723,"address":[55040856],"length":1,"stats":{"Line":0}},{"line":16724,"address":[],"length":0,"stats":{"Line":0}},{"line":16725,"address":[],"length":0,"stats":{"Line":0}},{"line":16730,"address":[],"length":0,"stats":{"Line":0}},{"line":16731,"address":[],"length":0,"stats":{"Line":0}},{"line":16732,"address":[54854690],"length":1,"stats":{"Line":0}},{"line":16734,"address":[55041061],"length":1,"stats":{"Line":0}},{"line":16735,"address":[54022723],"length":1,"stats":{"Line":0}},{"line":16736,"address":[],"length":0,"stats":{"Line":0}},{"line":16737,"address":[54022733],"length":1,"stats":{"Line":0}},{"line":16739,"address":[],"length":0,"stats":{"Line":0}},{"line":16741,"address":[54022881],"length":1,"stats":{"Line":0}},{"line":16742,"address":[54022925],"length":1,"stats":{"Line":0}},{"line":16743,"address":[54022969],"length":1,"stats":{"Line":0}},{"line":16744,"address":[54855124],"length":1,"stats":{"Line":0}},{"line":16745,"address":[54855171],"length":1,"stats":{"Line":0}},{"line":16746,"address":[],"length":0,"stats":{"Line":0}},{"line":16747,"address":[],"length":0,"stats":{"Line":0}},{"line":16749,"address":[],"length":0,"stats":{"Line":0}},{"line":16751,"address":[54023217],"length":1,"stats":{"Line":0}},{"line":16752,"address":[56593763],"length":1,"stats":{"Line":0}},{"line":16753,"address":[55041707],"length":1,"stats":{"Line":0}},{"line":16755,"address":[55041760],"length":1,"stats":{"Line":0}},{"line":16756,"address":[],"length":0,"stats":{"Line":0}},{"line":16758,"address":[55041846],"length":1,"stats":{"Line":0}},{"line":16759,"address":[],"length":0,"stats":{"Line":0}},{"line":16760,"address":[],"length":0,"stats":{"Line":0}},{"line":16763,"address":[54023581],"length":1,"stats":{"Line":0}},{"line":16764,"address":[],"length":0,"stats":{"Line":0}},{"line":16765,"address":[54855700],"length":1,"stats":{"Line":0}},{"line":16767,"address":[55042051],"length":1,"stats":{"Line":0}},{"line":16768,"address":[55042058],"length":1,"stats":{"Line":0}},{"line":16771,"address":[56594220],"length":1,"stats":{"Line":0}},{"line":16774,"address":[55042145],"length":1,"stats":{"Line":0}},{"line":16775,"address":[],"length":0,"stats":{"Line":0}},{"line":16777,"address":[],"length":0,"stats":{"Line":0}},{"line":16778,"address":[54855902],"length":1,"stats":{"Line":0}},{"line":16779,"address":[54855909],"length":1,"stats":{"Line":0}},{"line":16780,"address":[56594307],"length":1,"stats":{"Line":0}},{"line":16785,"address":[],"length":0,"stats":{"Line":0}},{"line":16786,"address":[55042321],"length":1,"stats":{"Line":0}},{"line":16789,"address":[],"length":0,"stats":{"Line":0}},{"line":16790,"address":[],"length":0,"stats":{"Line":0}},{"line":16792,"address":[],"length":0,"stats":{"Line":0}},{"line":16793,"address":[56594585],"length":1,"stats":{"Line":0}},{"line":16797,"address":[55042594],"length":1,"stats":{"Line":0}},{"line":16798,"address":[],"length":0,"stats":{"Line":0}},{"line":16799,"address":[56594716],"length":1,"stats":{"Line":0}},{"line":16803,"address":[54024346],"length":1,"stats":{"Line":0}},{"line":16804,"address":[],"length":0,"stats":{"Line":0}},{"line":16805,"address":[54024356],"length":1,"stats":{"Line":0}},{"line":16807,"address":[56594934],"length":1,"stats":{"Line":0}},{"line":16808,"address":[],"length":0,"stats":{"Line":0}},{"line":16809,"address":[54024472],"length":1,"stats":{"Line":0}},{"line":16811,"address":[54024589],"length":1,"stats":{"Line":0}},{"line":16812,"address":[],"length":0,"stats":{"Line":0}},{"line":16815,"address":[54024869],"length":1,"stats":{"Line":0}},{"line":16816,"address":[54024951],"length":1,"stats":{"Line":0}},{"line":16817,"address":[54025009],"length":1,"stats":{"Line":0}},{"line":16819,"address":[],"length":0,"stats":{"Line":0}},{"line":16820,"address":[54025096],"length":1,"stats":{"Line":0}},{"line":16821,"address":[],"length":0,"stats":{"Line":0}},{"line":16822,"address":[54025106],"length":1,"stats":{"Line":0}},{"line":16824,"address":[54025185],"length":1,"stats":{"Line":0}},{"line":16828,"address":[56892512],"length":1,"stats":{"Line":0}},{"line":16833,"address":[],"length":0,"stats":{"Line":0}},{"line":16835,"address":[55340473],"length":1,"stats":{"Line":0}},{"line":16836,"address":[54327538],"length":1,"stats":{"Line":0}},{"line":16837,"address":[],"length":0,"stats":{"Line":0}},{"line":16838,"address":[56892681],"length":1,"stats":{"Line":0}},{"line":16841,"address":[54327631],"length":1,"stats":{"Line":0}},{"line":16842,"address":[55340643],"length":1,"stats":{"Line":0}},{"line":16843,"address":[],"length":0,"stats":{"Line":0}},{"line":16844,"address":[],"length":0,"stats":{"Line":0}},{"line":16845,"address":[54327757],"length":1,"stats":{"Line":0}},{"line":16848,"address":[55159952],"length":1,"stats":{"Line":0}},{"line":16849,"address":[],"length":0,"stats":{"Line":0}},{"line":16850,"address":[],"length":0,"stats":{"Line":0}},{"line":16853,"address":[55160031],"length":1,"stats":{"Line":0}},{"line":16855,"address":[56893066],"length":1,"stats":{"Line":0}},{"line":16856,"address":[],"length":0,"stats":{"Line":0}},{"line":16857,"address":[54327951],"length":1,"stats":{"Line":0}},{"line":16862,"address":[54328091],"length":1,"stats":{"Line":0}},{"line":16863,"address":[],"length":0,"stats":{"Line":0}},{"line":16864,"address":[55341053],"length":1,"stats":{"Line":0}},{"line":16868,"address":[55341145],"length":1,"stats":{"Line":0}},{"line":16869,"address":[],"length":0,"stats":{"Line":0}},{"line":16870,"address":[56893331],"length":1,"stats":{"Line":0}},{"line":16872,"address":[55160415],"length":1,"stats":{"Line":0}},{"line":16874,"address":[],"length":0,"stats":{"Line":0}},{"line":16875,"address":[56893519],"length":1,"stats":{"Line":0}},{"line":16876,"address":[54328441],"length":1,"stats":{"Line":0}},{"line":16877,"address":[],"length":0,"stats":{"Line":0}},{"line":16878,"address":[55160643],"length":1,"stats":{"Line":0}},{"line":16879,"address":[],"length":0,"stats":{"Line":0}},{"line":16880,"address":[],"length":0,"stats":{"Line":0}},{"line":16882,"address":[54328631],"length":1,"stats":{"Line":0}},{"line":16884,"address":[54328689],"length":1,"stats":{"Line":0}},{"line":16885,"address":[54328745],"length":1,"stats":{"Line":0}},{"line":16886,"address":[55160913],"length":1,"stats":{"Line":0}},{"line":16887,"address":[55341799],"length":1,"stats":{"Line":0}},{"line":16888,"address":[56894031],"length":1,"stats":{"Line":0}},{"line":16890,"address":[55161078],"length":1,"stats":{"Line":0}},{"line":16891,"address":[55161136],"length":1,"stats":{"Line":0}},{"line":16893,"address":[56894170],"length":1,"stats":{"Line":0}},{"line":16894,"address":[],"length":0,"stats":{"Line":0}},{"line":16895,"address":[],"length":0,"stats":{"Line":0}},{"line":16898,"address":[54329165],"length":1,"stats":{"Line":0}},{"line":16899,"address":[],"length":0,"stats":{"Line":0}},{"line":16900,"address":[56894287],"length":1,"stats":{"Line":0}},{"line":16902,"address":[54329262],"length":1,"stats":{"Line":0}},{"line":16903,"address":[55342206],"length":1,"stats":{"Line":0}},{"line":16906,"address":[55161432],"length":1,"stats":{"Line":0}},{"line":16908,"address":[56894469],"length":1,"stats":{"Line":0}},{"line":16909,"address":[],"length":0,"stats":{"Line":0}},{"line":16911,"address":[],"length":0,"stats":{"Line":0}},{"line":16912,"address":[55342310],"length":1,"stats":{"Line":0}},{"line":16913,"address":[55161493],"length":1,"stats":{"Line":0}},{"line":16914,"address":[56894519],"length":1,"stats":{"Line":0}},{"line":16919,"address":[55342452],"length":1,"stats":{"Line":0}},{"line":16920,"address":[55342469],"length":1,"stats":{"Line":0}},{"line":16923,"address":[],"length":0,"stats":{"Line":0}},{"line":16924,"address":[],"length":0,"stats":{"Line":0}},{"line":16926,"address":[],"length":0,"stats":{"Line":0}},{"line":16927,"address":[56894797],"length":1,"stats":{"Line":0}},{"line":16931,"address":[],"length":0,"stats":{"Line":0}},{"line":16932,"address":[],"length":0,"stats":{"Line":0}},{"line":16933,"address":[55161936],"length":1,"stats":{"Line":0}},{"line":16936,"address":[],"length":0,"stats":{"Line":0}},{"line":16937,"address":[],"length":0,"stats":{"Line":0}},{"line":16938,"address":[55162052],"length":1,"stats":{"Line":0}},{"line":16940,"address":[56895157],"length":1,"stats":{"Line":0}},{"line":16941,"address":[54330247],"length":1,"stats":{"Line":0}},{"line":16943,"address":[55343324],"length":1,"stats":{"Line":0}},{"line":16944,"address":[55343382],"length":1,"stats":{"Line":0}},{"line":16945,"address":[],"length":0,"stats":{"Line":0}},{"line":16948,"address":[55162629],"length":1,"stats":{"Line":0}},{"line":16949,"address":[55162666],"length":1,"stats":{"Line":0}},{"line":16950,"address":[56895729],"length":1,"stats":{"Line":0}},{"line":16951,"address":[56895785],"length":1,"stats":{"Line":0}},{"line":16953,"address":[55343666],"length":1,"stats":{"Line":0}},{"line":16954,"address":[56895863],"length":1,"stats":{"Line":0}},{"line":16955,"address":[55343899],"length":1,"stats":{"Line":0}},{"line":16956,"address":[56896124],"length":1,"stats":{"Line":0}},{"line":16958,"address":[54331098],"length":1,"stats":{"Line":0}},{"line":16959,"address":[55344030],"length":1,"stats":{"Line":0}},{"line":16960,"address":[55344243],"length":1,"stats":{"Line":0}},{"line":16961,"address":[56896468],"length":1,"stats":{"Line":0}},{"line":16963,"address":[55163557],"length":1,"stats":{"Line":0}},{"line":16964,"address":[56896550],"length":1,"stats":{"Line":0}},{"line":16965,"address":[],"length":0,"stats":{"Line":0}},{"line":16966,"address":[54331476],"length":1,"stats":{"Line":0}},{"line":16968,"address":[],"length":0,"stats":{"Line":0}},{"line":16969,"address":[],"length":0,"stats":{"Line":0}},{"line":16970,"address":[55163708],"length":1,"stats":{"Line":0}},{"line":16972,"address":[55344661],"length":1,"stats":{"Line":0}},{"line":16976,"address":[53674080],"length":1,"stats":{"Line":0}},{"line":16981,"address":[],"length":0,"stats":{"Line":0}},{"line":16983,"address":[54696633],"length":1,"stats":{"Line":0}},{"line":16984,"address":[],"length":0,"stats":{"Line":0}},{"line":16985,"address":[],"length":0,"stats":{"Line":0}},{"line":16986,"address":[54506361],"length":1,"stats":{"Line":0}},{"line":16989,"address":[54696749],"length":1,"stats":{"Line":0}},{"line":16990,"address":[56248915],"length":1,"stats":{"Line":0}},{"line":16991,"address":[56248980],"length":1,"stats":{"Line":0}},{"line":16992,"address":[],"length":0,"stats":{"Line":0}},{"line":16993,"address":[56248987],"length":1,"stats":{"Line":0}},{"line":16996,"address":[53674544],"length":1,"stats":{"Line":0}},{"line":16997,"address":[],"length":0,"stats":{"Line":0}},{"line":16998,"address":[54506663],"length":1,"stats":{"Line":0}},{"line":17001,"address":[54506735],"length":1,"stats":{"Line":0}},{"line":17003,"address":[],"length":0,"stats":{"Line":0}},{"line":17004,"address":[],"length":0,"stats":{"Line":0}},{"line":17005,"address":[54697065],"length":1,"stats":{"Line":0}},{"line":17010,"address":[],"length":0,"stats":{"Line":0}},{"line":17011,"address":[],"length":0,"stats":{"Line":0}},{"line":17012,"address":[54506917],"length":1,"stats":{"Line":0}},{"line":17016,"address":[54507011],"length":1,"stats":{"Line":0}},{"line":17017,"address":[],"length":0,"stats":{"Line":0}},{"line":17018,"address":[],"length":0,"stats":{"Line":0}},{"line":17020,"address":[56249523],"length":1,"stats":{"Line":0}},{"line":17022,"address":[54697459],"length":1,"stats":{"Line":0}},{"line":17023,"address":[56249615],"length":1,"stats":{"Line":0}},{"line":17024,"address":[54507257],"length":1,"stats":{"Line":0}},{"line":17025,"address":[53675188],"length":1,"stats":{"Line":0}},{"line":17026,"address":[54507347],"length":1,"stats":{"Line":0}},{"line":17027,"address":[],"length":0,"stats":{"Line":0}},{"line":17028,"address":[],"length":0,"stats":{"Line":0}},{"line":17030,"address":[54697735],"length":1,"stats":{"Line":0}},{"line":17032,"address":[],"length":0,"stats":{"Line":0}},{"line":17033,"address":[54697847],"length":1,"stats":{"Line":0}},{"line":17034,"address":[54507617],"length":1,"stats":{"Line":0}},{"line":17035,"address":[54507673],"length":1,"stats":{"Line":0}},{"line":17036,"address":[56250127],"length":1,"stats":{"Line":0}},{"line":17038,"address":[],"length":0,"stats":{"Line":0}},{"line":17039,"address":[54698125],"length":1,"stats":{"Line":0}},{"line":17041,"address":[56250266],"length":1,"stats":{"Line":0}},{"line":17042,"address":[],"length":0,"stats":{"Line":0}},{"line":17043,"address":[54698164],"length":1,"stats":{"Line":0}},{"line":17046,"address":[53675869],"length":1,"stats":{"Line":0}},{"line":17047,"address":[],"length":0,"stats":{"Line":0}},{"line":17048,"address":[54507988],"length":1,"stats":{"Line":0}},{"line":17050,"address":[],"length":0,"stats":{"Line":0}},{"line":17051,"address":[54508085],"length":1,"stats":{"Line":0}},{"line":17054,"address":[53676024],"length":1,"stats":{"Line":0}},{"line":17056,"address":[],"length":0,"stats":{"Line":0}},{"line":17057,"address":[],"length":0,"stats":{"Line":0}},{"line":17059,"address":[],"length":0,"stats":{"Line":0}},{"line":17060,"address":[56250582],"length":1,"stats":{"Line":0}},{"line":17061,"address":[56250589],"length":1,"stats":{"Line":0}},{"line":17062,"address":[54698503],"length":1,"stats":{"Line":0}},{"line":17067,"address":[54508336],"length":1,"stats":{"Line":0}},{"line":17068,"address":[54508353],"length":1,"stats":{"Line":0}},{"line":17071,"address":[],"length":0,"stats":{"Line":0}},{"line":17072,"address":[],"length":0,"stats":{"Line":0}},{"line":17074,"address":[],"length":0,"stats":{"Line":0}},{"line":17075,"address":[56250893],"length":1,"stats":{"Line":0}},{"line":17079,"address":[],"length":0,"stats":{"Line":0}},{"line":17080,"address":[],"length":0,"stats":{"Line":0}},{"line":17081,"address":[53676528],"length":1,"stats":{"Line":0}},{"line":17084,"address":[54508746],"length":1,"stats":{"Line":0}},{"line":17085,"address":[],"length":0,"stats":{"Line":0}},{"line":17086,"address":[53676644],"length":1,"stats":{"Line":0}},{"line":17088,"address":[54699141],"length":1,"stats":{"Line":0}},{"line":17089,"address":[53676951],"length":1,"stats":{"Line":0}},{"line":17091,"address":[],"length":0,"stats":{"Line":0}},{"line":17092,"address":[],"length":0,"stats":{"Line":0}},{"line":17093,"address":[53677173],"length":1,"stats":{"Line":0}},{"line":17096,"address":[54699596],"length":1,"stats":{"Line":0}},{"line":17097,"address":[53677258],"length":1,"stats":{"Line":0}},{"line":17098,"address":[54699713],"length":1,"stats":{"Line":0}},{"line":17099,"address":[56251881],"length":1,"stats":{"Line":0}},{"line":17101,"address":[53677456],"length":1,"stats":{"Line":0}},{"line":17102,"address":[54509589],"length":1,"stats":{"Line":0}},{"line":17103,"address":[53677692],"length":1,"stats":{"Line":0}},{"line":17104,"address":[54700109],"length":1,"stats":{"Line":0}},{"line":17106,"address":[],"length":0,"stats":{"Line":0}},{"line":17107,"address":[],"length":0,"stats":{"Line":0}},{"line":17108,"address":[54510150],"length":1,"stats":{"Line":0}},{"line":17109,"address":[],"length":0,"stats":{"Line":0}},{"line":17111,"address":[54510261],"length":1,"stats":{"Line":0}},{"line":17112,"address":[],"length":0,"stats":{"Line":0}},{"line":17113,"address":[],"length":0,"stats":{"Line":0}},{"line":17114,"address":[54700544],"length":1,"stats":{"Line":0}},{"line":17116,"address":[56252813],"length":1,"stats":{"Line":0}},{"line":17117,"address":[],"length":0,"stats":{"Line":0}},{"line":17118,"address":[56252774],"length":1,"stats":{"Line":0}},{"line":17120,"address":[53678459],"length":1,"stats":{"Line":0}},{"line":17124,"address":[56273536],"length":1,"stats":{"Line":0}},{"line":17129,"address":[56273627],"length":1,"stats":{"Line":0}},{"line":17131,"address":[],"length":0,"stats":{"Line":0}},{"line":17132,"address":[53699490],"length":1,"stats":{"Line":0}},{"line":17133,"address":[],"length":0,"stats":{"Line":0}},{"line":17134,"address":[],"length":0,"stats":{"Line":0}},{"line":17137,"address":[54531695],"length":1,"stats":{"Line":0}},{"line":17138,"address":[53699637],"length":1,"stats":{"Line":0}},{"line":17139,"address":[],"length":0,"stats":{"Line":0}},{"line":17140,"address":[],"length":0,"stats":{"Line":0}},{"line":17141,"address":[],"length":0,"stats":{"Line":0}},{"line":17144,"address":[56273990],"length":1,"stats":{"Line":0}},{"line":17145,"address":[],"length":0,"stats":{"Line":0}},{"line":17146,"address":[56273997],"length":1,"stats":{"Line":0}},{"line":17149,"address":[56274067],"length":1,"stats":{"Line":0}},{"line":17151,"address":[53699882],"length":1,"stats":{"Line":0}},{"line":17152,"address":[],"length":0,"stats":{"Line":0}},{"line":17153,"address":[53699897],"length":1,"stats":{"Line":0}},{"line":17158,"address":[53700037],"length":1,"stats":{"Line":0}},{"line":17159,"address":[],"length":0,"stats":{"Line":0}},{"line":17160,"address":[56274247],"length":1,"stats":{"Line":0}},{"line":17164,"address":[54532253],"length":1,"stats":{"Line":0}},{"line":17165,"address":[],"length":0,"stats":{"Line":0}},{"line":17166,"address":[53700151],"length":1,"stats":{"Line":0}},{"line":17168,"address":[54722333],"length":1,"stats":{"Line":0}},{"line":17170,"address":[],"length":0,"stats":{"Line":0}},{"line":17171,"address":[54532455],"length":1,"stats":{"Line":0}},{"line":17172,"address":[54722469],"length":1,"stats":{"Line":0}},{"line":17173,"address":[53700430],"length":1,"stats":{"Line":0}},{"line":17174,"address":[53700477],"length":1,"stats":{"Line":0}},{"line":17175,"address":[],"length":0,"stats":{"Line":0}},{"line":17176,"address":[53700487],"length":1,"stats":{"Line":0}},{"line":17178,"address":[],"length":0,"stats":{"Line":0}},{"line":17180,"address":[53700635],"length":1,"stats":{"Line":0}},{"line":17181,"address":[],"length":0,"stats":{"Line":0}},{"line":17182,"address":[54722825],"length":1,"stats":{"Line":0}},{"line":17183,"address":[54532915],"length":1,"stats":{"Line":0}},{"line":17184,"address":[54532971],"length":1,"stats":{"Line":0}},{"line":17186,"address":[53700912],"length":1,"stats":{"Line":0}},{"line":17187,"address":[53700970],"length":1,"stats":{"Line":0}},{"line":17189,"address":[53700999],"length":1,"stats":{"Line":0}},{"line":17190,"address":[],"length":0,"stats":{"Line":0}},{"line":17191,"address":[53701009],"length":1,"stats":{"Line":0}},{"line":17194,"address":[56275298],"length":1,"stats":{"Line":0}},{"line":17195,"address":[],"length":0,"stats":{"Line":0}},{"line":17196,"address":[54533230],"length":1,"stats":{"Line":0}},{"line":17198,"address":[],"length":0,"stats":{"Line":0}},{"line":17199,"address":[56275400],"length":1,"stats":{"Line":0}},{"line":17202,"address":[54723338],"length":1,"stats":{"Line":0}},{"line":17204,"address":[53701303],"length":1,"stats":{"Line":0}},{"line":17205,"address":[],"length":0,"stats":{"Line":0}},{"line":17207,"address":[],"length":0,"stats":{"Line":0}},{"line":17208,"address":[53701320],"length":1,"stats":{"Line":0}},{"line":17209,"address":[53701327],"length":1,"stats":{"Line":0}},{"line":17210,"address":[53701354],"length":1,"stats":{"Line":0}},{"line":17215,"address":[53701466],"length":1,"stats":{"Line":0}},{"line":17216,"address":[56275663],"length":1,"stats":{"Line":0}},{"line":17219,"address":[54533732],"length":1,"stats":{"Line":0}},{"line":17220,"address":[],"length":0,"stats":{"Line":0}},{"line":17222,"address":[],"length":0,"stats":{"Line":0}},{"line":17223,"address":[53701637],"length":1,"stats":{"Line":0}},{"line":17227,"address":[56275936],"length":1,"stats":{"Line":0}},{"line":17228,"address":[],"length":0,"stats":{"Line":0}},{"line":17229,"address":[56275946],"length":1,"stats":{"Line":0}},{"line":17233,"address":[],"length":0,"stats":{"Line":0}},{"line":17234,"address":[],"length":0,"stats":{"Line":0}},{"line":17235,"address":[53701878],"length":1,"stats":{"Line":0}},{"line":17237,"address":[56276148],"length":1,"stats":{"Line":0}},{"line":17239,"address":[54534146],"length":1,"stats":{"Line":0}},{"line":17240,"address":[],"length":0,"stats":{"Line":0}},{"line":17241,"address":[54534156],"length":1,"stats":{"Line":0}},{"line":17243,"address":[56276329],"length":1,"stats":{"Line":0}},{"line":17244,"address":[54534463],"length":1,"stats":{"Line":0}},{"line":17246,"address":[54534620],"length":1,"stats":{"Line":0}},{"line":17247,"address":[],"length":0,"stats":{"Line":0}},{"line":17248,"address":[],"length":0,"stats":{"Line":0}},{"line":17251,"address":[56276784],"length":1,"stats":{"Line":0}},{"line":17252,"address":[54724709],"length":1,"stats":{"Line":0}},{"line":17253,"address":[53702740],"length":1,"stats":{"Line":0}},{"line":17254,"address":[54534910],"length":1,"stats":{"Line":0}},{"line":17256,"address":[54724902],"length":1,"stats":{"Line":0}},{"line":17257,"address":[],"length":0,"stats":{"Line":0}},{"line":17258,"address":[],"length":0,"stats":{"Line":0}},{"line":17259,"address":[54724941],"length":1,"stats":{"Line":0}},{"line":17261,"address":[],"length":0,"stats":{"Line":0}},{"line":17262,"address":[56277193],"length":1,"stats":{"Line":0}},{"line":17264,"address":[53703099],"length":1,"stats":{"Line":0}},{"line":17265,"address":[53703120],"length":1,"stats":{"Line":0}},{"line":17266,"address":[54535275],"length":1,"stats":{"Line":0}},{"line":17267,"address":[54725255],"length":1,"stats":{"Line":0}},{"line":17269,"address":[],"length":0,"stats":{"Line":0}},{"line":17270,"address":[],"length":0,"stats":{"Line":0}},{"line":17271,"address":[],"length":0,"stats":{"Line":0}},{"line":17272,"address":[53703305],"length":1,"stats":{"Line":0}},{"line":17274,"address":[54535576],"length":1,"stats":{"Line":0}},{"line":17275,"address":[56277538],"length":1,"stats":{"Line":0}},{"line":17276,"address":[53703425],"length":1,"stats":{"Line":0}},{"line":17278,"address":[],"length":0,"stats":{"Line":0}},{"line":17282,"address":[53658032],"length":1,"stats":{"Line":0}},{"line":17287,"address":[53658120],"length":1,"stats":{"Line":0}},{"line":17290,"address":[54490278],"length":1,"stats":{"Line":0}},{"line":17291,"address":[54490303],"length":1,"stats":{"Line":0}},{"line":17292,"address":[],"length":0,"stats":{"Line":0}},{"line":17293,"address":[],"length":0,"stats":{"Line":0}},{"line":17296,"address":[53658284],"length":1,"stats":{"Line":0}},{"line":17297,"address":[53658338],"length":1,"stats":{"Line":0}},{"line":17298,"address":[],"length":0,"stats":{"Line":0}},{"line":17299,"address":[],"length":0,"stats":{"Line":0}},{"line":17300,"address":[54681029],"length":1,"stats":{"Line":0}},{"line":17304,"address":[53658487],"length":1,"stats":{"Line":0}},{"line":17305,"address":[],"length":0,"stats":{"Line":0}},{"line":17306,"address":[56233226],"length":1,"stats":{"Line":0}},{"line":17309,"address":[54681181],"length":1,"stats":{"Line":0}},{"line":17311,"address":[56233307],"length":1,"stats":{"Line":0}},{"line":17312,"address":[],"length":0,"stats":{"Line":0}},{"line":17313,"address":[54490701],"length":1,"stats":{"Line":0}},{"line":17318,"address":[54681336],"length":1,"stats":{"Line":0}},{"line":17319,"address":[],"length":0,"stats":{"Line":0}},{"line":17320,"address":[53658730],"length":1,"stats":{"Line":0}},{"line":17325,"address":[54490936],"length":1,"stats":{"Line":0}},{"line":17326,"address":[],"length":0,"stats":{"Line":0}},{"line":17327,"address":[54681448],"length":1,"stats":{"Line":0}},{"line":17329,"address":[53658929],"length":1,"stats":{"Line":0}},{"line":17331,"address":[54681589],"length":1,"stats":{"Line":0}},{"line":17332,"address":[53659023],"length":1,"stats":{"Line":0}},{"line":17333,"address":[],"length":0,"stats":{"Line":0}},{"line":17334,"address":[56233832],"length":1,"stats":{"Line":0}},{"line":17335,"address":[56233879],"length":1,"stats":{"Line":0}},{"line":17336,"address":[],"length":0,"stats":{"Line":0}},{"line":17337,"address":[56233889],"length":1,"stats":{"Line":0}},{"line":17339,"address":[54681865],"length":1,"stats":{"Line":0}},{"line":17341,"address":[],"length":0,"stats":{"Line":0}},{"line":17342,"address":[56234089],"length":1,"stats":{"Line":0}},{"line":17343,"address":[54682033],"length":1,"stats":{"Line":0}},{"line":17345,"address":[54682086],"length":1,"stats":{"Line":0}},{"line":17346,"address":[53659538],"length":1,"stats":{"Line":0}},{"line":17348,"address":[53659567],"length":1,"stats":{"Line":0}},{"line":17349,"address":[],"length":0,"stats":{"Line":0}},{"line":17350,"address":[56234294],"length":1,"stats":{"Line":0}},{"line":17353,"address":[],"length":0,"stats":{"Line":0}},{"line":17354,"address":[],"length":0,"stats":{"Line":0}},{"line":17355,"address":[53659686],"length":1,"stats":{"Line":0}},{"line":17357,"address":[54682377],"length":1,"stats":{"Line":0}},{"line":17358,"address":[54682384],"length":1,"stats":{"Line":0}},{"line":17361,"address":[53659834],"length":1,"stats":{"Line":0}},{"line":17364,"address":[53659871],"length":1,"stats":{"Line":0}},{"line":17365,"address":[],"length":0,"stats":{"Line":0}},{"line":17367,"address":[],"length":0,"stats":{"Line":0}},{"line":17368,"address":[54492000],"length":1,"stats":{"Line":0}},{"line":17369,"address":[54682495],"length":1,"stats":{"Line":0}},{"line":17370,"address":[54682521],"length":1,"stats":{"Line":0}},{"line":17375,"address":[54682630],"length":1,"stats":{"Line":0}},{"line":17376,"address":[56234759],"length":1,"stats":{"Line":0}},{"line":17379,"address":[54682782],"length":1,"stats":{"Line":0}},{"line":17380,"address":[],"length":0,"stats":{"Line":0}},{"line":17382,"address":[],"length":0,"stats":{"Line":0}},{"line":17383,"address":[54682799],"length":1,"stats":{"Line":0}},{"line":17387,"address":[56235032],"length":1,"stats":{"Line":0}},{"line":17388,"address":[],"length":0,"stats":{"Line":0}},{"line":17389,"address":[56235042],"length":1,"stats":{"Line":0}},{"line":17393,"address":[54683034],"length":1,"stats":{"Line":0}},{"line":17394,"address":[],"length":0,"stats":{"Line":0}},{"line":17395,"address":[54683044],"length":1,"stats":{"Line":0}},{"line":17397,"address":[54683159],"length":1,"stats":{"Line":0}},{"line":17400,"address":[56235475],"length":1,"stats":{"Line":0}},{"line":17401,"address":[56235555],"length":1,"stats":{"Line":0}},{"line":17402,"address":[56235611],"length":1,"stats":{"Line":0}},{"line":17404,"address":[54683556],"length":1,"stats":{"Line":0}},{"line":17406,"address":[56235689],"length":1,"stats":{"Line":0}},{"line":17410,"address":[53714192],"length":1,"stats":{"Line":0}},{"line":17414,"address":[56288279],"length":1,"stats":{"Line":0}},{"line":17417,"address":[54736219],"length":1,"stats":{"Line":0}},{"line":17418,"address":[54736244],"length":1,"stats":{"Line":0}},{"line":17419,"address":[],"length":0,"stats":{"Line":0}},{"line":17420,"address":[],"length":0,"stats":{"Line":0}},{"line":17423,"address":[53714436],"length":1,"stats":{"Line":0}},{"line":17424,"address":[54736401],"length":1,"stats":{"Line":0}},{"line":17425,"address":[54546688],"length":1,"stats":{"Line":0}},{"line":17426,"address":[],"length":0,"stats":{"Line":0}},{"line":17427,"address":[54736485],"length":1,"stats":{"Line":0}},{"line":17431,"address":[56288678],"length":1,"stats":{"Line":0}},{"line":17432,"address":[],"length":0,"stats":{"Line":0}},{"line":17433,"address":[54546785],"length":1,"stats":{"Line":0}},{"line":17435,"address":[54546852],"length":1,"stats":{"Line":0}},{"line":17436,"address":[],"length":0,"stats":{"Line":0}},{"line":17437,"address":[],"length":0,"stats":{"Line":0}},{"line":17442,"address":[54546953],"length":1,"stats":{"Line":0}},{"line":17443,"address":[53714885],"length":1,"stats":{"Line":0}},{"line":17444,"address":[53714940],"length":1,"stats":{"Line":0}},{"line":17445,"address":[],"length":0,"stats":{"Line":0}},{"line":17447,"address":[],"length":0,"stats":{"Line":0}},{"line":17448,"address":[56288965],"length":1,"stats":{"Line":0}},{"line":17449,"address":[54736860],"length":1,"stats":{"Line":0}},{"line":17450,"address":[],"length":0,"stats":{"Line":0}},{"line":17454,"address":[54547442,54547358,54547210],"length":1,"stats":{"Line":0}},{"line":17455,"address":[],"length":0,"stats":{"Line":0}},{"line":17456,"address":[53715115],"length":1,"stats":{"Line":0}},{"line":17457,"address":[54478640,54478624],"length":1,"stats":{"Line":0}},{"line":17462,"address":[56289465],"length":1,"stats":{"Line":0}},{"line":17463,"address":[],"length":0,"stats":{"Line":0}},{"line":17464,"address":[],"length":0,"stats":{"Line":0}},{"line":17466,"address":[53715548],"length":1,"stats":{"Line":0}},{"line":17467,"address":[54547667],"length":1,"stats":{"Line":0}},{"line":17471,"address":[54547710],"length":1,"stats":{"Line":0}},{"line":17472,"address":[54737524],"length":1,"stats":{"Line":0}},{"line":17473,"address":[54737571],"length":1,"stats":{"Line":0}},{"line":17474,"address":[54547844],"length":1,"stats":{"Line":0}},{"line":17475,"address":[56289771],"length":1,"stats":{"Line":0}},{"line":17476,"address":[],"length":0,"stats":{"Line":0}},{"line":17477,"address":[53715786],"length":1,"stats":{"Line":0}},{"line":17479,"address":[53715873],"length":1,"stats":{"Line":0}},{"line":17481,"address":[53715931],"length":1,"stats":{"Line":0}},{"line":17482,"address":[54548099],"length":1,"stats":{"Line":0}},{"line":17483,"address":[56290031],"length":1,"stats":{"Line":0}},{"line":17485,"address":[56290084],"length":1,"stats":{"Line":0}},{"line":17486,"address":[56290141],"length":1,"stats":{"Line":0}},{"line":17488,"address":[],"length":0,"stats":{"Line":0}},{"line":17489,"address":[],"length":0,"stats":{"Line":0}},{"line":17490,"address":[],"length":0,"stats":{"Line":0}},{"line":17493,"address":[53716292],"length":1,"stats":{"Line":0}},{"line":17494,"address":[],"length":0,"stats":{"Line":0}},{"line":17495,"address":[54548411],"length":1,"stats":{"Line":0}},{"line":17497,"address":[54738260],"length":1,"stats":{"Line":0}},{"line":17498,"address":[54548505],"length":1,"stats":{"Line":0}},{"line":17501,"address":[56290426],"length":1,"stats":{"Line":0}},{"line":17504,"address":[],"length":0,"stats":{"Line":0}},{"line":17505,"address":[],"length":0,"stats":{"Line":0}},{"line":17507,"address":[],"length":0,"stats":{"Line":0}},{"line":17508,"address":[54738362],"length":1,"stats":{"Line":0}},{"line":17509,"address":[53716496],"length":1,"stats":{"Line":0}},{"line":17510,"address":[],"length":0,"stats":{"Line":0}},{"line":17515,"address":[53716629],"length":1,"stats":{"Line":0}},{"line":17517,"address":[56290625],"length":1,"stats":{"Line":0}},{"line":17518,"address":[],"length":0,"stats":{"Line":0}},{"line":17519,"address":[54548786],"length":1,"stats":{"Line":0}},{"line":17524,"address":[53716775],"length":1,"stats":{"Line":0}},{"line":17525,"address":[],"length":0,"stats":{"Line":0}},{"line":17527,"address":[],"length":0,"stats":{"Line":0}},{"line":17528,"address":[54548902],"length":1,"stats":{"Line":0}},{"line":17532,"address":[53716901],"length":1,"stats":{"Line":0}},{"line":17533,"address":[],"length":0,"stats":{"Line":0}},{"line":17534,"address":[54738776],"length":1,"stats":{"Line":0}},{"line":17538,"address":[56291003],"length":1,"stats":{"Line":0}},{"line":17539,"address":[],"length":0,"stats":{"Line":0}},{"line":17541,"address":[],"length":0,"stats":{"Line":0}},{"line":17542,"address":[56291017],"length":1,"stats":{"Line":0}},{"line":17543,"address":[53717049],"length":1,"stats":{"Line":0}},{"line":17544,"address":[56291050],"length":1,"stats":{"Line":0}},{"line":17549,"address":[53717185],"length":1,"stats":{"Line":0}},{"line":17551,"address":[56291171],"length":1,"stats":{"Line":0}},{"line":17552,"address":[],"length":0,"stats":{"Line":0}},{"line":17553,"address":[],"length":0,"stats":{"Line":0}},{"line":17558,"address":[56291303],"length":1,"stats":{"Line":0}},{"line":17559,"address":[],"length":0,"stats":{"Line":0}},{"line":17561,"address":[],"length":0,"stats":{"Line":0}},{"line":17562,"address":[53717352],"length":1,"stats":{"Line":0}},{"line":17566,"address":[],"length":0,"stats":{"Line":0}},{"line":17568,"address":[],"length":0,"stats":{"Line":0}},{"line":17569,"address":[56291602],"length":1,"stats":{"Line":0}},{"line":17570,"address":[53717697],"length":1,"stats":{"Line":0}},{"line":17572,"address":[56291715],"length":1,"stats":{"Line":0}},{"line":17573,"address":[54549904],"length":1,"stats":{"Line":0}},{"line":17577,"address":[54025216],"length":1,"stats":{"Line":0}},{"line":17581,"address":[54025287],"length":1,"stats":{"Line":0}},{"line":17584,"address":[],"length":0,"stats":{"Line":0}},{"line":17585,"address":[54025364],"length":1,"stats":{"Line":0}},{"line":17586,"address":[],"length":0,"stats":{"Line":0}},{"line":17587,"address":[54857483],"length":1,"stats":{"Line":0}},{"line":17590,"address":[54025460],"length":1,"stats":{"Line":0}},{"line":17591,"address":[55043873],"length":1,"stats":{"Line":0}},{"line":17592,"address":[],"length":0,"stats":{"Line":0}},{"line":17593,"address":[],"length":0,"stats":{"Line":0}},{"line":17594,"address":[54857719],"length":1,"stats":{"Line":0}},{"line":17598,"address":[54025690],"length":1,"stats":{"Line":0}},{"line":17599,"address":[],"length":0,"stats":{"Line":0}},{"line":17600,"address":[54857809],"length":1,"stats":{"Line":0}},{"line":17602,"address":[],"length":0,"stats":{"Line":0}},{"line":17603,"address":[],"length":0,"stats":{"Line":0}},{"line":17604,"address":[54025774],"length":1,"stats":{"Line":0}},{"line":17609,"address":[],"length":0,"stats":{"Line":0}},{"line":17610,"address":[54858021],"length":1,"stats":{"Line":0}},{"line":17611,"address":[],"length":0,"stats":{"Line":0}},{"line":17612,"address":[],"length":0,"stats":{"Line":0}},{"line":17614,"address":[],"length":0,"stats":{"Line":0}},{"line":17615,"address":[54858093],"length":1,"stats":{"Line":0}},{"line":17616,"address":[],"length":0,"stats":{"Line":0}},{"line":17617,"address":[],"length":0,"stats":{"Line":0}},{"line":17621,"address":[],"length":0,"stats":{"Line":0}},{"line":17622,"address":[],"length":0,"stats":{"Line":0}},{"line":17623,"address":[55044479],"length":1,"stats":{"Line":0}},{"line":17624,"address":[55044588,55044658],"length":1,"stats":{"Line":0}},{"line":17629,"address":[54858602],"length":1,"stats":{"Line":0}},{"line":17630,"address":[],"length":0,"stats":{"Line":0}},{"line":17631,"address":[55044832],"length":1,"stats":{"Line":0}},{"line":17633,"address":[55044905],"length":1,"stats":{"Line":0}},{"line":17634,"address":[54858691],"length":1,"stats":{"Line":0}},{"line":17638,"address":[54858734],"length":1,"stats":{"Line":0}},{"line":17639,"address":[],"length":0,"stats":{"Line":0}},{"line":17640,"address":[54858824],"length":1,"stats":{"Line":0}},{"line":17641,"address":[56597199],"length":1,"stats":{"Line":0}},{"line":17642,"address":[56597243],"length":1,"stats":{"Line":0}},{"line":17643,"address":[54858956],"length":1,"stats":{"Line":0}},{"line":17644,"address":[],"length":0,"stats":{"Line":0}},{"line":17645,"address":[54858966],"length":1,"stats":{"Line":0}},{"line":17647,"address":[54859053],"length":1,"stats":{"Line":0}},{"line":17649,"address":[],"length":0,"stats":{"Line":0}},{"line":17650,"address":[54859167],"length":1,"stats":{"Line":0}},{"line":17651,"address":[],"length":0,"stats":{"Line":0}},{"line":17653,"address":[55045488],"length":1,"stats":{"Line":0}},{"line":17654,"address":[54027219],"length":1,"stats":{"Line":0}},{"line":17656,"address":[54027248],"length":1,"stats":{"Line":0}},{"line":17657,"address":[],"length":0,"stats":{"Line":0}},{"line":17658,"address":[],"length":0,"stats":{"Line":0}},{"line":17661,"address":[],"length":0,"stats":{"Line":0}},{"line":17662,"address":[],"length":0,"stats":{"Line":0}},{"line":17663,"address":[54859479],"length":1,"stats":{"Line":0}},{"line":17665,"address":[],"length":0,"stats":{"Line":0}},{"line":17666,"address":[],"length":0,"stats":{"Line":0}},{"line":17669,"address":[54859621],"length":1,"stats":{"Line":0}},{"line":17672,"address":[55045864],"length":1,"stats":{"Line":0}},{"line":17673,"address":[],"length":0,"stats":{"Line":0}},{"line":17675,"address":[],"length":0,"stats":{"Line":0}},{"line":17676,"address":[],"length":0,"stats":{"Line":0}},{"line":17677,"address":[],"length":0,"stats":{"Line":0}},{"line":17678,"address":[55045911],"length":1,"stats":{"Line":0}},{"line":17682,"address":[54027697],"length":1,"stats":{"Line":0}},{"line":17683,"address":[],"length":0,"stats":{"Line":0}},{"line":17684,"address":[55046021],"length":1,"stats":{"Line":0}},{"line":17687,"address":[55046091],"length":1,"stats":{"Line":0}},{"line":17689,"address":[54859903],"length":1,"stats":{"Line":0}},{"line":17690,"address":[],"length":0,"stats":{"Line":0}},{"line":17691,"address":[56598248],"length":1,"stats":{"Line":0}},{"line":17696,"address":[54860034],"length":1,"stats":{"Line":0}},{"line":17697,"address":[],"length":0,"stats":{"Line":0}},{"line":17699,"address":[],"length":0,"stats":{"Line":0}},{"line":17700,"address":[54027937],"length":1,"stats":{"Line":0}},{"line":17704,"address":[54028048],"length":1,"stats":{"Line":0}},{"line":17705,"address":[],"length":0,"stats":{"Line":0}},{"line":17706,"address":[55046369],"length":1,"stats":{"Line":0}},{"line":17710,"address":[56598596],"length":1,"stats":{"Line":0}},{"line":17711,"address":[],"length":0,"stats":{"Line":0}},{"line":17713,"address":[],"length":0,"stats":{"Line":0}},{"line":17714,"address":[55046498],"length":1,"stats":{"Line":0}},{"line":17715,"address":[54860308],"length":1,"stats":{"Line":0}},{"line":17716,"address":[54028223],"length":1,"stats":{"Line":0}},{"line":17721,"address":[54028335],"length":1,"stats":{"Line":0}},{"line":17723,"address":[],"length":0,"stats":{"Line":0}},{"line":17724,"address":[],"length":0,"stats":{"Line":0}},{"line":17725,"address":[55046688],"length":1,"stats":{"Line":0}},{"line":17730,"address":[],"length":0,"stats":{"Line":0}},{"line":17731,"address":[],"length":0,"stats":{"Line":0}},{"line":17733,"address":[],"length":0,"stats":{"Line":0}},{"line":17734,"address":[56598920],"length":1,"stats":{"Line":0}},{"line":17738,"address":[55046945],"length":1,"stats":{"Line":0}},{"line":17740,"address":[55047009],"length":1,"stats":{"Line":0}},{"line":17741,"address":[54860904],"length":1,"stats":{"Line":0}},{"line":17742,"address":[54028850],"length":1,"stats":{"Line":0}},{"line":17744,"address":[54028908],"length":1,"stats":{"Line":0}},{"line":17745,"address":[56599351],"length":1,"stats":{"Line":0}},{"line":17751,"address":[54008080],"length":1,"stats":{"Line":0}},{"line":17752,"address":[],"length":0,"stats":{"Line":0}},{"line":17754,"address":[55026759,55026820,55027004],"length":1,"stats":{"Line":0}},{"line":17755,"address":[],"length":0,"stats":{"Line":0}},{"line":17756,"address":[55026769],"length":1,"stats":{"Line":0}},{"line":17757,"address":[53115344,53115360],"length":1,"stats":{"Line":0}},{"line":17758,"address":[55027057],"length":1,"stats":{"Line":0}},{"line":17760,"address":[54008275],"length":1,"stats":{"Line":0}},{"line":17761,"address":[54008244],"length":1,"stats":{"Line":0}},{"line":17767,"address":[54920720],"length":1,"stats":{"Line":0}},{"line":17771,"address":[54920792],"length":1,"stats":{"Line":0}},{"line":17773,"address":[56657975],"length":1,"stats":{"Line":0}},{"line":17774,"address":[],"length":0,"stats":{"Line":0}},{"line":17777,"address":[55105883],"length":1,"stats":{"Line":0}},{"line":17781,"address":[54920807,54920927],"length":1,"stats":{"Line":0}},{"line":17782,"address":[54088929],"length":1,"stats":{"Line":0}},{"line":17783,"address":[55106039],"length":1,"stats":{"Line":0}},{"line":17784,"address":[],"length":0,"stats":{"Line":0}},{"line":17785,"address":[54921060],"length":1,"stats":{"Line":0}},{"line":17787,"address":[54089030],"length":1,"stats":{"Line":0}},{"line":17789,"address":[55105978],"length":1,"stats":{"Line":0}},{"line":17790,"address":[54921003,54921455],"length":1,"stats":{"Line":0}},{"line":17792,"address":[56658819],"length":1,"stats":{"Line":0}},{"line":17797,"address":[54922954,54921334,54921850],"length":1,"stats":{"Line":0}},{"line":17798,"address":[],"length":0,"stats":{"Line":0}},{"line":17799,"address":[56659196],"length":1,"stats":{"Line":0}},{"line":17800,"address":[54922065],"length":1,"stats":{"Line":0}},{"line":17801,"address":[],"length":0,"stats":{"Line":0}},{"line":17802,"address":[],"length":0,"stats":{"Line":0}},{"line":17804,"address":[54090046],"length":1,"stats":{"Line":0}},{"line":17806,"address":[56659143],"length":1,"stats":{"Line":0}},{"line":17807,"address":[54089907,54090342],"length":1,"stats":{"Line":0}},{"line":17808,"address":[54922676],"length":1,"stats":{"Line":0}},{"line":17812,"address":[55107820,55107321],"length":1,"stats":{"Line":0}},{"line":17815,"address":[54089851],"length":1,"stats":{"Line":0}},{"line":17819,"address":[54746464,54748058,54748064],"length":1,"stats":{"Line":0}},{"line":17825,"address":[],"length":0,"stats":{"Line":0}},{"line":17828,"address":[],"length":0,"stats":{"Line":0}},{"line":17829,"address":[53914978],"length":1,"stats":{"Line":0}},{"line":17831,"address":[53915021],"length":1,"stats":{"Line":0}},{"line":17832,"address":[56489212],"length":1,"stats":{"Line":0}},{"line":17833,"address":[54749272],"length":1,"stats":{"Line":0}},{"line":17837,"address":[54936816],"length":1,"stats":{"Line":0}},{"line":17838,"address":[54749052],"length":1,"stats":{"Line":0}},{"line":17839,"address":[54936910],"length":1,"stats":{"Line":0}},{"line":17840,"address":[56489075],"length":1,"stats":{"Line":0}},{"line":17842,"address":[56489300,56489155],"length":1,"stats":{"Line":0}},{"line":17845,"address":[53917515],"length":1,"stats":{"Line":0}},{"line":17846,"address":[54937467],"length":1,"stats":{"Line":0}},{"line":17848,"address":[56489647],"length":1,"stats":{"Line":0}},{"line":17851,"address":[56489674],"length":1,"stats":{"Line":0}},{"line":17853,"address":[56486874],"length":1,"stats":{"Line":0}},{"line":17855,"address":[54746944,54747178,54747469],"length":1,"stats":{"Line":0}},{"line":17856,"address":[],"length":0,"stats":{"Line":0}},{"line":17857,"address":[],"length":0,"stats":{"Line":0}},{"line":17858,"address":[56487183],"length":1,"stats":{"Line":0}},{"line":17860,"address":[53915233],"length":1,"stats":{"Line":0}},{"line":17864,"address":[53915383],"length":1,"stats":{"Line":0}},{"line":17865,"address":[54935904,54935379,54935466],"length":1,"stats":{"Line":0}},{"line":17866,"address":[54747894],"length":1,"stats":{"Line":0}},{"line":17868,"address":[],"length":0,"stats":{"Line":0}},{"line":17871,"address":[56486977],"length":1,"stats":{"Line":0}},{"line":17872,"address":[],"length":0,"stats":{"Line":0}},{"line":17873,"address":[],"length":0,"stats":{"Line":0}},{"line":17876,"address":[53914939,53915978],"length":1,"stats":{"Line":0}},{"line":17879,"address":[56488424,56488266],"length":1,"stats":{"Line":0}},{"line":17880,"address":[],"length":0,"stats":{"Line":0}},{"line":17881,"address":[],"length":0,"stats":{"Line":0}},{"line":17885,"address":[53916573],"length":1,"stats":{"Line":0}},{"line":17887,"address":[],"length":0,"stats":{"Line":0}},{"line":17889,"address":[53914709,53917680],"length":1,"stats":{"Line":0}},{"line":17890,"address":[54749916],"length":1,"stats":{"Line":0}},{"line":17896,"address":[],"length":0,"stats":{"Line":0}},{"line":17898,"address":[56604407],"length":1,"stats":{"Line":0}},{"line":17901,"address":[54034258,54034342],"length":1,"stats":{"Line":0}},{"line":17902,"address":[],"length":0,"stats":{"Line":0}},{"line":17904,"address":[],"length":0,"stats":{"Line":0}},{"line":17907,"address":[],"length":0,"stats":{"Line":0}},{"line":17908,"address":[54015680],"length":1,"stats":{"Line":0}},{"line":17909,"address":[],"length":0,"stats":{"Line":0}},{"line":17910,"address":[53116795,53116863],"length":1,"stats":{"Line":0}},{"line":17911,"address":[],"length":0,"stats":{"Line":0}},{"line":17915,"address":[56609218,56605056,56605147],"length":1,"stats":{"Line":0}},{"line":17918,"address":[54035052,54035147],"length":1,"stats":{"Line":0}},{"line":17919,"address":[56605563],"length":1,"stats":{"Line":0}},{"line":17920,"address":[56607005],"length":1,"stats":{"Line":0}},{"line":17922,"address":[56608518,56607025],"length":1,"stats":{"Line":0}},{"line":17923,"address":[55056537,55056430,55056486],"length":1,"stats":{"Line":0}},{"line":17924,"address":[54870674],"length":1,"stats":{"Line":0}},{"line":17925,"address":[54038776,54038839],"length":1,"stats":{"Line":0}},{"line":17927,"address":[55054747],"length":1,"stats":{"Line":0}},{"line":17929,"address":[56606894,56608066],"length":1,"stats":{"Line":0}},{"line":17931,"address":[],"length":0,"stats":{"Line":0}},{"line":17933,"address":[54870210,54868821],"length":1,"stats":{"Line":0}},{"line":17935,"address":[55054672],"length":1,"stats":{"Line":0}},{"line":17936,"address":[],"length":0,"stats":{"Line":0}},{"line":17937,"address":[],"length":0,"stats":{"Line":0}},{"line":17939,"address":[56606819,56607054],"length":1,"stats":{"Line":0}},{"line":17941,"address":[],"length":0,"stats":{"Line":0}},{"line":17942,"address":[56607141],"length":1,"stats":{"Line":0}},{"line":17943,"address":[],"length":0,"stats":{"Line":0}},{"line":17944,"address":[],"length":0,"stats":{"Line":0}},{"line":17946,"address":[54869314],"length":1,"stats":{"Line":0}},{"line":17947,"address":[54037274],"length":1,"stats":{"Line":0}},{"line":17948,"address":[54869423],"length":1,"stats":{"Line":0}},{"line":17950,"address":[56607631],"length":1,"stats":{"Line":0}},{"line":17953,"address":[],"length":0,"stats":{"Line":0}},{"line":17954,"address":[54037803,54037541],"length":1,"stats":{"Line":0}},{"line":17955,"address":[56607972],"length":1,"stats":{"Line":0}},{"line":17959,"address":[],"length":0,"stats":{"Line":0}},{"line":17964,"address":[54035344],"length":1,"stats":{"Line":0}},{"line":17965,"address":[55053691],"length":1,"stats":{"Line":0}},{"line":17966,"address":[55053858],"length":1,"stats":{"Line":0}},{"line":17967,"address":[],"length":0,"stats":{"Line":0}},{"line":17968,"address":[],"length":0,"stats":{"Line":0}},{"line":17970,"address":[56606028,56606160],"length":1,"stats":{"Line":0}},{"line":17972,"address":[],"length":0,"stats":{"Line":0}},{"line":17973,"address":[56606094,56606536],"length":1,"stats":{"Line":0}},{"line":17975,"address":[],"length":0,"stats":{"Line":0}},{"line":17981,"address":[54035597],"length":1,"stats":{"Line":0}},{"line":17985,"address":[],"length":0,"stats":{"Line":0}},{"line":17987,"address":[55244311],"length":1,"stats":{"Line":0}},{"line":17988,"address":[55062129],"length":1,"stats":{"Line":0}},{"line":17990,"address":[55062001],"length":1,"stats":{"Line":0}},{"line":17994,"address":[55062167],"length":1,"stats":{"Line":0}},{"line":17995,"address":[],"length":0,"stats":{"Line":0}},{"line":17996,"address":[],"length":0,"stats":{"Line":0}},{"line":17997,"address":[55244893,55244973],"length":1,"stats":{"Line":0}},{"line":17998,"address":[54230564,54231160],"length":1,"stats":{"Line":0}},{"line":18002,"address":[55245016,55245380,55245093],"length":1,"stats":{"Line":0}},{"line":18003,"address":[55245188,55245217],"length":1,"stats":{"Line":0}},{"line":18004,"address":[54230824,54230750],"length":1,"stats":{"Line":0}},{"line":18005,"address":[55245403,55245355],"length":1,"stats":{"Line":0}},{"line":18012,"address":[56797979,56796818],"length":1,"stats":{"Line":0}},{"line":18013,"address":[56797995,56798063],"length":1,"stats":{"Line":0}},{"line":18014,"address":[],"length":0,"stats":{"Line":0}},{"line":18018,"address":[],"length":0,"stats":{"Line":0}},{"line":18019,"address":[],"length":0,"stats":{"Line":0}},{"line":18020,"address":[55246224,55246543],"length":1,"stats":{"Line":0}},{"line":18023,"address":[56798365,56798419],"length":1,"stats":{"Line":0}},{"line":18024,"address":[],"length":0,"stats":{"Line":0}},{"line":18025,"address":[],"length":0,"stats":{"Line":0}},{"line":18030,"address":[56600768],"length":1,"stats":{"Line":0}},{"line":18035,"address":[54030455],"length":1,"stats":{"Line":0}},{"line":18038,"address":[56600984],"length":1,"stats":{"Line":0}},{"line":18040,"address":[54030773],"length":1,"stats":{"Line":0}},{"line":18041,"address":[56601184],"length":1,"stats":{"Line":0}},{"line":18042,"address":[55049128],"length":1,"stats":{"Line":0}},{"line":18044,"address":[55049192],"length":1,"stats":{"Line":0}},{"line":18045,"address":[54030947],"length":1,"stats":{"Line":0}},{"line":18049,"address":[55049249],"length":1,"stats":{"Line":0}},{"line":18052,"address":[],"length":0,"stats":{"Line":0}},{"line":18053,"address":[],"length":0,"stats":{"Line":0}},{"line":18057,"address":[55049352],"length":1,"stats":{"Line":0}},{"line":18058,"address":[55049407,55049647],"length":1,"stats":{"Line":0}},{"line":18059,"address":[55049746],"length":1,"stats":{"Line":0}},{"line":18060,"address":[55049907],"length":1,"stats":{"Line":0}},{"line":18061,"address":[56602169],"length":1,"stats":{"Line":0}},{"line":18062,"address":[54863983],"length":1,"stats":{"Line":0}},{"line":18063,"address":[],"length":0,"stats":{"Line":0}},{"line":18064,"address":[56602233],"length":1,"stats":{"Line":0}},{"line":18067,"address":[],"length":0,"stats":{"Line":0}},{"line":18068,"address":[],"length":0,"stats":{"Line":0}},{"line":18071,"address":[55050275],"length":1,"stats":{"Line":0}},{"line":18072,"address":[],"length":0,"stats":{"Line":0}},{"line":18076,"address":[56602482],"length":1,"stats":{"Line":0}},{"line":18077,"address":[],"length":0,"stats":{"Line":0}},{"line":18079,"address":[55050525],"length":1,"stats":{"Line":0}},{"line":18080,"address":[56602652],"length":1,"stats":{"Line":0}},{"line":18082,"address":[54032434],"length":1,"stats":{"Line":0}},{"line":18083,"address":[],"length":0,"stats":{"Line":0}},{"line":18086,"address":[55049494],"length":1,"stats":{"Line":0}},{"line":18088,"address":[55049509],"length":1,"stats":{"Line":0}},{"line":18089,"address":[54031275],"length":1,"stats":{"Line":0}},{"line":18096,"address":[54864697],"length":1,"stats":{"Line":0}},{"line":18097,"address":[54032629],"length":1,"stats":{"Line":0}},{"line":18098,"address":[56602992],"length":1,"stats":{"Line":0}},{"line":18100,"address":[54032771],"length":1,"stats":{"Line":0}},{"line":18103,"address":[54864941],"length":1,"stats":{"Line":0}},{"line":18104,"address":[54032850],"length":1,"stats":{"Line":0}},{"line":18111,"address":[56714320],"length":1,"stats":{"Line":0}},{"line":18117,"address":[],"length":0,"stats":{"Line":0}},{"line":18120,"address":[54978027],"length":1,"stats":{"Line":0}},{"line":18121,"address":[54145962],"length":1,"stats":{"Line":0}},{"line":18122,"address":[54978121],"length":1,"stats":{"Line":0}},{"line":18126,"address":[56714581],"length":1,"stats":{"Line":0}},{"line":18129,"address":[],"length":0,"stats":{"Line":0}},{"line":18132,"address":[56714644],"length":1,"stats":{"Line":0}},{"line":18133,"address":[54146287,54146181],"length":1,"stats":{"Line":0}},{"line":18134,"address":[54146361,54146515],"length":1,"stats":{"Line":0}},{"line":18137,"address":[55162581,55162941],"length":1,"stats":{"Line":0}},{"line":18141,"address":[56714957,56715027],"length":1,"stats":{"Line":0}},{"line":18142,"address":[],"length":0,"stats":{"Line":0}},{"line":18148,"address":[54146862],"length":1,"stats":{"Line":0}},{"line":18152,"address":[54978756],"length":1,"stats":{"Line":0}},{"line":18155,"address":[56715192],"length":1,"stats":{"Line":0}},{"line":18156,"address":[55163055],"length":1,"stats":{"Line":0}},{"line":18157,"address":[],"length":0,"stats":{"Line":0}},{"line":18160,"address":[55163266,55163132],"length":1,"stats":{"Line":0}},{"line":18161,"address":[54147008],"length":1,"stats":{"Line":0}},{"line":18162,"address":[54147065],"length":1,"stats":{"Line":0}},{"line":18165,"address":[56715628],"length":1,"stats":{"Line":0}},{"line":18166,"address":[56715796,56715692],"length":1,"stats":{"Line":0}},{"line":18167,"address":[],"length":0,"stats":{"Line":0}},{"line":18170,"address":[54147213,54147570],"length":1,"stats":{"Line":0}},{"line":18174,"address":[],"length":0,"stats":{"Line":0}},{"line":18175,"address":[],"length":0,"stats":{"Line":0}},{"line":18181,"address":[54979789],"length":1,"stats":{"Line":0}},{"line":18185,"address":[54147637],"length":1,"stats":{"Line":0}},{"line":18187,"address":[54979767],"length":1,"stats":{"Line":0}},{"line":18191,"address":[],"length":0,"stats":{"Line":0}},{"line":18192,"address":[55027167],"length":1,"stats":{"Line":0}},{"line":18194,"address":[54008738],"length":1,"stats":{"Line":0}},{"line":18195,"address":[54840903],"length":1,"stats":{"Line":0}},{"line":18198,"address":[54840943],"length":1,"stats":{"Line":0}},{"line":18199,"address":[54840968,54841059],"length":1,"stats":{"Line":0}},{"line":18200,"address":[54841180,54843435],"length":1,"stats":{"Line":0}},{"line":18201,"address":[],"length":0,"stats":{"Line":0}},{"line":18202,"address":[56581955,56581735,56579790],"length":1,"stats":{"Line":0}},{"line":18203,"address":[54843470,54843713],"length":1,"stats":{"Line":0}},{"line":18204,"address":[],"length":0,"stats":{"Line":0}},{"line":18205,"address":[54011367,54011609],"length":1,"stats":{"Line":0}},{"line":18206,"address":[54011637],"length":1,"stats":{"Line":0}},{"line":18210,"address":[54841222],"length":1,"stats":{"Line":0}},{"line":18211,"address":[54841269,54841427],"length":1,"stats":{"Line":0}},{"line":18212,"address":[54009267,54009171],"length":1,"stats":{"Line":0}},{"line":18215,"address":[56579927,56580054],"length":1,"stats":{"Line":0}},{"line":18219,"address":[],"length":0,"stats":{"Line":0}},{"line":18220,"address":[56580322,56580446],"length":1,"stats":{"Line":0}},{"line":18221,"address":[],"length":0,"stats":{"Line":0}},{"line":18222,"address":[56580595,56580659],"length":1,"stats":{"Line":0}},{"line":18224,"address":[56580577],"length":1,"stats":{"Line":0}},{"line":18228,"address":[54842076],"length":1,"stats":{"Line":0}},{"line":18229,"address":[54011109,54010106],"length":1,"stats":{"Line":0}},{"line":18231,"address":[54842413],"length":1,"stats":{"Line":0}},{"line":18232,"address":[54842420],"length":1,"stats":{"Line":0}},{"line":18236,"address":[55028918],"length":1,"stats":{"Line":0}},{"line":18239,"address":[],"length":0,"stats":{"Line":0}},{"line":18240,"address":[54010519,54010434],"length":1,"stats":{"Line":0}},{"line":18241,"address":[],"length":0,"stats":{"Line":0}},{"line":18242,"address":[56581278],"length":1,"stats":{"Line":0}},{"line":18246,"address":[56581126,56581713,56581359],"length":1,"stats":{"Line":0}},{"line":18249,"address":[56581499,56581596,56581635],"length":1,"stats":{"Line":0}},{"line":18250,"address":[],"length":0,"stats":{"Line":0}},{"line":18256,"address":[55029548],"length":1,"stats":{"Line":0}},{"line":18260,"address":[54009694],"length":1,"stats":{"Line":0}},{"line":18261,"address":[56580394],"length":1,"stats":{"Line":0}},{"line":18265,"address":[54232496],"length":1,"stats":{"Line":0}},{"line":18270,"address":[55064677],"length":1,"stats":{"Line":0}},{"line":18271,"address":[],"length":0,"stats":{"Line":0}},{"line":18273,"address":[54232743],"length":1,"stats":{"Line":0}},{"line":18275,"address":[],"length":0,"stats":{"Line":0}},{"line":18277,"address":[55247136],"length":1,"stats":{"Line":0}},{"line":18279,"address":[55247054],"length":1,"stats":{"Line":0}},{"line":18281,"address":[],"length":0,"stats":{"Line":0}},{"line":18282,"address":[56799581],"length":1,"stats":{"Line":0}},{"line":18284,"address":[56799420],"length":1,"stats":{"Line":0}},{"line":18286,"address":[55064944,55065094],"length":1,"stats":{"Line":0}},{"line":18287,"address":[54233214],"length":1,"stats":{"Line":0}},{"line":18289,"address":[54233489],"length":1,"stats":{"Line":0}},{"line":18290,"address":[56800270],"length":1,"stats":{"Line":0}},{"line":18292,"address":[54233862,54233799],"length":1,"stats":{"Line":0}},{"line":18293,"address":[],"length":0,"stats":{"Line":0}},{"line":18294,"address":[],"length":0,"stats":{"Line":0}},{"line":18295,"address":[56800446],"length":1,"stats":{"Line":0}},{"line":18301,"address":[55041840],"length":1,"stats":{"Line":0}},{"line":18306,"address":[],"length":0,"stats":{"Line":0}},{"line":18309,"address":[55225155],"length":1,"stats":{"Line":0}},{"line":18310,"address":[56777468],"length":1,"stats":{"Line":0}},{"line":18311,"address":[55042322],"length":1,"stats":{"Line":0}},{"line":18312,"address":[],"length":0,"stats":{"Line":0}},{"line":18313,"address":[55042329],"length":1,"stats":{"Line":0}},{"line":18317,"address":[56777614],"length":1,"stats":{"Line":0}},{"line":18318,"address":[55225518],"length":1,"stats":{"Line":0}},{"line":18319,"address":[],"length":0,"stats":{"Line":0}},{"line":18320,"address":[54210363],"length":1,"stats":{"Line":0}},{"line":18322,"address":[54210430],"length":1,"stats":{"Line":0}},{"line":18323,"address":[],"length":0,"stats":{"Line":0}},{"line":18324,"address":[],"length":0,"stats":{"Line":0}},{"line":18329,"address":[55225697],"length":1,"stats":{"Line":0}},{"line":18330,"address":[55042663],"length":1,"stats":{"Line":0}},{"line":18331,"address":[55042675,55042768],"length":1,"stats":{"Line":0}},{"line":18332,"address":[],"length":0,"stats":{"Line":0}},{"line":18333,"address":[55043023],"length":1,"stats":{"Line":0}},{"line":18334,"address":[56778238],"length":1,"stats":{"Line":0}},{"line":18335,"address":[],"length":0,"stats":{"Line":0}},{"line":18340,"address":[54210785],"length":1,"stats":{"Line":0}},{"line":18341,"address":[],"length":0,"stats":{"Line":0}},{"line":18342,"address":[54211137],"length":1,"stats":{"Line":0}},{"line":18343,"address":[55226363],"length":1,"stats":{"Line":0}},{"line":18344,"address":[],"length":0,"stats":{"Line":0}},{"line":18346,"address":[55043855,55044226,55044423],"length":1,"stats":{"Line":0}},{"line":18347,"address":[55044234],"length":1,"stats":{"Line":0}},{"line":18348,"address":[],"length":0,"stats":{"Line":0}},{"line":18349,"address":[54212164],"length":1,"stats":{"Line":0}},{"line":18350,"address":[],"length":0,"stats":{"Line":0}},{"line":18351,"address":[56779469],"length":1,"stats":{"Line":0}},{"line":18353,"address":[55044358,55044436],"length":1,"stats":{"Line":0}},{"line":18354,"address":[55044546],"length":1,"stats":{"Line":0}},{"line":18355,"address":[],"length":0,"stats":{"Line":0}},{"line":18356,"address":[56779839],"length":1,"stats":{"Line":0}},{"line":18359,"address":[],"length":0,"stats":{"Line":0}},{"line":18360,"address":[56779179],"length":1,"stats":{"Line":0}},{"line":18361,"address":[54211933],"length":1,"stats":{"Line":0}},{"line":18362,"address":[55227129],"length":1,"stats":{"Line":0}},{"line":18363,"address":[],"length":0,"stats":{"Line":0}},{"line":18366,"address":[],"length":0,"stats":{"Line":0}},{"line":18367,"address":[55228093,55228008,55226701],"length":1,"stats":{"Line":0}},{"line":18368,"address":[55045043,55045084],"length":1,"stats":{"Line":0}},{"line":18371,"address":[],"length":0,"stats":{"Line":0}},{"line":18373,"address":[56778603],"length":1,"stats":{"Line":0}},{"line":18374,"address":[],"length":0,"stats":{"Line":0}},{"line":18375,"address":[],"length":0,"stats":{"Line":0}},{"line":18376,"address":[54211304],"length":1,"stats":{"Line":0}},{"line":18377,"address":[55226492],"length":1,"stats":{"Line":0}},{"line":18378,"address":[],"length":0,"stats":{"Line":0}},{"line":18379,"address":[54211354],"length":1,"stats":{"Line":0}},{"line":18381,"address":[55226572],"length":1,"stats":{"Line":0}},{"line":18382,"address":[54212606,54211487],"length":1,"stats":{"Line":0}},{"line":18383,"address":[],"length":0,"stats":{"Line":0}},{"line":18384,"address":[55227842],"length":1,"stats":{"Line":0}},{"line":18385,"address":[54212768],"length":1,"stats":{"Line":0}},{"line":18386,"address":[56780111],"length":1,"stats":{"Line":0}},{"line":18391,"address":[56778490],"length":1,"stats":{"Line":0}},{"line":18395,"address":[55125056],"length":1,"stats":{"Line":0}},{"line":18402,"address":[54293000],"length":1,"stats":{"Line":0}},{"line":18403,"address":[],"length":0,"stats":{"Line":0}},{"line":18404,"address":[54293079],"length":1,"stats":{"Line":0}},{"line":18405,"address":[],"length":0,"stats":{"Line":0}},{"line":18406,"address":[55306814],"length":1,"stats":{"Line":0}},{"line":18408,"address":[54293149],"length":1,"stats":{"Line":0}},{"line":18409,"address":[],"length":0,"stats":{"Line":0}},{"line":18410,"address":[55306882],"length":1,"stats":{"Line":0}},{"line":18413,"address":[54293222],"length":1,"stats":{"Line":0}},{"line":18415,"address":[],"length":0,"stats":{"Line":0}},{"line":18416,"address":[],"length":0,"stats":{"Line":0}},{"line":18417,"address":[55125375],"length":1,"stats":{"Line":0}},{"line":18424,"address":[],"length":0,"stats":{"Line":0}},{"line":18425,"address":[55125522],"length":1,"stats":{"Line":0}},{"line":18426,"address":[],"length":0,"stats":{"Line":0}},{"line":18427,"address":[56859315],"length":1,"stats":{"Line":0}},{"line":18429,"address":[56859377],"length":1,"stats":{"Line":0}},{"line":18430,"address":[],"length":0,"stats":{"Line":0}},{"line":18431,"address":[54293491],"length":1,"stats":{"Line":0}},{"line":18434,"address":[55125687],"length":1,"stats":{"Line":0}},{"line":18438,"address":[56859504],"length":1,"stats":{"Line":0}},{"line":18445,"address":[54293686],"length":1,"stats":{"Line":0}},{"line":18446,"address":[],"length":0,"stats":{"Line":0}},{"line":18447,"address":[55125805],"length":1,"stats":{"Line":0}},{"line":18451,"address":[56859664],"length":1,"stats":{"Line":0}},{"line":18452,"address":[54293803],"length":1,"stats":{"Line":0}},{"line":18453,"address":[55307578],"length":1,"stats":{"Line":0}},{"line":18454,"address":[],"length":0,"stats":{"Line":0}},{"line":18455,"address":[56859761],"length":1,"stats":{"Line":0}},{"line":18457,"address":[],"length":0,"stats":{"Line":0}},{"line":18458,"address":[],"length":0,"stats":{"Line":0}},{"line":18459,"address":[54293946],"length":1,"stats":{"Line":0}},{"line":18462,"address":[56859911],"length":1,"stats":{"Line":0}},{"line":18463,"address":[],"length":0,"stats":{"Line":0}},{"line":18464,"address":[54294027],"length":1,"stats":{"Line":0}},{"line":18472,"address":[55126346],"length":1,"stats":{"Line":0}},{"line":18473,"address":[54294292],"length":1,"stats":{"Line":0}},{"line":18474,"address":[],"length":0,"stats":{"Line":0}},{"line":18475,"address":[],"length":0,"stats":{"Line":0}},{"line":18477,"address":[54294376],"length":1,"stats":{"Line":0}},{"line":18479,"address":[],"length":0,"stats":{"Line":0}},{"line":18481,"address":[55308182],"length":1,"stats":{"Line":0}},{"line":18482,"address":[],"length":0,"stats":{"Line":0}},{"line":18485,"address":[56860474],"length":1,"stats":{"Line":0}},{"line":18488,"address":[54294645],"length":1,"stats":{"Line":0}},{"line":18489,"address":[],"length":0,"stats":{"Line":0}},{"line":18490,"address":[],"length":0,"stats":{"Line":0}},{"line":18492,"address":[],"length":0,"stats":{"Line":0}},{"line":18493,"address":[],"length":0,"stats":{"Line":0}},{"line":18494,"address":[],"length":0,"stats":{"Line":0}},{"line":18497,"address":[54294800],"length":1,"stats":{"Line":0}},{"line":18498,"address":[],"length":0,"stats":{"Line":0}},{"line":18502,"address":[56860820],"length":1,"stats":{"Line":0}},{"line":18503,"address":[54294953],"length":1,"stats":{"Line":0}},{"line":18506,"address":[],"length":0,"stats":{"Line":0}},{"line":18507,"address":[55127211],"length":1,"stats":{"Line":0}},{"line":18511,"address":[55308865],"length":1,"stats":{"Line":0}},{"line":18512,"address":[],"length":0,"stats":{"Line":0}},{"line":18513,"address":[55127285],"length":1,"stats":{"Line":0}},{"line":18515,"address":[55308952],"length":1,"stats":{"Line":0}},{"line":18516,"address":[],"length":0,"stats":{"Line":0}},{"line":18517,"address":[],"length":0,"stats":{"Line":0}},{"line":18518,"address":[54295267],"length":1,"stats":{"Line":0}},{"line":18519,"address":[55309022],"length":1,"stats":{"Line":0}},{"line":18520,"address":[56861238],"length":1,"stats":{"Line":0}},{"line":18521,"address":[],"length":0,"stats":{"Line":0}},{"line":18522,"address":[55127482],"length":1,"stats":{"Line":0}},{"line":18524,"address":[55309171],"length":1,"stats":{"Line":0}},{"line":18525,"address":[],"length":0,"stats":{"Line":0}},{"line":18526,"address":[55127593],"length":1,"stats":{"Line":0}},{"line":18528,"address":[55309259],"length":1,"stats":{"Line":0}},{"line":18532,"address":[54242240],"length":1,"stats":{"Line":0}},{"line":18540,"address":[55256582,55257061],"length":1,"stats":{"Line":0}},{"line":18541,"address":[54242369],"length":1,"stats":{"Line":0}},{"line":18543,"address":[55256693],"length":1,"stats":{"Line":0}},{"line":18544,"address":[],"length":0,"stats":{"Line":0}},{"line":18549,"address":[55256825],"length":1,"stats":{"Line":0}},{"line":18550,"address":[],"length":0,"stats":{"Line":0}},{"line":18551,"address":[],"length":0,"stats":{"Line":0}},{"line":18552,"address":[55074710],"length":1,"stats":{"Line":0}},{"line":18554,"address":[56809122],"length":1,"stats":{"Line":0}},{"line":18555,"address":[],"length":0,"stats":{"Line":0}},{"line":18556,"address":[54242672],"length":1,"stats":{"Line":0}},{"line":18559,"address":[55074868],"length":1,"stats":{"Line":0}},{"line":18563,"address":[54177632],"length":1,"stats":{"Line":0}},{"line":18569,"address":[55009812],"length":1,"stats":{"Line":0}},{"line":18570,"address":[56745820],"length":1,"stats":{"Line":0}},{"line":18571,"address":[],"length":0,"stats":{"Line":0}},{"line":18572,"address":[55009891],"length":1,"stats":{"Line":0}},{"line":18574,"address":[54177846],"length":1,"stats":{"Line":0}},{"line":18575,"address":[],"length":0,"stats":{"Line":0}},{"line":18576,"address":[],"length":0,"stats":{"Line":0}},{"line":18581,"address":[],"length":0,"stats":{"Line":0}},{"line":18582,"address":[55193884],"length":1,"stats":{"Line":0}},{"line":18583,"address":[],"length":0,"stats":{"Line":0}},{"line":18584,"address":[],"length":0,"stats":{"Line":0}},{"line":18588,"address":[54178079],"length":1,"stats":{"Line":0}},{"line":18589,"address":[55194005],"length":1,"stats":{"Line":0}},{"line":18590,"address":[],"length":0,"stats":{"Line":0}},{"line":18591,"address":[],"length":0,"stats":{"Line":0}},{"line":18592,"address":[54178177],"length":1,"stats":{"Line":0}},{"line":18594,"address":[56746300],"length":1,"stats":{"Line":0}},{"line":18595,"address":[],"length":0,"stats":{"Line":0}},{"line":18596,"address":[55010379],"length":1,"stats":{"Line":0}},{"line":18599,"address":[56746372],"length":1,"stats":{"Line":0}},{"line":18600,"address":[],"length":0,"stats":{"Line":0}},{"line":18601,"address":[],"length":0,"stats":{"Line":0}},{"line":18609,"address":[55010690],"length":1,"stats":{"Line":0}},{"line":18610,"address":[],"length":0,"stats":{"Line":0}},{"line":18611,"address":[],"length":0,"stats":{"Line":0}},{"line":18613,"address":[54178660],"length":1,"stats":{"Line":0}},{"line":18615,"address":[],"length":0,"stats":{"Line":0}},{"line":18617,"address":[55194625],"length":1,"stats":{"Line":0}},{"line":18618,"address":[56746802],"length":1,"stats":{"Line":0}},{"line":18621,"address":[],"length":0,"stats":{"Line":0}},{"line":18622,"address":[],"length":0,"stats":{"Line":0}},{"line":18623,"address":[54178918],"length":1,"stats":{"Line":0}},{"line":18625,"address":[],"length":0,"stats":{"Line":0}},{"line":18628,"address":[55011907,55011163],"length":1,"stats":{"Line":0}},{"line":18630,"address":[54179174],"length":1,"stats":{"Line":0}},{"line":18631,"address":[56747214],"length":1,"stats":{"Line":0}},{"line":18634,"address":[],"length":0,"stats":{"Line":0}},{"line":18636,"address":[55011476],"length":1,"stats":{"Line":0}},{"line":18637,"address":[56747402],"length":1,"stats":{"Line":0}},{"line":18640,"address":[55195366],"length":1,"stats":{"Line":0}},{"line":18642,"address":[55011632],"length":1,"stats":{"Line":0}},{"line":18643,"address":[],"length":0,"stats":{"Line":0}},{"line":18649,"address":[],"length":0,"stats":{"Line":0}},{"line":18653,"address":[54518912],"length":1,"stats":{"Line":0}},{"line":18658,"address":[54709119],"length":1,"stats":{"Line":0}},{"line":18659,"address":[53687010],"length":1,"stats":{"Line":0}},{"line":18663,"address":[56261408],"length":1,"stats":{"Line":0}},{"line":18669,"address":[53687117],"length":1,"stats":{"Line":0}},{"line":18670,"address":[53687274],"length":1,"stats":{"Line":0}},{"line":18671,"address":[56261817],"length":1,"stats":{"Line":0}},{"line":18677,"address":[55111984],"length":1,"stats":{"Line":0}},{"line":18682,"address":[56846059],"length":1,"stats":{"Line":0}},{"line":18685,"address":[56846102],"length":1,"stats":{"Line":0}},{"line":18686,"address":[55112143],"length":1,"stats":{"Line":0}},{"line":18687,"address":[],"length":0,"stats":{"Line":0}},{"line":18688,"address":[],"length":0,"stats":{"Line":0}},{"line":18692,"address":[55294042],"length":1,"stats":{"Line":0}},{"line":18693,"address":[],"length":0,"stats":{"Line":0}},{"line":18694,"address":[55294164],"length":1,"stats":{"Line":0}},{"line":18695,"address":[],"length":0,"stats":{"Line":0}},{"line":18696,"address":[],"length":0,"stats":{"Line":0}},{"line":18700,"address":[56846417],"length":1,"stats":{"Line":0}},{"line":18702,"address":[55294282],"length":1,"stats":{"Line":0}},{"line":18704,"address":[56846472],"length":1,"stats":{"Line":0}},{"line":18705,"address":[],"length":0,"stats":{"Line":0}},{"line":18706,"address":[],"length":0,"stats":{"Line":0}},{"line":18711,"address":[55112623],"length":1,"stats":{"Line":0}},{"line":18712,"address":[],"length":0,"stats":{"Line":0}},{"line":18713,"address":[55112630],"length":1,"stats":{"Line":0}},{"line":18715,"address":[55294497],"length":1,"stats":{"Line":0}},{"line":18716,"address":[],"length":0,"stats":{"Line":0}},{"line":18717,"address":[],"length":0,"stats":{"Line":0}},{"line":18722,"address":[56846779],"length":1,"stats":{"Line":0}},{"line":18723,"address":[],"length":0,"stats":{"Line":0}},{"line":18724,"address":[54280700],"length":1,"stats":{"Line":0}},{"line":18728,"address":[],"length":0,"stats":{"Line":0}},{"line":18729,"address":[54280812],"length":1,"stats":{"Line":0}},{"line":18730,"address":[55112968],"length":1,"stats":{"Line":0}},{"line":18731,"address":[55113012],"length":1,"stats":{"Line":0}},{"line":18732,"address":[54280944],"length":1,"stats":{"Line":0}},{"line":18734,"address":[55294900],"length":1,"stats":{"Line":0}},{"line":18735,"address":[],"length":0,"stats":{"Line":0}},{"line":18736,"address":[55113113],"length":1,"stats":{"Line":0}},{"line":18738,"address":[],"length":0,"stats":{"Line":0}},{"line":18739,"address":[],"length":0,"stats":{"Line":0}},{"line":18742,"address":[55113274],"length":1,"stats":{"Line":0}},{"line":18743,"address":[],"length":0,"stats":{"Line":0}},{"line":18744,"address":[56847253],"length":1,"stats":{"Line":0}},{"line":18746,"address":[55113371],"length":1,"stats":{"Line":0}},{"line":18748,"address":[55113426],"length":1,"stats":{"Line":0}},{"line":18749,"address":[55113479],"length":1,"stats":{"Line":0}},{"line":18750,"address":[55113532],"length":1,"stats":{"Line":0}},{"line":18751,"address":[56847550],"length":1,"stats":{"Line":0}},{"line":18752,"address":[],"length":0,"stats":{"Line":0}},{"line":18753,"address":[56847554],"length":1,"stats":{"Line":0}},{"line":18754,"address":[55295427],"length":1,"stats":{"Line":0}},{"line":18756,"address":[55113691],"length":1,"stats":{"Line":0}},{"line":18757,"address":[],"length":0,"stats":{"Line":0}},{"line":18759,"address":[54281666],"length":1,"stats":{"Line":0}},{"line":18760,"address":[],"length":0,"stats":{"Line":0}},{"line":18761,"address":[56847752],"length":1,"stats":{"Line":0}},{"line":18764,"address":[55295673],"length":1,"stats":{"Line":0}},{"line":18765,"address":[],"length":0,"stats":{"Line":0}},{"line":18766,"address":[55295680],"length":1,"stats":{"Line":0}},{"line":18768,"address":[55113984],"length":1,"stats":{"Line":0}},{"line":18769,"address":[55113991],"length":1,"stats":{"Line":0}},{"line":18772,"address":[],"length":0,"stats":{"Line":0}},{"line":18775,"address":[54281967],"length":1,"stats":{"Line":0}},{"line":18776,"address":[],"length":0,"stats":{"Line":0}},{"line":18778,"address":[],"length":0,"stats":{"Line":0}},{"line":18779,"address":[56848055],"length":1,"stats":{"Line":0}},{"line":18780,"address":[56848062],"length":1,"stats":{"Line":0}},{"line":18781,"address":[54282018],"length":1,"stats":{"Line":0}},{"line":18786,"address":[],"length":0,"stats":{"Line":0}},{"line":18788,"address":[55114259],"length":1,"stats":{"Line":0}},{"line":18789,"address":[],"length":0,"stats":{"Line":0}},{"line":18790,"address":[54282183],"length":1,"stats":{"Line":0}},{"line":18795,"address":[55296173],"length":1,"stats":{"Line":0}},{"line":18796,"address":[],"length":0,"stats":{"Line":0}},{"line":18798,"address":[],"length":0,"stats":{"Line":0}},{"line":18799,"address":[],"length":0,"stats":{"Line":0}},{"line":18803,"address":[54282424],"length":1,"stats":{"Line":0}},{"line":18804,"address":[],"length":0,"stats":{"Line":0}},{"line":18805,"address":[],"length":0,"stats":{"Line":0}},{"line":18809,"address":[56848580],"length":1,"stats":{"Line":0}},{"line":18810,"address":[],"length":0,"stats":{"Line":0}},{"line":18811,"address":[],"length":0,"stats":{"Line":0}},{"line":18814,"address":[56848701],"length":1,"stats":{"Line":0}},{"line":18815,"address":[],"length":0,"stats":{"Line":0}},{"line":18816,"address":[],"length":0,"stats":{"Line":0}},{"line":18820,"address":[54282724],"length":1,"stats":{"Line":0}},{"line":18821,"address":[],"length":0,"stats":{"Line":0}},{"line":18823,"address":[55114853],"length":1,"stats":{"Line":0}},{"line":18824,"address":[],"length":0,"stats":{"Line":0}},{"line":18825,"address":[56848813],"length":1,"stats":{"Line":0}},{"line":18826,"address":[55296674],"length":1,"stats":{"Line":0}},{"line":18837,"address":[55115142],"length":1,"stats":{"Line":0}},{"line":18838,"address":[],"length":0,"stats":{"Line":0}},{"line":18840,"address":[],"length":0,"stats":{"Line":0}},{"line":18841,"address":[55115160],"length":1,"stats":{"Line":0}},{"line":18842,"address":[54283058],"length":1,"stats":{"Line":0}},{"line":18843,"address":[],"length":0,"stats":{"Line":0}},{"line":18844,"address":[],"length":0,"stats":{"Line":0}},{"line":18845,"address":[54283150],"length":1,"stats":{"Line":0}},{"line":18846,"address":[55297059],"length":1,"stats":{"Line":0}},{"line":18852,"address":[54283308],"length":1,"stats":{"Line":0}},{"line":18853,"address":[],"length":0,"stats":{"Line":0}},{"line":18855,"address":[55115437],"length":1,"stats":{"Line":0}},{"line":18856,"address":[55115452],"length":1,"stats":{"Line":0}},{"line":18864,"address":[55297427],"length":1,"stats":{"Line":0}},{"line":18865,"address":[],"length":0,"stats":{"Line":0}},{"line":18866,"address":[],"length":0,"stats":{"Line":0}},{"line":18872,"address":[54283794],"length":1,"stats":{"Line":0}},{"line":18873,"address":[],"length":0,"stats":{"Line":0}},{"line":18874,"address":[55297667],"length":1,"stats":{"Line":0}},{"line":18877,"address":[55115992],"length":1,"stats":{"Line":0}},{"line":18878,"address":[],"length":0,"stats":{"Line":0}},{"line":18879,"address":[55297751],"length":1,"stats":{"Line":0}},{"line":18881,"address":[54283970],"length":1,"stats":{"Line":0}},{"line":18882,"address":[55297839],"length":1,"stats":{"Line":0}},{"line":18886,"address":[55116140],"length":1,"stats":{"Line":0}},{"line":18887,"address":[],"length":0,"stats":{"Line":0}},{"line":18888,"address":[],"length":0,"stats":{"Line":0}},{"line":18889,"address":[],"length":0,"stats":{"Line":0}},{"line":18892,"address":[55298003],"length":1,"stats":{"Line":0}},{"line":18894,"address":[],"length":0,"stats":{"Line":0}},{"line":18895,"address":[],"length":0,"stats":{"Line":0}},{"line":18896,"address":[54284197],"length":1,"stats":{"Line":0}},{"line":18901,"address":[56850331],"length":1,"stats":{"Line":0}},{"line":18902,"address":[],"length":0,"stats":{"Line":0}},{"line":18904,"address":[],"length":0,"stats":{"Line":0}},{"line":18905,"address":[56850348],"length":1,"stats":{"Line":0}},{"line":18909,"address":[54284438],"length":1,"stats":{"Line":0}},{"line":18910,"address":[],"length":0,"stats":{"Line":0}},{"line":18911,"address":[56850479],"length":1,"stats":{"Line":0}},{"line":18913,"address":[56850570],"length":1,"stats":{"Line":0}},{"line":18914,"address":[],"length":0,"stats":{"Line":0}},{"line":18917,"address":[56850683],"length":1,"stats":{"Line":0}},{"line":18918,"address":[54284694],"length":1,"stats":{"Line":0}},{"line":18919,"address":[55298624],"length":1,"stats":{"Line":0}},{"line":18920,"address":[56850856],"length":1,"stats":{"Line":0}},{"line":18923,"address":[54284892],"length":1,"stats":{"Line":0}},{"line":18924,"address":[54284921],"length":1,"stats":{"Line":0}},{"line":18925,"address":[],"length":0,"stats":{"Line":0}},{"line":18926,"address":[55117043],"length":1,"stats":{"Line":0}},{"line":18928,"address":[54285021],"length":1,"stats":{"Line":0}},{"line":18933,"address":[55298896],"length":1,"stats":{"Line":0}},{"line":18939,"address":[55299051],"length":1,"stats":{"Line":0}},{"line":18942,"address":[55117369],"length":1,"stats":{"Line":0}},{"line":18943,"address":[55299122],"length":1,"stats":{"Line":0}},{"line":18944,"address":[],"length":0,"stats":{"Line":0}},{"line":18945,"address":[],"length":0,"stats":{"Line":0}},{"line":18949,"address":[56851389],"length":1,"stats":{"Line":0}},{"line":18950,"address":[56851446],"length":1,"stats":{"Line":0}},{"line":18951,"address":[55299338],"length":1,"stats":{"Line":0}},{"line":18952,"address":[],"length":0,"stats":{"Line":0}},{"line":18953,"address":[56851521],"length":1,"stats":{"Line":0}},{"line":18957,"address":[56851591],"length":1,"stats":{"Line":0}},{"line":18959,"address":[56851635],"length":1,"stats":{"Line":0}},{"line":18961,"address":[56851652],"length":1,"stats":{"Line":0}},{"line":18962,"address":[],"length":0,"stats":{"Line":0}},{"line":18963,"address":[56851688],"length":1,"stats":{"Line":0}},{"line":18968,"address":[55299614],"length":1,"stats":{"Line":0}},{"line":18969,"address":[],"length":0,"stats":{"Line":0}},{"line":18970,"address":[],"length":0,"stats":{"Line":0}},{"line":18972,"address":[55299686],"length":1,"stats":{"Line":0}},{"line":18973,"address":[],"length":0,"stats":{"Line":0}},{"line":18974,"address":[55117976],"length":1,"stats":{"Line":0}},{"line":18979,"address":[56851977],"length":1,"stats":{"Line":0}},{"line":18980,"address":[],"length":0,"stats":{"Line":0}},{"line":18981,"address":[54285978],"length":1,"stats":{"Line":0}},{"line":18985,"address":[54286050],"length":1,"stats":{"Line":0}},{"line":18986,"address":[],"length":0,"stats":{"Line":0}},{"line":18987,"address":[56852142],"length":1,"stats":{"Line":0}},{"line":18988,"address":[55300010],"length":1,"stats":{"Line":0}},{"line":18989,"address":[56852230],"length":1,"stats":{"Line":0}},{"line":18991,"address":[55118384],"length":1,"stats":{"Line":0}},{"line":18992,"address":[],"length":0,"stats":{"Line":0}},{"line":18993,"address":[56852287],"length":1,"stats":{"Line":0}},{"line":18995,"address":[],"length":0,"stats":{"Line":0}},{"line":18997,"address":[56852423],"length":1,"stats":{"Line":0}},{"line":18998,"address":[],"length":0,"stats":{"Line":0}},{"line":18999,"address":[54286432],"length":1,"stats":{"Line":0}},{"line":19001,"address":[55300334],"length":1,"stats":{"Line":0}},{"line":19002,"address":[55300351],"length":1,"stats":{"Line":0}},{"line":19005,"address":[54286617],"length":1,"stats":{"Line":0}},{"line":19006,"address":[55300494],"length":1,"stats":{"Line":0}},{"line":19007,"address":[],"length":0,"stats":{"Line":0}},{"line":19008,"address":[55118897],"length":1,"stats":{"Line":0}},{"line":19009,"address":[],"length":0,"stats":{"Line":0}},{"line":19010,"address":[],"length":0,"stats":{"Line":0}},{"line":19011,"address":[],"length":0,"stats":{"Line":0}},{"line":19012,"address":[55119009],"length":1,"stats":{"Line":0}},{"line":19014,"address":[54286950],"length":1,"stats":{"Line":0}},{"line":19015,"address":[55300828],"length":1,"stats":{"Line":0}},{"line":19017,"address":[],"length":0,"stats":{"Line":0}},{"line":19018,"address":[],"length":0,"stats":{"Line":0}},{"line":19019,"address":[54287047],"length":1,"stats":{"Line":0}},{"line":19022,"address":[54287149],"length":1,"stats":{"Line":0}},{"line":19023,"address":[],"length":0,"stats":{"Line":0}},{"line":19024,"address":[],"length":0,"stats":{"Line":0}},{"line":19026,"address":[55119358],"length":1,"stats":{"Line":0}},{"line":19027,"address":[55301069],"length":1,"stats":{"Line":0}},{"line":19030,"address":[56853295],"length":1,"stats":{"Line":0}},{"line":19033,"address":[55119453],"length":1,"stats":{"Line":0}},{"line":19034,"address":[],"length":0,"stats":{"Line":0}},{"line":19036,"address":[],"length":0,"stats":{"Line":0}},{"line":19037,"address":[],"length":0,"stats":{"Line":0}},{"line":19038,"address":[55301180],"length":1,"stats":{"Line":0}},{"line":19039,"address":[],"length":0,"stats":{"Line":0}},{"line":19044,"address":[55301315],"length":1,"stats":{"Line":0}},{"line":19046,"address":[55119633],"length":1,"stats":{"Line":0}},{"line":19047,"address":[],"length":0,"stats":{"Line":0}},{"line":19048,"address":[54287557],"length":1,"stats":{"Line":0}},{"line":19053,"address":[55301467],"length":1,"stats":{"Line":0}},{"line":19054,"address":[],"length":0,"stats":{"Line":0}},{"line":19056,"address":[],"length":0,"stats":{"Line":0}},{"line":19057,"address":[],"length":0,"stats":{"Line":0}},{"line":19061,"address":[],"length":0,"stats":{"Line":0}},{"line":19062,"address":[],"length":0,"stats":{"Line":0}},{"line":19063,"address":[56853791],"length":1,"stats":{"Line":0}},{"line":19067,"address":[54287893],"length":1,"stats":{"Line":0}},{"line":19068,"address":[],"length":0,"stats":{"Line":0}},{"line":19069,"address":[],"length":0,"stats":{"Line":0}},{"line":19072,"address":[],"length":0,"stats":{"Line":0}},{"line":19073,"address":[],"length":0,"stats":{"Line":0}},{"line":19074,"address":[56854002],"length":1,"stats":{"Line":0}},{"line":19077,"address":[54288098],"length":1,"stats":{"Line":0}},{"line":19078,"address":[],"length":0,"stats":{"Line":0}},{"line":19080,"address":[54288115],"length":1,"stats":{"Line":0}},{"line":19081,"address":[56854204],"length":1,"stats":{"Line":0}},{"line":19082,"address":[],"length":0,"stats":{"Line":0}},{"line":19083,"address":[54288167],"length":1,"stats":{"Line":0}},{"line":19093,"address":[],"length":0,"stats":{"Line":0}},{"line":19094,"address":[],"length":0,"stats":{"Line":0}},{"line":19096,"address":[],"length":0,"stats":{"Line":0}},{"line":19097,"address":[54288422],"length":1,"stats":{"Line":0}},{"line":19098,"address":[],"length":0,"stats":{"Line":0}},{"line":19099,"address":[],"length":0,"stats":{"Line":0}},{"line":19100,"address":[56854486],"length":1,"stats":{"Line":0}},{"line":19101,"address":[],"length":0,"stats":{"Line":0}},{"line":19102,"address":[55120670],"length":1,"stats":{"Line":0}},{"line":19107,"address":[55302474],"length":1,"stats":{"Line":0}},{"line":19108,"address":[],"length":0,"stats":{"Line":0}},{"line":19110,"address":[56854667],"length":1,"stats":{"Line":0}},{"line":19111,"address":[56854682],"length":1,"stats":{"Line":0}},{"line":19119,"address":[],"length":0,"stats":{"Line":0}},{"line":19120,"address":[],"length":0,"stats":{"Line":0}},{"line":19121,"address":[56854914],"length":1,"stats":{"Line":0}},{"line":19127,"address":[55121280],"length":1,"stats":{"Line":0}},{"line":19128,"address":[],"length":0,"stats":{"Line":0}},{"line":19129,"address":[],"length":0,"stats":{"Line":0}},{"line":19132,"address":[56855214],"length":1,"stats":{"Line":0}},{"line":19133,"address":[],"length":0,"stats":{"Line":0}},{"line":19134,"address":[55121373],"length":1,"stats":{"Line":0}},{"line":19136,"address":[],"length":0,"stats":{"Line":0}},{"line":19137,"address":[54289351],"length":1,"stats":{"Line":0}},{"line":19141,"address":[54289402],"length":1,"stats":{"Line":0}},{"line":19142,"address":[55303220],"length":1,"stats":{"Line":0}},{"line":19143,"address":[],"length":0,"stats":{"Line":0}},{"line":19144,"address":[54289446],"length":1,"stats":{"Line":0}},{"line":19147,"address":[56855473],"length":1,"stats":{"Line":0}},{"line":19149,"address":[54289535],"length":1,"stats":{"Line":0}},{"line":19150,"address":[],"length":0,"stats":{"Line":0}},{"line":19151,"address":[54289571],"length":1,"stats":{"Line":0}},{"line":19156,"address":[55303449],"length":1,"stats":{"Line":0}},{"line":19157,"address":[],"length":0,"stats":{"Line":0}},{"line":19159,"address":[],"length":0,"stats":{"Line":0}},{"line":19160,"address":[55303466],"length":1,"stats":{"Line":0}},{"line":19164,"address":[55303603],"length":1,"stats":{"Line":0}},{"line":19165,"address":[55121990],"length":1,"stats":{"Line":0}},{"line":19166,"address":[],"length":0,"stats":{"Line":0}},{"line":19168,"address":[55303756],"length":1,"stats":{"Line":0}},{"line":19171,"address":[54290043],"length":1,"stats":{"Line":0}},{"line":19172,"address":[],"length":0,"stats":{"Line":0}},{"line":19173,"address":[56856106],"length":1,"stats":{"Line":0}},{"line":19174,"address":[54290220],"length":1,"stats":{"Line":0}},{"line":19177,"address":[54290278],"length":1,"stats":{"Line":0}},{"line":19180,"address":[56856256],"length":1,"stats":{"Line":0}},{"line":19181,"address":[],"length":0,"stats":{"Line":0}},{"line":19182,"address":[],"length":0,"stats":{"Line":0}},{"line":19184,"address":[55122517],"length":1,"stats":{"Line":0}},{"line":19185,"address":[],"length":0,"stats":{"Line":0}},{"line":19187,"address":[],"length":0,"stats":{"Line":0}},{"line":19188,"address":[55122534],"length":1,"stats":{"Line":0}},{"line":19189,"address":[54290429],"length":1,"stats":{"Line":0}},{"line":19190,"address":[56856394],"length":1,"stats":{"Line":0}},{"line":19196,"address":[56856511],"length":1,"stats":{"Line":0}},{"line":19197,"address":[],"length":0,"stats":{"Line":0}},{"line":19199,"address":[55304352],"length":1,"stats":{"Line":0}},{"line":19200,"address":[],"length":0,"stats":{"Line":0}},{"line":19211,"address":[55122990],"length":1,"stats":{"Line":0}},{"line":19213,"address":[55123007],"length":1,"stats":{"Line":0}},{"line":19214,"address":[],"length":0,"stats":{"Line":0}},{"line":19215,"address":[55304687],"length":1,"stats":{"Line":0}},{"line":19220,"address":[],"length":0,"stats":{"Line":0}},{"line":19221,"address":[],"length":0,"stats":{"Line":0}},{"line":19222,"address":[],"length":0,"stats":{"Line":0}},{"line":19224,"address":[54291117],"length":1,"stats":{"Line":0}},{"line":19225,"address":[54291124],"length":1,"stats":{"Line":0}},{"line":19229,"address":[],"length":0,"stats":{"Line":0}},{"line":19230,"address":[],"length":0,"stats":{"Line":0}},{"line":19232,"address":[],"length":0,"stats":{"Line":0}},{"line":19233,"address":[56857126],"length":1,"stats":{"Line":0}},{"line":19234,"address":[55304957],"length":1,"stats":{"Line":0}},{"line":19235,"address":[55304983],"length":1,"stats":{"Line":0}},{"line":19242,"address":[54291346],"length":1,"stats":{"Line":0}},{"line":19244,"address":[55305109],"length":1,"stats":{"Line":0}},{"line":19245,"address":[],"length":0,"stats":{"Line":0}},{"line":19246,"address":[56857321],"length":1,"stats":{"Line":0}},{"line":19251,"address":[54291500],"length":1,"stats":{"Line":0}},{"line":19252,"address":[],"length":0,"stats":{"Line":0}},{"line":19254,"address":[],"length":0,"stats":{"Line":0}},{"line":19255,"address":[56857437],"length":1,"stats":{"Line":0}},{"line":19260,"address":[54291653],"length":1,"stats":{"Line":0}},{"line":19261,"address":[],"length":0,"stats":{"Line":0}},{"line":19263,"address":[54291670],"length":1,"stats":{"Line":0}},{"line":19264,"address":[54291685],"length":1,"stats":{"Line":0}},{"line":19272,"address":[55305629],"length":1,"stats":{"Line":0}},{"line":19273,"address":[54292058],"length":1,"stats":{"Line":0}},{"line":19274,"address":[56857978],"length":1,"stats":{"Line":0}},{"line":19278,"address":[55305859],"length":1,"stats":{"Line":0}},{"line":19279,"address":[],"length":0,"stats":{"Line":0}},{"line":19280,"address":[],"length":0,"stats":{"Line":0}},{"line":19283,"address":[55124315],"length":1,"stats":{"Line":0}},{"line":19285,"address":[55124330],"length":1,"stats":{"Line":0}},{"line":19286,"address":[],"length":0,"stats":{"Line":0}},{"line":19287,"address":[56858157],"length":1,"stats":{"Line":0}},{"line":19292,"address":[55124461],"length":1,"stats":{"Line":0}},{"line":19293,"address":[],"length":0,"stats":{"Line":0}},{"line":19295,"address":[],"length":0,"stats":{"Line":0}},{"line":19296,"address":[55124476],"length":1,"stats":{"Line":0}},{"line":19300,"address":[],"length":0,"stats":{"Line":0}},{"line":19301,"address":[],"length":0,"stats":{"Line":0}},{"line":19306,"address":[56858444],"length":1,"stats":{"Line":0}},{"line":19307,"address":[55306509,55306311],"length":1,"stats":{"Line":0}},{"line":19308,"address":[55306607],"length":1,"stats":{"Line":0}},{"line":19311,"address":[55124784],"length":1,"stats":{"Line":0}},{"line":19314,"address":[55124842],"length":1,"stats":{"Line":0}},{"line":19315,"address":[55124876],"length":1,"stats":{"Line":0}},{"line":19319,"address":[54001736,54003489,54000272],"length":1,"stats":{"Line":0}},{"line":19321,"address":[55019171],"length":1,"stats":{"Line":0}},{"line":19322,"address":[54000435],"length":1,"stats":{"Line":0}},{"line":19325,"address":[56571482,56571386],"length":1,"stats":{"Line":0}},{"line":19328,"address":[55019477],"length":1,"stats":{"Line":0}},{"line":19333,"address":[],"length":0,"stats":{"Line":0}},{"line":19334,"address":[54832834],"length":1,"stats":{"Line":0}},{"line":19335,"address":[54000755,54000885],"length":1,"stats":{"Line":0}},{"line":19336,"address":[54001040,54003421],"length":1,"stats":{"Line":0}},{"line":19337,"address":[54833884],"length":1,"stats":{"Line":0}},{"line":19338,"address":[56572660],"length":1,"stats":{"Line":0}},{"line":19339,"address":[],"length":0,"stats":{"Line":0}},{"line":19340,"address":[],"length":0,"stats":{"Line":0}},{"line":19342,"address":[56572688],"length":1,"stats":{"Line":0}},{"line":19343,"address":[56572988,56572890],"length":1,"stats":{"Line":0}},{"line":19344,"address":[],"length":0,"stats":{"Line":0}},{"line":19345,"address":[56573051],"length":1,"stats":{"Line":0}},{"line":19347,"address":[54834492,54834610],"length":1,"stats":{"Line":0}},{"line":19348,"address":[54002543],"length":1,"stats":{"Line":0}},{"line":19349,"address":[54002669],"length":1,"stats":{"Line":0}},{"line":19350,"address":[56573589],"length":1,"stats":{"Line":0}},{"line":19353,"address":[54002876],"length":1,"stats":{"Line":0}},{"line":19354,"address":[],"length":0,"stats":{"Line":0}},{"line":19355,"address":[54506953,54506928],"length":1,"stats":{"Line":0}},{"line":19356,"address":[54835325],"length":1,"stats":{"Line":0}},{"line":19362,"address":[54833175,54833315],"length":1,"stats":{"Line":0}},{"line":19363,"address":[],"length":0,"stats":{"Line":0}},{"line":19364,"address":[56572163,56572403,56572476],"length":1,"stats":{"Line":0}},{"line":19365,"address":[],"length":0,"stats":{"Line":0}},{"line":19366,"address":[54833407,54833649],"length":1,"stats":{"Line":0}},{"line":19368,"address":[],"length":0,"stats":{"Line":0}},{"line":19372,"address":[55022175,55019589],"length":1,"stats":{"Line":0}},{"line":19373,"address":[55022248],"length":1,"stats":{"Line":0}},{"line":19374,"address":[54836016],"length":1,"stats":{"Line":0}},{"line":19375,"address":[54003919],"length":1,"stats":{"Line":0}},{"line":19376,"address":[54836051],"length":1,"stats":{"Line":0}},{"line":19377,"address":[],"length":0,"stats":{"Line":0}},{"line":19378,"address":[],"length":0,"stats":{"Line":0}},{"line":19380,"address":[],"length":0,"stats":{"Line":0}},{"line":19384,"address":[54003647,54003678],"length":1,"stats":{"Line":0}},{"line":19387,"address":[56574569],"length":1,"stats":{"Line":0}},{"line":19388,"address":[54835935],"length":1,"stats":{"Line":0}},{"line":19390,"address":[56574652],"length":1,"stats":{"Line":0}},{"line":19392,"address":[54003875],"length":1,"stats":{"Line":0}},{"line":19397,"address":[54218788,54218909,54212992],"length":1,"stats":{"Line":0}},{"line":19405,"address":[],"length":0,"stats":{"Line":0}},{"line":19406,"address":[56785928,56780745,56780835,56780965],"length":1,"stats":{"Line":0}},{"line":19407,"address":[],"length":0,"stats":{"Line":0}},{"line":19411,"address":[56781033],"length":1,"stats":{"Line":0}},{"line":19412,"address":[55045920],"length":1,"stats":{"Line":0}},{"line":19413,"address":[54213847,54213922],"length":1,"stats":{"Line":0}},{"line":19414,"address":[],"length":0,"stats":{"Line":0}},{"line":19415,"address":[],"length":0,"stats":{"Line":0}},{"line":19416,"address":[55046274,55046202],"length":1,"stats":{"Line":0}},{"line":19417,"address":[56781490,56781414],"length":1,"stats":{"Line":0}},{"line":19418,"address":[],"length":0,"stats":{"Line":0}},{"line":19420,"address":[54214298],"length":1,"stats":{"Line":0}},{"line":19423,"address":[55229477,55229389],"length":1,"stats":{"Line":0}},{"line":19424,"address":[54214405],"length":1,"stats":{"Line":0}},{"line":19427,"address":[56785667,56781671,56781755,56781862],"length":1,"stats":{"Line":0}},{"line":19428,"address":[],"length":0,"stats":{"Line":0}},{"line":19429,"address":[55046553],"length":1,"stats":{"Line":0}},{"line":19430,"address":[55229572,55229638],"length":1,"stats":{"Line":0}},{"line":19431,"address":[],"length":0,"stats":{"Line":0}},{"line":19432,"address":[54215002,54214875,54214822,54218594],"length":1,"stats":{"Line":0}},{"line":19433,"address":[56782057],"length":1,"stats":{"Line":0}},{"line":19434,"address":[55229986,55229920],"length":1,"stats":{"Line":0}},{"line":19435,"address":[55047175],"length":1,"stats":{"Line":0}},{"line":19436,"address":[54215075],"length":1,"stats":{"Line":0}},{"line":19439,"address":[55047281],"length":1,"stats":{"Line":0}},{"line":19440,"address":[],"length":0,"stats":{"Line":0}},{"line":19441,"address":[55232918,55233143,55233497,55233036],"length":1,"stats":{"Line":0}},{"line":19442,"address":[],"length":0,"stats":{"Line":0}},{"line":19443,"address":[],"length":0,"stats":{"Line":0}},{"line":19444,"address":[53128768,53128752],"length":1,"stats":{"Line":0}},{"line":19445,"address":[],"length":0,"stats":{"Line":0}},{"line":19446,"address":[55233222],"length":1,"stats":{"Line":0}},{"line":19447,"address":[55050507,55050417],"length":1,"stats":{"Line":0}},{"line":19448,"address":[55050629],"length":1,"stats":{"Line":0}},{"line":19452,"address":[54215489],"length":1,"stats":{"Line":0}},{"line":19453,"address":[55047766,55049769],"length":1,"stats":{"Line":0}},{"line":19459,"address":[],"length":0,"stats":{"Line":0}},{"line":19460,"address":[],"length":0,"stats":{"Line":0}},{"line":19467,"address":[54215951,54217655,54216154,54216027],"length":1,"stats":{"Line":0}},{"line":19468,"address":[],"length":0,"stats":{"Line":0}},{"line":19469,"address":[54215961],"length":1,"stats":{"Line":0}},{"line":19470,"address":[54027696,54027712],"length":1,"stats":{"Line":0}},{"line":19471,"address":[54216239,54216307,54216434,54217631],"length":1,"stats":{"Line":0}},{"line":19472,"address":[56783398],"length":1,"stats":{"Line":0}},{"line":19473,"address":[56114912,56114896],"length":1,"stats":{"Line":0}},{"line":19477,"address":[],"length":0,"stats":{"Line":0}},{"line":19478,"address":[],"length":0,"stats":{"Line":0}},{"line":19479,"address":[54216591,54216673],"length":1,"stats":{"Line":0}},{"line":19480,"address":[],"length":0,"stats":{"Line":0}},{"line":19481,"address":[54217047,54216965],"length":1,"stats":{"Line":0}},{"line":19482,"address":[56784358,56784280],"length":1,"stats":{"Line":0}},{"line":19483,"address":[55232381,55232303],"length":1,"stats":{"Line":0}},{"line":19484,"address":[55049650],"length":1,"stats":{"Line":0}},{"line":19486,"address":[54217546],"length":1,"stats":{"Line":0}},{"line":19490,"address":[56870928,56875774,56874753],"length":1,"stats":{"Line":0}},{"line":19497,"address":[54305255],"length":1,"stats":{"Line":0}},{"line":19498,"address":[54305613,54305526,54305697,54305294,54305442],"length":1,"stats":{"Line":0}},{"line":19499,"address":[],"length":0,"stats":{"Line":0}},{"line":19500,"address":[54305311],"length":1,"stats":{"Line":0}},{"line":19501,"address":[56871180,56871250],"length":1,"stats":{"Line":0}},{"line":19504,"address":[],"length":0,"stats":{"Line":0}},{"line":19507,"address":[56871541],"length":1,"stats":{"Line":0}},{"line":19510,"address":[55138099,55138015,55137961],"length":1,"stats":{"Line":0}},{"line":19511,"address":[],"length":0,"stats":{"Line":0}},{"line":19512,"address":[54305872],"length":1,"stats":{"Line":0}},{"line":19513,"address":[53135392,53135416],"length":1,"stats":{"Line":0}},{"line":19514,"address":[],"length":0,"stats":{"Line":0}},{"line":19515,"address":[],"length":0,"stats":{"Line":0}},{"line":19516,"address":[55319641],"length":1,"stats":{"Line":0}},{"line":19518,"address":[56871898],"length":1,"stats":{"Line":0}},{"line":19519,"address":[],"length":0,"stats":{"Line":0}},{"line":19521,"address":[55319737],"length":1,"stats":{"Line":0}},{"line":19522,"address":[56871941],"length":1,"stats":{"Line":0}},{"line":19526,"address":[56872021],"length":1,"stats":{"Line":0}},{"line":19527,"address":[55138395],"length":1,"stats":{"Line":0}},{"line":19531,"address":[56872069],"length":1,"stats":{"Line":0}},{"line":19533,"address":[55138485],"length":1,"stats":{"Line":0}},{"line":19535,"address":[55138503],"length":1,"stats":{"Line":0}},{"line":19536,"address":[],"length":0,"stats":{"Line":0}},{"line":19537,"address":[54306427],"length":1,"stats":{"Line":0}},{"line":19542,"address":[],"length":0,"stats":{"Line":0}},{"line":19543,"address":[],"length":0,"stats":{"Line":0}},{"line":19544,"address":[54306538],"length":1,"stats":{"Line":0}},{"line":19546,"address":[55138725],"length":1,"stats":{"Line":0}},{"line":19547,"address":[55138771],"length":1,"stats":{"Line":0}},{"line":19550,"address":[],"length":0,"stats":{"Line":0}},{"line":19553,"address":[55320447],"length":1,"stats":{"Line":0}},{"line":19554,"address":[55320606,55320680],"length":1,"stats":{"Line":0}},{"line":19556,"address":[56872932,56873029],"length":1,"stats":{"Line":0}},{"line":19557,"address":[55139752,55139665],"length":1,"stats":{"Line":0}},{"line":19558,"address":[55323341,55323563,55321297],"length":1,"stats":{"Line":0}},{"line":19559,"address":[55323502],"length":1,"stats":{"Line":0}},{"line":19563,"address":[],"length":0,"stats":{"Line":0}},{"line":19564,"address":[55321366],"length":1,"stats":{"Line":0}},{"line":19565,"address":[],"length":0,"stats":{"Line":0}},{"line":19567,"address":[55140181,55140290,55140358],"length":1,"stats":{"Line":0}},{"line":19568,"address":[55321730,55321789],"length":1,"stats":{"Line":0}},{"line":19569,"address":[56874220,56874155,56874364],"length":1,"stats":{"Line":0}},{"line":19570,"address":[56874388],"length":1,"stats":{"Line":0}},{"line":19572,"address":[54309041,54308659],"length":1,"stats":{"Line":0}},{"line":19576,"address":[56873795,56874775],"length":1,"stats":{"Line":0}},{"line":19577,"address":[55322695,55323264],"length":1,"stats":{"Line":0}},{"line":19584,"address":[55141917,55141831,55141455,55139991,55141582,55141704],"length":1,"stats":{"Line":0}},{"line":19585,"address":[],"length":0,"stats":{"Line":0}},{"line":19586,"address":[54307893,54309280],"length":1,"stats":{"Line":0}},{"line":19587,"address":[56120832,56120848],"length":1,"stats":{"Line":0}},{"line":19590,"address":[53135582,53135568],"length":1,"stats":{"Line":0}},{"line":19591,"address":[],"length":0,"stats":{"Line":0}},{"line":19594,"address":[55139352],"length":1,"stats":{"Line":0}},{"line":19598,"address":[56787247,56785952,56796218],"length":1,"stats":{"Line":0}},{"line":19605,"address":[55233918],"length":1,"stats":{"Line":0}},{"line":19608,"address":[],"length":0,"stats":{"Line":0}},{"line":19611,"address":[55235037,55234237,55234177],"length":1,"stats":{"Line":0}},{"line":19612,"address":[54219549,54219440],"length":1,"stats":{"Line":0}},{"line":19613,"address":[54219708,54220174,54219791],"length":1,"stats":{"Line":0}},{"line":19614,"address":[55052115,55051965],"length":1,"stats":{"Line":0}},{"line":19619,"address":[],"length":0,"stats":{"Line":0}},{"line":19620,"address":[],"length":0,"stats":{"Line":0}},{"line":19621,"address":[55235244],"length":1,"stats":{"Line":0}},{"line":19622,"address":[56787621,56787534],"length":1,"stats":{"Line":0}},{"line":19623,"address":[55053356,55052890,55052973],"length":1,"stats":{"Line":0}},{"line":19624,"address":[56788067,56787921],"length":1,"stats":{"Line":0}},{"line":19632,"address":[54221362,54220286,54221328],"length":1,"stats":{"Line":0}},{"line":19633,"address":[55055529,55053448,55053501],"length":1,"stats":{"Line":0}},{"line":19634,"address":[56788418],"length":1,"stats":{"Line":0}},{"line":19635,"address":[55053705,55053570,55053637],"length":1,"stats":{"Line":0}},{"line":19636,"address":[55053953,55053888],"length":1,"stats":{"Line":0}},{"line":19637,"address":[55054157,55054087,55055000],"length":1,"stats":{"Line":0}},{"line":19638,"address":[],"length":0,"stats":{"Line":0}},{"line":19639,"address":[55054376,55054453],"length":1,"stats":{"Line":0}},{"line":19641,"address":[55237133],"length":1,"stats":{"Line":0}},{"line":19642,"address":[54222393,54222912],"length":1,"stats":{"Line":0}},{"line":19643,"address":[],"length":0,"stats":{"Line":0}},{"line":19644,"address":[56789314,56789813,56789479],"length":1,"stats":{"Line":0}},{"line":19646,"address":[54222570,54222704],"length":1,"stats":{"Line":0}},{"line":19650,"address":[56790041,56788971],"length":1,"stats":{"Line":0}},{"line":19651,"address":[],"length":0,"stats":{"Line":0}},{"line":19654,"address":[55237894,55238166],"length":1,"stats":{"Line":0}},{"line":19655,"address":[54223174,54223233],"length":1,"stats":{"Line":0}},{"line":19660,"address":[56788393,56792104,56790374],"length":1,"stats":{"Line":0}},{"line":19661,"address":[54223491],"length":1,"stats":{"Line":0}},{"line":19662,"address":[55055629,55055764,55055696,55061540],"length":1,"stats":{"Line":0}},{"line":19663,"address":[55238537,55238598],"length":1,"stats":{"Line":0}},{"line":19664,"address":[54224027,54224110],"length":1,"stats":{"Line":0}},{"line":19665,"address":[55238902,55238954],"length":1,"stats":{"Line":0}},{"line":19666,"address":[56791132],"length":1,"stats":{"Line":0}},{"line":19667,"address":[56791170,56791627],"length":1,"stats":{"Line":0}},{"line":19668,"address":[],"length":0,"stats":{"Line":0}},{"line":19669,"address":[56791145,56791622,56791307],"length":1,"stats":{"Line":0}},{"line":19670,"address":[55239283,55239156],"length":1,"stats":{"Line":0}},{"line":19674,"address":[56792091,56791819],"length":1,"stats":{"Line":0}},{"line":19675,"address":[55057099,55057158],"length":1,"stats":{"Line":0}},{"line":19680,"address":[55055566,55057373],"length":1,"stats":{"Line":0}},{"line":19682,"address":[54228600,54229386,54225366],"length":1,"stats":{"Line":0}},{"line":19685,"address":[54228798],"length":1,"stats":{"Line":0}},{"line":19686,"address":[54228908,54228833],"length":1,"stats":{"Line":0}},{"line":19687,"address":[55243678,55243900,55243563],"length":1,"stats":{"Line":0}},{"line":19688,"address":[55243839],"length":1,"stats":{"Line":0}},{"line":19692,"address":[55243578],"length":1,"stats":{"Line":0}},{"line":19695,"address":[54520432],"length":1,"stats":{"Line":0}},{"line":19696,"address":[54520456],"length":1,"stats":{"Line":0}},{"line":19700,"address":[56792512,56792595],"length":1,"stats":{"Line":0}},{"line":19701,"address":[55058104,55058191],"length":1,"stats":{"Line":0}},{"line":19702,"address":[56793036,56795056,56795278],"length":1,"stats":{"Line":0}},{"line":19703,"address":[54228486],"length":1,"stats":{"Line":0}},{"line":19708,"address":[56793054],"length":1,"stats":{"Line":0}},{"line":19709,"address":[],"length":0,"stats":{"Line":0}},{"line":19710,"address":[55241037],"length":1,"stats":{"Line":0}},{"line":19713,"address":[54226508,54226685,54226617],"length":1,"stats":{"Line":0}},{"line":19714,"address":[56793469,56793529],"length":1,"stats":{"Line":0}},{"line":19715,"address":[54226907,54226988,54227136],"length":1,"stats":{"Line":0}},{"line":19716,"address":[56793955],"length":1,"stats":{"Line":0}},{"line":19719,"address":[55241729,55242097],"length":1,"stats":{"Line":0}},{"line":19724,"address":[56793358,56794354],"length":1,"stats":{"Line":0}},{"line":19725,"address":[55060344,55059813],"length":1,"stats":{"Line":0}},{"line":19731,"address":[55242790,55242540,55242697,55240981,55242433],"length":1,"stats":{"Line":0}},{"line":19732,"address":[],"length":0,"stats":{"Line":0}},{"line":19733,"address":[55059871,55058444],"length":1,"stats":{"Line":0}},{"line":19734,"address":[55059907,55059997],"length":1,"stats":{"Line":0}},{"line":19737,"address":[54520421,54520416],"length":1,"stats":{"Line":0}},{"line":19739,"address":[55060246],"length":1,"stats":{"Line":0}},{"line":19743,"address":[55031680,55032911,55032917],"length":1,"stats":{"Line":0}},{"line":19749,"address":[],"length":0,"stats":{"Line":0}},{"line":19752,"address":[55215429],"length":1,"stats":{"Line":0}},{"line":19753,"address":[],"length":0,"stats":{"Line":0}},{"line":19754,"address":[56767754,56767670],"length":1,"stats":{"Line":0}},{"line":19755,"address":[54200027],"length":1,"stats":{"Line":0}},{"line":19758,"address":[56767851,56768517,56767925,56768032],"length":1,"stats":{"Line":0}},{"line":19759,"address":[],"length":0,"stats":{"Line":0}},{"line":19760,"address":[56767858],"length":1,"stats":{"Line":0}},{"line":19761,"address":[53127488],"length":1,"stats":{"Line":0}},{"line":19762,"address":[54518768],"length":1,"stats":{"Line":0}},{"line":19766,"address":[55216135,55216280,55216028,55215942,55216340],"length":1,"stats":{"Line":0}},{"line":19767,"address":[],"length":0,"stats":{"Line":0}},{"line":19768,"address":[55032479],"length":1,"stats":{"Line":0}},{"line":19769,"address":[54026096,54026080],"length":1,"stats":{"Line":0}},{"line":19772,"address":[54200672],"length":1,"stats":{"Line":0}},{"line":19774,"address":[56768456],"length":1,"stats":{"Line":0}},{"line":19778,"address":[56512976],"length":1,"stats":{"Line":0}},{"line":19784,"address":[54960936],"length":1,"stats":{"Line":0}},{"line":19785,"address":[56513190],"length":1,"stats":{"Line":0}},{"line":19788,"address":[],"length":0,"stats":{"Line":0}},{"line":19789,"address":[],"length":0,"stats":{"Line":0}},{"line":19791,"address":[54502336,54502350],"length":1,"stats":{"Line":0}},{"line":19794,"address":[54961817,54961573,54961653,54961399,54961737],"length":1,"stats":{"Line":0}},{"line":19795,"address":[],"length":0,"stats":{"Line":0}},{"line":19797,"address":[],"length":0,"stats":{"Line":0}},{"line":19798,"address":[54773913],"length":1,"stats":{"Line":0}},{"line":19801,"address":[53109808,53109792],"length":1,"stats":{"Line":0}},{"line":19804,"address":[54502432,54502446],"length":1,"stats":{"Line":0}},{"line":19806,"address":[],"length":0,"stats":{"Line":0}},{"line":19810,"address":[54895936],"length":1,"stats":{"Line":0}},{"line":19811,"address":[56633446,56633552,56633484],"length":1,"stats":{"Line":0}},{"line":19812,"address":[],"length":0,"stats":{"Line":0}},{"line":19814,"address":[54016400,54016414],"length":1,"stats":{"Line":0}},{"line":19816,"address":[54896275,54896443,54896362,54896194,54896126],"length":1,"stats":{"Line":0}},{"line":19817,"address":[],"length":0,"stats":{"Line":0}},{"line":19818,"address":[56633602],"length":1,"stats":{"Line":0}},{"line":19819,"address":[54064060,54064132],"length":1,"stats":{"Line":0}},{"line":19822,"address":[55081715,55081653],"length":1,"stats":{"Line":0}},{"line":19824,"address":[56633965],"length":1,"stats":{"Line":0}},{"line":19828,"address":[],"length":0,"stats":{"Line":0}},{"line":19829,"address":[54999373,54999334,54999442],"length":1,"stats":{"Line":0}},{"line":19830,"address":[],"length":0,"stats":{"Line":0}},{"line":19832,"address":[54167250,54167302],"length":1,"stats":{"Line":0}},{"line":19834,"address":[],"length":0,"stats":{"Line":0}},{"line":19835,"address":[],"length":0,"stats":{"Line":0}},{"line":19836,"address":[],"length":0,"stats":{"Line":0}},{"line":19837,"address":[],"length":0,"stats":{"Line":0}},{"line":19838,"address":[53124320],"length":1,"stats":{"Line":0}},{"line":19842,"address":[54167596],"length":1,"stats":{"Line":0}},{"line":19843,"address":[56110782],"length":1,"stats":{"Line":0}},{"line":19846,"address":[56736045],"length":1,"stats":{"Line":0}},{"line":19850,"address":[],"length":0,"stats":{"Line":0}},{"line":19851,"address":[56766828,56766790,56766896],"length":1,"stats":{"Line":0}},{"line":19852,"address":[],"length":0,"stats":{"Line":0}},{"line":19854,"address":[54025822,54025808],"length":1,"stats":{"Line":0}},{"line":19856,"address":[54199299,54199150,54199467,54199218,54199386],"length":1,"stats":{"Line":0}},{"line":19857,"address":[],"length":0,"stats":{"Line":0}},{"line":19858,"address":[54199157],"length":1,"stats":{"Line":0}},{"line":19859,"address":[54025904],"length":1,"stats":{"Line":0}},{"line":19860,"address":[56113408],"length":1,"stats":{"Line":0}},{"line":19864,"address":[],"length":0,"stats":{"Line":0}},{"line":19865,"address":[53126958],"length":1,"stats":{"Line":0}},{"line":19868,"address":[55031639],"length":1,"stats":{"Line":0}},{"line":19876,"address":[54510624],"length":1,"stats":{"Line":0}},{"line":19880,"address":[],"length":0,"stats":{"Line":0}},{"line":19881,"address":[54701042],"length":1,"stats":{"Line":0}},{"line":19882,"address":[53678746],"length":1,"stats":{"Line":0}},{"line":19883,"address":[],"length":0,"stats":{"Line":0}},{"line":19884,"address":[54701103],"length":1,"stats":{"Line":0}},{"line":19886,"address":[56253282],"length":1,"stats":{"Line":0}},{"line":19887,"address":[],"length":0,"stats":{"Line":0}},{"line":19888,"address":[54510949],"length":1,"stats":{"Line":0}},{"line":19891,"address":[54701281],"length":1,"stats":{"Line":0}},{"line":19892,"address":[],"length":0,"stats":{"Line":0}},{"line":19893,"address":[54701291],"length":1,"stats":{"Line":0}},{"line":19895,"address":[53679021],"length":1,"stats":{"Line":0}},{"line":19899,"address":[56228496],"length":1,"stats":{"Line":0}},{"line":19903,"address":[56228542],"length":1,"stats":{"Line":0}},{"line":19906,"address":[54676562],"length":1,"stats":{"Line":0}},{"line":19907,"address":[],"length":0,"stats":{"Line":0}},{"line":19908,"address":[],"length":0,"stats":{"Line":0}},{"line":19909,"address":[],"length":0,"stats":{"Line":0}},{"line":19917,"address":[53654147],"length":1,"stats":{"Line":0}},{"line":19918,"address":[],"length":0,"stats":{"Line":0}},{"line":19919,"address":[53654162],"length":1,"stats":{"Line":0}},{"line":19921,"address":[],"length":0,"stats":{"Line":0}},{"line":19924,"address":[54486412],"length":1,"stats":{"Line":0}},{"line":19926,"address":[54677004],"length":1,"stats":{"Line":0}},{"line":19927,"address":[],"length":0,"stats":{"Line":0}},{"line":19930,"address":[],"length":0,"stats":{"Line":0}},{"line":19931,"address":[],"length":0,"stats":{"Line":0}},{"line":19934,"address":[56229354],"length":1,"stats":{"Line":0}},{"line":19938,"address":[55076448],"length":1,"stats":{"Line":0}},{"line":19943,"address":[54891175],"length":1,"stats":{"Line":0}},{"line":19944,"address":[],"length":0,"stats":{"Line":0}},{"line":19946,"address":[56629014],"length":1,"stats":{"Line":0}},{"line":19947,"address":[54891558],"length":1,"stats":{"Line":0}},{"line":19948,"address":[],"length":0,"stats":{"Line":0}},{"line":19949,"address":[],"length":0,"stats":{"Line":0}},{"line":19952,"address":[54891637],"length":1,"stats":{"Line":0}},{"line":19953,"address":[55077006],"length":1,"stats":{"Line":0}},{"line":19958,"address":[56629292],"length":1,"stats":{"Line":0}},{"line":19959,"address":[],"length":0,"stats":{"Line":0}},{"line":19960,"address":[],"length":0,"stats":{"Line":0}},{"line":19961,"address":[54891834],"length":1,"stats":{"Line":0}},{"line":19968,"address":[56629550],"length":1,"stats":{"Line":0}},{"line":19969,"address":[],"length":0,"stats":{"Line":0}},{"line":19970,"address":[56629565],"length":1,"stats":{"Line":0}},{"line":19972,"address":[],"length":0,"stats":{"Line":0}},{"line":19974,"address":[],"length":0,"stats":{"Line":0}},{"line":19976,"address":[],"length":0,"stats":{"Line":0}},{"line":19977,"address":[55077615],"length":1,"stats":{"Line":0}},{"line":19980,"address":[56629901],"length":1,"stats":{"Line":0}},{"line":19981,"address":[54892413],"length":1,"stats":{"Line":0}},{"line":19984,"address":[],"length":0,"stats":{"Line":0}},{"line":19988,"address":[53932944],"length":1,"stats":{"Line":0}},{"line":19992,"address":[53932999],"length":1,"stats":{"Line":0}},{"line":19993,"address":[54765263],"length":1,"stats":{"Line":0}},{"line":19994,"address":[56505046],"length":1,"stats":{"Line":0}},{"line":19995,"address":[],"length":0,"stats":{"Line":0}},{"line":19996,"address":[54765327],"length":1,"stats":{"Line":0}},{"line":20000,"address":[53933290],"length":1,"stats":{"Line":0}},{"line":20001,"address":[],"length":0,"stats":{"Line":0}},{"line":20002,"address":[53933305],"length":1,"stats":{"Line":0}},{"line":20010,"address":[54953233],"length":1,"stats":{"Line":0}},{"line":20011,"address":[54765676],"length":1,"stats":{"Line":0}},{"line":20012,"address":[],"length":0,"stats":{"Line":0}},{"line":20013,"address":[54953292],"length":1,"stats":{"Line":0}},{"line":20015,"address":[54953365],"length":1,"stats":{"Line":0}},{"line":20016,"address":[],"length":0,"stats":{"Line":0}},{"line":20017,"address":[],"length":0,"stats":{"Line":0}},{"line":20019,"address":[54765832],"length":1,"stats":{"Line":0}},{"line":20020,"address":[],"length":0,"stats":{"Line":0}},{"line":20021,"address":[54953452],"length":1,"stats":{"Line":0}},{"line":20029,"address":[54953659],"length":1,"stats":{"Line":0}},{"line":20030,"address":[54766120],"length":1,"stats":{"Line":0}},{"line":20031,"address":[],"length":0,"stats":{"Line":0}},{"line":20032,"address":[54766127],"length":1,"stats":{"Line":0}},{"line":20034,"address":[54953799],"length":1,"stats":{"Line":0}},{"line":20035,"address":[53934137],"length":1,"stats":{"Line":0}},{"line":20037,"address":[],"length":0,"stats":{"Line":0}},{"line":20038,"address":[53934196],"length":1,"stats":{"Line":0}},{"line":20041,"address":[56506147],"length":1,"stats":{"Line":0}},{"line":20042,"address":[],"length":0,"stats":{"Line":0}},{"line":20043,"address":[56506154],"length":1,"stats":{"Line":0}},{"line":20045,"address":[54766518],"length":1,"stats":{"Line":0}},{"line":20048,"address":[56506272],"length":1,"stats":{"Line":0}},{"line":20049,"address":[54954204],"length":1,"stats":{"Line":0}},{"line":20050,"address":[54766665],"length":1,"stats":{"Line":0}},{"line":20051,"address":[54954307],"length":1,"stats":{"Line":0}},{"line":20054,"address":[],"length":0,"stats":{"Line":0}},{"line":20055,"address":[53934692],"length":1,"stats":{"Line":0}},{"line":20056,"address":[],"length":0,"stats":{"Line":0}},{"line":20058,"address":[54954495],"length":1,"stats":{"Line":0}},{"line":20061,"address":[],"length":0,"stats":{"Line":0}},{"line":20062,"address":[56506693],"length":1,"stats":{"Line":0}},{"line":20063,"address":[],"length":0,"stats":{"Line":0}},{"line":20064,"address":[54954591],"length":1,"stats":{"Line":0}},{"line":20067,"address":[54954688],"length":1,"stats":{"Line":0}},{"line":20068,"address":[],"length":0,"stats":{"Line":0}},{"line":20069,"address":[53934996],"length":1,"stats":{"Line":0}},{"line":20071,"address":[54954780],"length":1,"stats":{"Line":0}},{"line":20072,"address":[56506899],"length":1,"stats":{"Line":0}},{"line":20076,"address":[56506946],"length":1,"stats":{"Line":0}},{"line":20080,"address":[54767271],"length":1,"stats":{"Line":0}},{"line":20081,"address":[54954873],"length":1,"stats":{"Line":0}},{"line":20084,"address":[54767429],"length":1,"stats":{"Line":0}},{"line":20085,"address":[],"length":0,"stats":{"Line":0}},{"line":20086,"address":[53935335],"length":1,"stats":{"Line":0}},{"line":20090,"address":[54767566],"length":1,"stats":{"Line":0}},{"line":20091,"address":[53935493],"length":1,"stats":{"Line":0}},{"line":20092,"address":[],"length":0,"stats":{"Line":0}},{"line":20093,"address":[54767623],"length":1,"stats":{"Line":0}},{"line":20099,"address":[56507547],"length":1,"stats":{"Line":0}},{"line":20100,"address":[],"length":0,"stats":{"Line":0}},{"line":20102,"address":[54767955],"length":1,"stats":{"Line":0}},{"line":20103,"address":[53935861],"length":1,"stats":{"Line":0}},{"line":20106,"address":[],"length":0,"stats":{"Line":0}},{"line":20107,"address":[53936019],"length":1,"stats":{"Line":0}},{"line":20111,"address":[54955796],"length":1,"stats":{"Line":0}},{"line":20112,"address":[],"length":0,"stats":{"Line":0}},{"line":20113,"address":[53936123],"length":1,"stats":{"Line":0}},{"line":20115,"address":[53936205],"length":1,"stats":{"Line":0}},{"line":20116,"address":[53936252],"length":1,"stats":{"Line":0}},{"line":20117,"address":[53936292],"length":1,"stats":{"Line":0}},{"line":20118,"address":[],"length":0,"stats":{"Line":0}},{"line":20119,"address":[],"length":0,"stats":{"Line":0}},{"line":20121,"address":[56508194],"length":1,"stats":{"Line":0}},{"line":20122,"address":[],"length":0,"stats":{"Line":0}},{"line":20123,"address":[54956089],"length":1,"stats":{"Line":0}},{"line":20125,"address":[],"length":0,"stats":{"Line":0}},{"line":20128,"address":[53936539],"length":1,"stats":{"Line":0}},{"line":20129,"address":[],"length":0,"stats":{"Line":0}},{"line":20130,"address":[],"length":0,"stats":{"Line":0}},{"line":20132,"address":[56508408],"length":1,"stats":{"Line":0}},{"line":20133,"address":[],"length":0,"stats":{"Line":0}},{"line":20134,"address":[54956303],"length":1,"stats":{"Line":0}},{"line":20137,"address":[54768815],"length":1,"stats":{"Line":0}},{"line":20138,"address":[54956394],"length":1,"stats":{"Line":0}},{"line":20141,"address":[],"length":0,"stats":{"Line":0}},{"line":20142,"address":[],"length":0,"stats":{"Line":0}},{"line":20144,"address":[],"length":0,"stats":{"Line":0}},{"line":20145,"address":[],"length":0,"stats":{"Line":0}},{"line":20149,"address":[54769122],"length":1,"stats":{"Line":0}},{"line":20152,"address":[56508839],"length":1,"stats":{"Line":0}},{"line":20153,"address":[],"length":0,"stats":{"Line":0}},{"line":20154,"address":[53937078],"length":1,"stats":{"Line":0}},{"line":20156,"address":[56508969],"length":1,"stats":{"Line":0}},{"line":20157,"address":[53937250],"length":1,"stats":{"Line":0}},{"line":20160,"address":[56509082],"length":1,"stats":{"Line":0}},{"line":20161,"address":[56509119],"length":1,"stats":{"Line":0}},{"line":20165,"address":[55036112],"length":1,"stats":{"Line":0}},{"line":20170,"address":[56588311],"length":1,"stats":{"Line":0}},{"line":20171,"address":[54017922],"length":1,"stats":{"Line":0}},{"line":20173,"address":[55036518],"length":1,"stats":{"Line":0}},{"line":20174,"address":[54850246],"length":1,"stats":{"Line":0}},{"line":20175,"address":[],"length":0,"stats":{"Line":0}},{"line":20176,"address":[],"length":0,"stats":{"Line":0}},{"line":20180,"address":[54018213],"length":1,"stats":{"Line":0}},{"line":20181,"address":[],"length":0,"stats":{"Line":0}},{"line":20182,"address":[],"length":0,"stats":{"Line":0}},{"line":20190,"address":[55036874],"length":1,"stats":{"Line":0}},{"line":20191,"address":[],"length":0,"stats":{"Line":0}},{"line":20192,"address":[54850554],"length":1,"stats":{"Line":0}},{"line":20194,"address":[55036951],"length":1,"stats":{"Line":0}},{"line":20195,"address":[],"length":0,"stats":{"Line":0}},{"line":20197,"address":[],"length":0,"stats":{"Line":0}},{"line":20198,"address":[55036966],"length":1,"stats":{"Line":0}},{"line":20204,"address":[54018629],"length":1,"stats":{"Line":0}},{"line":20205,"address":[],"length":0,"stats":{"Line":0}},{"line":20206,"address":[56589191],"length":1,"stats":{"Line":0}},{"line":20214,"address":[54018854],"length":1,"stats":{"Line":0}},{"line":20215,"address":[],"length":0,"stats":{"Line":0}},{"line":20219,"address":[54851064],"length":1,"stats":{"Line":0}},{"line":20220,"address":[55037426],"length":1,"stats":{"Line":0}},{"line":20221,"address":[54851161],"length":1,"stats":{"Line":0}},{"line":20222,"address":[54851211],"length":1,"stats":{"Line":0}},{"line":20224,"address":[],"length":0,"stats":{"Line":0}},{"line":20225,"address":[],"length":0,"stats":{"Line":0}},{"line":20226,"address":[54851315],"length":1,"stats":{"Line":0}},{"line":20228,"address":[56589829],"length":1,"stats":{"Line":0}},{"line":20230,"address":[55037774],"length":1,"stats":{"Line":0}},{"line":20231,"address":[],"length":0,"stats":{"Line":0}},{"line":20232,"address":[],"length":0,"stats":{"Line":0}},{"line":20233,"address":[54851498],"length":1,"stats":{"Line":0}},{"line":20236,"address":[],"length":0,"stats":{"Line":0}},{"line":20237,"address":[],"length":0,"stats":{"Line":0}},{"line":20238,"address":[55037917],"length":1,"stats":{"Line":0}},{"line":20240,"address":[56590114],"length":1,"stats":{"Line":0}},{"line":20241,"address":[54019586],"length":1,"stats":{"Line":0}},{"line":20244,"address":[54019634],"length":1,"stats":{"Line":0}},{"line":20245,"address":[54851775],"length":1,"stats":{"Line":0}},{"line":20246,"address":[55038103],"length":1,"stats":{"Line":0}},{"line":20248,"address":[54851992],"length":1,"stats":{"Line":0}},{"line":20249,"address":[],"length":0,"stats":{"Line":0}},{"line":20250,"address":[54019898],"length":1,"stats":{"Line":0}},{"line":20252,"address":[54852124],"length":1,"stats":{"Line":0}},{"line":20253,"address":[54020070],"length":1,"stats":{"Line":0}},{"line":20255,"address":[54852240],"length":1,"stats":{"Line":0}},{"line":20256,"address":[55038581],"length":1,"stats":{"Line":0}},{"line":20260,"address":[54934576],"length":1,"stats":{"Line":0}},{"line":20265,"address":[55119575],"length":1,"stats":{"Line":0}},{"line":20266,"address":[54102722],"length":1,"stats":{"Line":0}},{"line":20268,"address":[54934986],"length":1,"stats":{"Line":0}},{"line":20269,"address":[54935051],"length":1,"stats":{"Line":0}},{"line":20270,"address":[],"length":0,"stats":{"Line":0}},{"line":20271,"address":[],"length":0,"stats":{"Line":0}},{"line":20273,"address":[56672203],"length":1,"stats":{"Line":0}},{"line":20274,"address":[],"length":0,"stats":{"Line":0}},{"line":20275,"address":[54935144],"length":1,"stats":{"Line":0}},{"line":20279,"address":[56672285],"length":1,"stats":{"Line":0}},{"line":20280,"address":[],"length":0,"stats":{"Line":0}},{"line":20282,"address":[54935236],"length":1,"stats":{"Line":0}},{"line":20283,"address":[55120152],"length":1,"stats":{"Line":0}},{"line":20293,"address":[54103379],"length":1,"stats":{"Line":0}},{"line":20294,"address":[],"length":0,"stats":{"Line":0}},{"line":20295,"address":[],"length":0,"stats":{"Line":0}},{"line":20296,"address":[55120429],"length":1,"stats":{"Line":0}},{"line":20299,"address":[54103492],"length":1,"stats":{"Line":0}},{"line":20300,"address":[56672707],"length":1,"stats":{"Line":0}},{"line":20301,"address":[54103586],"length":1,"stats":{"Line":0}},{"line":20302,"address":[56672807],"length":1,"stats":{"Line":0}},{"line":20304,"address":[56672867],"length":1,"stats":{"Line":0}},{"line":20305,"address":[],"length":0,"stats":{"Line":0}},{"line":20309,"address":[56672921],"length":1,"stats":{"Line":0}},{"line":20310,"address":[56672947],"length":1,"stats":{"Line":0}},{"line":20311,"address":[],"length":0,"stats":{"Line":0}},{"line":20312,"address":[],"length":0,"stats":{"Line":0}},{"line":20314,"address":[55120879],"length":1,"stats":{"Line":0}},{"line":20315,"address":[],"length":0,"stats":{"Line":0}},{"line":20316,"address":[55120889],"length":1,"stats":{"Line":0}},{"line":20318,"address":[54103960],"length":1,"stats":{"Line":0}},{"line":20319,"address":[],"length":0,"stats":{"Line":0}},{"line":20320,"address":[55120973],"length":1,"stats":{"Line":0}},{"line":20322,"address":[54104039],"length":1,"stats":{"Line":0}},{"line":20323,"address":[56673210],"length":1,"stats":{"Line":0}},{"line":20325,"address":[54936201],"length":1,"stats":{"Line":0}},{"line":20328,"address":[],"length":0,"stats":{"Line":0}},{"line":20329,"address":[55121174],"length":1,"stats":{"Line":0}},{"line":20330,"address":[56673383],"length":1,"stats":{"Line":0}},{"line":20331,"address":[54104227],"length":1,"stats":{"Line":0}},{"line":20333,"address":[54104270],"length":1,"stats":{"Line":0}},{"line":20336,"address":[55121336],"length":1,"stats":{"Line":0}},{"line":20337,"address":[55121357],"length":1,"stats":{"Line":0}},{"line":20338,"address":[],"length":0,"stats":{"Line":0}},{"line":20339,"address":[54104365],"length":1,"stats":{"Line":0}},{"line":20341,"address":[54104455],"length":1,"stats":{"Line":0}},{"line":20343,"address":[56673816],"length":1,"stats":{"Line":0}},{"line":20347,"address":[54064976],"length":1,"stats":{"Line":0}},{"line":20355,"address":[54065111],"length":1,"stats":{"Line":0}},{"line":20356,"address":[56634848],"length":1,"stats":{"Line":0}},{"line":20357,"address":[54065453],"length":1,"stats":{"Line":0}},{"line":20359,"address":[56635167],"length":1,"stats":{"Line":0}},{"line":20360,"address":[56635235],"length":1,"stats":{"Line":0}},{"line":20361,"address":[],"length":0,"stats":{"Line":0}},{"line":20362,"address":[54065680],"length":1,"stats":{"Line":0}},{"line":20364,"address":[55083168],"length":1,"stats":{"Line":0}},{"line":20365,"address":[],"length":0,"stats":{"Line":0}},{"line":20366,"address":[54065775],"length":1,"stats":{"Line":0}},{"line":20368,"address":[55083258],"length":1,"stats":{"Line":0}},{"line":20369,"address":[],"length":0,"stats":{"Line":0}},{"line":20370,"address":[54897979],"length":1,"stats":{"Line":0}},{"line":20374,"address":[],"length":0,"stats":{"Line":0}},{"line":20375,"address":[],"length":0,"stats":{"Line":0}},{"line":20376,"address":[55083361],"length":1,"stats":{"Line":0}},{"line":20382,"address":[54066180],"length":1,"stats":{"Line":0}},{"line":20383,"address":[],"length":0,"stats":{"Line":0}},{"line":20384,"address":[54898307],"length":1,"stats":{"Line":0}},{"line":20390,"address":[54898525],"length":1,"stats":{"Line":0}},{"line":20391,"address":[],"length":0,"stats":{"Line":0}},{"line":20392,"address":[],"length":0,"stats":{"Line":0}},{"line":20400,"address":[56636182],"length":1,"stats":{"Line":0}},{"line":20401,"address":[],"length":0,"stats":{"Line":0}},{"line":20403,"address":[],"length":0,"stats":{"Line":0}},{"line":20404,"address":[54898762],"length":1,"stats":{"Line":0}},{"line":20408,"address":[],"length":0,"stats":{"Line":0}},{"line":20409,"address":[],"length":0,"stats":{"Line":0}},{"line":20410,"address":[54898874],"length":1,"stats":{"Line":0}},{"line":20412,"address":[56636377],"length":1,"stats":{"Line":0}},{"line":20413,"address":[],"length":0,"stats":{"Line":0}},{"line":20415,"address":[],"length":0,"stats":{"Line":0}},{"line":20416,"address":[],"length":0,"stats":{"Line":0}},{"line":20421,"address":[54066949],"length":1,"stats":{"Line":0}},{"line":20422,"address":[],"length":0,"stats":{"Line":0}},{"line":20423,"address":[],"length":0,"stats":{"Line":0}},{"line":20431,"address":[54067186],"length":1,"stats":{"Line":0}},{"line":20432,"address":[55084582],"length":1,"stats":{"Line":0}},{"line":20436,"address":[55084666],"length":1,"stats":{"Line":0}},{"line":20437,"address":[56636873],"length":1,"stats":{"Line":0}},{"line":20438,"address":[55084769],"length":1,"stats":{"Line":0}},{"line":20439,"address":[56636985],"length":1,"stats":{"Line":0}},{"line":20440,"address":[54899617],"length":1,"stats":{"Line":0}},{"line":20441,"address":[],"length":0,"stats":{"Line":0}},{"line":20442,"address":[55084885],"length":1,"stats":{"Line":0}},{"line":20443,"address":[],"length":0,"stats":{"Line":0}},{"line":20446,"address":[55084982],"length":1,"stats":{"Line":0}},{"line":20447,"address":[54067658],"length":1,"stats":{"Line":0}},{"line":20449,"address":[55085090],"length":1,"stats":{"Line":0}},{"line":20452,"address":[54899886],"length":1,"stats":{"Line":0}},{"line":20453,"address":[54899923],"length":1,"stats":{"Line":0}},{"line":20454,"address":[],"length":0,"stats":{"Line":0}},{"line":20455,"address":[],"length":0,"stats":{"Line":0}},{"line":20458,"address":[55085276],"length":1,"stats":{"Line":0}},{"line":20459,"address":[],"length":0,"stats":{"Line":0}},{"line":20460,"address":[54067923],"length":1,"stats":{"Line":0}},{"line":20463,"address":[56637567],"length":1,"stats":{"Line":0}},{"line":20464,"address":[],"length":0,"stats":{"Line":0}},{"line":20466,"address":[],"length":0,"stats":{"Line":0}},{"line":20467,"address":[],"length":0,"stats":{"Line":0}},{"line":20468,"address":[],"length":0,"stats":{"Line":0}},{"line":20472,"address":[54900298],"length":1,"stats":{"Line":0}},{"line":20473,"address":[55085560],"length":1,"stats":{"Line":0}},{"line":20477,"address":[54068244],"length":1,"stats":{"Line":0}},{"line":20478,"address":[54900385],"length":1,"stats":{"Line":0}},{"line":20479,"address":[],"length":0,"stats":{"Line":0}},{"line":20481,"address":[56637817],"length":1,"stats":{"Line":0}},{"line":20482,"address":[54900418],"length":1,"stats":{"Line":0}},{"line":20492,"address":[56638102],"length":1,"stats":{"Line":0}},{"line":20493,"address":[],"length":0,"stats":{"Line":0}},{"line":20494,"address":[56638109],"length":1,"stats":{"Line":0}},{"line":20496,"address":[54068673],"length":1,"stats":{"Line":0}},{"line":20497,"address":[],"length":0,"stats":{"Line":0}},{"line":20501,"address":[54900843],"length":1,"stats":{"Line":0}},{"line":20502,"address":[54900872],"length":1,"stats":{"Line":0}},{"line":20503,"address":[],"length":0,"stats":{"Line":0}},{"line":20506,"address":[54901098],"length":1,"stats":{"Line":0}},{"line":20507,"address":[55086363],"length":1,"stats":{"Line":0}},{"line":20510,"address":[54901256],"length":1,"stats":{"Line":0}},{"line":20511,"address":[56638717],"length":1,"stats":{"Line":0}},{"line":20514,"address":[54069260],"length":1,"stats":{"Line":0}},{"line":20516,"address":[56638795],"length":1,"stats":{"Line":0}},{"line":20517,"address":[],"length":0,"stats":{"Line":0}},{"line":20518,"address":[55086653],"length":1,"stats":{"Line":0}},{"line":20521,"address":[56638920],"length":1,"stats":{"Line":0}},{"line":20523,"address":[56638938],"length":1,"stats":{"Line":0}},{"line":20524,"address":[],"length":0,"stats":{"Line":0}},{"line":20525,"address":[56639069],"length":1,"stats":{"Line":0}},{"line":20526,"address":[54901580],"length":1,"stats":{"Line":0}},{"line":20527,"address":[],"length":0,"stats":{"Line":0}},{"line":20533,"address":[],"length":0,"stats":{"Line":0}},{"line":20535,"address":[55087067],"length":1,"stats":{"Line":0}},{"line":20537,"address":[56639245],"length":1,"stats":{"Line":0}},{"line":20538,"address":[],"length":0,"stats":{"Line":0}},{"line":20539,"address":[54901981],"length":1,"stats":{"Line":0}},{"line":20540,"address":[55087127],"length":1,"stats":{"Line":0}},{"line":20541,"address":[56639325],"length":1,"stats":{"Line":0}},{"line":20547,"address":[56639487],"length":1,"stats":{"Line":0}},{"line":20548,"address":[54902111],"length":1,"stats":{"Line":0}},{"line":20551,"address":[54070101],"length":1,"stats":{"Line":0}},{"line":20552,"address":[],"length":0,"stats":{"Line":0}},{"line":20553,"address":[55087452],"length":1,"stats":{"Line":0}},{"line":20555,"address":[56639693],"length":1,"stats":{"Line":0}},{"line":20557,"address":[54070209],"length":1,"stats":{"Line":0}},{"line":20558,"address":[],"length":0,"stats":{"Line":0}},{"line":20563,"address":[54070417],"length":1,"stats":{"Line":0}},{"line":20565,"address":[54902576],"length":1,"stats":{"Line":0}},{"line":20566,"address":[56639983],"length":1,"stats":{"Line":0}},{"line":20569,"address":[54902734],"length":1,"stats":{"Line":0}},{"line":20570,"address":[54070680],"length":1,"stats":{"Line":0}},{"line":20573,"address":[56640234],"length":1,"stats":{"Line":0}},{"line":20574,"address":[54070775],"length":1,"stats":{"Line":0}},{"line":20578,"address":[56689664],"length":1,"stats":{"Line":0}},{"line":20583,"address":[55137591],"length":1,"stats":{"Line":0}},{"line":20584,"address":[],"length":0,"stats":{"Line":0}},{"line":20586,"address":[55137910],"length":1,"stats":{"Line":0}},{"line":20587,"address":[],"length":0,"stats":{"Line":0}},{"line":20588,"address":[],"length":0,"stats":{"Line":0}},{"line":20589,"address":[55137982],"length":1,"stats":{"Line":0}},{"line":20591,"address":[56690214],"length":1,"stats":{"Line":0}},{"line":20592,"address":[],"length":0,"stats":{"Line":0}},{"line":20593,"address":[54953547],"length":1,"stats":{"Line":0}},{"line":20597,"address":[55138139],"length":1,"stats":{"Line":0}},{"line":20598,"address":[],"length":0,"stats":{"Line":0}},{"line":20599,"address":[56690314],"length":1,"stats":{"Line":0}},{"line":20609,"address":[56690515],"length":1,"stats":{"Line":0}},{"line":20610,"address":[],"length":0,"stats":{"Line":0}},{"line":20611,"address":[54020747],"length":1,"stats":{"Line":0}},{"line":20612,"address":[],"length":0,"stats":{"Line":0}},{"line":20614,"address":[],"length":0,"stats":{"Line":0}},{"line":20615,"address":[],"length":0,"stats":{"Line":0}},{"line":20616,"address":[],"length":0,"stats":{"Line":0}},{"line":20617,"address":[],"length":0,"stats":{"Line":0}},{"line":20621,"address":[54121879],"length":1,"stats":{"Line":0}},{"line":20622,"address":[],"length":0,"stats":{"Line":0}},{"line":20624,"address":[],"length":0,"stats":{"Line":0}},{"line":20625,"address":[],"length":0,"stats":{"Line":0}},{"line":20634,"address":[],"length":0,"stats":{"Line":0}},{"line":20635,"address":[],"length":0,"stats":{"Line":0}},{"line":20637,"address":[],"length":0,"stats":{"Line":0}},{"line":20638,"address":[],"length":0,"stats":{"Line":0}},{"line":20639,"address":[],"length":0,"stats":{"Line":0}},{"line":20644,"address":[55138947],"length":1,"stats":{"Line":0}},{"line":20648,"address":[54060960],"length":1,"stats":{"Line":0}},{"line":20653,"address":[54061047],"length":1,"stats":{"Line":0}},{"line":20654,"address":[54061218],"length":1,"stats":{"Line":0}},{"line":20656,"address":[54893482],"length":1,"stats":{"Line":0}},{"line":20657,"address":[54061435],"length":1,"stats":{"Line":0}},{"line":20658,"address":[],"length":0,"stats":{"Line":0}},{"line":20659,"address":[54893554],"length":1,"stats":{"Line":0}},{"line":20661,"address":[55078971],"length":1,"stats":{"Line":0}},{"line":20662,"address":[],"length":0,"stats":{"Line":0}},{"line":20663,"address":[54061528],"length":1,"stats":{"Line":0}},{"line":20667,"address":[],"length":0,"stats":{"Line":0}},{"line":20668,"address":[],"length":0,"stats":{"Line":0}},{"line":20669,"address":[],"length":0,"stats":{"Line":0}},{"line":20675,"address":[55079283],"length":1,"stats":{"Line":0}},{"line":20676,"address":[],"length":0,"stats":{"Line":0}},{"line":20677,"address":[56631458],"length":1,"stats":{"Line":0}},{"line":20685,"address":[54894177],"length":1,"stats":{"Line":0}},{"line":20686,"address":[],"length":0,"stats":{"Line":0}},{"line":20687,"address":[55079514],"length":1,"stats":{"Line":0}},{"line":20690,"address":[54894263],"length":1,"stats":{"Line":0}},{"line":20691,"address":[55079635],"length":1,"stats":{"Line":0}},{"line":20692,"address":[56631845],"length":1,"stats":{"Line":0}},{"line":20693,"address":[55079738],"length":1,"stats":{"Line":0}},{"line":20695,"address":[54894473],"length":1,"stats":{"Line":0}},{"line":20696,"address":[],"length":0,"stats":{"Line":0}},{"line":20700,"address":[56632015],"length":1,"stats":{"Line":0}},{"line":20702,"address":[],"length":0,"stats":{"Line":0}},{"line":20703,"address":[],"length":0,"stats":{"Line":0}},{"line":20704,"address":[54062454],"length":1,"stats":{"Line":0}},{"line":20707,"address":[54894641],"length":1,"stats":{"Line":0}},{"line":20708,"address":[54062544],"length":1,"stats":{"Line":0}},{"line":20713,"address":[54062670],"length":1,"stats":{"Line":0}},{"line":20714,"address":[],"length":0,"stats":{"Line":0}},{"line":20716,"address":[],"length":0,"stats":{"Line":0}},{"line":20717,"address":[55080138],"length":1,"stats":{"Line":0}},{"line":20726,"address":[56632568],"length":1,"stats":{"Line":0}},{"line":20727,"address":[],"length":0,"stats":{"Line":0}},{"line":20729,"address":[],"length":0,"stats":{"Line":0}},{"line":20730,"address":[],"length":0,"stats":{"Line":0}},{"line":20731,"address":[55080426],"length":1,"stats":{"Line":0}},{"line":20735,"address":[54895225],"length":1,"stats":{"Line":0}},{"line":20736,"address":[54063120],"length":1,"stats":{"Line":0}},{"line":20738,"address":[55080592],"length":1,"stats":{"Line":0}},{"line":20741,"address":[54895339],"length":1,"stats":{"Line":0}},{"line":20742,"address":[54895360],"length":1,"stats":{"Line":0}},{"line":20743,"address":[54895408],"length":1,"stats":{"Line":0}},{"line":20744,"address":[56632892],"length":1,"stats":{"Line":0}},{"line":20746,"address":[],"length":0,"stats":{"Line":0}},{"line":20749,"address":[54895522],"length":1,"stats":{"Line":0}},{"line":20750,"address":[56633019],"length":1,"stats":{"Line":0}},{"line":20751,"address":[],"length":0,"stats":{"Line":0}},{"line":20752,"address":[55080877],"length":1,"stats":{"Line":0}},{"line":20754,"address":[55080978],"length":1,"stats":{"Line":0}},{"line":20756,"address":[54895865],"length":1,"stats":{"Line":0}},{"line":20760,"address":[54952960,54951760,54952954],"length":1,"stats":{"Line":0}},{"line":20765,"address":[55136375],"length":1,"stats":{"Line":0}},{"line":20768,"address":[],"length":0,"stats":{"Line":0}},{"line":20769,"address":[],"length":0,"stats":{"Line":0}},{"line":20770,"address":[54119892],"length":1,"stats":{"Line":0}},{"line":20771,"address":[55136600,55136670],"length":1,"stats":{"Line":0}},{"line":20775,"address":[55136794],"length":1,"stats":{"Line":0}},{"line":20776,"address":[54513696],"length":1,"stats":{"Line":0}},{"line":20777,"address":[54513705],"length":1,"stats":{"Line":0}},{"line":20778,"address":[54513779],"length":1,"stats":{"Line":0}},{"line":20779,"address":[],"length":0,"stats":{"Line":0}},{"line":20783,"address":[54120329,54120778],"length":1,"stats":{"Line":0}},{"line":20784,"address":[],"length":0,"stats":{"Line":0}},{"line":20786,"address":[],"length":0,"stats":{"Line":0}},{"line":20787,"address":[54120340],"length":1,"stats":{"Line":0}},{"line":20788,"address":[],"length":0,"stats":{"Line":0}},{"line":20796,"address":[54952933],"length":1,"stats":{"Line":0}},{"line":20800,"address":[54513232],"length":1,"stats":{"Line":0}},{"line":20805,"address":[56255624],"length":1,"stats":{"Line":0}},{"line":20806,"address":[53681336],"length":1,"stats":{"Line":0}},{"line":20809,"address":[54703798],"length":1,"stats":{"Line":0}},{"line":20810,"address":[53681509],"length":1,"stats":{"Line":0}},{"line":20811,"address":[],"length":0,"stats":{"Line":0}},{"line":20812,"address":[54513636],"length":1,"stats":{"Line":0}},{"line":20815,"address":[56256033],"length":1,"stats":{"Line":0}},{"line":20816,"address":[],"length":0,"stats":{"Line":0}},{"line":20817,"address":[54513734],"length":1,"stats":{"Line":0}},{"line":20822,"address":[54704012],"length":1,"stats":{"Line":0}},{"line":20823,"address":[54477192],"length":1,"stats":{"Line":0}},{"line":20824,"address":[],"length":0,"stats":{"Line":0}},{"line":20825,"address":[],"length":0,"stats":{"Line":0}},{"line":20828,"address":[56256213],"length":1,"stats":{"Line":0}},{"line":20829,"address":[],"length":0,"stats":{"Line":0}},{"line":20830,"address":[54513913],"length":1,"stats":{"Line":0}},{"line":20837,"address":[56256467],"length":1,"stats":{"Line":0}},{"line":20841,"address":[54951728],"length":1,"stats":{"Line":0}},{"line":20846,"address":[56503912],"length":1,"stats":{"Line":0}},{"line":20847,"address":[54764312],"length":1,"stats":{"Line":0}},{"line":20850,"address":[],"length":0,"stats":{"Line":0}},{"line":20851,"address":[54952113],"length":1,"stats":{"Line":0}},{"line":20852,"address":[],"length":0,"stats":{"Line":0}},{"line":20853,"address":[],"length":0,"stats":{"Line":0}},{"line":20856,"address":[54952209],"length":1,"stats":{"Line":0}},{"line":20857,"address":[],"length":0,"stats":{"Line":0}},{"line":20858,"address":[],"length":0,"stats":{"Line":0}},{"line":20863,"address":[],"length":0,"stats":{"Line":0}},{"line":20864,"address":[54007688],"length":1,"stats":{"Line":0}},{"line":20865,"address":[],"length":0,"stats":{"Line":0}},{"line":20866,"address":[56096625],"length":1,"stats":{"Line":0}},{"line":20869,"address":[54764766],"length":1,"stats":{"Line":0}},{"line":20870,"address":[],"length":0,"stats":{"Line":0}},{"line":20871,"address":[56504512],"length":1,"stats":{"Line":0}},{"line":20878,"address":[54765023],"length":1,"stats":{"Line":0}},{"line":20882,"address":[55038608],"length":1,"stats":{"Line":0}},{"line":20886,"address":[],"length":0,"stats":{"Line":0}},{"line":20891,"address":[54020399],"length":1,"stats":{"Line":0}},{"line":20892,"address":[54852555],"length":1,"stats":{"Line":0}},{"line":20894,"address":[56591020],"length":1,"stats":{"Line":0}},{"line":20895,"address":[],"length":0,"stats":{"Line":0}},{"line":20896,"address":[54852613],"length":1,"stats":{"Line":0}},{"line":20898,"address":[54020580],"length":1,"stats":{"Line":0}},{"line":20899,"address":[],"length":0,"stats":{"Line":0}},{"line":20900,"address":[54020587],"length":1,"stats":{"Line":0}},{"line":20902,"address":[54020659],"length":1,"stats":{"Line":0}},{"line":20903,"address":[],"length":0,"stats":{"Line":0}},{"line":20904,"address":[54852778],"length":1,"stats":{"Line":0}},{"line":20908,"address":[55039263,55039146],"length":1,"stats":{"Line":0}},{"line":20909,"address":[],"length":0,"stats":{"Line":0}},{"line":20912,"address":[],"length":0,"stats":{"Line":0}},{"line":20913,"address":[],"length":0,"stats":{"Line":0}},{"line":20914,"address":[54853018],"length":1,"stats":{"Line":0}},{"line":20918,"address":[54853095],"length":1,"stats":{"Line":0}},{"line":20919,"address":[],"length":0,"stats":{"Line":0}},{"line":20920,"address":[56591508],"length":1,"stats":{"Line":0}},{"line":20922,"address":[56591583],"length":1,"stats":{"Line":0}},{"line":20923,"address":[55039529],"length":1,"stats":{"Line":0}},{"line":20924,"address":[],"length":0,"stats":{"Line":0}},{"line":20925,"address":[54021134],"length":1,"stats":{"Line":0}},{"line":20927,"address":[54021214],"length":1,"stats":{"Line":0}},{"line":20930,"address":[56591774],"length":1,"stats":{"Line":0}},{"line":20931,"address":[54853438],"length":1,"stats":{"Line":0}},{"line":20932,"address":[],"length":0,"stats":{"Line":0}},{"line":20933,"address":[54853445],"length":1,"stats":{"Line":0}},{"line":20935,"address":[54021399],"length":1,"stats":{"Line":0}},{"line":20937,"address":[56591942],"length":1,"stats":{"Line":0}},{"line":20939,"address":[54853564],"length":1,"stats":{"Line":0}},{"line":20940,"address":[],"length":0,"stats":{"Line":0}},{"line":20945,"address":[56592164],"length":1,"stats":{"Line":0}},{"line":20949,"address":[54983712],"length":1,"stats":{"Line":0}},{"line":20955,"address":[53964535],"length":1,"stats":{"Line":0}},{"line":20956,"address":[53964706],"length":1,"stats":{"Line":0}},{"line":20958,"address":[54984153],"length":1,"stats":{"Line":0}},{"line":20959,"address":[54797039],"length":1,"stats":{"Line":0}},{"line":20960,"address":[54984296],"length":1,"stats":{"Line":0}},{"line":20961,"address":[],"length":0,"stats":{"Line":0}},{"line":20962,"address":[54797123],"length":1,"stats":{"Line":0}},{"line":20966,"address":[53965094],"length":1,"stats":{"Line":0}},{"line":20967,"address":[],"length":0,"stats":{"Line":0}},{"line":20968,"address":[56536503],"length":1,"stats":{"Line":0}},{"line":20970,"address":[54984456],"length":1,"stats":{"Line":0}},{"line":20971,"address":[],"length":0,"stats":{"Line":0}},{"line":20972,"address":[53965178],"length":1,"stats":{"Line":0}},{"line":20977,"address":[],"length":0,"stats":{"Line":0}},{"line":20978,"address":[54984615,54984697],"length":1,"stats":{"Line":0}},{"line":20980,"address":[54984687],"length":1,"stats":{"Line":0}},{"line":20984,"address":[54797624],"length":1,"stats":{"Line":0}},{"line":20985,"address":[],"length":0,"stats":{"Line":0}},{"line":20986,"address":[56536915],"length":1,"stats":{"Line":0}},{"line":20990,"address":[53965599],"length":1,"stats":{"Line":0}},{"line":20991,"address":[54984925],"length":1,"stats":{"Line":0}},{"line":20992,"address":[54797799],"length":1,"stats":{"Line":0}},{"line":20993,"address":[],"length":0,"stats":{"Line":0}},{"line":20994,"address":[],"length":0,"stats":{"Line":0}},{"line":20996,"address":[56537163],"length":1,"stats":{"Line":0}},{"line":20997,"address":[],"length":0,"stats":{"Line":0}},{"line":20998,"address":[54985058],"length":1,"stats":{"Line":0}},{"line":21001,"address":[53965845],"length":1,"stats":{"Line":0}},{"line":21002,"address":[],"length":0,"stats":{"Line":0}},{"line":21003,"address":[54985138],"length":1,"stats":{"Line":0}},{"line":21011,"address":[],"length":0,"stats":{"Line":0}},{"line":21012,"address":[],"length":0,"stats":{"Line":0}},{"line":21013,"address":[54985360],"length":1,"stats":{"Line":0}},{"line":21015,"address":[54985430],"length":1,"stats":{"Line":0}},{"line":21016,"address":[56537590],"length":1,"stats":{"Line":0}},{"line":21018,"address":[54985522],"length":1,"stats":{"Line":0}},{"line":21019,"address":[53966266],"length":1,"stats":{"Line":0}},{"line":21022,"address":[],"length":0,"stats":{"Line":0}},{"line":21023,"address":[],"length":0,"stats":{"Line":0}},{"line":21024,"address":[53966407],"length":1,"stats":{"Line":0}},{"line":21026,"address":[],"length":0,"stats":{"Line":0}},{"line":21030,"address":[53966529],"length":1,"stats":{"Line":0}},{"line":21031,"address":[53966581],"length":1,"stats":{"Line":0}},{"line":21032,"address":[],"length":0,"stats":{"Line":0}},{"line":21033,"address":[54798700],"length":1,"stats":{"Line":0}},{"line":21035,"address":[54985923],"length":1,"stats":{"Line":0}},{"line":21036,"address":[],"length":0,"stats":{"Line":0}},{"line":21037,"address":[53966667],"length":1,"stats":{"Line":0}},{"line":21040,"address":[54986000],"length":1,"stats":{"Line":0}},{"line":21041,"address":[54986015],"length":1,"stats":{"Line":0}},{"line":21046,"address":[54798997],"length":1,"stats":{"Line":0}},{"line":21047,"address":[53966900],"length":1,"stats":{"Line":0}},{"line":21051,"address":[53967026],"length":1,"stats":{"Line":0}},{"line":21053,"address":[54986301],"length":1,"stats":{"Line":0}},{"line":21054,"address":[],"length":0,"stats":{"Line":0}},{"line":21059,"address":[56538687],"length":1,"stats":{"Line":0}},{"line":21063,"address":[56747840],"length":1,"stats":{"Line":0}},{"line":21070,"address":[],"length":0,"stats":{"Line":0}},{"line":21071,"address":[56748118],"length":1,"stats":{"Line":0}},{"line":21073,"address":[55012355],"length":1,"stats":{"Line":0}},{"line":21074,"address":[55196177],"length":1,"stats":{"Line":0}},{"line":21077,"address":[56748390],"length":1,"stats":{"Line":0}},{"line":21078,"address":[54180409,54180481],"length":1,"stats":{"Line":0}},{"line":21079,"address":[56748744],"length":1,"stats":{"Line":0}},{"line":21081,"address":[54180440],"length":1,"stats":{"Line":0}},{"line":21085,"address":[55012985],"length":1,"stats":{"Line":0}},{"line":21086,"address":[56748949],"length":1,"stats":{"Line":0}},{"line":21087,"address":[55013094],"length":1,"stats":{"Line":0}},{"line":21088,"address":[],"length":0,"stats":{"Line":0}},{"line":21089,"address":[54180989],"length":1,"stats":{"Line":0}},{"line":21092,"address":[54181081,54181162],"length":1,"stats":{"Line":0}},{"line":21095,"address":[56749271],"length":1,"stats":{"Line":0}},{"line":21096,"address":[],"length":0,"stats":{"Line":0}},{"line":21101,"address":[54181338],"length":1,"stats":{"Line":0}},{"line":21102,"address":[55197254],"length":1,"stats":{"Line":0}},{"line":21103,"address":[55013562],"length":1,"stats":{"Line":0}},{"line":21105,"address":[],"length":0,"stats":{"Line":0}},{"line":21106,"address":[55197386],"length":1,"stats":{"Line":0}},{"line":21110,"address":[55013689],"length":1,"stats":{"Line":0}},{"line":21111,"address":[],"length":0,"stats":{"Line":0}},{"line":21112,"address":[],"length":0,"stats":{"Line":0}},{"line":21113,"address":[54181621],"length":1,"stats":{"Line":0}},{"line":21115,"address":[],"length":0,"stats":{"Line":0}},{"line":21116,"address":[],"length":0,"stats":{"Line":0}},{"line":21117,"address":[55197563],"length":1,"stats":{"Line":0}},{"line":21123,"address":[56749936],"length":1,"stats":{"Line":0}},{"line":21124,"address":[55014084],"length":1,"stats":{"Line":0}},{"line":21127,"address":[56750049],"length":1,"stats":{"Line":0}},{"line":21128,"address":[55014185],"length":1,"stats":{"Line":0}},{"line":21129,"address":[],"length":0,"stats":{"Line":0}},{"line":21130,"address":[],"length":0,"stats":{"Line":0}},{"line":21132,"address":[55014267],"length":1,"stats":{"Line":0}},{"line":21133,"address":[],"length":0,"stats":{"Line":0}},{"line":21134,"address":[56750173],"length":1,"stats":{"Line":0}},{"line":21136,"address":[54182229],"length":1,"stats":{"Line":0}},{"line":21137,"address":[],"length":0,"stats":{"Line":0}},{"line":21138,"address":[],"length":0,"stats":{"Line":0}},{"line":21141,"address":[56750337],"length":1,"stats":{"Line":0}},{"line":21142,"address":[55198226],"length":1,"stats":{"Line":0}},{"line":21145,"address":[56750450],"length":1,"stats":{"Line":0}},{"line":21146,"address":[55014577],"length":1,"stats":{"Line":0}},{"line":21147,"address":[],"length":0,"stats":{"Line":0}},{"line":21148,"address":[55014878],"length":1,"stats":{"Line":0}},{"line":21151,"address":[54182811],"length":1,"stats":{"Line":0}},{"line":21152,"address":[],"length":0,"stats":{"Line":0}},{"line":21154,"address":[55198752,55198737],"length":1,"stats":{"Line":0}},{"line":21155,"address":[],"length":0,"stats":{"Line":0}},{"line":21156,"address":[],"length":0,"stats":{"Line":0}},{"line":21159,"address":[56751013],"length":1,"stats":{"Line":0}},{"line":21160,"address":[],"length":0,"stats":{"Line":0}},{"line":21161,"address":[55015130],"length":1,"stats":{"Line":0}},{"line":21163,"address":[55015205],"length":1,"stats":{"Line":0}},{"line":21164,"address":[],"length":0,"stats":{"Line":0}},{"line":21165,"address":[56751108],"length":1,"stats":{"Line":0}},{"line":21169,"address":[],"length":0,"stats":{"Line":0}},{"line":21170,"address":[55015345,55015397],"length":1,"stats":{"Line":0}},{"line":21171,"address":[56751518],"length":1,"stats":{"Line":0}},{"line":21173,"address":[54183677],"length":1,"stats":{"Line":0}},{"line":21174,"address":[],"length":0,"stats":{"Line":0}},{"line":21175,"address":[55015804],"length":1,"stats":{"Line":0}},{"line":21177,"address":[55199619],"length":1,"stats":{"Line":0}},{"line":21178,"address":[],"length":0,"stats":{"Line":0}},{"line":21179,"address":[55199626],"length":1,"stats":{"Line":0}},{"line":21181,"address":[],"length":0,"stats":{"Line":0}},{"line":21182,"address":[55015996],"length":1,"stats":{"Line":0}},{"line":21186,"address":[54183264],"length":1,"stats":{"Line":0}},{"line":21190,"address":[54183962],"length":1,"stats":{"Line":0}},{"line":21191,"address":[],"length":0,"stats":{"Line":0}},{"line":21192,"address":[],"length":0,"stats":{"Line":0}},{"line":21193,"address":[56752017],"length":1,"stats":{"Line":0}},{"line":21197,"address":[],"length":0,"stats":{"Line":0}},{"line":21198,"address":[],"length":0,"stats":{"Line":0}},{"line":21199,"address":[54184443],"length":1,"stats":{"Line":0}},{"line":21201,"address":[56752580],"length":1,"stats":{"Line":0}},{"line":21202,"address":[],"length":0,"stats":{"Line":0}},{"line":21203,"address":[55016725],"length":1,"stats":{"Line":0}},{"line":21205,"address":[],"length":0,"stats":{"Line":0}},{"line":21206,"address":[],"length":0,"stats":{"Line":0}},{"line":21207,"address":[56752695],"length":1,"stats":{"Line":0}},{"line":21209,"address":[55200616],"length":1,"stats":{"Line":0}},{"line":21210,"address":[55016917],"length":1,"stats":{"Line":0}},{"line":21214,"address":[],"length":0,"stats":{"Line":0}},{"line":21219,"address":[54184891],"length":1,"stats":{"Line":0}},{"line":21220,"address":[],"length":0,"stats":{"Line":0}},{"line":21221,"address":[56752874],"length":1,"stats":{"Line":0}},{"line":21223,"address":[],"length":0,"stats":{"Line":0}},{"line":21224,"address":[],"length":0,"stats":{"Line":0}},{"line":21225,"address":[55017104],"length":1,"stats":{"Line":0}},{"line":21228,"address":[55200887],"length":1,"stats":{"Line":0}},{"line":21229,"address":[55200943],"length":1,"stats":{"Line":0}},{"line":21230,"address":[54185187],"length":1,"stats":{"Line":0}},{"line":21232,"address":[56753228],"length":1,"stats":{"Line":0}},{"line":21233,"address":[55017375],"length":1,"stats":{"Line":0}},{"line":21237,"address":[],"length":0,"stats":{"Line":0}},{"line":21240,"address":[],"length":0,"stats":{"Line":0}},{"line":21241,"address":[],"length":0,"stats":{"Line":0}},{"line":21242,"address":[55201153],"length":1,"stats":{"Line":0}},{"line":21244,"address":[54185433],"length":1,"stats":{"Line":0}},{"line":21245,"address":[],"length":0,"stats":{"Line":0}},{"line":21246,"address":[56753417],"length":1,"stats":{"Line":0}},{"line":21248,"address":[55201337],"length":1,"stats":{"Line":0}},{"line":21249,"address":[],"length":0,"stats":{"Line":0}},{"line":21250,"address":[55201352],"length":1,"stats":{"Line":0}},{"line":21255,"address":[55201447],"length":1,"stats":{"Line":0}},{"line":21256,"address":[],"length":0,"stats":{"Line":0}},{"line":21257,"address":[],"length":0,"stats":{"Line":0}},{"line":21259,"address":[54185823],"length":1,"stats":{"Line":0}},{"line":21260,"address":[55017942],"length":1,"stats":{"Line":0}},{"line":21264,"address":[54185881],"length":1,"stats":{"Line":0}},{"line":21265,"address":[55018030],"length":1,"stats":{"Line":0}},{"line":21266,"address":[],"length":0,"stats":{"Line":0}},{"line":21267,"address":[54185925],"length":1,"stats":{"Line":0}},{"line":21270,"address":[56753962],"length":1,"stats":{"Line":0}},{"line":21271,"address":[56753980],"length":1,"stats":{"Line":0}},{"line":21274,"address":[55201971],"length":1,"stats":{"Line":0}},{"line":21275,"address":[],"length":0,"stats":{"Line":0}},{"line":21276,"address":[55018290],"length":1,"stats":{"Line":0}},{"line":21278,"address":[54186245],"length":1,"stats":{"Line":0}},{"line":21279,"address":[],"length":0,"stats":{"Line":0}},{"line":21280,"address":[55202061],"length":1,"stats":{"Line":0}},{"line":21286,"address":[],"length":0,"stats":{"Line":0}},{"line":21288,"address":[56754455],"length":1,"stats":{"Line":0}},{"line":21289,"address":[55018627],"length":1,"stats":{"Line":0}},{"line":21295,"address":[],"length":0,"stats":{"Line":0}},{"line":21297,"address":[54186795],"length":1,"stats":{"Line":0}},{"line":21298,"address":[],"length":0,"stats":{"Line":0}},{"line":21299,"address":[55018943],"length":1,"stats":{"Line":0}},{"line":21304,"address":[],"length":0,"stats":{"Line":0}},{"line":21305,"address":[55019065],"length":1,"stats":{"Line":0}},{"line":21307,"address":[],"length":0,"stats":{"Line":0}},{"line":21308,"address":[55203022],"length":1,"stats":{"Line":0}},{"line":21309,"address":[55019353],"length":1,"stats":{"Line":0}},{"line":21311,"address":[],"length":0,"stats":{"Line":0}},{"line":21314,"address":[55203135],"length":1,"stats":{"Line":0}},{"line":21315,"address":[55203172],"length":1,"stats":{"Line":0}},{"line":21316,"address":[],"length":0,"stats":{"Line":0}},{"line":21317,"address":[56755339],"length":1,"stats":{"Line":0}},{"line":21319,"address":[55019579],"length":1,"stats":{"Line":0}},{"line":21320,"address":[56755459],"length":1,"stats":{"Line":0}},{"line":21321,"address":[55019686],"length":1,"stats":{"Line":0}},{"line":21322,"address":[],"length":0,"stats":{"Line":0}},{"line":21323,"address":[54187581],"length":1,"stats":{"Line":0}},{"line":21325,"address":[55203447],"length":1,"stats":{"Line":0}},{"line":21326,"address":[],"length":0,"stats":{"Line":0}},{"line":21327,"address":[55019783],"length":1,"stats":{"Line":0}},{"line":21329,"address":[55019850],"length":1,"stats":{"Line":0}},{"line":21330,"address":[],"length":0,"stats":{"Line":0}},{"line":21331,"address":[54187756],"length":1,"stats":{"Line":0}},{"line":21338,"address":[54187983],"length":1,"stats":{"Line":0}},{"line":21339,"address":[],"length":0,"stats":{"Line":0}},{"line":21340,"address":[54187990],"length":1,"stats":{"Line":0}},{"line":21342,"address":[56756001],"length":1,"stats":{"Line":0}},{"line":21343,"address":[56756008],"length":1,"stats":{"Line":0}},{"line":21346,"address":[54188115],"length":1,"stats":{"Line":0}},{"line":21348,"address":[54188133],"length":1,"stats":{"Line":0}},{"line":21349,"address":[],"length":0,"stats":{"Line":0}},{"line":21350,"address":[55203935],"length":1,"stats":{"Line":0}},{"line":21355,"address":[54188309],"length":1,"stats":{"Line":0}},{"line":21356,"address":[],"length":0,"stats":{"Line":0}},{"line":21357,"address":[55204088],"length":1,"stats":{"Line":0}},{"line":21359,"address":[54188391],"length":1,"stats":{"Line":0}},{"line":21360,"address":[56756328],"length":1,"stats":{"Line":0}},{"line":21363,"address":[],"length":0,"stats":{"Line":0}},{"line":21364,"address":[],"length":0,"stats":{"Line":0}},{"line":21365,"address":[54188456],"length":1,"stats":{"Line":0}},{"line":21367,"address":[54188539],"length":1,"stats":{"Line":0}},{"line":21368,"address":[],"length":0,"stats":{"Line":0}},{"line":21369,"address":[55020658],"length":1,"stats":{"Line":0}},{"line":21372,"address":[56756545],"length":1,"stats":{"Line":0}},{"line":21373,"address":[54188639],"length":1,"stats":{"Line":0}},{"line":21377,"address":[54188779],"length":1,"stats":{"Line":0}},{"line":21378,"address":[55020909],"length":1,"stats":{"Line":0}},{"line":21381,"address":[56756849],"length":1,"stats":{"Line":0}},{"line":21383,"address":[],"length":0,"stats":{"Line":0}},{"line":21384,"address":[55204722],"length":1,"stats":{"Line":0}},{"line":21388,"address":[],"length":0,"stats":{"Line":0}},{"line":21389,"address":[55021531],"length":1,"stats":{"Line":0}},{"line":21390,"address":[55021538],"length":1,"stats":{"Line":0}},{"line":21392,"address":[],"length":0,"stats":{"Line":0}},{"line":21395,"address":[55021645],"length":1,"stats":{"Line":0}},{"line":21396,"address":[55021666],"length":1,"stats":{"Line":0}},{"line":21397,"address":[],"length":0,"stats":{"Line":0}},{"line":21398,"address":[54189564],"length":1,"stats":{"Line":0}},{"line":21400,"address":[],"length":0,"stats":{"Line":0}},{"line":21401,"address":[55021766],"length":1,"stats":{"Line":0}},{"line":21402,"address":[54189855],"length":1,"stats":{"Line":0}},{"line":21403,"address":[55022011],"length":1,"stats":{"Line":0}},{"line":21404,"address":[55022061],"length":1,"stats":{"Line":0}},{"line":21407,"address":[56757926],"length":1,"stats":{"Line":0}},{"line":21414,"address":[54190034],"length":1,"stats":{"Line":0}},{"line":21415,"address":[],"length":0,"stats":{"Line":0}},{"line":21416,"address":[],"length":0,"stats":{"Line":0}},{"line":21418,"address":[54190124],"length":1,"stats":{"Line":0}},{"line":21419,"address":[],"length":0,"stats":{"Line":0}},{"line":21420,"address":[55022243],"length":1,"stats":{"Line":0}},{"line":21422,"address":[],"length":0,"stats":{"Line":0}},{"line":21423,"address":[],"length":0,"stats":{"Line":0}},{"line":21424,"address":[55205978],"length":1,"stats":{"Line":0}},{"line":21426,"address":[56758218],"length":1,"stats":{"Line":0}},{"line":21427,"address":[],"length":0,"stats":{"Line":0}},{"line":21428,"address":[55022438],"length":1,"stats":{"Line":0}},{"line":21433,"address":[55022535],"length":1,"stats":{"Line":0}},{"line":21434,"address":[55022591],"length":1,"stats":{"Line":0}},{"line":21435,"address":[55022647],"length":1,"stats":{"Line":0}},{"line":21437,"address":[55022716],"length":1,"stats":{"Line":0}},{"line":21438,"address":[54190611],"length":1,"stats":{"Line":0}},{"line":21442,"address":[55022774],"length":1,"stats":{"Line":0}},{"line":21443,"address":[],"length":0,"stats":{"Line":0}},{"line":21444,"address":[],"length":0,"stats":{"Line":0}},{"line":21445,"address":[56758610],"length":1,"stats":{"Line":0}},{"line":21447,"address":[55206536],"length":1,"stats":{"Line":0}},{"line":21448,"address":[56758768],"length":1,"stats":{"Line":0}},{"line":21449,"address":[],"length":0,"stats":{"Line":0}},{"line":21450,"address":[55022998],"length":1,"stats":{"Line":0}},{"line":21458,"address":[],"length":0,"stats":{"Line":0}},{"line":21459,"address":[55023281],"length":1,"stats":{"Line":0}},{"line":21460,"address":[],"length":0,"stats":{"Line":0}},{"line":21461,"address":[],"length":0,"stats":{"Line":0}},{"line":21463,"address":[],"length":0,"stats":{"Line":0}},{"line":21464,"address":[],"length":0,"stats":{"Line":0}},{"line":21466,"address":[55207128],"length":1,"stats":{"Line":0}},{"line":21467,"address":[],"length":0,"stats":{"Line":0}},{"line":21468,"address":[],"length":0,"stats":{"Line":0}},{"line":21471,"address":[],"length":0,"stats":{"Line":0}},{"line":21472,"address":[56759395],"length":1,"stats":{"Line":0}},{"line":21473,"address":[],"length":0,"stats":{"Line":0}},{"line":21474,"address":[55023622],"length":1,"stats":{"Line":0}},{"line":21476,"address":[54191592],"length":1,"stats":{"Line":0}},{"line":21477,"address":[56759599],"length":1,"stats":{"Line":0}},{"line":21478,"address":[],"length":0,"stats":{"Line":0}},{"line":21479,"address":[56759609],"length":1,"stats":{"Line":0}},{"line":21481,"address":[54191798],"length":1,"stats":{"Line":0}},{"line":21483,"address":[],"length":0,"stats":{"Line":0}},{"line":21484,"address":[],"length":0,"stats":{"Line":0}},{"line":21485,"address":[56759903],"length":1,"stats":{"Line":0}},{"line":21486,"address":[],"length":0,"stats":{"Line":0}},{"line":21487,"address":[55024131],"length":1,"stats":{"Line":0}},{"line":21489,"address":[55207838],"length":1,"stats":{"Line":0}},{"line":21490,"address":[55024228],"length":1,"stats":{"Line":0}},{"line":21493,"address":[],"length":0,"stats":{"Line":0}},{"line":21495,"address":[54192188],"length":1,"stats":{"Line":0}},{"line":21496,"address":[],"length":0,"stats":{"Line":0}},{"line":21499,"address":[54192346],"length":1,"stats":{"Line":0}},{"line":21500,"address":[],"length":0,"stats":{"Line":0}},{"line":21501,"address":[55024476],"length":1,"stats":{"Line":0}},{"line":21504,"address":[55024595],"length":1,"stats":{"Line":0}},{"line":21505,"address":[55208225],"length":1,"stats":{"Line":0}},{"line":21508,"address":[54192649],"length":1,"stats":{"Line":0}},{"line":21509,"address":[],"length":0,"stats":{"Line":0}},{"line":21510,"address":[],"length":0,"stats":{"Line":0}},{"line":21511,"address":[55024834],"length":1,"stats":{"Line":0}},{"line":21513,"address":[54192794],"length":1,"stats":{"Line":0}},{"line":21514,"address":[],"length":0,"stats":{"Line":0}},{"line":21515,"address":[56760679],"length":1,"stats":{"Line":0}},{"line":21517,"address":[54192884],"length":1,"stats":{"Line":0}},{"line":21518,"address":[54193006],"length":1,"stats":{"Line":0}},{"line":21519,"address":[55025240],"length":1,"stats":{"Line":0}},{"line":21520,"address":[54193135],"length":1,"stats":{"Line":0}},{"line":21523,"address":[55208901],"length":1,"stats":{"Line":0}},{"line":21525,"address":[55208922],"length":1,"stats":{"Line":0}},{"line":21526,"address":[54193225],"length":1,"stats":{"Line":0}},{"line":21529,"address":[54193365],"length":1,"stats":{"Line":0}},{"line":21530,"address":[],"length":0,"stats":{"Line":0}},{"line":21532,"address":[56761348],"length":1,"stats":{"Line":0}},{"line":21533,"address":[55209373],"length":1,"stats":{"Line":0}},{"line":21534,"address":[55025826],"length":1,"stats":{"Line":0}},{"line":21537,"address":[55025887],"length":1,"stats":{"Line":0}},{"line":21538,"address":[],"length":0,"stats":{"Line":0}},{"line":21539,"address":[],"length":0,"stats":{"Line":0}},{"line":21540,"address":[],"length":0,"stats":{"Line":0}},{"line":21542,"address":[55209600],"length":1,"stats":{"Line":0}},{"line":21543,"address":[],"length":0,"stats":{"Line":0}},{"line":21545,"address":[56761775],"length":1,"stats":{"Line":0}},{"line":21546,"address":[55026057],"length":1,"stats":{"Line":0}},{"line":21547,"address":[56761826],"length":1,"stats":{"Line":0}},{"line":21548,"address":[55026135],"length":1,"stats":{"Line":0}},{"line":21552,"address":[55026236],"length":1,"stats":{"Line":0}},{"line":21553,"address":[],"length":0,"stats":{"Line":0}},{"line":21554,"address":[54194139],"length":1,"stats":{"Line":0}},{"line":21561,"address":[56762216],"length":1,"stats":{"Line":0}},{"line":21562,"address":[],"length":0,"stats":{"Line":0}},{"line":21563,"address":[55210063],"length":1,"stats":{"Line":0}},{"line":21565,"address":[55210136],"length":1,"stats":{"Line":0}},{"line":21567,"address":[56762344],"length":1,"stats":{"Line":0}},{"line":21569,"address":[56762359],"length":1,"stats":{"Line":0}},{"line":21570,"address":[],"length":0,"stats":{"Line":0}},{"line":21571,"address":[],"length":0,"stats":{"Line":0}},{"line":21576,"address":[56762524],"length":1,"stats":{"Line":0}},{"line":21577,"address":[],"length":0,"stats":{"Line":0}},{"line":21578,"address":[54194678],"length":1,"stats":{"Line":0}},{"line":21580,"address":[55210444],"length":1,"stats":{"Line":0}},{"line":21583,"address":[54194811],"length":1,"stats":{"Line":0}},{"line":21584,"address":[],"length":0,"stats":{"Line":0}},{"line":21585,"address":[54194815],"length":1,"stats":{"Line":0}},{"line":21586,"address":[54194864],"length":1,"stats":{"Line":0}},{"line":21587,"address":[],"length":0,"stats":{"Line":0}},{"line":21588,"address":[54194868],"length":1,"stats":{"Line":0}},{"line":21589,"address":[56762769],"length":1,"stats":{"Line":0}},{"line":21590,"address":[],"length":0,"stats":{"Line":0}},{"line":21591,"address":[54194924],"length":1,"stats":{"Line":0}},{"line":21592,"address":[55027088],"length":1,"stats":{"Line":0}},{"line":21594,"address":[55027138],"length":1,"stats":{"Line":0}},{"line":21595,"address":[54195033],"length":1,"stats":{"Line":0}},{"line":21597,"address":[55210769],"length":1,"stats":{"Line":0}},{"line":21598,"address":[],"length":0,"stats":{"Line":0}},{"line":21599,"address":[54195117],"length":1,"stats":{"Line":0}},{"line":21602,"address":[],"length":0,"stats":{"Line":0}},{"line":21603,"address":[55210876],"length":1,"stats":{"Line":0}},{"line":21604,"address":[],"length":0,"stats":{"Line":0}},{"line":21605,"address":[56763046],"length":1,"stats":{"Line":0}},{"line":21607,"address":[56763123],"length":1,"stats":{"Line":0}},{"line":21608,"address":[54195392],"length":1,"stats":{"Line":0}},{"line":21609,"address":[],"length":0,"stats":{"Line":0}},{"line":21610,"address":[55027514],"length":1,"stats":{"Line":0}},{"line":21612,"address":[54195481],"length":1,"stats":{"Line":0}},{"line":21614,"address":[55027707],"length":1,"stats":{"Line":0}},{"line":21615,"address":[55027749],"length":1,"stats":{"Line":0}},{"line":21616,"address":[55027807],"length":1,"stats":{"Line":0}},{"line":21617,"address":[],"length":0,"stats":{"Line":0}},{"line":21618,"address":[54195702],"length":1,"stats":{"Line":0}},{"line":21620,"address":[54195792],"length":1,"stats":{"Line":0}},{"line":21621,"address":[54195799],"length":1,"stats":{"Line":0}},{"line":21624,"address":[55027962],"length":1,"stats":{"Line":0}},{"line":21625,"address":[55027983],"length":1,"stats":{"Line":0}},{"line":21626,"address":[55028038],"length":1,"stats":{"Line":0}},{"line":21627,"address":[],"length":0,"stats":{"Line":0}},{"line":21628,"address":[],"length":0,"stats":{"Line":0}},{"line":21630,"address":[55211686],"length":1,"stats":{"Line":0}},{"line":21631,"address":[],"length":0,"stats":{"Line":0}},{"line":21632,"address":[56763853],"length":1,"stats":{"Line":0}},{"line":21635,"address":[55211766],"length":1,"stats":{"Line":0}},{"line":21636,"address":[55028220],"length":1,"stats":{"Line":0}},{"line":21639,"address":[55211935],"length":1,"stats":{"Line":0}},{"line":21640,"address":[],"length":0,"stats":{"Line":0}},{"line":21641,"address":[56764102],"length":1,"stats":{"Line":0}},{"line":21643,"address":[55212015],"length":1,"stats":{"Line":0}},{"line":21644,"address":[],"length":0,"stats":{"Line":0}},{"line":21645,"address":[54196350],"length":1,"stats":{"Line":0}},{"line":21648,"address":[54196425],"length":1,"stats":{"Line":0}},{"line":21649,"address":[],"length":0,"stats":{"Line":0}},{"line":21653,"address":[56764403],"length":1,"stats":{"Line":0}},{"line":21655,"address":[55212261],"length":1,"stats":{"Line":0}},{"line":21656,"address":[55212276],"length":1,"stats":{"Line":0}},{"line":21661,"address":[55212553],"length":1,"stats":{"Line":0}},{"line":21662,"address":[],"length":0,"stats":{"Line":0}},{"line":21663,"address":[56764720],"length":1,"stats":{"Line":0}},{"line":21665,"address":[55212630],"length":1,"stats":{"Line":0}},{"line":21666,"address":[],"length":0,"stats":{"Line":0}},{"line":21667,"address":[],"length":0,"stats":{"Line":0}},{"line":21669,"address":[54197055],"length":1,"stats":{"Line":0}},{"line":21670,"address":[],"length":0,"stats":{"Line":0}},{"line":21671,"address":[56765122],"length":1,"stats":{"Line":0}},{"line":21672,"address":[54197306],"length":1,"stats":{"Line":0}},{"line":21675,"address":[55029469],"length":1,"stats":{"Line":0}},{"line":21676,"address":[55029498],"length":1,"stats":{"Line":0}},{"line":21677,"address":[54197573],"length":1,"stats":{"Line":0}},{"line":21678,"address":[],"length":0,"stats":{"Line":0}},{"line":21681,"address":[56765503],"length":1,"stats":{"Line":0}},{"line":21682,"address":[55213364],"length":1,"stats":{"Line":0}},{"line":21683,"address":[],"length":0,"stats":{"Line":0}},{"line":21684,"address":[55029827],"length":1,"stats":{"Line":0}},{"line":21686,"address":[54197874],"length":1,"stats":{"Line":0}},{"line":21687,"address":[54197796],"length":1,"stats":{"Line":0}},{"line":21688,"address":[55029947],"length":1,"stats":{"Line":0}},{"line":21690,"address":[54197994],"length":1,"stats":{"Line":0}},{"line":21691,"address":[55213695],"length":1,"stats":{"Line":0}},{"line":21692,"address":[56765904],"length":1,"stats":{"Line":0}},{"line":21695,"address":[55030261],"length":1,"stats":{"Line":0}},{"line":21696,"address":[],"length":0,"stats":{"Line":0}},{"line":21697,"address":[],"length":0,"stats":{"Line":0}},{"line":21698,"address":[54198180],"length":1,"stats":{"Line":0}},{"line":21700,"address":[56766156],"length":1,"stats":{"Line":0}},{"line":21701,"address":[55213918],"length":1,"stats":{"Line":0}},{"line":21702,"address":[54198303],"length":1,"stats":{"Line":0}},{"line":21705,"address":[55214116],"length":1,"stats":{"Line":0}},{"line":21709,"address":[56308720],"length":1,"stats":{"Line":0}},{"line":21713,"address":[54567191],"length":1,"stats":{"Line":0}},{"line":21714,"address":[54567343],"length":1,"stats":{"Line":0}},{"line":21715,"address":[],"length":0,"stats":{"Line":0}},{"line":21716,"address":[54567462],"length":1,"stats":{"Line":0}},{"line":21717,"address":[],"length":0,"stats":{"Line":0}},{"line":21718,"address":[],"length":0,"stats":{"Line":0}},{"line":21722,"address":[54567546],"length":1,"stats":{"Line":0}},{"line":21723,"address":[],"length":0,"stats":{"Line":0}},{"line":21724,"address":[56309133],"length":1,"stats":{"Line":0}},{"line":21726,"address":[54757086],"length":1,"stats":{"Line":0}},{"line":21727,"address":[],"length":0,"stats":{"Line":0}},{"line":21728,"address":[54757096],"length":1,"stats":{"Line":0}},{"line":21733,"address":[53735609],"length":1,"stats":{"Line":0}},{"line":21734,"address":[56309341],"length":1,"stats":{"Line":0}},{"line":21735,"address":[54567809],"length":1,"stats":{"Line":0}},{"line":21736,"address":[],"length":0,"stats":{"Line":0}},{"line":21737,"address":[53735704],"length":1,"stats":{"Line":0}},{"line":21739,"address":[],"length":0,"stats":{"Line":0}},{"line":21740,"address":[],"length":0,"stats":{"Line":0}},{"line":21741,"address":[54567895],"length":1,"stats":{"Line":0}},{"line":21744,"address":[53735855],"length":1,"stats":{"Line":0}},{"line":21745,"address":[],"length":0,"stats":{"Line":0}},{"line":21746,"address":[],"length":0,"stats":{"Line":0}},{"line":21754,"address":[54757649],"length":1,"stats":{"Line":0}},{"line":21756,"address":[],"length":0,"stats":{"Line":0}},{"line":21757,"address":[54568225],"length":1,"stats":{"Line":0}},{"line":21762,"address":[54757929],"length":1,"stats":{"Line":0}},{"line":21766,"address":[54524960],"length":1,"stats":{"Line":0}},{"line":21770,"address":[54715079],"length":1,"stats":{"Line":0}},{"line":21771,"address":[],"length":0,"stats":{"Line":0}},{"line":21772,"address":[56267398],"length":1,"stats":{"Line":0}},{"line":21773,"address":[53693174],"length":1,"stats":{"Line":0}},{"line":21774,"address":[],"length":0,"stats":{"Line":0}},{"line":21775,"address":[56267467],"length":1,"stats":{"Line":0}},{"line":21779,"address":[],"length":0,"stats":{"Line":0}},{"line":21780,"address":[],"length":0,"stats":{"Line":0}},{"line":21781,"address":[],"length":0,"stats":{"Line":0}},{"line":21783,"address":[54715502],"length":1,"stats":{"Line":0}},{"line":21784,"address":[],"length":0,"stats":{"Line":0}},{"line":21785,"address":[54525454],"length":1,"stats":{"Line":0}},{"line":21790,"address":[56267713],"length":1,"stats":{"Line":0}},{"line":21791,"address":[],"length":0,"stats":{"Line":0}},{"line":21792,"address":[],"length":0,"stats":{"Line":0}},{"line":21798,"address":[54715756],"length":1,"stats":{"Line":0}},{"line":21799,"address":[],"length":0,"stats":{"Line":0}},{"line":21800,"address":[56267878],"length":1,"stats":{"Line":0}},{"line":21802,"address":[],"length":0,"stats":{"Line":0}},{"line":21803,"address":[],"length":0,"stats":{"Line":0}},{"line":21804,"address":[56267962],"length":1,"stats":{"Line":0}},{"line":21808,"address":[54715920],"length":1,"stats":{"Line":0}},{"line":21809,"address":[54715969],"length":1,"stats":{"Line":0}},{"line":21810,"address":[],"length":0,"stats":{"Line":0}},{"line":21811,"address":[53693815],"length":1,"stats":{"Line":0}},{"line":21813,"address":[],"length":0,"stats":{"Line":0}},{"line":21814,"address":[],"length":0,"stats":{"Line":0}},{"line":21815,"address":[],"length":0,"stats":{"Line":0}},{"line":21818,"address":[56268235],"length":1,"stats":{"Line":0}},{"line":21819,"address":[53693981],"length":1,"stats":{"Line":0}},{"line":21822,"address":[54526224],"length":1,"stats":{"Line":0}},{"line":21823,"address":[],"length":0,"stats":{"Line":0}},{"line":21825,"address":[],"length":0,"stats":{"Line":0}},{"line":21826,"address":[],"length":0,"stats":{"Line":0}},{"line":21830,"address":[56268506],"length":1,"stats":{"Line":0}},{"line":21831,"address":[],"length":0,"stats":{"Line":0}},{"line":21832,"address":[],"length":0,"stats":{"Line":0}},{"line":21835,"address":[],"length":0,"stats":{"Line":0}},{"line":21839,"address":[54521472],"length":1,"stats":{"Line":0}},{"line":21844,"address":[53689447],"length":1,"stats":{"Line":0}},{"line":21845,"address":[54521730],"length":1,"stats":{"Line":0}},{"line":21847,"address":[56264081],"length":1,"stats":{"Line":0}},{"line":21848,"address":[54712026],"length":1,"stats":{"Line":0}},{"line":21849,"address":[53689887],"length":1,"stats":{"Line":0}},{"line":21850,"address":[],"length":0,"stats":{"Line":0}},{"line":21851,"address":[],"length":0,"stats":{"Line":0}},{"line":21855,"address":[53689971],"length":1,"stats":{"Line":0}},{"line":21856,"address":[],"length":0,"stats":{"Line":0}},{"line":21857,"address":[56264292],"length":1,"stats":{"Line":0}},{"line":21859,"address":[54522157],"length":1,"stats":{"Line":0}},{"line":21860,"address":[],"length":0,"stats":{"Line":0}},{"line":21861,"address":[53690055],"length":1,"stats":{"Line":0}},{"line":21866,"address":[],"length":0,"stats":{"Line":0}},{"line":21867,"address":[54712388],"length":1,"stats":{"Line":0}},{"line":21868,"address":[],"length":0,"stats":{"Line":0}},{"line":21869,"address":[],"length":0,"stats":{"Line":0}},{"line":21870,"address":[54522353],"length":1,"stats":{"Line":0}},{"line":21872,"address":[56264629],"length":1,"stats":{"Line":0}},{"line":21873,"address":[],"length":0,"stats":{"Line":0}},{"line":21874,"address":[54522440],"length":1,"stats":{"Line":0}},{"line":21877,"address":[53690395],"length":1,"stats":{"Line":0}},{"line":21878,"address":[],"length":0,"stats":{"Line":0}},{"line":21879,"address":[56264716],"length":1,"stats":{"Line":0}},{"line":21887,"address":[54522737],"length":1,"stats":{"Line":0}},{"line":21888,"address":[],"length":0,"stats":{"Line":0}},{"line":21889,"address":[53690632],"length":1,"stats":{"Line":0}},{"line":21891,"address":[54712893],"length":1,"stats":{"Line":0}},{"line":21892,"address":[54712941],"length":1,"stats":{"Line":0}},{"line":21894,"address":[56265097],"length":1,"stats":{"Line":0}},{"line":21895,"address":[53690813],"length":1,"stats":{"Line":0}},{"line":21898,"address":[54713129],"length":1,"stats":{"Line":0}},{"line":21899,"address":[],"length":0,"stats":{"Line":0}},{"line":21900,"address":[54523063],"length":1,"stats":{"Line":0}},{"line":21902,"address":[53691023],"length":1,"stats":{"Line":0}},{"line":21906,"address":[],"length":0,"stats":{"Line":0}},{"line":21908,"address":[],"length":0,"stats":{"Line":0}},{"line":21909,"address":[54713316],"length":1,"stats":{"Line":0}},{"line":21913,"address":[],"length":0,"stats":{"Line":0}},{"line":21914,"address":[53691284],"length":1,"stats":{"Line":0}},{"line":21917,"address":[54523525],"length":1,"stats":{"Line":0}},{"line":21919,"address":[54523543],"length":1,"stats":{"Line":0}},{"line":21920,"address":[56265735],"length":1,"stats":{"Line":0}},{"line":21928,"address":[],"length":0,"stats":{"Line":0}},{"line":21932,"address":[54887392],"length":1,"stats":{"Line":0}},{"line":21937,"address":[],"length":0,"stats":{"Line":0}},{"line":21938,"address":[54055538],"length":1,"stats":{"Line":0}},{"line":21940,"address":[54055690],"length":1,"stats":{"Line":0}},{"line":21941,"address":[55073279],"length":1,"stats":{"Line":0}},{"line":21942,"address":[55073344],"length":1,"stats":{"Line":0}},{"line":21943,"address":[],"length":0,"stats":{"Line":0}},{"line":21944,"address":[54055819],"length":1,"stats":{"Line":0}},{"line":21946,"address":[],"length":0,"stats":{"Line":0}},{"line":21947,"address":[],"length":0,"stats":{"Line":0}},{"line":21948,"address":[55073435],"length":1,"stats":{"Line":0}},{"line":21952,"address":[54055987],"length":1,"stats":{"Line":0}},{"line":21953,"address":[],"length":0,"stats":{"Line":0}},{"line":21954,"address":[55073522],"length":1,"stats":{"Line":0}},{"line":21956,"address":[55073587],"length":1,"stats":{"Line":0}},{"line":21957,"address":[],"length":0,"stats":{"Line":0}},{"line":21958,"address":[],"length":0,"stats":{"Line":0}},{"line":21961,"address":[54888287],"length":1,"stats":{"Line":0}},{"line":21962,"address":[],"length":0,"stats":{"Line":0}},{"line":21963,"address":[55073706],"length":1,"stats":{"Line":0}},{"line":21965,"address":[54888361],"length":1,"stats":{"Line":0}},{"line":21966,"address":[],"length":0,"stats":{"Line":0}},{"line":21967,"address":[55073781],"length":1,"stats":{"Line":0}},{"line":21972,"address":[54888473],"length":1,"stats":{"Line":0}},{"line":21975,"address":[54888552],"length":1,"stats":{"Line":0}},{"line":21976,"address":[54056484],"length":1,"stats":{"Line":0}},{"line":21977,"address":[],"length":0,"stats":{"Line":0}},{"line":21978,"address":[],"length":0,"stats":{"Line":0}},{"line":21979,"address":[55074061],"length":1,"stats":{"Line":0}},{"line":21981,"address":[],"length":0,"stats":{"Line":0}},{"line":21982,"address":[],"length":0,"stats":{"Line":0}},{"line":21983,"address":[],"length":0,"stats":{"Line":0}},{"line":21986,"address":[55074203],"length":1,"stats":{"Line":0}},{"line":21987,"address":[],"length":0,"stats":{"Line":0}},{"line":21988,"address":[54888816],"length":1,"stats":{"Line":0}},{"line":21996,"address":[54056919],"length":1,"stats":{"Line":0}},{"line":21997,"address":[],"length":0,"stats":{"Line":0}},{"line":21998,"address":[56626597],"length":1,"stats":{"Line":0}},{"line":22000,"address":[56626667],"length":1,"stats":{"Line":0}},{"line":22001,"address":[54057048],"length":1,"stats":{"Line":0}},{"line":22003,"address":[55074599],"length":1,"stats":{"Line":0}},{"line":22004,"address":[54057107],"length":1,"stats":{"Line":0}},{"line":22007,"address":[55074743],"length":1,"stats":{"Line":0}},{"line":22008,"address":[],"length":0,"stats":{"Line":0}},{"line":22009,"address":[54057245],"length":1,"stats":{"Line":0}},{"line":22011,"address":[56626980],"length":1,"stats":{"Line":0}},{"line":22014,"address":[55074868],"length":1,"stats":{"Line":0}},{"line":22016,"address":[54889526],"length":1,"stats":{"Line":0}},{"line":22017,"address":[55074930],"length":1,"stats":{"Line":0}},{"line":22021,"address":[],"length":0,"stats":{"Line":0}},{"line":22022,"address":[55075077],"length":1,"stats":{"Line":0}},{"line":22025,"address":[54057728],"length":1,"stats":{"Line":0}},{"line":22026,"address":[],"length":0,"stats":{"Line":0}},{"line":22027,"address":[],"length":0,"stats":{"Line":0}},{"line":22029,"address":[],"length":0,"stats":{"Line":0}},{"line":22031,"address":[],"length":0,"stats":{"Line":0}},{"line":22032,"address":[54889963],"length":1,"stats":{"Line":0}},{"line":22038,"address":[54058129],"length":1,"stats":{"Line":0}},{"line":22039,"address":[],"length":0,"stats":{"Line":0}},{"line":22040,"address":[54058136],"length":1,"stats":{"Line":0}},{"line":22043,"address":[56627863],"length":1,"stats":{"Line":0}},{"line":22044,"address":[55075721],"length":1,"stats":{"Line":0}},{"line":22048,"address":[],"length":0,"stats":{"Line":0}},{"line":22049,"address":[55075877],"length":1,"stats":{"Line":0}},{"line":22052,"address":[],"length":0,"stats":{"Line":0}},{"line":22053,"address":[],"length":0,"stats":{"Line":0}},{"line":22054,"address":[54890659],"length":1,"stats":{"Line":0}},{"line":22056,"address":[],"length":0,"stats":{"Line":0}},{"line":22058,"address":[54058648],"length":1,"stats":{"Line":0}},{"line":22059,"address":[54058663],"length":1,"stats":{"Line":0}},{"line":22067,"address":[],"length":0,"stats":{"Line":0}},{"line":22071,"address":[53679040],"length":1,"stats":{"Line":0}},{"line":22078,"address":[54701527],"length":1,"stats":{"Line":0}},{"line":22079,"address":[56253808],"length":1,"stats":{"Line":0}},{"line":22081,"address":[],"length":0,"stats":{"Line":0}},{"line":22082,"address":[54701911],"length":1,"stats":{"Line":0}},{"line":22083,"address":[],"length":0,"stats":{"Line":0}},{"line":22084,"address":[53679570],"length":1,"stats":{"Line":0}},{"line":22088,"address":[],"length":0,"stats":{"Line":0}},{"line":22089,"address":[],"length":0,"stats":{"Line":0}},{"line":22090,"address":[54511769],"length":1,"stats":{"Line":0}},{"line":22098,"address":[54511974],"length":1,"stats":{"Line":0}},{"line":22099,"address":[],"length":0,"stats":{"Line":0}},{"line":22100,"address":[],"length":0,"stats":{"Line":0}},{"line":22101,"address":[],"length":0,"stats":{"Line":0}},{"line":22102,"address":[54702478],"length":1,"stats":{"Line":0}},{"line":22104,"address":[53680209],"length":1,"stats":{"Line":0}},{"line":22105,"address":[53680224],"length":1,"stats":{"Line":0}},{"line":22109,"address":[54512115],"length":1,"stats":{"Line":0}},{"line":22113,"address":[],"length":0,"stats":{"Line":0}},{"line":22114,"address":[],"length":0,"stats":{"Line":0}},{"line":22115,"address":[],"length":0,"stats":{"Line":0}},{"line":22117,"address":[],"length":0,"stats":{"Line":0}},{"line":22118,"address":[56254904],"length":1,"stats":{"Line":0}},{"line":22119,"address":[],"length":0,"stats":{"Line":0}},{"line":22120,"address":[],"length":0,"stats":{"Line":0}},{"line":22124,"address":[53680538],"length":1,"stats":{"Line":0}},{"line":22125,"address":[56255027],"length":1,"stats":{"Line":0}},{"line":22126,"address":[],"length":0,"stats":{"Line":0}},{"line":22127,"address":[54512701],"length":1,"stats":{"Line":0}},{"line":22129,"address":[54702987],"length":1,"stats":{"Line":0}},{"line":22130,"address":[],"length":0,"stats":{"Line":0}},{"line":22131,"address":[],"length":0,"stats":{"Line":0}},{"line":22140,"address":[56255318],"length":1,"stats":{"Line":0}},{"line":22141,"address":[],"length":0,"stats":{"Line":0}},{"line":22144,"address":[56255529],"length":1,"stats":{"Line":0}},{"line":22148,"address":[54064432],"length":1,"stats":{"Line":0}},{"line":22152,"address":[54064478],"length":1,"stats":{"Line":0}},{"line":22153,"address":[54064611],"length":1,"stats":{"Line":0}},{"line":22154,"address":[55082051],"length":1,"stats":{"Line":0}},{"line":22155,"address":[],"length":0,"stats":{"Line":0}},{"line":22156,"address":[55082058],"length":1,"stats":{"Line":0}},{"line":22161,"address":[55082134],"length":1,"stats":{"Line":0}},{"line":22162,"address":[55082166],"length":1,"stats":{"Line":0}},{"line":22163,"address":[56634368],"length":1,"stats":{"Line":0}},{"line":22164,"address":[54064880],"length":1,"stats":{"Line":0}},{"line":22166,"address":[54897068],"length":1,"stats":{"Line":0}},{"line":22170,"address":[54060416],"length":1,"stats":{"Line":0}},{"line":22174,"address":[54892574],"length":1,"stats":{"Line":0}},{"line":22175,"address":[56630210],"length":1,"stats":{"Line":0}},{"line":22176,"address":[56630245],"length":1,"stats":{"Line":0}},{"line":22177,"address":[],"length":0,"stats":{"Line":0}},{"line":22178,"address":[54060638],"length":1,"stats":{"Line":0}},{"line":22183,"address":[54060716],"length":1,"stats":{"Line":0}},{"line":22184,"address":[56630360],"length":1,"stats":{"Line":0}},{"line":22185,"address":[54892895],"length":1,"stats":{"Line":0}},{"line":22186,"address":[],"length":0,"stats":{"Line":0}},{"line":22187,"address":[54060790],"length":1,"stats":{"Line":0}},{"line":22189,"address":[54060859],"length":1,"stats":{"Line":0}},{"line":22191,"address":[54060935],"length":1,"stats":{"Line":0}},{"line":22195,"address":[55075352,55075346,55074912],"length":1,"stats":{"Line":0}},{"line":22197,"address":[],"length":0,"stats":{"Line":0}},{"line":22198,"address":[],"length":0,"stats":{"Line":0}},{"line":22199,"address":[],"length":0,"stats":{"Line":0}},{"line":22200,"address":[54242879],"length":1,"stats":{"Line":0}},{"line":22202,"address":[55075249,55075333],"length":1,"stats":{"Line":0}},{"line":22203,"address":[55257464],"length":1,"stats":{"Line":0}},{"line":22204,"address":[55257491],"length":1,"stats":{"Line":0}}],"covered":1716,"coverable":12422},{"path":["/","home","md","language","mdhavers","src","llvm","compiler.rs"],"content":"//! Main LLVM compiler interface\n//!\n//! Provides high-level API for compiling mdhavers to LLVM IR, object files,\n//! and native executables.\n\nuse std::io::Write;\nuse std::path::Path;\nuse std::process::Command;\n\n/// Embedded runtime object file - compiled into the binary at build time\nstatic EMBEDDED_RUNTIME: &[u8] = include_bytes!(\"../../runtime/mdh_runtime.o\");\n\n/// Embedded GC stub - minimal malloc wrappers for standalone builds\nstatic EMBEDDED_GC_STUB: &[u8] = include_bytes!(\"../../runtime/gc_stub.o\");\n\nuse inkwell::context::Context;\nuse inkwell::module::Module;\nuse inkwell::passes::PassManager;\nuse inkwell::targets::{\n    CodeModel, FileType, InitializationConfig, RelocMode, Target, TargetMachine,\n};\nuse inkwell::OptimizationLevel;\n\nuse crate::ast::Program;\nuse crate::error::HaversError;\n\nuse super::codegen::CodeGen;\n\n/// LLVM Compiler for mdhavers\npub struct LLVMCompiler {\n    // Configuration options\n    opt_level: OptimizationLevel,\n}\n\nimpl LLVMCompiler {\n    pub fn new() -> Self {\n        LLVMCompiler {\n            opt_level: OptimizationLevel::Default,\n        }\n    }\n\n    /// Set optimization level (0-3)\n    pub fn with_optimization(mut self, level: u8) -> Self {\n        self.opt_level = match level {\n            0 => OptimizationLevel::None,\n            1 => OptimizationLevel::Less,\n            2 => OptimizationLevel::Default,\n            _ => OptimizationLevel::Aggressive,\n        };\n        self\n    }\n\n    /// Compile to LLVM IR (text format)\n    pub fn compile_to_ir(&self, program: &Program) -> Result<String, HaversError> {\n        let context = Context::create();\n        let mut codegen = CodeGen::new(&context, \"mdhavers_module\");\n\n        codegen.compile(program)?;\n\n        Ok(codegen.get_module().print_to_string().to_string())\n    }\n\n    /// Compile to object file\n    #[allow(dead_code)]\n    pub fn compile_to_object(\n        &self,\n        program: &Program,\n        output_path: &Path,\n    ) -> Result<(), HaversError> {\n        self.compile_to_object_with_source(program, output_path, None)\n    }\n\n    /// Compile to object file with source path for import resolution\n    pub fn compile_to_object_with_source(\n        &self,\n        program: &Program,\n        output_path: &Path,\n        source_path: Option<&Path>,\n    ) -> Result<(), HaversError> {\n        let context = Context::create();\n        let mut codegen = CodeGen::new(&context, \"mdhavers_module\");\n        if let Some(path) = source_path {\n            codegen.set_source_path(path);\n        }\n\n        codegen.compile(program)?;\n\n        // Initialize native target\n        Target::initialize_native(&InitializationConfig::default()).map_err(|e| {\n            HaversError::CompileError(format!(\"Failed to initialize target: {}\", e))\n        })?;\n\n        let target_triple = TargetMachine::get_default_triple();\n        let target = Target::from_triple(&target_triple)\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to get target: {}\", e)))?;\n\n        let target_machine = target\n            .create_target_machine(\n                &target_triple,\n                \"generic\",\n                \"\",\n                self.opt_level,\n                RelocMode::PIC, // Use PIC for PIE executables\n                CodeModel::Default,\n            )\n            .ok_or_else(|| {\n                HaversError::CompileError(\"Failed to create target machine\".to_string())\n            })?;\n\n        // Run optimization passes\n        self.run_optimization_passes(codegen.get_module())?;\n\n        // Write object file\n        target_machine\n            .write_to_file(codegen.get_module(), FileType::Object, output_path)\n            .map_err(|e| {\n                HaversError::CompileError(format!(\"Failed to write object file: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    /// Compile to native executable\n    #[allow(dead_code)]\n    pub fn compile_to_native(\n        &self,\n        program: &Program,\n        output_path: &Path,\n        opt_level: u8,\n    ) -> Result<(), HaversError> {\n        self.compile_to_native_with_source(program, output_path, opt_level, None)\n    }\n\n    /// Compile to native executable with source path for import resolution\n    pub fn compile_to_native_with_source(\n        &self,\n        program: &Program,\n        output_path: &Path,\n        opt_level: u8,\n        source_path: Option<&Path>,\n    ) -> Result<(), HaversError> {\n        // First compile to object file\n        let obj_path = output_path.with_extension(\"o\");\n        let compiler = LLVMCompiler::new().with_optimization(opt_level);\n        compiler.compile_to_object_with_source(program, &obj_path, source_path)?;\n\n        // Generate unique temp file names using process ID and a counter\n        // This avoids race conditions when tests run in parallel\n        let unique_id = format!(\"{}_{:?}\", std::process::id(), std::thread::current().id());\n        let runtime_path = std::env::temp_dir().join(format!(\"mdh_runtime_{}.o\", unique_id));\n        let gc_stub_path = std::env::temp_dir().join(format!(\"mdh_gc_stub_{}.o\", unique_id));\n\n        // Write embedded runtime to temp file for linking\n        std::fs::File::create(&runtime_path)\n            .and_then(|mut f| f.write_all(EMBEDDED_RUNTIME))\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to write runtime: {}\", e)))?;\n\n        // Write embedded GC stub to temp file for linking\n        std::fs::File::create(&gc_stub_path)\n            .and_then(|mut f| f.write_all(EMBEDDED_GC_STUB))\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to write GC stub: {}\", e)))?;\n\n        // Link with system linker\n        let status = Command::new(\"cc\")\n            .args([\n                obj_path.to_str().unwrap(),\n                runtime_path.to_str().unwrap(),\n                gc_stub_path.to_str().unwrap(),\n                \"-lm\", // Math library (for floor, ceil, etc.)\n                \"-o\",\n                output_path.to_str().unwrap(),\n            ])\n            .status()\n            .map_err(|e| HaversError::CompileError(format!(\"Failed to run linker: {}\", e)))?;\n\n        // Clean up temp files\n        let _ = std::fs::remove_file(&obj_path);\n        let _ = std::fs::remove_file(&runtime_path);\n        let _ = std::fs::remove_file(&gc_stub_path);\n\n        if status.success() {\n            Ok(())\n        } else {\n            Err(HaversError::CompileError(format!(\n                \"Linker failed with exit code: {:?}\",\n                status.code()\n            )))\n        }\n    }\n\n    /// Run LLVM optimization passes\n    fn run_optimization_passes(&self, module: &Module) -> Result<(), HaversError> {\n        // Verify the module first\n        if let Err(e) = module.verify() {\n            return Err(HaversError::CompileError(format!(\n                \"Module verification failed: {}\",\n                e.to_string()\n            )));\n        }\n\n        // Skip optimization if level is None\n        if matches!(self.opt_level, OptimizationLevel::None) {\n            return Ok(());\n        }\n\n        // Create function pass manager\n        let fpm: PassManager<inkwell::values::FunctionValue> = PassManager::create(module);\n\n        // Add passes based on optimization level\n        match self.opt_level {\n            OptimizationLevel::Less => {\n                // -O1: Basic optimizations\n                fpm.add_instruction_combining_pass();\n                fpm.add_reassociate_pass();\n                fpm.add_gvn_pass();\n                fpm.add_cfg_simplification_pass();\n                fpm.add_basic_alias_analysis_pass();\n                fpm.add_promote_memory_to_register_pass();\n            }\n            OptimizationLevel::Default => {\n                // -O2: Standard optimizations\n                fpm.add_instruction_combining_pass();\n                fpm.add_reassociate_pass();\n                fpm.add_gvn_pass();\n                fpm.add_cfg_simplification_pass();\n                fpm.add_basic_alias_analysis_pass();\n                fpm.add_promote_memory_to_register_pass();\n                fpm.add_instruction_combining_pass();\n                fpm.add_tail_call_elimination_pass();\n                fpm.add_dead_store_elimination_pass();\n                fpm.add_loop_unroll_pass();\n                fpm.add_licm_pass();\n            }\n            OptimizationLevel::Aggressive => {\n                // -O3: Aggressive optimizations\n                fpm.add_instruction_combining_pass();\n                fpm.add_reassociate_pass();\n                fpm.add_gvn_pass();\n                fpm.add_cfg_simplification_pass();\n                fpm.add_basic_alias_analysis_pass();\n                fpm.add_promote_memory_to_register_pass();\n                fpm.add_instruction_combining_pass();\n                fpm.add_tail_call_elimination_pass();\n                fpm.add_dead_store_elimination_pass();\n                fpm.add_loop_unroll_pass();\n                fpm.add_licm_pass();\n                fpm.add_aggressive_dce_pass();\n                fpm.add_scalarizer_pass();\n                fpm.add_merged_load_store_motion_pass();\n                fpm.add_ind_var_simplify_pass();\n                fpm.add_loop_vectorize_pass();\n                fpm.add_slp_vectorize_pass();\n            }\n            OptimizationLevel::None => {}\n        }\n\n        fpm.initialize();\n\n        // Run on all functions\n        for func in module.get_functions() {\n            fpm.run_on(&func);\n        }\n\n        fpm.finalize();\n\n        Ok(())\n    }\n}\n\nimpl Default for LLVMCompiler {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::parse;\n\n    #[test]\n    fn test_compile_simple() {\n        let source = r#\"\n            ken x = 42\n            blether x\n        \"#;\n\n        let program = parse(source).unwrap();\n        let compiler = LLVMCompiler::new();\n        let ir = compiler.compile_to_ir(&program).unwrap();\n\n        assert!(ir.contains(\"define i32 @main\"));\n        // Check for inlined integer creation: { i8 2, i64 42 }\n        assert!(ir.contains(\"i8 2\") || ir.contains(\"insertvalue\"));\n        // Check for printf call (used by blether)\n        assert!(ir.contains(\"@printf\"));\n    }\n\n    #[test]\n    fn test_compile_function() {\n        let source = r#\"\n            dae add(a, b) {\n                gie a + b\n            }\n\n            ken result = add(1, 2)\n            blether result\n        \"#;\n\n        let program = parse(source).unwrap();\n        let compiler = LLVMCompiler::new();\n        let ir = compiler.compile_to_ir(&program).unwrap();\n\n        assert!(ir.contains(\"define\"));\n        assert!(ir.contains(\"@add\"));\n    }\n\n    #[test]\n    fn test_compile_control_flow() {\n        let source = r#\"\n            ken x = 10\n            gin x > 5 {\n                blether \"big\"\n            } ither {\n                blether \"small\"\n            }\n        \"#;\n\n        let program = parse(source).unwrap();\n        let compiler = LLVMCompiler::new();\n        let ir = compiler.compile_to_ir(&program).unwrap();\n\n        assert!(ir.contains(\"br i1\")); // Conditional branch\n        assert!(ir.contains(\"then\"));\n        assert!(ir.contains(\"else\"));\n    }\n\n    #[test]\n    fn test_compile_loop() {\n        let source = r#\"\n            ken i = 0\n            whiles i < 10 {\n                blether i\n                i = i + 1\n            }\n        \"#;\n\n        let program = parse(source).unwrap();\n        let compiler = LLVMCompiler::new();\n        let ir = compiler.compile_to_ir(&program).unwrap();\n\n        assert!(ir.contains(\"loop\"));\n        assert!(ir.contains(\"body\"));\n    }\n}\n","traces":[{"line":43,"address":[54982352],"length":1,"stats":{"Line":2}},{"line":44,"address":[55596575,55596639],"length":1,"stats":{"Line":12}},{"line":45,"address":[55814515],"length":1,"stats":{"Line":0}},{"line":46,"address":[55814525],"length":1,"stats":{"Line":0}},{"line":47,"address":[54982423],"length":1,"stats":{"Line":2}},{"line":48,"address":[55596601],"length":1,"stats":{"Line":0}},{"line":50,"address":[54982439],"length":1,"stats":{"Line":8}},{"line":54,"address":[54981520,54982166,54982160],"length":1,"stats":{"Line":2}},{"line":55,"address":[55595798],"length":1,"stats":{"Line":4}},{"line":56,"address":[54383524],"length":1,"stats":{"Line":6}},{"line":58,"address":[55595957,55595900],"length":1,"stats":{"Line":10}},{"line":60,"address":[55813978,55814103],"length":1,"stats":{"Line":4}},{"line":65,"address":[54384208],"length":1,"stats":{"Line":0}},{"line":70,"address":[55596528],"length":1,"stats":{"Line":0}},{"line":74,"address":[54389552,54391526,54391571],"length":1,"stats":{"Line":7}},{"line":80,"address":[54987993],"length":1,"stats":{"Line":7}},{"line":81,"address":[54988010],"length":1,"stats":{"Line":7}},{"line":82,"address":[54988093],"length":1,"stats":{"Line":9}},{"line":83,"address":[54988156,54988254],"length":1,"stats":{"Line":0}},{"line":86,"address":[54988256,54988183,54989985],"length":1,"stats":{"Line":20}},{"line":89,"address":[55602324,55602569,55603823],"length":1,"stats":{"Line":6}},{"line":90,"address":[54655766,54655826],"length":1,"stats":{"Line":0}},{"line":93,"address":[54390322],"length":1,"stats":{"Line":8}},{"line":94,"address":[55602737,55602623,55603806,55602844],"length":1,"stats":{"Line":12}},{"line":95,"address":[54390508,54390442],"length":1,"stats":{"Line":8}},{"line":97,"address":[54989250,54989123,54989960],"length":1,"stats":{"Line":8}},{"line":102,"address":[55602901],"length":1,"stats":{"Line":8}},{"line":106,"address":[54980896],"length":1,"stats":{"Line":6}},{"line":107,"address":[54980910],"length":1,"stats":{"Line":0}},{"line":111,"address":[54989933,54989303,54989392],"length":1,"stats":{"Line":14}},{"line":114,"address":[55821896,55822024,55821769],"length":1,"stats":{"Line":5}},{"line":115,"address":[55821667],"length":1,"stats":{"Line":5}},{"line":116,"address":[53978432,53978667,53978673],"length":1,"stats":{"Line":11}},{"line":117,"address":[54655575,54655510],"length":1,"stats":{"Line":0}},{"line":120,"address":[55603666],"length":1,"stats":{"Line":9}},{"line":125,"address":[55596416],"length":1,"stats":{"Line":5}},{"line":131,"address":[54384167],"length":1,"stats":{"Line":3}},{"line":135,"address":[54987794,54987860,54983984],"length":1,"stats":{"Line":2}},{"line":143,"address":[55598237],"length":1,"stats":{"Line":6}},{"line":144,"address":[54984279,54984203],"length":1,"stats":{"Line":8}},{"line":145,"address":[54386086,54389526],"length":1,"stats":{"Line":6}},{"line":149,"address":[54984574],"length":1,"stats":{"Line":3}},{"line":150,"address":[54984937,54985008],"length":1,"stats":{"Line":16}},{"line":151,"address":[54985337],"length":1,"stats":{"Line":12}},{"line":154,"address":[54985774,54987802,54985901,54985693],"length":1,"stats":{"Line":16}},{"line":155,"address":[54654352,54654360],"length":1,"stats":{"Line":28}},{"line":156,"address":[54654720,54654742],"length":1,"stats":{"Line":4}},{"line":159,"address":[54387666,54387735,54389468,54387842],"length":1,"stats":{"Line":16}},{"line":160,"address":[55599969],"length":1,"stats":{"Line":28}},{"line":161,"address":[55600066,55600000],"length":1,"stats":{"Line":4}},{"line":164,"address":[55600978,55601085,55600155],"length":1,"stats":{"Line":14}},{"line":165,"address":[55600769],"length":1,"stats":{"Line":4}},{"line":166,"address":[55600277,55600194],"length":1,"stats":{"Line":16}},{"line":167,"address":[54388102],"length":1,"stats":{"Line":12}},{"line":168,"address":[54388254],"length":1,"stats":{"Line":4}},{"line":171,"address":[55600666],"length":1,"stats":{"Line":12}},{"line":174,"address":[54980128,54980150],"length":1,"stats":{"Line":20}},{"line":177,"address":[55601158],"length":1,"stats":{"Line":10}},{"line":178,"address":[55819362],"length":1,"stats":{"Line":11}},{"line":179,"address":[55601262],"length":1,"stats":{"Line":10}},{"line":181,"address":[54389042,54389101],"length":1,"stats":{"Line":22}},{"line":182,"address":[55601366],"length":1,"stats":{"Line":10}},{"line":184,"address":[54987456],"length":1,"stats":{"Line":0}},{"line":186,"address":[55819554,55819511],"length":1,"stats":{"Line":0}},{"line":192,"address":[54982448,54982905,54982911],"length":1,"stats":{"Line":5}},{"line":194,"address":[54982499],"length":1,"stats":{"Line":9}},{"line":195,"address":[54384540],"length":1,"stats":{"Line":0}},{"line":197,"address":[54384456],"length":1,"stats":{"Line":0}},{"line":202,"address":[55814677],"length":1,"stats":{"Line":5}},{"line":203,"address":[54384849],"length":1,"stats":{"Line":0}},{"line":207,"address":[55815055],"length":1,"stats":{"Line":9}},{"line":210,"address":[54982968],"length":1,"stats":{"Line":5}},{"line":213,"address":[55597232],"length":1,"stats":{"Line":0}},{"line":214,"address":[55815239],"length":1,"stats":{"Line":0}},{"line":215,"address":[55815258],"length":1,"stats":{"Line":0}},{"line":216,"address":[55815277],"length":1,"stats":{"Line":0}},{"line":217,"address":[55597368],"length":1,"stats":{"Line":0}},{"line":218,"address":[55597383],"length":1,"stats":{"Line":0}},{"line":222,"address":[55815151],"length":1,"stats":{"Line":9}},{"line":223,"address":[54983227],"length":1,"stats":{"Line":6}},{"line":224,"address":[54385130],"length":1,"stats":{"Line":10}},{"line":225,"address":[54385145],"length":1,"stats":{"Line":6}},{"line":226,"address":[55815396],"length":1,"stats":{"Line":10}},{"line":227,"address":[55815415],"length":1,"stats":{"Line":6}},{"line":228,"address":[54983322],"length":1,"stats":{"Line":10}},{"line":229,"address":[55597493],"length":1,"stats":{"Line":6}},{"line":230,"address":[54983360],"length":1,"stats":{"Line":10}},{"line":231,"address":[55597523],"length":1,"stats":{"Line":6}},{"line":232,"address":[54385250],"length":1,"stats":{"Line":10}},{"line":236,"address":[54983061],"length":1,"stats":{"Line":0}},{"line":237,"address":[55815534],"length":1,"stats":{"Line":0}},{"line":238,"address":[55597573],"length":1,"stats":{"Line":0}},{"line":239,"address":[55597588],"length":1,"stats":{"Line":0}},{"line":240,"address":[55597603],"length":1,"stats":{"Line":0}},{"line":241,"address":[54983498],"length":1,"stats":{"Line":0}},{"line":242,"address":[55597633],"length":1,"stats":{"Line":0}},{"line":243,"address":[55597648],"length":1,"stats":{"Line":0}},{"line":244,"address":[55597663],"length":1,"stats":{"Line":0}},{"line":245,"address":[55815686],"length":1,"stats":{"Line":0}},{"line":246,"address":[54385405],"length":1,"stats":{"Line":0}},{"line":247,"address":[55597708],"length":1,"stats":{"Line":0}},{"line":248,"address":[54385435],"length":1,"stats":{"Line":0}},{"line":249,"address":[55597738],"length":1,"stats":{"Line":0}},{"line":250,"address":[54983669],"length":1,"stats":{"Line":0}},{"line":251,"address":[54385480],"length":1,"stats":{"Line":0}},{"line":252,"address":[55815819],"length":1,"stats":{"Line":0}},{"line":257,"address":[55815110],"length":1,"stats":{"Line":6}},{"line":260,"address":[55597800],"length":1,"stats":{"Line":10}},{"line":261,"address":[55597973,55598029],"length":1,"stats":{"Line":16}},{"line":264,"address":[54385692],"length":1,"stats":{"Line":5}},{"line":266,"address":[54385716],"length":1,"stats":{"Line":8}},{"line":271,"address":[55595744],"length":1,"stats":{"Line":0}},{"line":272,"address":[55595745],"length":1,"stats":{"Line":0}}],"covered":74,"coverable":113},{"path":["/","home","md","language","mdhavers","src","llvm","mod.rs"],"content":"//! LLVM Backend for mdhavers\n//!\n//! Compiles mdhavers AST to LLVM IR for native code generation.\n//! Uses inkwell as a safe Rust wrapper around the LLVM C API.\n//!\n//! Note: This module is a work-in-progress. Some types and functions are\n//! defined but not yet used.\n\n#[allow(dead_code)]\npub mod builtins;\npub mod codegen;\npub mod compiler;\n#[allow(dead_code)]\npub mod runtime;\n#[allow(dead_code)]\npub mod types;\n\n// Re-export main types\npub use compiler::LLVMCompiler;\n#[allow(unused_imports)]\npub use types::{InferredType, MdhTypes, ValueTag};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","src","llvm","runtime.rs"],"content":"//! Runtime Function Declarations\n//!\n//! Declares external C runtime functions that provide the mdhavers runtime.\n\nuse inkwell::module::Module;\nuse inkwell::values::FunctionValue;\nuse inkwell::AddressSpace;\n\nuse super::types::MdhTypes;\n\n/// Collection of runtime function declarations\npub struct RuntimeFunctions<'ctx> {\n    // Value creation\n    pub make_nil: FunctionValue<'ctx>,\n    pub make_bool: FunctionValue<'ctx>,\n    pub make_int: FunctionValue<'ctx>,\n    pub make_float: FunctionValue<'ctx>,\n    pub make_string: FunctionValue<'ctx>,\n    pub make_list: FunctionValue<'ctx>,\n\n    // Arithmetic\n    pub add: FunctionValue<'ctx>,\n    pub sub: FunctionValue<'ctx>,\n    pub mul: FunctionValue<'ctx>,\n    pub div: FunctionValue<'ctx>,\n    pub modulo: FunctionValue<'ctx>,\n    pub neg: FunctionValue<'ctx>,\n\n    // Comparison\n    pub eq: FunctionValue<'ctx>,\n    pub ne: FunctionValue<'ctx>,\n    pub lt: FunctionValue<'ctx>,\n    pub le: FunctionValue<'ctx>,\n    pub gt: FunctionValue<'ctx>,\n    pub ge: FunctionValue<'ctx>,\n\n    // Logical\n    pub not: FunctionValue<'ctx>,\n    pub truthy: FunctionValue<'ctx>,\n\n    // Type operations\n    pub get_tag: FunctionValue<'ctx>,\n    pub type_of: FunctionValue<'ctx>,\n\n    // I/O\n    pub blether: FunctionValue<'ctx>,\n    pub speir: FunctionValue<'ctx>,\n    pub get_key: FunctionValue<'ctx>,\n\n    // List operations\n    pub list_get: FunctionValue<'ctx>,\n    pub list_set: FunctionValue<'ctx>,\n    pub list_push: FunctionValue<'ctx>,\n    pub list_pop: FunctionValue<'ctx>,\n    pub len: FunctionValue<'ctx>,\n\n    // String operations\n    pub str_concat: FunctionValue<'ctx>,\n    pub to_string: FunctionValue<'ctx>,\n    pub to_int: FunctionValue<'ctx>,\n    pub to_float: FunctionValue<'ctx>,\n\n    // Math\n    pub abs: FunctionValue<'ctx>,\n    pub random: FunctionValue<'ctx>,\n    pub floor: FunctionValue<'ctx>,\n    pub ceil: FunctionValue<'ctx>,\n    pub round: FunctionValue<'ctx>,\n}\n\nimpl<'ctx> RuntimeFunctions<'ctx> {\n    pub fn declare(module: &Module<'ctx>, types: &MdhTypes<'ctx>) -> Self {\n        let _context = module.get_context();\n        let value_type = types.value_type;\n        let i8_type = types.i8_type;\n        let i32_type = types.i32_type;\n        let i64_type = types.i64_type;\n        let f64_type = types.f64_type;\n        let bool_type = types.bool_type;\n        let void_type = types.void_type;\n        let str_ptr = i8_type.ptr_type(AddressSpace::default());\n\n        // Value creation functions\n        let make_nil = module.add_function(\"__mdh_make_nil\", value_type.fn_type(&[], false), None);\n\n        let make_bool = module.add_function(\n            \"__mdh_make_bool\",\n            value_type.fn_type(&[bool_type.into()], false),\n            None,\n        );\n\n        let make_int = module.add_function(\n            \"__mdh_make_int\",\n            value_type.fn_type(&[i64_type.into()], false),\n            None,\n        );\n\n        let make_float = module.add_function(\n            \"__mdh_make_float\",\n            value_type.fn_type(&[f64_type.into()], false),\n            None,\n        );\n\n        let make_string = module.add_function(\n            \"__mdh_make_string\",\n            value_type.fn_type(&[str_ptr.into()], false),\n            None,\n        );\n\n        let make_list = module.add_function(\n            \"__mdh_make_list\",\n            value_type.fn_type(&[i32_type.into()], false),\n            None,\n        );\n\n        // Arithmetic functions\n        let add = module.add_function(\n            \"__mdh_add\",\n            value_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let sub = module.add_function(\n            \"__mdh_sub\",\n            value_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let mul = module.add_function(\n            \"__mdh_mul\",\n            value_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let div = module.add_function(\n            \"__mdh_div\",\n            value_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let modulo = module.add_function(\n            \"__mdh_mod\",\n            value_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let neg = module.add_function(\n            \"__mdh_neg\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        // Comparison functions\n        let eq = module.add_function(\n            \"__mdh_eq\",\n            bool_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let ne = module.add_function(\n            \"__mdh_ne\",\n            bool_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let lt = module.add_function(\n            \"__mdh_lt\",\n            bool_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let le = module.add_function(\n            \"__mdh_le\",\n            bool_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let gt = module.add_function(\n            \"__mdh_gt\",\n            bool_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let ge = module.add_function(\n            \"__mdh_ge\",\n            bool_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        // Logical functions\n        let not = module.add_function(\n            \"__mdh_not\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let truthy = module.add_function(\n            \"__mdh_truthy\",\n            bool_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        // Type operations\n        let get_tag = module.add_function(\n            \"__mdh_get_tag\",\n            i8_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let type_of = module.add_function(\n            \"__mdh_type_of\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        // I/O\n        let blether = module.add_function(\n            \"__mdh_blether\",\n            void_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let speir = module.add_function(\n            \"__mdh_speir\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let get_key = module.add_function(\"__mdh_get_key\", value_type.fn_type(&[], false), None);\n\n        // List operations\n        let list_get = module.add_function(\n            \"__mdh_list_get\",\n            value_type.fn_type(&[value_type.into(), i64_type.into()], false),\n            None,\n        );\n\n        let list_set = module.add_function(\n            \"__mdh_list_set\",\n            void_type.fn_type(\n                &[value_type.into(), i64_type.into(), value_type.into()],\n                false,\n            ),\n            None,\n        );\n\n        let list_push = module.add_function(\n            \"__mdh_list_push\",\n            void_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let list_pop = module.add_function(\n            \"__mdh_list_pop\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let len = module.add_function(\n            \"__mdh_len\",\n            i64_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        // String operations\n        let str_concat = module.add_function(\n            \"__mdh_str_concat\",\n            value_type.fn_type(&[value_type.into(), value_type.into()], false),\n            None,\n        );\n\n        let to_string = module.add_function(\n            \"__mdh_to_string\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let to_int = module.add_function(\n            \"__mdh_to_int\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let to_float = module.add_function(\n            \"__mdh_to_float\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        // Math\n        let abs = module.add_function(\n            \"__mdh_abs\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let random = module.add_function(\n            \"__mdh_random\",\n            value_type.fn_type(&[i64_type.into(), i64_type.into()], false),\n            None,\n        );\n\n        let floor = module.add_function(\n            \"__mdh_floor\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let ceil = module.add_function(\n            \"__mdh_ceil\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        let round = module.add_function(\n            \"__mdh_round\",\n            value_type.fn_type(&[value_type.into()], false),\n            None,\n        );\n\n        RuntimeFunctions {\n            make_nil,\n            make_bool,\n            make_int,\n            make_float,\n            make_string,\n            make_list,\n            add,\n            sub,\n            mul,\n            div,\n            modulo,\n            neg,\n            eq,\n            ne,\n            lt,\n            le,\n            gt,\n            ge,\n            not,\n            truthy,\n            get_tag,\n            type_of,\n            blether,\n            speir,\n            get_key,\n            list_get,\n            list_set,\n            list_push,\n            list_pop,\n            len,\n            str_concat,\n            to_string,\n            to_int,\n            to_float,\n            abs,\n            random,\n            floor,\n            ceil,\n            round,\n        }\n    }\n}\n","traces":[{"line":72,"address":[54579744],"length":1,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[54579836],"length":1,"stats":{"Line":0}},{"line":75,"address":[54579855],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[55885853],"length":1,"stats":{"Line":0}},{"line":81,"address":[55885873],"length":1,"stats":{"Line":0}},{"line":84,"address":[54580012],"length":1,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[55885992],"length":1,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[54580274],"length":1,"stats":{"Line":0}},{"line":94,"address":[55886109],"length":1,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[54580319],"length":1,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[54580502],"length":1,"stats":{"Line":0}},{"line":106,"address":[55886337],"length":1,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[55886568],"length":1,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[54580964],"length":1,"stats":{"Line":0}},{"line":125,"address":[54580838],"length":1,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[54581138],"length":1,"stats":{"Line":0}},{"line":131,"address":[54581012],"length":1,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[55887090],"length":1,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[54581486],"length":1,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[54581603],"length":1,"stats":{"Line":0}},{"line":149,"address":[55887438],"length":1,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[55887687],"length":1,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[54581969],"length":1,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[55887921],"length":1,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[54582203],"length":1,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[54582389],"length":1,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[54582575],"length":1,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[55888734],"length":1,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[55888782],"length":1,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[54583181],"length":1,"stats":{"Line":0}},{"line":212,"address":[55889016],"length":1,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[55889202],"length":1,"stats":{"Line":0}},{"line":219,"address":[54583229],"length":1,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[55889319],"length":1,"stats":{"Line":0}},{"line":225,"address":[54583346],"length":1,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[54583539],"length":1,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[54583932],"length":1,"stats":{"Line":0}},{"line":240,"address":[55889804],"length":1,"stats":{"Line":0}},{"line":241,"address":[54583725],"length":1,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[54583975],"length":1,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[54584337],"length":1,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[54584859],"length":1,"stats":{"Line":0}},{"line":286,"address":[54584790],"length":1,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[54584976],"length":1,"stats":{"Line":0}},{"line":293,"address":[54584907],"length":1,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[54585162],"length":1,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[54585210],"length":1,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[55891300],"length":1,"stats":{"Line":0}},{"line":311,"address":[54585327],"length":1,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[54585513],"length":1,"stats":{"Line":0}},{"line":317,"address":[54585444],"length":1,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":125},{"path":["/","home","md","language","mdhavers","src","llvm","types.rs"],"content":"//! LLVM Type Definitions for mdhavers\n//!\n//! Defines the runtime value representation and type system.\n\nuse inkwell::context::Context;\nuse inkwell::types::{BasicTypeEnum, PointerType, StructType};\n\n/// Value type tags - must match runtime/mdh_runtime.h MdhTag enum\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum ValueTag {\n    Nil = 0,\n    Bool = 1,\n    Int = 2,\n    Float = 3,\n    String = 4,\n    List = 5,\n    Dict = 6,\n    Function = 7,\n    Class = 8,\n    Instance = 9,\n    Range = 10,\n}\n\nimpl ValueTag {\n    pub fn as_u8(self) -> u8 {\n        self as u8\n    }\n}\n\n/// LLVM types used throughout codegen\npub struct MdhTypes<'ctx> {\n    /// The main MdhValue struct type: { i8 tag, i64 data }\n    pub value_type: StructType<'ctx>,\n    /// i8 type (for tag)\n    pub i8_type: inkwell::types::IntType<'ctx>,\n    /// i32 type\n    pub i32_type: inkwell::types::IntType<'ctx>,\n    /// i64 type (for data field)\n    pub i64_type: inkwell::types::IntType<'ctx>,\n    /// f64 type (for floats)\n    pub f64_type: inkwell::types::FloatType<'ctx>,\n    /// bool type (i1)\n    pub bool_type: inkwell::types::IntType<'ctx>,\n    /// void type\n    pub void_type: inkwell::types::VoidType<'ctx>,\n    /// char* type (for strings)\n    pub str_ptr_type: PointerType<'ctx>,\n}\n\nimpl<'ctx> MdhTypes<'ctx> {\n    pub fn new(context: &'ctx Context) -> Self {\n        let i8_type = context.i8_type();\n        let i64_type = context.i64_type();\n\n        // MdhValue: { i8 tag, i64 data }\n        let value_type = context.struct_type(\n            &[i8_type.into(), i64_type.into()],\n            false, // not packed\n        );\n\n        MdhTypes {\n            value_type,\n            i8_type,\n            i32_type: context.i32_type(),\n            i64_type,\n            f64_type: context.f64_type(),\n            bool_type: context.bool_type(),\n            void_type: context.void_type(),\n            str_ptr_type: i8_type.ptr_type(inkwell::AddressSpace::default()),\n        }\n    }\n\n    /// Get the MdhValue type as a basic type\n    pub fn value_basic_type(&self) -> BasicTypeEnum<'ctx> {\n        self.value_type.into()\n    }\n}\n\n/// Inferred type information for optimization\n#[derive(Debug, Clone, PartialEq)]\npub enum InferredType {\n    /// Type is unknown, use boxed value\n    Unknown,\n    /// Definitely nil\n    Nil,\n    /// Definitely boolean\n    Bool,\n    /// Definitely integer\n    Int,\n    /// Definitely float\n    Float,\n    /// Definitely string\n    String,\n    /// Definitely a list\n    List,\n    /// Definitely a dict\n    Dict,\n    /// A user-defined function\n    Function,\n    /// Numeric (int or float)\n    Numeric,\n}\n\nimpl InferredType {\n    /// Check if this type is known at compile time\n    pub fn is_known(&self) -> bool {\n        !matches!(self, InferredType::Unknown)\n    }\n\n    /// Get the value tag for this type, if known\n    pub fn tag(&self) -> Option<ValueTag> {\n        match self {\n            InferredType::Nil => Some(ValueTag::Nil),\n            InferredType::Bool => Some(ValueTag::Bool),\n            InferredType::Int => Some(ValueTag::Int),\n            InferredType::Float => Some(ValueTag::Float),\n            InferredType::String => Some(ValueTag::String),\n            InferredType::List => Some(ValueTag::List),\n            InferredType::Dict => Some(ValueTag::Dict),\n            InferredType::Function => Some(ValueTag::Function),\n            _ => None,\n        }\n    }\n}\n","traces":[{"line":26,"address":[55617712],"length":1,"stats":{"Line":5}},{"line":52,"address":[55328544],"length":1,"stats":{"Line":15}},{"line":53,"address":[56180647],"length":1,"stats":{"Line":15}},{"line":54,"address":[55617422],"length":1,"stats":{"Line":15}},{"line":57,"address":[54304737],"length":1,"stats":{"Line":15}},{"line":58,"address":[55617445],"length":1,"stats":{"Line":15}},{"line":65,"address":[55328738],"length":1,"stats":{"Line":15}},{"line":67,"address":[55617569],"length":1,"stats":{"Line":15}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":69,"address":[55328783],"length":1,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[55617333],"length":1,"stats":{"Line":0}},{"line":107,"address":[55617296],"length":1,"stats":{"Line":0}},{"line":108,"address":[55617301],"length":1,"stats":{"Line":0}},{"line":112,"address":[55328368],"length":1,"stats":{"Line":0}},{"line":113,"address":[55328373],"length":1,"stats":{"Line":0}},{"line":114,"address":[56180482],"length":1,"stats":{"Line":0}},{"line":115,"address":[54304457],"length":1,"stats":{"Line":0}},{"line":116,"address":[55328432],"length":1,"stats":{"Line":0}},{"line":117,"address":[54304471],"length":1,"stats":{"Line":0}},{"line":118,"address":[54304478],"length":1,"stats":{"Line":0}},{"line":119,"address":[55617269],"length":1,"stats":{"Line":0}},{"line":120,"address":[55617276],"length":1,"stats":{"Line":0}},{"line":121,"address":[55617283],"length":1,"stats":{"Line":0}},{"line":122,"address":[55617227],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":26},{"path":["/","home","md","language","mdhavers","src","lsp","main.rs"],"content":"//! mdhavers Language Server - Gie yer editor some Scots smarts!\n//!\n//! This provides LSP support fer mdhavers, includin':\n//! - Diagnostics (error reportin')\n//! - Hover documentation\n//! - Completions fer keywords an' builtins\n//! - Go tae definition\n\nuse std::collections::HashMap;\nuse std::error::Error;\n\nuse lsp_server::{Connection, ExtractError, Message, Notification, Request, RequestId, Response};\nuse lsp_types::{\n    notification::{DidChangeTextDocument, DidCloseTextDocument, DidOpenTextDocument},\n    request::{Completion, GotoDefinition, HoverRequest},\n    CompletionItem, CompletionItemKind, CompletionOptions, CompletionParams, CompletionResponse,\n    Diagnostic, DiagnosticSeverity, DidChangeTextDocumentParams, DidCloseTextDocumentParams,\n    DidOpenTextDocumentParams, GotoDefinitionParams, GotoDefinitionResponse, Hover, HoverContents,\n    HoverParams, HoverProviderCapability, InitializeParams, MarkupContent, MarkupKind, Position,\n    Range, ServerCapabilities, TextDocumentSyncCapability, TextDocumentSyncKind, Uri,\n};\nuse serde_json::Value;\n\n// Import the mdhavers parser and lexer\n// We need to make these modules public in lib.rs\nmod mdhavers_bindings;\nuse mdhavers_bindings::{get_diagnostics, get_keyword_info, get_keywords_and_builtins};\n\n/// A wee document store tae keep track o' open files\nstruct DocumentStore {\n    documents: HashMap<Uri, String>,\n}\n\nimpl DocumentStore {\n    fn new() -> Self {\n        DocumentStore {\n            documents: HashMap::new(),\n        }\n    }\n\n    fn open(&mut self, uri: Uri, text: String) {\n        self.documents.insert(uri, text);\n    }\n\n    fn update(&mut self, uri: &Uri, text: String) {\n        self.documents.insert(uri.clone(), text);\n    }\n\n    fn close(&mut self, uri: &Uri) {\n        self.documents.remove(uri);\n    }\n\n    fn get(&self, uri: &Uri) -> Option<&String> {\n        self.documents.get(uri)\n    }\n}\n\nfn main() -> Result<(), Box<dyn Error + Sync + Send>> {\n    // Suppress the colored output fer LSP mode\n    colored::control::set_override(false);\n\n    eprintln!(\" mdhavers LSP Server startin' up! Haud on...\");\n\n    // Create the transport via stdio\n    let (connection, io_threads) = Connection::stdio();\n\n    // Run the server\n    let server_capabilities = serde_json::to_value(ServerCapabilities {\n        text_document_sync: Some(TextDocumentSyncCapability::Kind(TextDocumentSyncKind::FULL)),\n        hover_provider: Some(HoverProviderCapability::Simple(true)),\n        completion_provider: Some(CompletionOptions {\n            trigger_characters: Some(vec![\".\".to_string()]),\n            ..Default::default()\n        }),\n        definition_provider: Some(lsp_types::OneOf::Left(true)),\n        ..Default::default()\n    })\n    .unwrap();\n\n    let initialization_params = match connection.initialize(server_capabilities) {\n        Ok(it) => it,\n        Err(e) => {\n            if e.channel_is_disconnected() {\n                io_threads.join()?;\n            }\n            return Err(e.into());\n        }\n    };\n\n    main_loop(connection, initialization_params)?;\n    io_threads.join()?;\n\n    eprintln!(\" mdhavers LSP Server shuttin' doon. Cheerio!\");\n    Ok(())\n}\n\nfn main_loop(connection: Connection, params: Value) -> Result<(), Box<dyn Error + Sync + Send>> {\n    let _params: InitializeParams = serde_json::from_value(params).unwrap();\n\n    let mut documents = DocumentStore::new();\n\n    eprintln!(\" Ready tae help ye write guid mdhavers code!\");\n\n    for msg in &connection.receiver {\n        match msg {\n            Message::Request(req) => {\n                if connection.handle_shutdown(&req)? {\n                    return Ok(());\n                }\n\n                let result = handle_request(&documents, req);\n                if let Some((id, response)) = result {\n                    connection.sender.send(Message::Response(Response {\n                        id,\n                        result: Some(response),\n                        error: None,\n                    }))?;\n                }\n            }\n            Message::Notification(not) => {\n                handle_notification(&connection, &mut documents, not)?;\n            }\n            Message::Response(_) => {}\n        }\n    }\n    Ok(())\n}\n\nfn handle_request(documents: &DocumentStore, req: Request) -> Option<(RequestId, Value)> {\n    // Handle hover request\n    if let Ok((id, params)) = cast_request::<HoverRequest>(req.clone()) {\n        let result = handle_hover(documents, params);\n        return Some((id, serde_json::to_value(result).unwrap()));\n    }\n\n    // Handle completion request\n    if let Ok((id, params)) = cast_request::<Completion>(req.clone()) {\n        let result = handle_completion(documents, params);\n        return Some((id, serde_json::to_value(result).unwrap()));\n    }\n\n    // Handle go-to-definition request\n    if let Ok((id, params)) = cast_request::<GotoDefinition>(req.clone()) {\n        let result = handle_goto_definition(documents, params);\n        return Some((id, serde_json::to_value(result).unwrap()));\n    }\n\n    None\n}\n\nfn handle_notification(\n    connection: &Connection,\n    documents: &mut DocumentStore,\n    not: Notification,\n) -> Result<(), Box<dyn Error + Sync + Send>> {\n    // Handle document opened\n    if let Ok(params) = cast_notification::<DidOpenTextDocument>(not.clone()) {\n        let DidOpenTextDocumentParams { text_document } = params;\n        documents.open(text_document.uri.clone(), text_document.text.clone());\n        publish_diagnostics(connection, &text_document.uri, &text_document.text)?;\n        return Ok(());\n    }\n\n    // Handle document changed\n    if let Ok(params) = cast_notification::<DidChangeTextDocument>(not.clone()) {\n        let DidChangeTextDocumentParams {\n            text_document,\n            content_changes,\n        } = params;\n        if let Some(change) = content_changes.into_iter().last() {\n            documents.update(&text_document.uri, change.text.clone());\n            publish_diagnostics(connection, &text_document.uri, &change.text)?;\n        }\n        return Ok(());\n    }\n\n    // Handle document closed\n    if let Ok(params) = cast_notification::<DidCloseTextDocument>(not.clone()) {\n        let DidCloseTextDocumentParams { text_document } = params;\n        documents.close(&text_document.uri);\n        return Ok(());\n    }\n\n    Ok(())\n}\n\nfn handle_hover(_documents: &DocumentStore, params: HoverParams) -> Option<Hover> {\n    // Get the word at the cursor position\n    // For now, we'll return documentation for keywords\n    let position = params.text_document_position_params.position;\n\n    // This is a simplified version - ideally we'd parse the document\n    // and find the exact token at the position\n    let keyword = get_word_at_position(&params, _documents)?;\n\n    if let Some(info) = get_keyword_info(&keyword) {\n        return Some(Hover {\n            contents: HoverContents::Markup(MarkupContent {\n                kind: MarkupKind::Markdown,\n                value: info,\n            }),\n            range: Some(Range {\n                start: position,\n                end: Position {\n                    line: position.line,\n                    character: position.character + keyword.len() as u32,\n                },\n            }),\n        });\n    }\n\n    None\n}\n\nfn handle_completion(\n    _documents: &DocumentStore,\n    _params: CompletionParams,\n) -> Option<CompletionResponse> {\n    let items = get_keywords_and_builtins();\n\n    let completion_items: Vec<CompletionItem> = items\n        .into_iter()\n        .map(|(name, kind, doc)| CompletionItem {\n            label: name.clone(),\n            kind: Some(match kind.as_str() {\n                \"keyword\" => CompletionItemKind::KEYWORD,\n                \"function\" => CompletionItemKind::FUNCTION,\n                \"constant\" => CompletionItemKind::CONSTANT,\n                _ => CompletionItemKind::TEXT,\n            }),\n            detail: Some(doc.clone()),\n            documentation: Some(lsp_types::Documentation::MarkupContent(MarkupContent {\n                kind: MarkupKind::Markdown,\n                value: doc,\n            })),\n            ..Default::default()\n        })\n        .collect();\n\n    Some(CompletionResponse::Array(completion_items))\n}\n\nfn handle_goto_definition(\n    _documents: &DocumentStore,\n    _params: GotoDefinitionParams,\n) -> Option<GotoDefinitionResponse> {\n    // For now, we don't support go-to-definition\n    // This would require tracking function definitions\n    None\n}\n\nfn publish_diagnostics(\n    connection: &Connection,\n    uri: &Uri,\n    text: &str,\n) -> Result<(), Box<dyn Error + Sync + Send>> {\n    let diagnostics = get_diagnostics(text);\n\n    let lsp_diagnostics: Vec<Diagnostic> = diagnostics\n        .into_iter()\n        .map(|(line, col, message, severity)| Diagnostic {\n            range: Range {\n                start: Position {\n                    line: line.saturating_sub(1) as u32,\n                    character: col.saturating_sub(1) as u32,\n                },\n                end: Position {\n                    line: line.saturating_sub(1) as u32,\n                    character: (col + 10) as u32, // Approximate end\n                },\n            },\n            severity: Some(match severity.as_str() {\n                \"error\" => DiagnosticSeverity::ERROR,\n                \"warning\" => DiagnosticSeverity::WARNING,\n                _ => DiagnosticSeverity::INFORMATION,\n            }),\n            source: Some(\"mdhavers\".to_string()),\n            message,\n            ..Default::default()\n        })\n        .collect();\n\n    let notification = lsp_server::Notification::new(\n        \"textDocument/publishDiagnostics\".to_string(),\n        lsp_types::PublishDiagnosticsParams {\n            uri: uri.clone(),\n            diagnostics: lsp_diagnostics,\n            version: None,\n        },\n    );\n\n    connection\n        .sender\n        .send(Message::Notification(notification))?;\n    Ok(())\n}\n\nfn get_word_at_position(params: &HoverParams, documents: &DocumentStore) -> Option<String> {\n    let uri = &params.text_document_position_params.text_document.uri;\n    let position = params.text_document_position_params.position;\n\n    let text = documents.get(uri)?;\n    let lines: Vec<&str> = text.lines().collect();\n\n    if position.line as usize >= lines.len() {\n        return None;\n    }\n\n    let line = lines[position.line as usize];\n    let col = position.character as usize;\n\n    if col >= line.len() {\n        return None;\n    }\n\n    // Find word boundaries\n    let chars: Vec<char> = line.chars().collect();\n    let mut start = col;\n    let mut end = col;\n\n    // Find start of word\n    while start > 0 && (chars[start - 1].is_alphanumeric() || chars[start - 1] == '_') {\n        start -= 1;\n    }\n\n    // Find end of word\n    while end < chars.len() && (chars[end].is_alphanumeric() || chars[end] == '_') {\n        end += 1;\n    }\n\n    if start < end {\n        Some(chars[start..end].iter().collect())\n    } else {\n        None\n    }\n}\n\nfn cast_request<R>(req: Request) -> Result<(RequestId, R::Params), ExtractError<Request>>\nwhere\n    R: lsp_types::request::Request,\n    R::Params: serde::de::DeserializeOwned,\n{\n    req.extract(R::METHOD)\n}\n\nfn cast_notification<N>(not: Notification) -> Result<N::Params, ExtractError<Notification>>\nwhere\n    N: lsp_types::notification::Notification,\n    N::Params: serde::de::DeserializeOwned,\n{\n    not.extract(N::METHOD)\n}\n","traces":[{"line":35,"address":[2477888],"length":1,"stats":{"Line":0}},{"line":37,"address":[2477902],"length":1,"stats":{"Line":0}},{"line":41,"address":[2477952],"length":1,"stats":{"Line":0}},{"line":42,"address":[2477970],"length":1,"stats":{"Line":0}},{"line":45,"address":[2478225,2478254,2478048],"length":1,"stats":{"Line":0}},{"line":46,"address":[2478151,2478080],"length":1,"stats":{"Line":0}},{"line":49,"address":[2478000],"length":1,"stats":{"Line":0}},{"line":50,"address":[2478020],"length":1,"stats":{"Line":0}},{"line":53,"address":[2477856],"length":1,"stats":{"Line":0}},{"line":54,"address":[2477870],"length":1,"stats":{"Line":0}},{"line":58,"address":[2489853,2490507,2486320],"length":1,"stats":{"Line":0}},{"line":60,"address":[2486327],"length":1,"stats":{"Line":0}},{"line":62,"address":[2486378],"length":1,"stats":{"Line":0}},{"line":65,"address":[2486427],"length":1,"stats":{"Line":0}},{"line":68,"address":[2487228],"length":1,"stats":{"Line":0}},{"line":69,"address":[2486572],"length":1,"stats":{"Line":0}},{"line":71,"address":[2486999],"length":1,"stats":{"Line":0}},{"line":72,"address":[2486684,2490480,2486620],"length":1,"stats":{"Line":0}},{"line":73,"address":[2486948],"length":1,"stats":{"Line":0}},{"line":76,"address":[2487177],"length":1,"stats":{"Line":0}},{"line":80,"address":[2488885],"length":1,"stats":{"Line":0}},{"line":81,"address":[2489043],"length":1,"stats":{"Line":0}},{"line":82,"address":[2488974],"length":1,"stats":{"Line":0}},{"line":83,"address":[2489907,2489014],"length":1,"stats":{"Line":0}},{"line":84,"address":[2490255,2489988],"length":1,"stats":{"Line":0}},{"line":86,"address":[2490218,2489913],"length":1,"stats":{"Line":0}},{"line":90,"address":[2489813,2489115,2489279],"length":1,"stats":{"Line":0}},{"line":91,"address":[2489752,2489412],"length":1,"stats":{"Line":0}},{"line":93,"address":[2489629],"length":1,"stats":{"Line":0}},{"line":94,"address":[2489674],"length":1,"stats":{"Line":0}},{"line":97,"address":[2490576,2492905,2493199],"length":1,"stats":{"Line":0}},{"line":98,"address":[2490664,2490600],"length":1,"stats":{"Line":0}},{"line":100,"address":[2490702],"length":1,"stats":{"Line":0}},{"line":102,"address":[2490813,2490750],"length":1,"stats":{"Line":0}},{"line":104,"address":[2490837],"length":1,"stats":{"Line":0}},{"line":105,"address":[2491058],"length":1,"stats":{"Line":0}},{"line":106,"address":[2491226],"length":1,"stats":{"Line":0}},{"line":107,"address":[2491314,2491590,2492667],"length":1,"stats":{"Line":0}},{"line":108,"address":[2491843],"length":1,"stats":{"Line":0}},{"line":111,"address":[2491724],"length":1,"stats":{"Line":0}},{"line":112,"address":[2491860],"length":1,"stats":{"Line":0}},{"line":113,"address":[2492020,2492537,2492365],"length":1,"stats":{"Line":0}},{"line":115,"address":[2491970],"length":1,"stats":{"Line":0}},{"line":116,"address":[2492012],"length":1,"stats":{"Line":0}},{"line":120,"address":[2491433],"length":1,"stats":{"Line":0}},{"line":121,"address":[2493087,2492921,2491513],"length":1,"stats":{"Line":0}},{"line":126,"address":[2491138],"length":1,"stats":{"Line":0}},{"line":129,"address":[2479038,2478272,2480671],"length":1,"stats":{"Line":0}},{"line":131,"address":[2478315,2478408,2478497],"length":1,"stats":{"Line":0}},{"line":132,"address":[2478647],"length":1,"stats":{"Line":0}},{"line":133,"address":[2478695],"length":1,"stats":{"Line":0}},{"line":137,"address":[2479141,2479254],"length":1,"stats":{"Line":0}},{"line":138,"address":[2479347],"length":1,"stats":{"Line":0}},{"line":139,"address":[2479395],"length":1,"stats":{"Line":0}},{"line":143,"address":[2479959,2479841],"length":1,"stats":{"Line":0}},{"line":144,"address":[2480143],"length":1,"stats":{"Line":0}},{"line":145,"address":[2480191],"length":1,"stats":{"Line":0}},{"line":148,"address":[2480647],"length":1,"stats":{"Line":0}},{"line":151,"address":[2480976,2482104,2483758],"length":1,"stats":{"Line":0}},{"line":157,"address":[2481215,2481125,2481042],"length":1,"stats":{"Line":0}},{"line":158,"address":[2481343],"length":1,"stats":{"Line":0}},{"line":159,"address":[2481538,2482082,2481487],"length":1,"stats":{"Line":0}},{"line":160,"address":[2481930,2481665],"length":1,"stats":{"Line":0}},{"line":161,"address":[2481889],"length":1,"stats":{"Line":0}},{"line":165,"address":[2482159,2482272],"length":1,"stats":{"Line":0}},{"line":167,"address":[2482384],"length":1,"stats":{"Line":0}},{"line":168,"address":[2482464],"length":1,"stats":{"Line":0}},{"line":170,"address":[2482512,2482579],"length":1,"stats":{"Line":0}},{"line":171,"address":[2482806,2482687],"length":1,"stats":{"Line":0}},{"line":172,"address":[2483051,2482821],"length":1,"stats":{"Line":0}},{"line":174,"address":[2482721],"length":1,"stats":{"Line":0}},{"line":178,"address":[2483276,2483351],"length":1,"stats":{"Line":0}},{"line":179,"address":[2483431],"length":1,"stats":{"Line":0}},{"line":180,"address":[2483519],"length":1,"stats":{"Line":0}},{"line":181,"address":[2483567],"length":1,"stats":{"Line":0}},{"line":184,"address":[2483738],"length":1,"stats":{"Line":0}},{"line":187,"address":[2476928,2477799,2477831],"length":1,"stats":{"Line":0}},{"line":190,"address":[2476966],"length":1,"stats":{"Line":0}},{"line":194,"address":[2477057,2477829,2476999],"length":1,"stats":{"Line":0}},{"line":196,"address":[2477246,2477170],"length":1,"stats":{"Line":0}},{"line":197,"address":[2477613],"length":1,"stats":{"Line":0}},{"line":198,"address":[2477326],"length":1,"stats":{"Line":0}},{"line":202,"address":[2477558],"length":1,"stats":{"Line":0}},{"line":206,"address":[2477523,2477766,2477421],"length":1,"stats":{"Line":0}},{"line":212,"address":[2477448],"length":1,"stats":{"Line":0}},{"line":215,"address":[2480955,2480688],"length":1,"stats":{"Line":0}},{"line":219,"address":[2480723],"length":1,"stats":{"Line":0}},{"line":223,"address":[2480798],"length":1,"stats":{"Line":0}},{"line":224,"address":[2868756,2868684],"length":1,"stats":{"Line":0}},{"line":225,"address":[2869019,2868769,2868834],"length":1,"stats":{"Line":0}},{"line":226,"address":[2868916,2868850],"length":1,"stats":{"Line":0}},{"line":227,"address":[2868893,2868933,2868972],"length":1,"stats":{"Line":0}},{"line":228,"address":[2868949,2868989,2869008],"length":1,"stats":{"Line":0}},{"line":229,"address":[2868995],"length":1,"stats":{"Line":0}},{"line":231,"address":[2869029],"length":1,"stats":{"Line":0}},{"line":232,"address":[2869143],"length":1,"stats":{"Line":0}},{"line":234,"address":[2869103],"length":1,"stats":{"Line":0}},{"line":236,"address":[2869263],"length":1,"stats":{"Line":0}},{"line":240,"address":[2480832],"length":1,"stats":{"Line":0}},{"line":243,"address":[2486256],"length":1,"stats":{"Line":0}},{"line":249,"address":[2486284],"length":1,"stats":{"Line":0}},{"line":252,"address":[2483776,2484717,2484723],"length":1,"stats":{"Line":0}},{"line":257,"address":[2483851],"length":1,"stats":{"Line":0}},{"line":261,"address":[2483923],"length":1,"stats":{"Line":0}},{"line":262,"address":[2870612],"length":1,"stats":{"Line":0}},{"line":264,"address":[2870434],"length":1,"stats":{"Line":0}},{"line":265,"address":[2870518],"length":1,"stats":{"Line":0}},{"line":268,"address":[2870549],"length":1,"stats":{"Line":0}},{"line":269,"address":[2870578,2870665],"length":1,"stats":{"Line":0}},{"line":272,"address":[2870648,2870824,2870695],"length":1,"stats":{"Line":0}},{"line":273,"address":[2870711,2870777],"length":1,"stats":{"Line":0}},{"line":274,"address":[2870813,2870754,2870794],"length":1,"stats":{"Line":0}},{"line":275,"address":[2870800],"length":1,"stats":{"Line":0}},{"line":277,"address":[2870835],"length":1,"stats":{"Line":0}},{"line":278,"address":[2870902],"length":1,"stats":{"Line":0}},{"line":279,"address":[2870958],"length":1,"stats":{"Line":0}},{"line":284,"address":[2484024,2483951],"length":1,"stats":{"Line":0}},{"line":285,"address":[2484122],"length":1,"stats":{"Line":0}},{"line":286,"address":[2484040],"length":1,"stats":{"Line":0}},{"line":287,"address":[2484085],"length":1,"stats":{"Line":0}},{"line":292,"address":[2484422,2484598,2484675],"length":1,"stats":{"Line":0}},{"line":294,"address":[2484470,2484297],"length":1,"stats":{"Line":0}},{"line":295,"address":[2484630],"length":1,"stats":{"Line":0}},{"line":298,"address":[2486230,2484752,2486208],"length":1,"stats":{"Line":0}},{"line":299,"address":[2484813],"length":1,"stats":{"Line":0}},{"line":300,"address":[2484828],"length":1,"stats":{"Line":0}},{"line":302,"address":[2484862],"length":1,"stats":{"Line":0}},{"line":303,"address":[2484948],"length":1,"stats":{"Line":0}},{"line":305,"address":[2485021,2485106],"length":1,"stats":{"Line":0}},{"line":306,"address":[2485160],"length":1,"stats":{"Line":0}},{"line":309,"address":[2485193,2485118],"length":1,"stats":{"Line":0}},{"line":310,"address":[2485232],"length":1,"stats":{"Line":0}},{"line":312,"address":[2485250],"length":1,"stats":{"Line":0}},{"line":313,"address":[2485333],"length":1,"stats":{"Line":0}},{"line":317,"address":[2485302,2485375],"length":1,"stats":{"Line":0}},{"line":318,"address":[2485390],"length":1,"stats":{"Line":0}},{"line":319,"address":[2485398],"length":1,"stats":{"Line":0}},{"line":322,"address":[2485406,2486182,2485576,2485453,2485667],"length":1,"stats":{"Line":0}},{"line":323,"address":[2485627,2486174,2486187],"length":1,"stats":{"Line":0}},{"line":327,"address":[2485772,2485417,2486143,2485740,2485909],"length":1,"stats":{"Line":0}},{"line":328,"address":[2485870,2486148,2486135],"length":1,"stats":{"Line":0}},{"line":331,"address":[2486098,2485940,2485745],"length":1,"stats":{"Line":0}},{"line":332,"address":[2486015,2485942],"length":1,"stats":{"Line":0}},{"line":334,"address":[2485927],"length":1,"stats":{"Line":0}},{"line":338,"address":[2868400,2868432,2868368],"length":1,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[2868496,2868464,2868528],"length":1,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":148},{"path":["/","home","md","language","mdhavers","src","lsp","mdhavers_bindings.rs"],"content":"//! Bindings tae the mdhavers parser fer the LSP\n//!\n//! This module provides the interface between the LSP server\n//! and the mdhavers language implementation.\n\nuse logos::Logos;\n\n/// Get diagnostics fer a piece o' mdhavers code\n/// Returns a list of (line, column, message, severity)\npub fn get_diagnostics(source: &str) -> Vec<(usize, usize, String, String)> {\n    let mut diagnostics = Vec::new();\n\n    // Try tae lex the source first\n    let mut lexer = TokenKind::lexer(source);\n    let mut line: usize = 1;\n    let mut col: usize = 1;\n\n    while let Some(token) = lexer.next() {\n        let slice = lexer.slice();\n\n        // Update line/column tracking\n        for c in slice.chars() {\n            if c == '\\n' {\n                line += 1;\n                col = 1;\n            } else {\n                col += 1;\n            }\n        }\n\n        if token.is_err() {\n            diagnostics.push((\n                line,\n                col.saturating_sub(slice.len()),\n                format!(\"Och! Ah dinnae ken whit '{}' is\", slice),\n                \"error\".to_string(),\n            ));\n        }\n    }\n\n    // Now try to parse and collect more errors\n    if let Err(parse_error) = parse_for_errors(source) {\n        diagnostics.push(parse_error);\n    }\n\n    diagnostics\n}\n\n/// A simplified token enum fer lexing (mirrors the main lexer)\n#[derive(Logos, Debug, Clone, PartialEq)]\n#[logos(skip r\"[ \\t\\r]+\")]\nenum TokenKind {\n    // Keywords\n    #[token(\"ken\")]\n    Ken,\n    #[token(\"gin\")]\n    Gin,\n    #[token(\"ither\")]\n    Ither,\n    #[token(\"than\")]\n    Than,\n    #[token(\"whiles\")]\n    Whiles,\n    #[token(\"fer\")]\n    Fer,\n    #[token(\"gie\")]\n    Gie,\n    #[token(\"blether\")]\n    Blether,\n    #[token(\"speir\")]\n    Speir,\n    #[token(\"fae\")]\n    Fae,\n    #[token(\"tae\")]\n    Tae,\n    #[token(\"an\")]\n    An,\n    #[token(\"or\")]\n    Or,\n    #[token(\"nae\")]\n    Nae,\n    #[token(\"aye\")]\n    Aye,\n    #[token(\"naething\")]\n    Naething,\n    #[token(\"dae\")]\n    Dae,\n    #[token(\"thing\")]\n    Thing,\n    #[token(\"fetch\")]\n    Fetch,\n    #[token(\"kin\")]\n    Kin,\n    #[token(\"brak\")]\n    Brak,\n    #[token(\"haud\")]\n    Haud,\n    #[token(\"in\")]\n    In,\n    #[token(\"is\")]\n    Is,\n    #[token(\"masel\")]\n    Masel,\n    #[token(\"hae_a_bash\")]\n    HaeABash,\n    #[token(\"gin_it_gangs_wrang\")]\n    GinItGangsWrang,\n    #[token(\"keek\")]\n    Keek,\n    #[token(\"whan\")]\n    Whan,\n    #[token(\"mak_siccar\")]\n    MakSiccar,\n\n    // Literals\n    #[regex(r\"[0-9]+\")]\n    Integer,\n    #[regex(r\"[0-9]+\\.[0-9]+\")]\n    Float,\n    #[regex(r#\"\"([^\"\\\\]|\\\\.)*\"\"#)]\n    String,\n    #[regex(r#\"'([^'\\\\]|\\\\.)*'\"#)]\n    SingleQuoteString,\n    #[regex(r#\"f\"([^\"\\\\]|\\\\.)*\"\"#)]\n    FString,\n    #[regex(r\"[a-zA-Z_][a-zA-Z0-9_]*\")]\n    Identifier,\n\n    // Operators\n    #[token(\"+\")]\n    Plus,\n    #[token(\"-\")]\n    Minus,\n    #[token(\"*\")]\n    Star,\n    #[token(\"/\")]\n    Slash,\n    #[token(\"%\")]\n    Percent,\n    #[token(\"=\")]\n    Equals,\n    #[token(\"==\")]\n    EqualsEquals,\n    #[token(\"!=\")]\n    BangEquals,\n    #[token(\"<\")]\n    Less,\n    #[token(\"<=\")]\n    LessEquals,\n    #[token(\">\")]\n    Greater,\n    #[token(\">=\")]\n    GreaterEquals,\n    #[token(\"!\")]\n    Bang,\n    #[token(\"+=\")]\n    PlusEquals,\n    #[token(\"-=\")]\n    MinusEquals,\n    #[token(\"*=\")]\n    StarEquals,\n    #[token(\"/=\")]\n    SlashEquals,\n    #[token(\"...\")]\n    DotDotDot,\n    #[token(\"..\")]\n    DotDot,\n    #[token(\".\")]\n    Dot,\n    #[token(\"_\", priority = 3)]\n    Underscore,\n\n    // Delimiters\n    #[token(\"(\")]\n    LeftParen,\n    #[token(\")\")]\n    RightParen,\n    #[token(\"{\")]\n    LeftBrace,\n    #[token(\"}\")]\n    RightBrace,\n    #[token(\"[\")]\n    LeftBracket,\n    #[token(\"]\")]\n    RightBracket,\n    #[token(\",\")]\n    Comma,\n    #[token(\":\")]\n    Colon,\n    #[token(\";\")]\n    Semicolon,\n    #[token(\"->\")]\n    Arrow,\n    #[token(\"|>\")]\n    PipeForward,\n    #[token(\"|\")]\n    Pipe,\n    #[token(\"\\n\")]\n    Newline,\n    #[regex(r\"#[^\\n]*\", logos::skip)]\n    Comment,\n}\n\n/// Simple parser fer error detection\nfn parse_for_errors(source: &str) -> Result<(), (usize, usize, String, String)> {\n    let mut brace_stack: Vec<(char, usize, usize)> = Vec::new();\n    let mut line = 1;\n    let mut col = 1;\n\n    for ch in source.chars() {\n        match ch {\n            '{' | '(' | '[' => {\n                brace_stack.push((ch, line, col));\n            }\n            '}' => {\n                if let Some((open, _, _)) = brace_stack.pop() {\n                    if open != '{' {\n                        return Err((\n                            line,\n                            col,\n                            format!(\"Unexpected '}}' - was expectin' a match fer '{}'\", open),\n                            \"error\".to_string(),\n                        ));\n                    }\n                } else {\n                    return Err((\n                        line,\n                        col,\n                        \"Unexpected '}}' - nae matchin' '{{' found\".to_string(),\n                        \"error\".to_string(),\n                    ));\n                }\n            }\n            ')' => {\n                if let Some((open, _, _)) = brace_stack.pop() {\n                    if open != '(' {\n                        return Err((\n                            line,\n                            col,\n                            format!(\"Unexpected ')' - was expectin' a match fer '{}'\", open),\n                            \"error\".to_string(),\n                        ));\n                    }\n                } else {\n                    return Err((\n                        line,\n                        col,\n                        \"Unexpected ')' - nae matchin' '(' found\".to_string(),\n                        \"error\".to_string(),\n                    ));\n                }\n            }\n            ']' => {\n                if let Some((open, _, _)) = brace_stack.pop() {\n                    if open != '[' {\n                        return Err((\n                            line,\n                            col,\n                            format!(\"Unexpected ']' - was expectin' a match fer '{}'\", open),\n                            \"error\".to_string(),\n                        ));\n                    }\n                } else {\n                    return Err((\n                        line,\n                        col,\n                        \"Unexpected ']' - nae matchin' '[' found\".to_string(),\n                        \"error\".to_string(),\n                    ));\n                }\n            }\n            '\\n' => {\n                line += 1;\n                col = 0;\n            }\n            _ => {}\n        }\n        col += 1;\n    }\n\n    // Check for unclosed brackets\n    if let Some((ch, l, c)) = brace_stack.pop() {\n        let close = match ch {\n            '{' => '}',\n            '(' => ')',\n            '[' => ']',\n            _ => '?',\n        };\n        return Err((\n            l,\n            c,\n            format!(\"Unclosed '{}' - missin' '{}'\", ch, close),\n            \"error\".to_string(),\n        ));\n    }\n\n    Ok(())\n}\n\n/// Get documentation fer a keyword or builtin\npub fn get_keyword_info(keyword: &str) -> Option<String> {\n    match keyword {\n        // Keywords\n        \"ken\" => Some(\"**ken** - Variable declaration\\n\\n```mdhavers\\nken x = 42\\nken name = \\\"Angus\\\"\\n```\\n\\nLike `let` or `var` in other languages. From Scots \\\"I ken\\\" meaning \\\"I know\\\".\".to_string()),\n        \"gin\" => Some(\"**gin** - If statement\\n\\n```mdhavers\\ngin x > 10 {\\n    blether \\\"Big number!\\\"\\n}\\n```\\n\\nConditional execution. From Scots \\\"gin\\\" meaning \\\"if\\\".\".to_string()),\n        \"ither\" => Some(\"**ither** - Else clause\\n\\n```mdhavers\\ngin x > 10 {\\n    blether \\\"Big\\\"\\n} ither {\\n    blether \\\"Wee\\\"\\n}\\n```\\n\\nFrom Scots \\\"ither\\\" meaning \\\"other\\\".\".to_string()),\n        \"than\" => Some(\"**than** - Then (for ternary expressions)\\n\\n```mdhavers\\nken result = gin x > 0 than \\\"positive\\\" ither \\\"negative\\\"\\n```\\n\\nUsed in ternary/conditional expressions.\".to_string()),\n        \"whiles\" => Some(\"**whiles** - While loop\\n\\n```mdhavers\\nwhiles x < 10 {\\n    blether x\\n    x = x + 1\\n}\\n```\\n\\nFrom Scots \\\"whiles\\\" meaning \\\"while\\\".\".to_string()),\n        \"fer\" => Some(\"**fer** - For loop\\n\\n```mdhavers\\nfer i in 1..10 {\\n    blether i\\n}\\n\\nfer item in my_list {\\n    blether item\\n}\\n```\\n\\nIterate over ranges or collections.\".to_string()),\n        \"dae\" => Some(\"**dae** - Function definition\\n\\n```mdhavers\\ndae greet(name) {\\n    blether f\\\"Hullo {name}!\\\"\\n}\\n\\ndae add(a, b = 0) {  # with default\\n    gie a + b\\n}\\n```\\n\\nFrom Scots \\\"dae\\\" meaning \\\"do\\\".\".to_string()),\n        \"gie\" => Some(\"**gie** - Return from function\\n\\n```mdhavers\\ndae square(x) {\\n    gie x * x\\n}\\n```\\n\\nFrom Scots \\\"gie\\\" meaning \\\"give\\\".\".to_string()),\n        \"blether\" => Some(\"**blether** - Print to output\\n\\n```mdhavers\\nblether \\\"Hullo warld!\\\"\\nblether f\\\"The answer is {42}\\\"\\n```\\n\\nFrom Scots \\\"blether\\\" meaning \\\"chat\\\" or \\\"talk\\\".\".to_string()),\n        \"speir\" => Some(\"**speir** - Get user input\\n\\n```mdhavers\\nken name = speir \\\"Whit's yer name? \\\"\\n```\\n\\nFrom Scots \\\"speir\\\" meaning \\\"ask\\\".\".to_string()),\n        \"aye\" => Some(\"**aye** - Boolean true\\n\\n```mdhavers\\nken happy = aye\\n```\\n\\nFrom Scots \\\"aye\\\" meaning \\\"yes\\\".\".to_string()),\n        \"nae\" => Some(\"**nae** - Boolean false / logical not\\n\\n```mdhavers\\nken sad = nae\\ngin nae is_empty {\\n    # do something\\n}\\n```\\n\\nFrom Scots \\\"nae\\\" meaning \\\"no\\\" or \\\"not\\\".\".to_string()),\n        \"naething\" => Some(\"**naething** - Null/nil value\\n\\n```mdhavers\\nken nothing = naething\\n```\\n\\nFrom Scots \\\"naething\\\" meaning \\\"nothing\\\".\".to_string()),\n        \"an\" => Some(\"**an** - Logical AND\\n\\n```mdhavers\\ngin x > 0 an x < 10 {\\n    blether \\\"In range!\\\"\\n}\\n```\\n\\nFrom Scots \\\"an\\\" meaning \\\"and\\\".\".to_string()),\n        \"or\" => Some(\"**or** - Logical OR\\n\\n```mdhavers\\ngin x < 0 or x > 100 {\\n    blether \\\"Oot o' range!\\\"\\n}\\n```\".to_string()),\n        \"brak\" => Some(\"**brak** - Break out of loop\\n\\n```mdhavers\\nfer i in 1..100 {\\n    gin i == 50 {\\n        brak\\n    }\\n}\\n```\\n\\nFrom Scots \\\"brak\\\" meaning \\\"break\\\".\".to_string()),\n        \"haud\" => Some(\"**haud** - Continue to next iteration\\n\\n```mdhavers\\nfer i in 1..10 {\\n    gin i % 2 == 0 {\\n        haud  # skip even numbers\\n    }\\n    blether i\\n}\\n```\\n\\nFrom Scots \\\"haud\\\" meaning \\\"hold\\\".\".to_string()),\n        \"kin\" => Some(\"**kin** - Class definition\\n\\n```mdhavers\\nkin Animal {\\n    dae mak(name) {\\n        masel.name = name\\n    }\\n    \\n    dae speak() {\\n        blether f\\\"{masel.name} says hello!\\\"\\n    }\\n}\\n```\\n\\nFrom Scots \\\"kin\\\" meaning \\\"family\\\" or \\\"type\\\".\".to_string()),\n        \"thing\" => Some(\"**thing** - Struct definition\\n\\n```mdhavers\\nthing Point { x, y }\\nken p = Point { x: 10, y: 20 }\\n```\\n\\nDefines a simple data structure.\".to_string()),\n        \"masel\" => Some(\"**masel** - Self reference in classes\\n\\n```mdhavers\\nkin Counter {\\n    dae increment() {\\n        masel.count = masel.count + 1\\n    }\\n}\\n```\\n\\nFrom Scots \\\"masel\\\" meaning \\\"myself\\\".\".to_string()),\n        \"fetch\" => Some(\"**fetch** - Import a module\\n\\n```mdhavers\\nfetch \\\"utils\\\"\\nfetch \\\"math\\\" tae maths\\n```\\n\\nImport code from another file.\".to_string()),\n        \"hae_a_bash\" => Some(\"**hae_a_bash** - Try block\\n\\n```mdhavers\\nhae_a_bash {\\n    # risky code\\n} gin_it_gangs_wrang e {\\n    blether f\\\"Error: {e}\\\"\\n}\\n```\\n\\nFrom Scots \\\"hae a bash\\\" meaning \\\"give it a try\\\".\".to_string()),\n        \"gin_it_gangs_wrang\" => Some(\"**gin_it_gangs_wrang** - Catch block\\n\\n```mdhavers\\nhae_a_bash {\\n    ken x = 1 / 0\\n} gin_it_gangs_wrang e {\\n    blether \\\"Oops!\\\"\\n}\\n```\\n\\nFrom Scots \\\"gin it gangs wrang\\\" meaning \\\"if it goes wrong\\\".\".to_string()),\n        \"keek\" => Some(\"**keek** - Match/switch statement\\n\\n```mdhavers\\nkeek value {\\n    whan 1 -> blether \\\"One\\\"\\n    whan 2 -> blether \\\"Two\\\"\\n    whan _ -> blether \\\"Something else\\\"\\n}\\n```\\n\\nFrom Scots \\\"keek\\\" meaning \\\"peek\\\" or \\\"look\\\".\".to_string()),\n        \"whan\" => Some(\"**whan** - Case in match statement\\n\\n```mdhavers\\nkeek x {\\n    whan 1 -> blether \\\"One\\\"\\n    whan 2 -> blether \\\"Two\\\"\\n}\\n```\\n\\nFrom Scots \\\"whan\\\" meaning \\\"when\\\".\".to_string()),\n        \"mak_siccar\" => Some(\"**mak_siccar** - Assert\\n\\n```mdhavers\\nmak_siccar x > 0, \\\"x must be positive!\\\"\\n```\\n\\nFrom Scots \\\"mak siccar\\\" meaning \\\"make sure\\\" - famously said by Robert the Bruce!\".to_string()),\n        \"in\" => Some(\"**in** - Used in for loops\\n\\n```mdhavers\\nfer item in list {\\n    blether item\\n}\\n```\".to_string()),\n        \"is\" => Some(\"**is** - Type checking\\n\\n```mdhavers\\ngin x is \\\"integer\\\" {\\n    blether \\\"It's a number!\\\"\\n}\\n```\".to_string()),\n        \"fae\" => Some(\"**fae** - From (used in imports and inheritance)\\n\\n```mdhavers\\nkin Dog fae Animal {\\n    # Dog inherits fae Animal\\n}\\n```\\n\\nFrom Scots \\\"fae\\\" meaning \\\"from\\\".\".to_string()),\n        \"tae\" => Some(\"**tae** - To (used in imports for aliasing)\\n\\n```mdhavers\\nfetch \\\"math\\\" tae maths\\n```\\n\\nFrom Scots \\\"tae\\\" meaning \\\"to\\\".\".to_string()),\n\n        // Built-in functions\n        \"len\" => Some(\"**len(x)** - Get the length\\n\\n```mdhavers\\nken size = len([1, 2, 3])  # 3\\nken chars = len(\\\"hello\\\")   # 5\\n```\".to_string()),\n        \"whit_kind\" => Some(\"**whit_kind(x)** - Get the type of a value\\n\\n```mdhavers\\nblether whit_kind(42)      # \\\"integer\\\"\\nblether whit_kind(\\\"hi\\\")    # \\\"string\\\"\\nblether whit_kind([1,2])   # \\\"list\\\"\\n```\\n\\nFrom Scots \\\"whit kind\\\" meaning \\\"what type\\\".\".to_string()),\n        \"tae_string\" => Some(\"**tae_string(x)** - Convert to string\\n\\n```mdhavers\\nken s = tae_string(42)  # \\\"42\\\"\\n```\".to_string()),\n        \"tae_int\" => Some(\"**tae_int(x)** - Convert to integer\\n\\n```mdhavers\\nken n = tae_int(\\\"42\\\")   # 42\\nken m = tae_int(3.14)   # 3\\n```\".to_string()),\n        \"tae_float\" => Some(\"**tae_float(x)** - Convert to float\\n\\n```mdhavers\\nken f = tae_float(\\\"3.14\\\")  # 3.14\\n```\".to_string()),\n        \"shove\" => Some(\"**shove(list, item)** - Add item to end of list\\n\\n```mdhavers\\nken nums = [1, 2]\\nshove(nums, 3)  # [1, 2, 3]\\n```\\n\\nFrom Scots \\\"shove\\\" meaning \\\"push\\\".\".to_string()),\n        \"yank\" => Some(\"**yank(list)** - Remove and return last item\\n\\n```mdhavers\\nken nums = [1, 2, 3]\\nken last = yank(nums)  # 3, nums is now [1, 2]\\n```\\n\\nFrom Scots \\\"yank\\\" meaning \\\"pull\\\".\".to_string()),\n        \"heid\" => Some(\"**heid(list)** - Get first element\\n\\n```mdhavers\\nken first = heid([1, 2, 3])  # 1\\n```\\n\\nFrom Scots \\\"heid\\\" meaning \\\"head\\\".\".to_string()),\n        \"tail\" => Some(\"**tail(list)** - Get all but first element\\n\\n```mdhavers\\nken rest = tail([1, 2, 3])  # [2, 3]\\n```\".to_string()),\n        \"bum\" => Some(\"**bum(list)** - Get last element\\n\\n```mdhavers\\nken last = bum([1, 2, 3])  # 3\\n```\\n\\nFrom Scots \\\"bum\\\" meaning \\\"bottom\\\".\".to_string()),\n        \"range\" => Some(\"**range(start, end)** - Create a range\\n\\n```mdhavers\\nken nums = range(1, 5)  # [1, 2, 3, 4]\\n```\".to_string()),\n        \"keys\" => Some(\"**keys(dict)** - Get dictionary keys\\n\\n```mdhavers\\nken k = keys({a: 1, b: 2})  # [\\\"a\\\", \\\"b\\\"]\\n```\".to_string()),\n        \"values\" => Some(\"**values(dict)** - Get dictionary values\\n\\n```mdhavers\\nken v = values({a: 1, b: 2})  # [1, 2]\\n```\".to_string()),\n        \"abs\" => Some(\"**abs(x)** - Absolute value\\n\\n```mdhavers\\nken n = abs(-42)  # 42\\n```\".to_string()),\n        \"min\" => Some(\"**min(a, b)** - Minimum of two values\\n\\n```mdhavers\\nken m = min(3, 7)  # 3\\n```\".to_string()),\n        \"max\" => Some(\"**max(a, b)** - Maximum of two values\\n\\n```mdhavers\\nken m = max(3, 7)  # 7\\n```\".to_string()),\n        \"floor\" => Some(\"**floor(x)** - Round down\\n\\n```mdhavers\\nken n = floor(3.7)  # 3\\n```\".to_string()),\n        \"ceil\" => Some(\"**ceil(x)** - Round up\\n\\n```mdhavers\\nken n = ceil(3.2)  # 4\\n```\".to_string()),\n        \"round\" => Some(\"**round(x)** - Round to nearest integer\\n\\n```mdhavers\\nken n = round(3.5)  # 4\\n```\".to_string()),\n        \"sqrt\" => Some(\"**sqrt(x)** - Square root\\n\\n```mdhavers\\nken r = sqrt(16)  # 4.0\\n```\".to_string()),\n        \"split\" => Some(\"**split(string, delimiter)** - Split string\\n\\n```mdhavers\\nken words = split(\\\"a,b,c\\\", \\\",\\\")  # [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n```\".to_string()),\n        \"join\" => Some(\"**join(list, delimiter)** - Join list to string\\n\\n```mdhavers\\nken s = join([\\\"a\\\", \\\"b\\\"], \\\"-\\\")  # \\\"a-b\\\"\\n```\".to_string()),\n        \"contains\" => Some(\"**contains(haystack, needle)** - Check if contains\\n\\n```mdhavers\\ncontains(\\\"hello\\\", \\\"ell\\\")  # aye\\ncontains([1,2,3], 2)       # aye\\n```\".to_string()),\n        \"reverse\" => Some(\"**reverse(list)** - Reverse a list\\n\\n```mdhavers\\nken r = reverse([1, 2, 3])  # [3, 2, 1]\\n```\".to_string()),\n        \"sort\" => Some(\"**sort(list)** - Sort a list\\n\\n```mdhavers\\nken s = sort([3, 1, 2])  # [1, 2, 3]\\n```\".to_string()),\n        \"upper\" => Some(\"**upper(string)** - Convert to uppercase\\n\\n```mdhavers\\nken u = upper(\\\"hello\\\")  # \\\"HELLO\\\"\\n```\".to_string()),\n        \"lower\" => Some(\"**lower(string)** - Convert to lowercase\\n\\n```mdhavers\\nken l = lower(\\\"HELLO\\\")  # \\\"hello\\\"\\n```\".to_string()),\n        \"shuffle\" => Some(\"**shuffle(list)** - Randomly shuffle a list\\n\\n```mdhavers\\nken s = shuffle([1, 2, 3])  # random order\\n```\".to_string()),\n        \"gaun\" => Some(\"**gaun(list, fn)** - Map function over list\\n\\n```mdhavers\\nken doubled = gaun([1, 2, 3], |x| x * 2)  # [2, 4, 6]\\n```\\n\\nFrom Scots \\\"gaun\\\" meaning \\\"going\\\".\".to_string()),\n        \"sieve\" => Some(\"**sieve(list, fn)** - Filter list by predicate\\n\\n```mdhavers\\nken evens = sieve([1,2,3,4], |x| x % 2 == 0)  # [2, 4]\\n```\\n\\nFrom Scots \\\"sieve\\\" meaning \\\"to filter\\\".\".to_string()),\n        \"tumble\" => Some(\"**tumble(list, init, fn)** - Reduce/fold list\\n\\n```mdhavers\\nken sum = tumble([1,2,3], 0, |acc, x| acc + x)  # 6\\n```\\n\\nFrom Scots \\\"tumble\\\" meaning \\\"to roll up\\\".\".to_string()),\n        \"aw\" => Some(\"**aw(list, fn)** - Check if all elements satisfy predicate\\n\\n```mdhavers\\nken all_pos = aw([1,2,3], |x| x > 0)  # aye\\n```\\n\\nFrom Scots \\\"aw\\\" meaning \\\"all\\\".\".to_string()),\n        \"ony\" => Some(\"**ony(list, fn)** - Check if any element satisfies predicate\\n\\n```mdhavers\\nken has_neg = ony([1,-2,3], |x| x < 0)  # aye\\n```\\n\\nFrom Scots \\\"ony\\\" meaning \\\"any\\\".\".to_string()),\n        \"hunt\" => Some(\"**hunt(list, fn)** - Find first element satisfying predicate\\n\\n```mdhavers\\nken first_even = hunt([1,2,3,4], |x| x % 2 == 0)  # 2\\n```\\n\\nFrom Scots \\\"hunt\\\" meaning \\\"search\\\".\".to_string()),\n        \"noo\" => Some(\"**noo()** - Current timestamp in milliseconds\\n\\n```mdhavers\\nken start = noo()\\n# ... do stuff ...\\nken elapsed = noo() - start\\n```\\n\\nFrom Scots \\\"noo\\\" meaning \\\"now\\\".\".to_string()),\n        \"bide\" => Some(\"**bide(ms)** - Sleep for milliseconds\\n\\n```mdhavers\\nbide(1000)  # wait 1 second\\n```\\n\\nFrom Scots \\\"bide\\\" meaning \\\"wait\\\".\".to_string()),\n        \"jammy\" => Some(\"**jammy(min, max)** - Random integer in range\\n\\n```mdhavers\\nken lucky = jammy(1, 100)  # random 1-99\\n```\\n\\nFrom Scots \\\"jammy\\\" meaning \\\"lucky\\\".\".to_string()),\n        \"clype\" => Some(\"**clype(msg)** - Print debug message to stderr\\n\\n```mdhavers\\nclype(\\\"Debug info here\\\")\\n```\\n\\nFrom Scots \\\"clype\\\" meaning \\\"to tell tales\\\".\".to_string()),\n\n        // Set functions\n        \"creel\" => Some(\"**creel(list)** - Create a set from list\\n\\n```mdhavers\\nken s = creel([1, 2, 2, 3])  # {1, 2, 3}\\n```\\n\\nFrom Scots \\\"creel\\\" - a basket.\".to_string()),\n        \"empty_creel\" => Some(\"**empty_creel()** - Create an empty set\\n\\n```mdhavers\\nken s = empty_creel()\\n```\".to_string()),\n        \"toss_in\" => Some(\"**toss_in(creel, item)** - Add to set\\n\\n```mdhavers\\ntoss_in(my_set, 42)\\n```\".to_string()),\n        \"chuck_oot\" => Some(\"**chuck_oot(creel, item)** - Remove from set\\n\\n```mdhavers\\nchuck_oot(my_set, 42)\\n```\".to_string()),\n\n        _ => None,\n    }\n}\n\n/// Get all keywords and builtins fer completion\n/// Returns (name, kind, documentation)\npub fn get_keywords_and_builtins() -> Vec<(String, String, String)> {\n    vec![\n        // Keywords\n        (\n            \"ken\".to_string(),\n            \"keyword\".to_string(),\n            \"Variable declaration\".to_string(),\n        ),\n        (\n            \"gin\".to_string(),\n            \"keyword\".to_string(),\n            \"If statement\".to_string(),\n        ),\n        (\n            \"ither\".to_string(),\n            \"keyword\".to_string(),\n            \"Else clause\".to_string(),\n        ),\n        (\n            \"than\".to_string(),\n            \"keyword\".to_string(),\n            \"Then (ternary)\".to_string(),\n        ),\n        (\n            \"whiles\".to_string(),\n            \"keyword\".to_string(),\n            \"While loop\".to_string(),\n        ),\n        (\n            \"fer\".to_string(),\n            \"keyword\".to_string(),\n            \"For loop\".to_string(),\n        ),\n        (\n            \"dae\".to_string(),\n            \"keyword\".to_string(),\n            \"Function definition\".to_string(),\n        ),\n        (\n            \"gie\".to_string(),\n            \"keyword\".to_string(),\n            \"Return statement\".to_string(),\n        ),\n        (\n            \"blether\".to_string(),\n            \"keyword\".to_string(),\n            \"Print output\".to_string(),\n        ),\n        (\n            \"speir\".to_string(),\n            \"keyword\".to_string(),\n            \"User input\".to_string(),\n        ),\n        (\n            \"aye\".to_string(),\n            \"constant\".to_string(),\n            \"Boolean true\".to_string(),\n        ),\n        (\n            \"nae\".to_string(),\n            \"keyword\".to_string(),\n            \"Boolean false / not\".to_string(),\n        ),\n        (\n            \"naething\".to_string(),\n            \"constant\".to_string(),\n            \"Null value\".to_string(),\n        ),\n        (\n            \"an\".to_string(),\n            \"keyword\".to_string(),\n            \"Logical AND\".to_string(),\n        ),\n        (\n            \"or\".to_string(),\n            \"keyword\".to_string(),\n            \"Logical OR\".to_string(),\n        ),\n        (\n            \"brak\".to_string(),\n            \"keyword\".to_string(),\n            \"Break from loop\".to_string(),\n        ),\n        (\n            \"haud\".to_string(),\n            \"keyword\".to_string(),\n            \"Continue loop\".to_string(),\n        ),\n        (\n            \"kin\".to_string(),\n            \"keyword\".to_string(),\n            \"Class definition\".to_string(),\n        ),\n        (\n            \"thing\".to_string(),\n            \"keyword\".to_string(),\n            \"Struct definition\".to_string(),\n        ),\n        (\n            \"masel\".to_string(),\n            \"keyword\".to_string(),\n            \"Self reference\".to_string(),\n        ),\n        (\n            \"fetch\".to_string(),\n            \"keyword\".to_string(),\n            \"Import module\".to_string(),\n        ),\n        (\n            \"hae_a_bash\".to_string(),\n            \"keyword\".to_string(),\n            \"Try block\".to_string(),\n        ),\n        (\n            \"gin_it_gangs_wrang\".to_string(),\n            \"keyword\".to_string(),\n            \"Catch block\".to_string(),\n        ),\n        (\n            \"keek\".to_string(),\n            \"keyword\".to_string(),\n            \"Match statement\".to_string(),\n        ),\n        (\n            \"whan\".to_string(),\n            \"keyword\".to_string(),\n            \"Match case\".to_string(),\n        ),\n        (\n            \"mak_siccar\".to_string(),\n            \"keyword\".to_string(),\n            \"Assert\".to_string(),\n        ),\n        (\n            \"in\".to_string(),\n            \"keyword\".to_string(),\n            \"For-in keyword\".to_string(),\n        ),\n        (\n            \"is\".to_string(),\n            \"keyword\".to_string(),\n            \"Type check\".to_string(),\n        ),\n        (\n            \"fae\".to_string(),\n            \"keyword\".to_string(),\n            \"From (inheritance)\".to_string(),\n        ),\n        (\n            \"tae\".to_string(),\n            \"keyword\".to_string(),\n            \"To (import alias)\".to_string(),\n        ),\n        // Built-in functions\n        (\n            \"len\".to_string(),\n            \"function\".to_string(),\n            \"Get length of list/string\".to_string(),\n        ),\n        (\n            \"whit_kind\".to_string(),\n            \"function\".to_string(),\n            \"Get type of value\".to_string(),\n        ),\n        (\n            \"tae_string\".to_string(),\n            \"function\".to_string(),\n            \"Convert to string\".to_string(),\n        ),\n        (\n            \"tae_int\".to_string(),\n            \"function\".to_string(),\n            \"Convert to integer\".to_string(),\n        ),\n        (\n            \"tae_float\".to_string(),\n            \"function\".to_string(),\n            \"Convert to float\".to_string(),\n        ),\n        (\n            \"shove\".to_string(),\n            \"function\".to_string(),\n            \"Add to list (push)\".to_string(),\n        ),\n        (\n            \"yank\".to_string(),\n            \"function\".to_string(),\n            \"Remove from list (pop)\".to_string(),\n        ),\n        (\n            \"heid\".to_string(),\n            \"function\".to_string(),\n            \"First element\".to_string(),\n        ),\n        (\n            \"tail\".to_string(),\n            \"function\".to_string(),\n            \"All but first\".to_string(),\n        ),\n        (\n            \"bum\".to_string(),\n            \"function\".to_string(),\n            \"Last element\".to_string(),\n        ),\n        (\n            \"range\".to_string(),\n            \"function\".to_string(),\n            \"Create range\".to_string(),\n        ),\n        (\n            \"keys\".to_string(),\n            \"function\".to_string(),\n            \"Dictionary keys\".to_string(),\n        ),\n        (\n            \"values\".to_string(),\n            \"function\".to_string(),\n            \"Dictionary values\".to_string(),\n        ),\n        (\n            \"abs\".to_string(),\n            \"function\".to_string(),\n            \"Absolute value\".to_string(),\n        ),\n        (\n            \"min\".to_string(),\n            \"function\".to_string(),\n            \"Minimum\".to_string(),\n        ),\n        (\n            \"max\".to_string(),\n            \"function\".to_string(),\n            \"Maximum\".to_string(),\n        ),\n        (\n            \"floor\".to_string(),\n            \"function\".to_string(),\n            \"Round down\".to_string(),\n        ),\n        (\n            \"ceil\".to_string(),\n            \"function\".to_string(),\n            \"Round up\".to_string(),\n        ),\n        (\n            \"round\".to_string(),\n            \"function\".to_string(),\n            \"Round\".to_string(),\n        ),\n        (\n            \"sqrt\".to_string(),\n            \"function\".to_string(),\n            \"Square root\".to_string(),\n        ),\n        (\n            \"split\".to_string(),\n            \"function\".to_string(),\n            \"Split string\".to_string(),\n        ),\n        (\n            \"join\".to_string(),\n            \"function\".to_string(),\n            \"Join list\".to_string(),\n        ),\n        (\n            \"contains\".to_string(),\n            \"function\".to_string(),\n            \"Check containment\".to_string(),\n        ),\n        (\n            \"reverse\".to_string(),\n            \"function\".to_string(),\n            \"Reverse list\".to_string(),\n        ),\n        (\n            \"sort\".to_string(),\n            \"function\".to_string(),\n            \"Sort list\".to_string(),\n        ),\n        (\n            \"upper\".to_string(),\n            \"function\".to_string(),\n            \"Uppercase\".to_string(),\n        ),\n        (\n            \"lower\".to_string(),\n            \"function\".to_string(),\n            \"Lowercase\".to_string(),\n        ),\n        (\n            \"shuffle\".to_string(),\n            \"function\".to_string(),\n            \"Shuffle list\".to_string(),\n        ),\n        (\n            \"gaun\".to_string(),\n            \"function\".to_string(),\n            \"Map function\".to_string(),\n        ),\n        (\n            \"sieve\".to_string(),\n            \"function\".to_string(),\n            \"Filter list\".to_string(),\n        ),\n        (\n            \"tumble\".to_string(),\n            \"function\".to_string(),\n            \"Reduce/fold\".to_string(),\n        ),\n        (\n            \"aw\".to_string(),\n            \"function\".to_string(),\n            \"All satisfy\".to_string(),\n        ),\n        (\n            \"ony\".to_string(),\n            \"function\".to_string(),\n            \"Any satisfy\".to_string(),\n        ),\n        (\n            \"hunt\".to_string(),\n            \"function\".to_string(),\n            \"Find first\".to_string(),\n        ),\n        (\n            \"noo\".to_string(),\n            \"function\".to_string(),\n            \"Current time (ms)\".to_string(),\n        ),\n        (\n            \"bide\".to_string(),\n            \"function\".to_string(),\n            \"Sleep (ms)\".to_string(),\n        ),\n        (\n            \"jammy\".to_string(),\n            \"function\".to_string(),\n            \"Random number\".to_string(),\n        ),\n        (\n            \"clype\".to_string(),\n            \"function\".to_string(),\n            \"Debug print\".to_string(),\n        ),\n        (\n            \"creel\".to_string(),\n            \"function\".to_string(),\n            \"Create set\".to_string(),\n        ),\n        (\n            \"empty_creel\".to_string(),\n            \"function\".to_string(),\n            \"Empty set\".to_string(),\n        ),\n        (\n            \"toss_in\".to_string(),\n            \"function\".to_string(),\n            \"Add to set\".to_string(),\n        ),\n        (\n            \"chuck_oot\".to_string(),\n            \"function\".to_string(),\n            \"Remove from set\".to_string(),\n        ),\n    ]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_diagnostics_valid() {\n        // Valid code should produce no diagnostics\n        let source = \"ken x = 42\\nblether x\";\n        let diagnostics = get_diagnostics(source);\n        assert!(\n            diagnostics.is_empty(),\n            \"Expected no diagnostics for valid code\"\n        );\n    }\n\n    #[test]\n    fn test_get_diagnostics_unmatched_braces() {\n        // Unclosed brace should produce an error\n        let source = \"gin x > 0 {\\n    blether x\\n\";\n        let diagnostics = get_diagnostics(source);\n        assert!(\n            !diagnostics.is_empty(),\n            \"Expected diagnostics for unclosed brace\"\n        );\n        assert!(diagnostics.iter().any(|d| d.2.contains(\"Unclosed\")));\n    }\n\n    #[test]\n    fn test_get_keyword_info() {\n        // Test that we get info for keywords\n        let info = get_keyword_info(\"ken\");\n        assert!(info.is_some());\n        assert!(info.unwrap().contains(\"Variable declaration\"));\n\n        let info = get_keyword_info(\"gin\");\n        assert!(info.is_some());\n        assert!(info.unwrap().contains(\"If statement\"));\n\n        // Unknown word should return None\n        let info = get_keyword_info(\"foobar\");\n        assert!(info.is_none());\n    }\n\n    #[test]\n    fn test_get_keywords_and_builtins() {\n        let items = get_keywords_and_builtins();\n        assert!(!items.is_empty());\n\n        // Check that common items are present\n        let names: Vec<&str> = items.iter().map(|i| i.0.as_str()).collect();\n        assert!(names.contains(&\"ken\"));\n        assert!(names.contains(&\"gin\"));\n        assert!(names.contains(&\"blether\"));\n        assert!(names.contains(&\"len\"));\n        assert!(names.contains(&\"gaun\"));\n    }\n}\n","traces":[{"line":10,"address":[2073674,2074004,2072752],"length":1,"stats":{"Line":2}},{"line":11,"address":[2072809],"length":1,"stats":{"Line":2}},{"line":14,"address":[2072838],"length":1,"stats":{"Line":2}},{"line":15,"address":[2072885],"length":1,"stats":{"Line":2}},{"line":16,"address":[2072897],"length":1,"stats":{"Line":2}},{"line":18,"address":[2072917],"length":1,"stats":{"Line":2}},{"line":19,"address":[2072988,2073049],"length":1,"stats":{"Line":4}},{"line":22,"address":[2073065],"length":1,"stats":{"Line":2}},{"line":23,"address":[2073229,2073758,2073795],"length":1,"stats":{"Line":6}},{"line":24,"address":[2073763,2073738,2073680],"length":1,"stats":{"Line":4}},{"line":25,"address":[2073746],"length":1,"stats":{"Line":2}},{"line":27,"address":[2073787,2073707,2073800],"length":1,"stats":{"Line":4}},{"line":31,"address":[2073251],"length":1,"stats":{"Line":2}},{"line":32,"address":[2073559],"length":1,"stats":{"Line":0}},{"line":33,"address":[2073275],"length":1,"stats":{"Line":0}},{"line":34,"address":[2073288],"length":1,"stats":{"Line":0}},{"line":35,"address":[2073351],"length":1,"stats":{"Line":0}},{"line":36,"address":[2073478],"length":1,"stats":{"Line":0}},{"line":42,"address":[2073029,2073818],"length":1,"stats":{"Line":3}},{"line":43,"address":[2073919,2074002],"length":1,"stats":{"Line":2}},{"line":46,"address":[2073959],"length":1,"stats":{"Line":1}},{"line":205,"address":[2082628,2081488,2085111],"length":1,"stats":{"Line":2}},{"line":206,"address":[2081551],"length":1,"stats":{"Line":2}},{"line":207,"address":[2081572],"length":1,"stats":{"Line":2}},{"line":208,"address":[2081584],"length":1,"stats":{"Line":2}},{"line":210,"address":[2085088,2081596,2081675],"length":1,"stats":{"Line":6}},{"line":211,"address":[2081825],"length":1,"stats":{"Line":2}},{"line":213,"address":[2082869,2082691],"length":1,"stats":{"Line":2}},{"line":216,"address":[2082776,2082874],"length":1,"stats":{"Line":0}},{"line":217,"address":[2082918],"length":1,"stats":{"Line":0}},{"line":218,"address":[2083232],"length":1,"stats":{"Line":0}},{"line":219,"address":[2082990],"length":1,"stats":{"Line":0}},{"line":220,"address":[2083003],"length":1,"stats":{"Line":0}},{"line":221,"address":[2083016],"length":1,"stats":{"Line":0}},{"line":222,"address":[2083143],"length":1,"stats":{"Line":0}},{"line":226,"address":[2083456],"length":1,"stats":{"Line":0}},{"line":227,"address":[2082934],"length":1,"stats":{"Line":0}},{"line":228,"address":[2082947],"length":1,"stats":{"Line":0}},{"line":229,"address":[2082960],"length":1,"stats":{"Line":0}},{"line":230,"address":[2083367],"length":1,"stats":{"Line":0}},{"line":235,"address":[2082799,2083591],"length":1,"stats":{"Line":0}},{"line":236,"address":[2083635],"length":1,"stats":{"Line":0}},{"line":237,"address":[2083949],"length":1,"stats":{"Line":0}},{"line":238,"address":[2083707],"length":1,"stats":{"Line":0}},{"line":239,"address":[2083720],"length":1,"stats":{"Line":0}},{"line":240,"address":[2083733],"length":1,"stats":{"Line":0}},{"line":241,"address":[2083860],"length":1,"stats":{"Line":0}},{"line":245,"address":[2084173],"length":1,"stats":{"Line":0}},{"line":246,"address":[2083651],"length":1,"stats":{"Line":0}},{"line":247,"address":[2083664],"length":1,"stats":{"Line":0}},{"line":248,"address":[2083677],"length":1,"stats":{"Line":0}},{"line":249,"address":[2084084],"length":1,"stats":{"Line":0}},{"line":254,"address":[2084308,2082825],"length":1,"stats":{"Line":0}},{"line":255,"address":[2084352],"length":1,"stats":{"Line":0}},{"line":256,"address":[2084666],"length":1,"stats":{"Line":0}},{"line":257,"address":[2084424],"length":1,"stats":{"Line":0}},{"line":258,"address":[2084437],"length":1,"stats":{"Line":0}},{"line":259,"address":[2084450],"length":1,"stats":{"Line":0}},{"line":260,"address":[2084577],"length":1,"stats":{"Line":0}},{"line":264,"address":[2084890],"length":1,"stats":{"Line":0}},{"line":265,"address":[2084368],"length":1,"stats":{"Line":0}},{"line":266,"address":[2084381],"length":1,"stats":{"Line":0}},{"line":267,"address":[2084394],"length":1,"stats":{"Line":0}},{"line":268,"address":[2084801],"length":1,"stats":{"Line":0}},{"line":272,"address":[2085050],"length":1,"stats":{"Line":2}},{"line":273,"address":[2085055,2085030,2082835],"length":1,"stats":{"Line":2}},{"line":274,"address":[2085038],"length":1,"stats":{"Line":2}},{"line":278,"address":[2082650,2085080,2085093],"length":1,"stats":{"Line":4}},{"line":282,"address":[2081963],"length":1,"stats":{"Line":2}},{"line":283,"address":[2082059],"length":1,"stats":{"Line":1}},{"line":284,"address":[2082160],"length":1,"stats":{"Line":1}},{"line":285,"address":[2082173],"length":1,"stats":{"Line":0}},{"line":286,"address":[2082186],"length":1,"stats":{"Line":0}},{"line":287,"address":[2082147],"length":1,"stats":{"Line":0}},{"line":289,"address":[2082483],"length":1,"stats":{"Line":1}},{"line":292,"address":[2082205],"length":1,"stats":{"Line":1}},{"line":293,"address":[2082391],"length":1,"stats":{"Line":1}},{"line":297,"address":[2082116],"length":1,"stats":{"Line":1}},{"line":301,"address":[2074032],"length":1,"stats":{"Line":1}},{"line":304,"address":[2074091,2074145],"length":1,"stats":{"Line":2}},{"line":305,"address":[2074122,2074236],"length":1,"stats":{"Line":2}},{"line":306,"address":[2074213,2074327],"length":1,"stats":{"Line":1}},{"line":307,"address":[2074418,2074304],"length":1,"stats":{"Line":1}},{"line":308,"address":[2074395,2074512],"length":1,"stats":{"Line":1}},{"line":309,"address":[2074489,2074615],"length":1,"stats":{"Line":1}},{"line":310,"address":[2074718,2074592],"length":1,"stats":{"Line":1}},{"line":311,"address":[2074821,2074695],"length":1,"stats":{"Line":1}},{"line":312,"address":[2074924,2074798],"length":1,"stats":{"Line":1}},{"line":313,"address":[2074901,2075027],"length":1,"stats":{"Line":1}},{"line":314,"address":[2075004,2075130],"length":1,"stats":{"Line":1}},{"line":315,"address":[2075233,2075107],"length":1,"stats":{"Line":1}},{"line":316,"address":[2075210,2075336],"length":1,"stats":{"Line":1}},{"line":317,"address":[2075313,2075439],"length":1,"stats":{"Line":1}},{"line":318,"address":[2075416,2075542],"length":1,"stats":{"Line":1}},{"line":319,"address":[2075519,2075645],"length":1,"stats":{"Line":1}},{"line":320,"address":[2075748,2075622],"length":1,"stats":{"Line":1}},{"line":321,"address":[2075725,2075851],"length":1,"stats":{"Line":1}},{"line":322,"address":[2075954,2075828],"length":1,"stats":{"Line":1}},{"line":323,"address":[2075931,2076057],"length":1,"stats":{"Line":1}},{"line":324,"address":[2076160,2076034],"length":1,"stats":{"Line":1}},{"line":325,"address":[2076137,2076263],"length":1,"stats":{"Line":1}},{"line":326,"address":[2076240,2076366],"length":1,"stats":{"Line":1}},{"line":327,"address":[2076343,2076469],"length":1,"stats":{"Line":1}},{"line":328,"address":[2076446,2076572],"length":1,"stats":{"Line":1}},{"line":329,"address":[2076675,2076549],"length":1,"stats":{"Line":1}},{"line":330,"address":[2076778,2076652],"length":1,"stats":{"Line":1}},{"line":331,"address":[2076881,2076755],"length":1,"stats":{"Line":1}},{"line":332,"address":[2076858,2076984],"length":1,"stats":{"Line":1}},{"line":333,"address":[2077087,2076961],"length":1,"stats":{"Line":1}},{"line":336,"address":[2077064,2077190],"length":1,"stats":{"Line":1}},{"line":337,"address":[2077293,2077167],"length":1,"stats":{"Line":1}},{"line":338,"address":[2077270,2077396],"length":1,"stats":{"Line":1}},{"line":339,"address":[2077499,2077373],"length":1,"stats":{"Line":1}},{"line":340,"address":[2077602,2077476],"length":1,"stats":{"Line":1}},{"line":341,"address":[2077579,2077705],"length":1,"stats":{"Line":1}},{"line":342,"address":[2077808,2077682],"length":1,"stats":{"Line":1}},{"line":343,"address":[2077785,2077911],"length":1,"stats":{"Line":1}},{"line":344,"address":[2077888,2078014],"length":1,"stats":{"Line":1}},{"line":345,"address":[2078117,2077991],"length":1,"stats":{"Line":1}},{"line":346,"address":[2078220,2078094],"length":1,"stats":{"Line":1}},{"line":347,"address":[2078197,2078323],"length":1,"stats":{"Line":1}},{"line":348,"address":[2078426,2078300],"length":1,"stats":{"Line":1}},{"line":349,"address":[2078529,2078403],"length":1,"stats":{"Line":1}},{"line":350,"address":[2078506,2078632],"length":1,"stats":{"Line":1}},{"line":351,"address":[2078609,2078735],"length":1,"stats":{"Line":1}},{"line":352,"address":[2078712,2078838],"length":1,"stats":{"Line":1}},{"line":353,"address":[2078941,2078815],"length":1,"stats":{"Line":1}},{"line":354,"address":[2078918,2079044],"length":1,"stats":{"Line":1}},{"line":355,"address":[2079021,2079147],"length":1,"stats":{"Line":1}},{"line":356,"address":[2079250,2079124],"length":1,"stats":{"Line":1}},{"line":357,"address":[2079227,2079353],"length":1,"stats":{"Line":1}},{"line":358,"address":[2079456,2079330],"length":1,"stats":{"Line":1}},{"line":359,"address":[2079433,2079559],"length":1,"stats":{"Line":1}},{"line":360,"address":[2079662,2079536],"length":1,"stats":{"Line":1}},{"line":361,"address":[2079639,2079765],"length":1,"stats":{"Line":1}},{"line":362,"address":[2079742,2079868],"length":1,"stats":{"Line":1}},{"line":363,"address":[2079971,2079845],"length":1,"stats":{"Line":1}},{"line":364,"address":[2080074,2079948],"length":1,"stats":{"Line":1}},{"line":365,"address":[2080177,2080051],"length":1,"stats":{"Line":1}},{"line":366,"address":[2080154,2080280],"length":1,"stats":{"Line":1}},{"line":367,"address":[2080383,2080257],"length":1,"stats":{"Line":1}},{"line":368,"address":[2080486,2080360],"length":1,"stats":{"Line":1}},{"line":369,"address":[2080589,2080463],"length":1,"stats":{"Line":1}},{"line":370,"address":[2080692,2080566],"length":1,"stats":{"Line":1}},{"line":371,"address":[2080795,2080669],"length":1,"stats":{"Line":1}},{"line":372,"address":[2080772,2080898],"length":1,"stats":{"Line":1}},{"line":373,"address":[2081001,2080875],"length":1,"stats":{"Line":1}},{"line":376,"address":[2081104,2080978],"length":1,"stats":{"Line":1}},{"line":377,"address":[2081081,2081207],"length":1,"stats":{"Line":1}},{"line":378,"address":[2081184,2081310],"length":1,"stats":{"Line":1}},{"line":379,"address":[2081397,2081287],"length":1,"stats":{"Line":1}},{"line":381,"address":[2081382],"length":1,"stats":{"Line":1}},{"line":387,"address":[2108929,2108935,2085136],"length":1,"stats":{"Line":1}},{"line":388,"address":[2091182,2098358,2108916,2104338,2100451,2101049,2089986,2091780,2097162,2087295,2098956,2102544,2099853,2085800,2098657,2099255,2103441,2094172,2089687,2087893,2090883,2101647,2085501,2086697,2095069,2095667,2089388,2106132,2091481,2102843,2085193,2092079,2096564,2090584,2093275,2088790,2085232,2093873,2106743,2088192,2092378,2102245,2099554,2096863,2094770,2086996,2092976,2105534,2086099,2086398,2093574,2100152,2104637,2095368,2103740,2104039,2096265,2103142,2106431,2089089,2105833,2092677,2095966,2101946,2105235,2100750,2090285,2088491,2101348,2104936,2098059,2097461,2097760,2087594,2094471],"length":1,"stats":{"Line":2}},{"line":391,"address":[2085203],"length":1,"stats":{"Line":1}},{"line":392,"address":[2085264],"length":1,"stats":{"Line":1}},{"line":393,"address":[2085329],"length":1,"stats":{"Line":1}},{"line":396,"address":[2085469],"length":1,"stats":{"Line":1}},{"line":397,"address":[2085533],"length":1,"stats":{"Line":1}},{"line":398,"address":[2085601],"length":1,"stats":{"Line":1}},{"line":401,"address":[2085765],"length":1,"stats":{"Line":1}},{"line":402,"address":[2085832],"length":1,"stats":{"Line":1}},{"line":403,"address":[2085900],"length":1,"stats":{"Line":1}},{"line":406,"address":[2086064],"length":1,"stats":{"Line":1}},{"line":407,"address":[2086131],"length":1,"stats":{"Line":1}},{"line":408,"address":[2086199],"length":1,"stats":{"Line":1}},{"line":411,"address":[2086363],"length":1,"stats":{"Line":1}},{"line":412,"address":[2086430],"length":1,"stats":{"Line":1}},{"line":413,"address":[2086498],"length":1,"stats":{"Line":1}},{"line":416,"address":[2086662],"length":1,"stats":{"Line":1}},{"line":417,"address":[2086729],"length":1,"stats":{"Line":1}},{"line":418,"address":[2086797],"length":1,"stats":{"Line":1}},{"line":421,"address":[2086961],"length":1,"stats":{"Line":1}},{"line":422,"address":[2087028],"length":1,"stats":{"Line":1}},{"line":423,"address":[2087096],"length":1,"stats":{"Line":1}},{"line":426,"address":[2087260],"length":1,"stats":{"Line":1}},{"line":427,"address":[2087327],"length":1,"stats":{"Line":1}},{"line":428,"address":[2087395],"length":1,"stats":{"Line":1}},{"line":431,"address":[2087559],"length":1,"stats":{"Line":1}},{"line":432,"address":[2087626],"length":1,"stats":{"Line":1}},{"line":433,"address":[2087694],"length":1,"stats":{"Line":1}},{"line":436,"address":[2087858],"length":1,"stats":{"Line":1}},{"line":437,"address":[2087925],"length":1,"stats":{"Line":1}},{"line":438,"address":[2087993],"length":1,"stats":{"Line":1}},{"line":441,"address":[2088157],"length":1,"stats":{"Line":1}},{"line":442,"address":[2088224],"length":1,"stats":{"Line":1}},{"line":443,"address":[2088292],"length":1,"stats":{"Line":1}},{"line":446,"address":[2088456],"length":1,"stats":{"Line":1}},{"line":447,"address":[2088523],"length":1,"stats":{"Line":1}},{"line":448,"address":[2088591],"length":1,"stats":{"Line":1}},{"line":451,"address":[2088755],"length":1,"stats":{"Line":1}},{"line":452,"address":[2088822],"length":1,"stats":{"Line":1}},{"line":453,"address":[2088890],"length":1,"stats":{"Line":1}},{"line":456,"address":[2089054],"length":1,"stats":{"Line":1}},{"line":457,"address":[2089121],"length":1,"stats":{"Line":1}},{"line":458,"address":[2089189],"length":1,"stats":{"Line":1}},{"line":461,"address":[2089353],"length":1,"stats":{"Line":1}},{"line":462,"address":[2089420],"length":1,"stats":{"Line":1}},{"line":463,"address":[2089488],"length":1,"stats":{"Line":1}},{"line":466,"address":[2089652],"length":1,"stats":{"Line":1}},{"line":467,"address":[2089719],"length":1,"stats":{"Line":1}},{"line":468,"address":[2089787],"length":1,"stats":{"Line":1}},{"line":471,"address":[2089951],"length":1,"stats":{"Line":1}},{"line":472,"address":[2090018],"length":1,"stats":{"Line":1}},{"line":473,"address":[2090086],"length":1,"stats":{"Line":1}},{"line":476,"address":[2090250],"length":1,"stats":{"Line":1}},{"line":477,"address":[2090317],"length":1,"stats":{"Line":1}},{"line":478,"address":[2090385],"length":1,"stats":{"Line":1}},{"line":481,"address":[2090549],"length":1,"stats":{"Line":1}},{"line":482,"address":[2090616],"length":1,"stats":{"Line":1}},{"line":483,"address":[2090684],"length":1,"stats":{"Line":1}},{"line":486,"address":[2090848],"length":1,"stats":{"Line":1}},{"line":487,"address":[2090915],"length":1,"stats":{"Line":1}},{"line":488,"address":[2090983],"length":1,"stats":{"Line":1}},{"line":491,"address":[2091147],"length":1,"stats":{"Line":1}},{"line":492,"address":[2091214],"length":1,"stats":{"Line":1}},{"line":493,"address":[2091282],"length":1,"stats":{"Line":1}},{"line":496,"address":[2091446],"length":1,"stats":{"Line":1}},{"line":497,"address":[2091513],"length":1,"stats":{"Line":1}},{"line":498,"address":[2091581],"length":1,"stats":{"Line":1}},{"line":501,"address":[2091745],"length":1,"stats":{"Line":1}},{"line":502,"address":[2091812],"length":1,"stats":{"Line":1}},{"line":503,"address":[2091880],"length":1,"stats":{"Line":1}},{"line":506,"address":[2092044],"length":1,"stats":{"Line":1}},{"line":507,"address":[2092111],"length":1,"stats":{"Line":1}},{"line":508,"address":[2092179],"length":1,"stats":{"Line":1}},{"line":511,"address":[2092343],"length":1,"stats":{"Line":1}},{"line":512,"address":[2092410],"length":1,"stats":{"Line":1}},{"line":513,"address":[2092478],"length":1,"stats":{"Line":1}},{"line":516,"address":[2092642],"length":1,"stats":{"Line":1}},{"line":517,"address":[2092709],"length":1,"stats":{"Line":1}},{"line":518,"address":[2092777],"length":1,"stats":{"Line":1}},{"line":521,"address":[2092941],"length":1,"stats":{"Line":1}},{"line":522,"address":[2093008],"length":1,"stats":{"Line":1}},{"line":523,"address":[2093076],"length":1,"stats":{"Line":1}},{"line":526,"address":[2093240],"length":1,"stats":{"Line":1}},{"line":527,"address":[2093307],"length":1,"stats":{"Line":1}},{"line":528,"address":[2093375],"length":1,"stats":{"Line":1}},{"line":531,"address":[2093539],"length":1,"stats":{"Line":1}},{"line":532,"address":[2093606],"length":1,"stats":{"Line":1}},{"line":533,"address":[2093674],"length":1,"stats":{"Line":1}},{"line":536,"address":[2093838],"length":1,"stats":{"Line":1}},{"line":537,"address":[2093905],"length":1,"stats":{"Line":1}},{"line":538,"address":[2093973],"length":1,"stats":{"Line":1}},{"line":542,"address":[2094137],"length":1,"stats":{"Line":1}},{"line":543,"address":[2094204],"length":1,"stats":{"Line":1}},{"line":544,"address":[2094272],"length":1,"stats":{"Line":1}},{"line":547,"address":[2094436],"length":1,"stats":{"Line":1}},{"line":548,"address":[2094503],"length":1,"stats":{"Line":1}},{"line":549,"address":[2094571],"length":1,"stats":{"Line":1}},{"line":552,"address":[2094735],"length":1,"stats":{"Line":1}},{"line":553,"address":[2094802],"length":1,"stats":{"Line":1}},{"line":554,"address":[2094870],"length":1,"stats":{"Line":1}},{"line":557,"address":[2095034],"length":1,"stats":{"Line":1}},{"line":558,"address":[2095101],"length":1,"stats":{"Line":1}},{"line":559,"address":[2095169],"length":1,"stats":{"Line":1}},{"line":562,"address":[2095333],"length":1,"stats":{"Line":1}},{"line":563,"address":[2095400],"length":1,"stats":{"Line":1}},{"line":564,"address":[2095468],"length":1,"stats":{"Line":1}},{"line":567,"address":[2095632],"length":1,"stats":{"Line":1}},{"line":568,"address":[2095699],"length":1,"stats":{"Line":1}},{"line":569,"address":[2095767],"length":1,"stats":{"Line":1}},{"line":572,"address":[2095931],"length":1,"stats":{"Line":1}},{"line":573,"address":[2095998],"length":1,"stats":{"Line":1}},{"line":574,"address":[2096066],"length":1,"stats":{"Line":1}},{"line":577,"address":[2096230],"length":1,"stats":{"Line":1}},{"line":578,"address":[2096297],"length":1,"stats":{"Line":1}},{"line":579,"address":[2096365],"length":1,"stats":{"Line":1}},{"line":582,"address":[2096529],"length":1,"stats":{"Line":1}},{"line":583,"address":[2096596],"length":1,"stats":{"Line":1}},{"line":584,"address":[2096664],"length":1,"stats":{"Line":1}},{"line":587,"address":[2096828],"length":1,"stats":{"Line":1}},{"line":588,"address":[2096895],"length":1,"stats":{"Line":1}},{"line":589,"address":[2096963],"length":1,"stats":{"Line":1}},{"line":592,"address":[2097127],"length":1,"stats":{"Line":1}},{"line":593,"address":[2097194],"length":1,"stats":{"Line":1}},{"line":594,"address":[2097262],"length":1,"stats":{"Line":1}},{"line":597,"address":[2097426],"length":1,"stats":{"Line":1}},{"line":598,"address":[2097493],"length":1,"stats":{"Line":1}},{"line":599,"address":[2097561],"length":1,"stats":{"Line":1}},{"line":602,"address":[2097725],"length":1,"stats":{"Line":1}},{"line":603,"address":[2097792],"length":1,"stats":{"Line":1}},{"line":604,"address":[2097860],"length":1,"stats":{"Line":1}},{"line":607,"address":[2098024],"length":1,"stats":{"Line":1}},{"line":608,"address":[2098091],"length":1,"stats":{"Line":1}},{"line":609,"address":[2098159],"length":1,"stats":{"Line":1}},{"line":612,"address":[2098323],"length":1,"stats":{"Line":1}},{"line":613,"address":[2098390],"length":1,"stats":{"Line":1}},{"line":614,"address":[2098458],"length":1,"stats":{"Line":1}},{"line":617,"address":[2098622],"length":1,"stats":{"Line":1}},{"line":618,"address":[2098689],"length":1,"stats":{"Line":1}},{"line":619,"address":[2098757],"length":1,"stats":{"Line":1}},{"line":622,"address":[2098921],"length":1,"stats":{"Line":1}},{"line":623,"address":[2098988],"length":1,"stats":{"Line":1}},{"line":624,"address":[2099056],"length":1,"stats":{"Line":1}},{"line":627,"address":[2099220],"length":1,"stats":{"Line":1}},{"line":628,"address":[2099287],"length":1,"stats":{"Line":1}},{"line":629,"address":[2099355],"length":1,"stats":{"Line":1}},{"line":632,"address":[2099519],"length":1,"stats":{"Line":1}},{"line":633,"address":[2099586],"length":1,"stats":{"Line":1}},{"line":634,"address":[2099654],"length":1,"stats":{"Line":1}},{"line":637,"address":[2099818],"length":1,"stats":{"Line":1}},{"line":638,"address":[2099885],"length":1,"stats":{"Line":1}},{"line":639,"address":[2099953],"length":1,"stats":{"Line":1}},{"line":642,"address":[2100117],"length":1,"stats":{"Line":1}},{"line":643,"address":[2100184],"length":1,"stats":{"Line":1}},{"line":644,"address":[2100252],"length":1,"stats":{"Line":1}},{"line":647,"address":[2100416],"length":1,"stats":{"Line":1}},{"line":648,"address":[2100483],"length":1,"stats":{"Line":1}},{"line":649,"address":[2100551],"length":1,"stats":{"Line":1}},{"line":652,"address":[2100715],"length":1,"stats":{"Line":1}},{"line":653,"address":[2100782],"length":1,"stats":{"Line":1}},{"line":654,"address":[2100850],"length":1,"stats":{"Line":1}},{"line":657,"address":[2101014],"length":1,"stats":{"Line":1}},{"line":658,"address":[2101081],"length":1,"stats":{"Line":1}},{"line":659,"address":[2101149],"length":1,"stats":{"Line":1}},{"line":662,"address":[2101313],"length":1,"stats":{"Line":1}},{"line":663,"address":[2101380],"length":1,"stats":{"Line":1}},{"line":664,"address":[2101448],"length":1,"stats":{"Line":1}},{"line":667,"address":[2101612],"length":1,"stats":{"Line":1}},{"line":668,"address":[2101679],"length":1,"stats":{"Line":1}},{"line":669,"address":[2101747],"length":1,"stats":{"Line":1}},{"line":672,"address":[2101911],"length":1,"stats":{"Line":1}},{"line":673,"address":[2101978],"length":1,"stats":{"Line":1}},{"line":674,"address":[2102046],"length":1,"stats":{"Line":1}},{"line":677,"address":[2102210],"length":1,"stats":{"Line":1}},{"line":678,"address":[2102277],"length":1,"stats":{"Line":1}},{"line":679,"address":[2102345],"length":1,"stats":{"Line":1}},{"line":682,"address":[2102509],"length":1,"stats":{"Line":1}},{"line":683,"address":[2102576],"length":1,"stats":{"Line":1}},{"line":684,"address":[2102644],"length":1,"stats":{"Line":1}},{"line":687,"address":[2102808],"length":1,"stats":{"Line":1}},{"line":688,"address":[2102875],"length":1,"stats":{"Line":1}},{"line":689,"address":[2102943],"length":1,"stats":{"Line":1}},{"line":692,"address":[2103107],"length":1,"stats":{"Line":1}},{"line":693,"address":[2103174],"length":1,"stats":{"Line":1}},{"line":694,"address":[2103242],"length":1,"stats":{"Line":1}},{"line":697,"address":[2103406],"length":1,"stats":{"Line":1}},{"line":698,"address":[2103473],"length":1,"stats":{"Line":1}},{"line":699,"address":[2103541],"length":1,"stats":{"Line":1}},{"line":702,"address":[2103705],"length":1,"stats":{"Line":1}},{"line":703,"address":[2103772],"length":1,"stats":{"Line":1}},{"line":704,"address":[2103840],"length":1,"stats":{"Line":1}},{"line":707,"address":[2104004],"length":1,"stats":{"Line":1}},{"line":708,"address":[2104071],"length":1,"stats":{"Line":1}},{"line":709,"address":[2104139],"length":1,"stats":{"Line":1}},{"line":712,"address":[2104303],"length":1,"stats":{"Line":1}},{"line":713,"address":[2104370],"length":1,"stats":{"Line":1}},{"line":714,"address":[2104438],"length":1,"stats":{"Line":1}},{"line":717,"address":[2104602],"length":1,"stats":{"Line":1}},{"line":718,"address":[2104669],"length":1,"stats":{"Line":1}},{"line":719,"address":[2104737],"length":1,"stats":{"Line":1}},{"line":722,"address":[2104901],"length":1,"stats":{"Line":1}},{"line":723,"address":[2104968],"length":1,"stats":{"Line":1}},{"line":724,"address":[2105036],"length":1,"stats":{"Line":1}},{"line":727,"address":[2105200],"length":1,"stats":{"Line":1}},{"line":728,"address":[2105267],"length":1,"stats":{"Line":1}},{"line":729,"address":[2105335],"length":1,"stats":{"Line":1}},{"line":732,"address":[2105499],"length":1,"stats":{"Line":1}},{"line":733,"address":[2105566],"length":1,"stats":{"Line":1}},{"line":734,"address":[2105634],"length":1,"stats":{"Line":1}},{"line":737,"address":[2105798],"length":1,"stats":{"Line":1}},{"line":738,"address":[2105865],"length":1,"stats":{"Line":1}},{"line":739,"address":[2105933],"length":1,"stats":{"Line":1}},{"line":742,"address":[2106097],"length":1,"stats":{"Line":1}},{"line":743,"address":[2106164],"length":1,"stats":{"Line":1}},{"line":744,"address":[2106232],"length":1,"stats":{"Line":1}},{"line":747,"address":[2106396],"length":1,"stats":{"Line":1}},{"line":748,"address":[2106463],"length":1,"stats":{"Line":1}},{"line":749,"address":[2106531],"length":1,"stats":{"Line":1}}],"covered":326,"coverable":370},{"path":["/","home","md","language","mdhavers","src","main.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\nuse std::process;\n\nuse clap::{Parser, Subcommand};\nuse colored::*;\nuse rustyline::error::ReadlineError;\nuse rustyline::DefaultEditor;\n\nmod ast;\nmod compiler;\nmod error;\nmod formatter;\nmod graphics;\nmod interpreter;\nmod lexer;\nmod parser;\nmod token;\nmod value;\nmod wasm_compiler;\n\n#[cfg(feature = \"llvm\")]\nmod llvm;\n\nuse crate::compiler::compile;\nuse crate::error::{format_error_context, random_scots_exclamation};\nuse crate::interpreter::{is_crash_handling_enabled, print_stack_trace, Interpreter};\nuse crate::parser::parse;\n\n/// Initialize crash handlers for graceful error reporting\nfn setup_crash_handlers() {\n    // Set up panic hook to print stack trace\n    let default_panic = std::panic::take_hook();\n    std::panic::set_hook(Box::new(move |panic_info| {\n        if is_crash_handling_enabled() {\n            eprintln!(\"\\n{}\", \" Och noo! The program crashed!\".red().bold());\n            if let Some(location) = panic_info.location() {\n                eprintln!(\n                    \"{}\",\n                    format!(\"Panic at {}:{}\", location.file(), location.line()).red()\n                );\n            }\n            if let Some(message) = panic_info.payload().downcast_ref::<&str>() {\n                eprintln!(\"{}\", format!(\"Message: {}\", message).red());\n            } else if let Some(message) = panic_info.payload().downcast_ref::<String>() {\n                eprintln!(\"{}\", format!(\"Message: {}\", message).red());\n            }\n            print_stack_trace();\n            eprintln!(\n                \"\\n{}\",\n                \"This shouldnae hae happened! Please report this issue.\".yellow()\n            );\n        }\n        default_panic(panic_info);\n    }));\n}\n\n/// mdhavers - A Scots programming language\n/// Pure havers, but working havers!\n#[derive(Parser)]\n#[command(name = \"mdhavers\")]\n#[command(author = \"Arthur\")]\n#[command(version = \"0.1.0\")]\n#[command(about = \"A Scots programming language - pure havers, but working havers!\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option<Commands>,\n\n    /// Run a .braw file directly\n    #[arg(value_name = \"FILE\")]\n    file: Option<PathBuf>,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Run a .braw program\n    Run {\n        /// The .braw file to run\n        file: PathBuf,\n    },\n\n    /// Compile a .braw program to JavaScript\n    Compile {\n        /// The .braw file to compile\n        file: PathBuf,\n\n        /// Output file (defaults to <input>.js)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n    },\n\n    /// Start the interactive REPL\n    Repl,\n\n    /// Check a .braw file for errors without running it\n    Check {\n        /// The .braw file to check\n        file: PathBuf,\n    },\n\n    /// Format a .braw file (pretty print)\n    #[command(name = \"fmt\")]\n    Format {\n        /// The .braw file to format\n        file: PathBuf,\n\n        /// Just check if formatting is needed (dinnae modify)\n        #[arg(long)]\n        check: bool,\n    },\n\n    /// Show tokens from lexer (for debugging)\n    Tokens {\n        /// The .braw file to tokenize\n        file: PathBuf,\n    },\n\n    /// Show AST from parser (for debugging)\n    Ast {\n        /// The .braw file to parse\n        file: PathBuf,\n    },\n\n    /// Trace a .braw program (step-by-step execution wi' Scottish commentary)\n    Trace {\n        /// The .braw file to trace\n        file: PathBuf,\n\n        /// Verbose mode - shows expressions and values too\n        #[arg(short, long)]\n        verbose: bool,\n    },\n\n    /// Compile a .braw program to WebAssembly (WAT format)\n    Wasm {\n        /// The .braw file to compile\n        file: PathBuf,\n\n        /// Output file (defaults to <input>.wat)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n    },\n\n    /// Build a native executable using LLVM\n    Build {\n        /// The .braw file to compile\n        file: PathBuf,\n\n        /// Output file (defaults to <input> without extension)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n\n        /// Optimization level (0-3)\n        #[arg(short = 'O', long, default_value = \"2\")]\n        opt_level: u8,\n\n        /// Emit LLVM IR instead of native binary\n        #[arg(long)]\n        emit_llvm: bool,\n    },\n}\n\nfn main() {\n    // Set up crash handlers for graceful error reporting\n    setup_crash_handlers();\n\n    let cli = Cli::parse();\n\n    let result = match cli.command {\n        Some(Commands::Run { file }) => run_file(&file),\n        Some(Commands::Compile { file, output }) => compile_file(&file, output),\n        Some(Commands::Repl) => run_repl(),\n        Some(Commands::Check { file }) => check_file(&file),\n        Some(Commands::Format { file, check }) => format_file(&file, check),\n        Some(Commands::Tokens { file }) => show_tokens(&file),\n        Some(Commands::Ast { file }) => show_ast(&file),\n        Some(Commands::Trace { file, verbose }) => trace_file(&file, verbose),\n        Some(Commands::Wasm { file, output }) => compile_wasm(&file, output),\n        Some(Commands::Build {\n            file,\n            output,\n            opt_level,\n            emit_llvm,\n        }) => build_native(&file, output, opt_level, emit_llvm),\n        None => {\n            // If a file is provided directly, run it\n            if let Some(file) = cli.file {\n                run_file(&file)\n            } else {\n                // Otherwise, start REPL\n                run_repl()\n            }\n        }\n    };\n\n    if let Err(e) = result {\n        eprintln!(\"{}: {}\", random_scots_exclamation().red().bold(), e);\n        process::exit(1);\n    }\n}\n\nfn run_file(path: &PathBuf) -> Result<(), String> {\n    let source = read_file(path)?;\n    let program = parse(&source).map_err(|e| format_parse_error(&source, e))?;\n    let mut interpreter = Interpreter::new();\n\n    // Set the current file name fer logging\n    let filename = path\n        .file_name()\n        .map(|s| s.to_string_lossy().to_string())\n        .unwrap_or_else(|| path.display().to_string());\n    interpreter.set_current_file(&filename);\n\n    // Set the current directory tae the file's directory fer module resolution\n    if let Some(parent) = path.parent() {\n        if !parent.as_os_str().is_empty() {\n            interpreter.set_current_dir(parent);\n        }\n    }\n\n    // Load the prelude (standard utility functions)\n    interpreter\n        .load_prelude()\n        .map_err(|e| format!(\"Error loading prelude: {}\", e))?;\n\n    interpreter\n        .interpret(&program)\n        .map_err(|e| format_runtime_error(&source, e))?;\n\n    Ok(())\n}\n\nfn trace_file(path: &PathBuf, verbose: bool) -> Result<(), String> {\n    use interpreter::TraceMode;\n\n    let source = read_file(path)?;\n    let program = parse(&source).map_err(|e| format_parse_error(&source, e))?;\n    let mut interpreter = Interpreter::new();\n\n    // Set the trace mode\n    interpreter.set_trace_mode(if verbose {\n        TraceMode::Verbose\n    } else {\n        TraceMode::Statements\n    });\n\n    // Set the current directory fer module resolution\n    if let Some(parent) = path.parent() {\n        if !parent.as_os_str().is_empty() {\n            interpreter.set_current_dir(parent);\n        }\n    }\n\n    println!(\"{}\", \"\".repeat(60).yellow());\n    println!(\n        \"{}\",\n        \"   mdhavers Tracer - Watchin' Yer Code Like a Hawk!\"\n            .yellow()\n            .bold()\n    );\n    if verbose {\n        println!(\"{}\", \"  Mode: Verbose (showin' everything)\".yellow());\n    } else {\n        println!(\"{}\", \"  Mode: Statements only\".yellow());\n    }\n    println!(\"{}\", \"\".repeat(60).yellow());\n    println!();\n\n    // Load the prelude (but without tracing it - too noisy)\n    let saved_mode = interpreter.trace_mode();\n    interpreter.set_trace_mode(TraceMode::Off);\n    interpreter\n        .load_prelude()\n        .map_err(|e| format!(\"Error loading prelude: {}\", e))?;\n    interpreter.set_trace_mode(saved_mode);\n\n    // Now run with tracing\n    interpreter\n        .interpret(&program)\n        .map_err(|e| format_runtime_error(&source, e))?;\n\n    println!();\n    println!(\"{}\", \"\".repeat(60).yellow());\n    println!(\n        \"{}\",\n        \"   Trace complete - Pure dead brilliant!\".yellow().bold()\n    );\n    println!(\"{}\", \"\".repeat(60).yellow());\n\n    Ok(())\n}\n\nfn compile_file(path: &PathBuf, output: Option<PathBuf>) -> Result<(), String> {\n    let source = read_file(path)?;\n    let js_code = compile(&source).map_err(|e| format_parse_error(&source, e))?;\n\n    let output_path = output.unwrap_or_else(|| {\n        let mut p = path.clone();\n        p.set_extension(\"js\");\n        p\n    });\n\n    fs::write(&output_path, &js_code)\n        .map_err(|e| format!(\"Cannae write tae {}: {}\", output_path.display(), e))?;\n\n    println!(\n        \"{} Compiled {} tae {}\",\n        \"Bonnie!\".green().bold(),\n        path.display(),\n        output_path.display()\n    );\n\n    Ok(())\n}\n\nfn compile_wasm(path: &PathBuf, output: Option<PathBuf>) -> Result<(), String> {\n    let source = read_file(path)?;\n    let wat_code =\n        wasm_compiler::compile_to_wat(&source).map_err(|e| format_parse_error(&source, e))?;\n\n    let output_path = output.unwrap_or_else(|| {\n        let mut p = path.clone();\n        p.set_extension(\"wat\");\n        p\n    });\n\n    fs::write(&output_path, &wat_code)\n        .map_err(|e| format!(\"Cannae write tae {}: {}\", output_path.display(), e))?;\n\n    println!(\n        \"{} Compiled {} tae WebAssembly (WAT)\",\n        \"Braw!\".green().bold(),\n        path.display()\n    );\n    println!(\"  {} {}\", \"Output:\".dimmed(), output_path.display());\n    println!();\n    println!(\"{}\", \"Tae convert tae binary WASM, use:\".dimmed());\n    println!(\"  {} wat2wasm {}\", \"$\".dimmed(), output_path.display());\n\n    Ok(())\n}\n\n#[cfg(not(feature = \"llvm\"))]\nfn build_native(\n    _path: &PathBuf,\n    _output: Option<PathBuf>,\n    _opt_level: u8,\n    _emit_llvm: bool,\n) -> Result<(), String> {\n    use colored::Colorize;\n    eprintln!(\"{}\", \"\".repeat(60).yellow());\n    eprintln!(\n        \"{}\",\n        \"  LLVM Native Compilation Not Available\".yellow().bold()\n    );\n    eprintln!(\"{}\", \"\".repeat(60).yellow());\n    eprintln!();\n    eprintln!(\"The 'build' command requires LLVM support, which wasnae\");\n    eprintln!(\"included in this build o' mdhavers.\");\n    eprintln!();\n    eprintln!(\"{}\", \"Tae enable native compilation:\".cyan().bold());\n    eprintln!();\n    eprintln!(\"  1. Install LLVM dependencies:\");\n    eprintln!(\n        \"     {}\",\n        \"sudo apt install llvm-15 libpolly-15-dev lld-15 libzstd-dev\".green()\n    );\n    eprintln!();\n    eprintln!(\"  2. Rebuild mdhavers with LLVM:\");\n    eprintln!(\"     {}\", \"make release\".green());\n    eprintln!(\n        \"     {} {}\",\n        \"or:\".dimmed(),\n        \"cargo build --release --features llvm\".green()\n    );\n    eprintln!();\n    eprintln!(\n        \"{}\",\n        \"Alternative compilation targets available now:\"\n            .cyan()\n            .bold()\n    );\n    eprintln!(\n        \"  {} - Compile tae JavaScript\",\n        \"mdhavers compile <file>\".green()\n    );\n    eprintln!(\n        \"  {} - Compile tae WebAssembly\",\n        \"mdhavers wasm <file>\".green()\n    );\n    eprintln!();\n    Err(\"LLVM support not available\".to_string())\n}\n\n#[cfg(feature = \"llvm\")]\nfn build_native(\n    path: &PathBuf,\n    output: Option<PathBuf>,\n    opt_level: u8,\n    emit_llvm: bool,\n) -> Result<(), String> {\n    let source = read_file(path)?;\n    let program = parse(&source).map_err(|e| format_parse_error(&source, e))?;\n\n    if emit_llvm {\n        // Emit LLVM IR\n        let compiler = llvm::LLVMCompiler::new().with_optimization(opt_level);\n        let ir = compiler\n            .compile_to_ir(&program)\n            .map_err(|e| format!(\"{}\", e))?;\n\n        let output_path = output.unwrap_or_else(|| {\n            let mut p = path.clone();\n            p.set_extension(\"ll\");\n            p\n        });\n\n        fs::write(&output_path, &ir)\n            .map_err(|e| format!(\"Cannae write tae {}: {}\", output_path.display(), e))?;\n\n        println!(\n            \"{} Compiled {} tae LLVM IR\",\n            \"Braw!\".green().bold(),\n            path.display()\n        );\n        println!(\"  {} {}\", \"Output:\".dimmed(), output_path.display());\n    } else {\n        // Build native executable\n        let output_path = output.unwrap_or_else(|| {\n            let mut p = path.clone();\n            p.set_extension(\"\");\n            p\n        });\n\n        let compiler = llvm::LLVMCompiler::new();\n        compiler\n            .compile_to_native_with_source(&program, &output_path, opt_level, Some(path))\n            .map_err(|e| format!(\"{}\", e))?;\n\n        println!(\n            \"{} Built native executable from {}\",\n            \"Braw!\".green().bold(),\n            path.display()\n        );\n        println!(\"  {} {}\", \"Output:\".dimmed(), output_path.display());\n        println!();\n        println!(\"{}\", \"Tae run:\".dimmed());\n        println!(\"  {} ./{}\", \"$\".dimmed(), output_path.display());\n    }\n\n    Ok(())\n}\n\nfn run_repl() -> Result<(), String> {\n    use interpreter::TraceMode;\n\n    println!(\"{}\", \"\".repeat(50).cyan());\n    println!(\n        \"{}\",\n        \"  mdhavers REPL - A Scots Programming Language\"\n            .cyan()\n            .bold()\n    );\n    println!(\"{}\", \"  Pure havers, but working havers!\".cyan());\n    println!(\"{}\", \"\".repeat(50).cyan());\n    println!();\n    println!(\n        \"{}\",\n        \"Type 'help' fer help, 'quit' or 'haud yer wheesht' tae exit.\".dimmed()\n    );\n    println!();\n\n    let mut rl = DefaultEditor::new().map_err(|e| e.to_string())?;\n\n    // Try to load history from file\n    let history_path = dirs::home_dir()\n        .map(|h| h.join(\".mdhavers_history\"))\n        .unwrap_or_else(|| std::path::PathBuf::from(\".mdhavers_history\"));\n\n    if history_path.exists() {\n        let _ = rl.load_history(&history_path);\n    }\n\n    let mut interpreter = Interpreter::new();\n    let mut trace_enabled = false;\n    let mut verbose_trace = false;\n\n    // Load the prelude fer REPL users\n    if let Err(e) = interpreter.load_prelude() {\n        eprintln!(\"{}: Couldnae load prelude: {}\", \"Warning\".yellow(), e);\n    }\n\n    loop {\n        // Update prompt to show trace mode\n        let prompt = if trace_enabled {\n            if verbose_trace {\n                format!(\"{} \", \"mdhavers[trace:v]>\".yellow().bold())\n            } else {\n                format!(\"{} \", \"mdhavers[trace]>\".yellow().bold())\n            }\n        } else {\n            format!(\"{} \", \"mdhavers>\".green().bold())\n        };\n        let readline = rl.readline(&prompt);\n\n        match readline {\n            Ok(line) => {\n                let line = line.trim();\n\n                if line.is_empty() {\n                    continue;\n                }\n\n                let _ = rl.add_history_entry(line);\n\n                // Handle special commands\n                match line.to_lowercase().as_str() {\n                    \"quit\" | \"exit\" | \"haud yer wheesht\" | \"bye\" | \"cheers\" => {\n                        println!(\"{}\", \"Haste ye back! Slinte!\".cyan());\n                        break;\n                    }\n                    \"help\" | \"halp\" => {\n                        print_repl_help();\n                        continue;\n                    }\n                    \"clear\" | \"cls\" => {\n                        print!(\"\\x1B[2J\\x1B[1;1H\");\n                        continue;\n                    }\n                    \":reset\" | \"reset\" => {\n                        interpreter = Interpreter::new();\n                        if let Err(e) = interpreter.load_prelude() {\n                            eprintln!(\"{}: Couldnae load prelude: {}\", \"Warning\".yellow(), e);\n                        }\n                        trace_enabled = false;\n                        verbose_trace = false;\n                        interpreter.set_trace_mode(TraceMode::Off);\n                        println!(\"{}\", \"Interpreter reset - fresh as a daisy!\".green());\n                        continue;\n                    }\n                    \":wisdom\" | \"wisdom\" => {\n                        // Print a wee bit of Scots wisdom\n                        print_scots_wisdom();\n                        continue;\n                    }\n                    \":codewisdom\" | \"codewisdom\" => {\n                        // Print programming-specific Scottish wisdom\n                        print_programming_wisdom();\n                        continue;\n                    }\n                    \":examples\" | \"examples\" => {\n                        print_repl_examples();\n                        continue;\n                    }\n                    \":trace\" | \"trace\" => {\n                        trace_enabled = !trace_enabled;\n                        verbose_trace = false;\n                        interpreter.set_trace_mode(if trace_enabled {\n                            TraceMode::Statements\n                        } else {\n                            TraceMode::Off\n                        });\n                        if trace_enabled {\n                            println!(\n                                \"{}\",\n                                \" Trace mode ON - watchin' yer code like a hawk!\".yellow()\n                            );\n                        } else {\n                            println!(\"{}\", \"Trace mode OFF - back tae normal.\".dimmed());\n                        }\n                        continue;\n                    }\n                    \":trace v\" | \"trace v\" | \":trace verbose\" | \"trace verbose\" => {\n                        trace_enabled = true;\n                        verbose_trace = true;\n                        interpreter.set_trace_mode(TraceMode::Verbose);\n                        println!(\n                            \"{}\",\n                            \" Verbose trace mode ON - showin' ye EVERYTHING!\".yellow()\n                        );\n                        continue;\n                    }\n                    \":vars\" | \"vars\" | \":env\" | \"env\" => {\n                        print_environment(&interpreter);\n                        continue;\n                    }\n                    _ => {}\n                }\n\n                // Try to parse and execute\n                match parse(line) {\n                    Ok(program) => match interpreter.interpret(&program) {\n                        Ok(value) => {\n                            // Only print non-nil values\n                            if !matches!(value, value::Value::Nil) {\n                                println!(\"{} {}\", \"=>\".dimmed(), format!(\"{}\", value).yellow());\n                            }\n                        }\n                        Err(e) => {\n                            eprintln!(\"{}: {}\", \"Och!\".red().bold(), e);\n                        }\n                    },\n                    Err(e) => {\n                        eprintln!(\"{}: {}\", \"Parse error\".red().bold(), e);\n                    }\n                }\n            }\n            Err(ReadlineError::Interrupted) => {\n                println!(\"{}\", \"Interrupted! Use 'quit' tae leave.\".yellow());\n            }\n            Err(ReadlineError::Eof) => {\n                println!(\"{}\", \"Haste ye back! Slinte!\".cyan());\n                break;\n            }\n            Err(err) => {\n                eprintln!(\"{}: {:?}\", \"Error\".red(), err);\n                break;\n            }\n        }\n    }\n\n    // Save history on exit\n    if let Err(e) = rl.save_history(&history_path) {\n        eprintln!(\"{}: Couldnae save history: {}\", \"Warning\".yellow(), e);\n    }\n\n    Ok(())\n}\n\nfn print_repl_help() {\n    println!();\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!(\n        \"{}\",\n        \"  mdhavers Help - Yer Guide tae Scots Coding\".cyan().bold()\n    );\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!();\n\n    println!(\"{}\", \"Keywords:\".yellow().bold());\n    println!(\"  {}  - declare a variable (I know)\", \"ken\".green());\n    println!(\"  {}  - if statement\", \"gin\".green());\n    println!(\"  {}  - else\", \"ither\".green());\n    println!(\"  {}  - while loop\", \"whiles\".green());\n    println!(\"  {}  - for loop\", \"fer\".green());\n    println!(\"  {}  - return from function (give)\", \"gie\".green());\n    println!(\"  {}  - print output (chat)\", \"blether\".green());\n    println!(\"  {}  - get user input (ask)\", \"speir\".green());\n    println!(\"  {}  - define a function (do)\", \"dae\".green());\n    println!(\"  {}  - define a class (family)\", \"kin\".green());\n    println!(\"  {}  - define a struct\", \"thing\".green());\n    println!(\"  {}  - true\", \"aye\".green());\n    println!(\"  {}  - false\", \"nae\".green());\n    println!(\"  {}  - null/none\", \"naething\".green());\n    println!(\"  {}  - logical and\", \"an\".green());\n    println!(\"  {}  - logical or\", \"or\".green());\n    println!(\"  {}  - break from loop\", \"brak\".green());\n    println!(\"  {}  - continue in loop\", \"haud\".green());\n    println!();\n\n    println!(\"{}\", \"Examples:\".yellow().bold());\n    println!(\"  {}\", \"ken x = 42\".dimmed());\n    println!(\"  {}\", \"gin x > 10 { blether \\\"big\\\" }\".dimmed());\n    println!(\"  {}\", \"dae add(a, b) { gie a + b }\".dimmed());\n    println!(\"  {}\", \"fer i in 1..10 { blether i }\".dimmed());\n    println!();\n\n    println!(\"{}\", \"Built-in Functions:\".yellow().bold());\n    println!(\"  {}    - length of list/string\", \"len(x)\".green());\n    println!(\"  {}  - type of value\", \"whit_kind(x)\".green());\n    println!(\"  {}  - convert to string\", \"tae_string(x)\".green());\n    println!(\"  {}  - convert to integer\", \"tae_int(x)\".green());\n    println!(\"  {}  - add to list\", \"shove(list, x)\".green());\n    println!(\"  {}  - remove from list\", \"yank(list)\".green());\n    println!();\n\n    println!(\"{}\", \"REPL Commands:\".yellow().bold());\n    println!(\"  {}           - show this help\", \"help\".green());\n    println!(\"  {} - exit the REPL\", \"quit / haud yer wheesht\".green());\n    println!(\"  {}          - clear the screen\", \"clear\".green());\n    println!(\"  {}          - reset the interpreter\", \"reset\".green());\n    println!(\"  {}         - get some Scots wisdom\", \"wisdom\".green());\n    println!(\"  {}     - get programming wisdom\", \"codewisdom\".green());\n    println!(\"  {}       - see example code\", \"examples\".green());\n    println!(\n        \"  {}          - toggle trace mode (debugger)\",\n        \"trace\".green()\n    );\n    println!(\"  {}       - verbose trace mode\", \"trace v\".green());\n    println!(\"  {}     - show defined variables\", \"vars / env\".green());\n    println!();\n}\n\nfn print_scots_wisdom() {\n    use std::time::{SystemTime, UNIX_EPOCH};\n    let seed = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as usize;\n\n    let proverbs = [\n        (\n            \"Mony a mickle maks a muckle\",\n            \"Many small things add up tae something big\",\n        ),\n        (\n            \"Lang may yer lum reek\",\n            \"May ye always hae fuel fer yer fire (prosperity)\",\n        ),\n        (\n            \"Whit's fer ye willnae go by ye\",\n            \"What's meant fer ye will find ye\",\n        ),\n        (\n            \"A nod's as guid as a wink tae a blind horse\",\n            \"Some hints are pointless\",\n        ),\n        (\n            \"Dinnae teach yer granny tae suck eggs\",\n            \"Dinnae give advice tae experts\",\n        ),\n        (\n            \"He wha daes the deil's wark gets the deil's wage\",\n            \"Bad deeds bring bad consequences\",\n        ),\n        (\n            \"Better a wee fire that warms than a muckle fire that burns\",\n            \"Moderation is best\",\n        ),\n        (\n            \"Guid gear comes in sma' bulk\",\n            \"Good things come in wee packages\",\n        ),\n        (\n            \"A blate cat maks a prood moose\",\n            \"Shyness invites boldness in others\",\n        ),\n        (\n            \"Facts are chiels that winna ding\",\n            \"Ye cannae argue wi' facts\",\n        ),\n        (\n            \"Ae man's meat is anither man's poison\",\n            \"What works fer one may no' work fer anither\",\n        ),\n        (\n            \"It's a lang road that has nae turnin'\",\n            \"Things will improve eventually\",\n        ),\n        (\n            \"Better bend than brek\",\n            \"It's better tae compromise than tae break\",\n        ),\n        (\"Frae savin' comes havin'\", \"Save now, prosper later\"),\n        (\n            \"They that dance maun pay the fiddler\",\n            \"Ye must pay fer yer pleasures\",\n        ),\n        (\"Oot o' sicht, oot o' mind\", \"We forget whit we dinnae see\"),\n        (\"A fool an' his money are soon parted\", \"Dinnae be wasteful\"),\n        (\n            \"There's nae fool like an auld fool\",\n            \"Age doesnae always bring wisdom\",\n        ),\n        (\n            \"Ye cannae mak a silk purse oot o' a soo's lug\",\n            \"Ye cannae improve on poor materials\",\n        ),\n        (\"Birds o' a feather flock thegither\", \"Like attracts like\"),\n    ];\n\n    let (proverb, meaning) = proverbs[seed % proverbs.len()];\n    println!();\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!(\"{}\", \"  A Wee Bit o' Scots Wisdom\".cyan().bold());\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!();\n    println!(\"  \\\"{}\\\"\", proverb.yellow().italic());\n    println!();\n    println!(\"  {}: {}\", \"Meaning\".dimmed(), meaning.dimmed());\n    println!();\n}\n\nfn print_programming_wisdom() {\n    let wisdom = crate::error::scots_programming_wisdom();\n    println!();\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!(\"{}\", \"  Scottish Programming Wisdom\".cyan().bold());\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!();\n    println!(\"  \\\"{}\\\"\", wisdom.yellow().italic());\n    println!();\n}\n\nfn print_repl_examples() {\n    println!();\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!(\"{}\", \"  mdhavers Examples\".cyan().bold());\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!();\n\n    println!(\"{}\", \"Variables:\".yellow().bold());\n    println!(\"  {}\", \"ken name = \\\"Hamish\\\"\".green());\n    println!(\"  {}\", \"ken age = 42\".green());\n    println!(\"  {}\", \"ken is_braw = aye\".green());\n    println!();\n\n    println!(\"{}\", \"Conditionals:\".yellow().bold());\n    println!(\n        \"  {}\",\n        \"gin age > 18 { blether \\\"Ye're auld enough!\\\" }\".green()\n    );\n    println!(\n        \"  {}\",\n        \"gin score > 90 { \\\"A\\\" } ither gin score > 70 { \\\"B\\\" } ither { \\\"C\\\" }\".green()\n    );\n    println!();\n\n    println!(\"{}\", \"Loops:\".yellow().bold());\n    println!(\"  {}\", \"fer i in 1..5 { blether i }\".green());\n    println!(\"  {}\", \"whiles x < 10 { x = x + 1 }\".green());\n    println!();\n\n    println!(\"{}\", \"Functions:\".yellow().bold());\n    println!(\n        \"  {}\",\n        \"dae greet(name) { gie \\\"Hullo, \\\" + name + \\\"!\\\" }\".green()\n    );\n    println!(\"  {}\", \"greet(\\\"Scotland\\\")\".green());\n    println!();\n\n    println!(\"{}\", \"Lists & Dicts:\".yellow().bold());\n    println!(\n        \"  {}\",\n        \"ken fruits = [\\\"apple\\\", \\\"banana\\\", \\\"cherry\\\"]\".green()\n    );\n    println!(\n        \"  {}\",\n        \"ken person = {\\\"name\\\": \\\"Morag\\\", \\\"age\\\": 28}\".green()\n    );\n    println!();\n\n    println!(\"{}\", \"Functional:\".yellow().bold());\n    println!(\"  {}\", \"gaun([1, 2, 3], |x| x * 2)\".green());\n    println!(\"  {}\", \"sieve([1, 2, 3, 4], |x| x % 2 == 0)\".green());\n    println!(\"  {}\", \"tumble([1, 2, 3, 4], 0, |acc, x| acc + x)\".green());\n    println!();\n}\n\nfn print_environment(interpreter: &Interpreter) {\n    let vars = interpreter.get_user_variables();\n\n    println!();\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!(\"{}\", \"  Yer Variables (Environment)\".cyan().bold());\n    println!(\n        \"{}\",\n        \"\".cyan()\n    );\n    println!();\n\n    if vars.is_empty() {\n        println!(\n            \"  {}\",\n            \"Nae variables defined yet - use 'ken x = 42' tae create one!\".dimmed()\n        );\n    } else {\n        // Separate user values from prelude functions\n        let user_vars: Vec<_> = vars.iter().filter(|(_, t, _)| t != \"function\").collect();\n        let user_funcs: Vec<_> = vars.iter().filter(|(_, t, _)| t == \"function\").collect();\n\n        if !user_vars.is_empty() {\n            println!(\"{}\", \"  Values:\".yellow().bold());\n            for (name, type_name, value) in &user_vars {\n                // Truncate long values\n                let display_value = if value.len() > 50 {\n                    format!(\"{}...\", &value[..47])\n                } else {\n                    value.clone()\n                };\n                println!(\n                    \"    {} : {} = {}\",\n                    name.green(),\n                    type_name.dimmed(),\n                    display_value.yellow()\n                );\n            }\n            println!();\n        }\n\n        if !user_funcs.is_empty() {\n            // Only show first few user functions, hide prelude\n            let show_funcs: Vec<_> = user_funcs.iter().take(10).collect();\n            let hidden = user_funcs.len().saturating_sub(10);\n\n            println!(\"{}\", \"  Functions:\".yellow().bold());\n            for (name, _, _) in show_funcs {\n                println!(\"    {}\", name.green());\n            }\n            if hidden > 0 {\n                println!(\"    {} ... and {} more functions\", \"\".dimmed(), hidden);\n            }\n        }\n    }\n    println!();\n}\n\nfn check_file(path: &PathBuf) -> Result<(), String> {\n    let source = read_file(path)?;\n\n    // Lex\n    let tokens = lexer::lex(&source).map_err(|e| format_parse_error(&source, e))?;\n    println!(\"{} Lexing passed ({} tokens)\", \"\".green(), tokens.len());\n\n    // Parse\n    let _program = parse(&source).map_err(|e| format_parse_error(&source, e))?;\n    println!(\"{} Parsing passed\", \"\".green());\n\n    println!(\n        \"\\n{} {} looks braw!\",\n        \"Bonnie!\".green().bold(),\n        path.display()\n    );\n\n    Ok(())\n}\n\nfn format_file(path: &PathBuf, check_only: bool) -> Result<(), String> {\n    let source = read_file(path)?;\n\n    // Format the code\n    let formatted =\n        formatter::format_source(&source).map_err(|e| format_parse_error(&source, e))?;\n\n    if check_only {\n        // Just check if formatting would change anything\n        if source == formatted {\n            println!(\n                \"{} {} is already formatted braw!\",\n                \"\".green(),\n                path.display()\n            );\n            Ok(())\n        } else {\n            println!(\"{} {} needs formattin'!\", \"\".red(), path.display());\n            Err(\"File needs formattin'\".to_string())\n        }\n    } else {\n        // Write back to file\n        fs::write(path, &formatted)\n            .map_err(|e| format!(\"Cannae write tae {}: {}\", path.display(), e))?;\n\n        println!(\n            \"{} Formatted {} - lookin' braw!\",\n            \"Bonnie!\".green().bold(),\n            path.display()\n        );\n\n        Ok(())\n    }\n}\n\nfn show_tokens(path: &PathBuf) -> Result<(), String> {\n    let source = read_file(path)?;\n    let tokens = lexer::lex(&source).map_err(|e| format_parse_error(&source, e))?;\n\n    println!(\"{}\", \"Tokens:\".cyan().bold());\n    println!(\"{}\", \"\".repeat(50));\n\n    for token in &tokens {\n        println!(\n            \"{:4}:{:2}  {:20} {:?}\",\n            token.line,\n            token.column,\n            format!(\"{}\", token.kind).green(),\n            token.lexeme.dimmed()\n        );\n    }\n\n    println!(\"{}\", \"\".repeat(50));\n    println!(\"Total: {} tokens\", tokens.len());\n\n    Ok(())\n}\n\nfn show_ast(path: &PathBuf) -> Result<(), String> {\n    let source = read_file(path)?;\n    let program = parse(&source).map_err(|e| format_parse_error(&source, e))?;\n\n    println!(\"{}\", \"AST:\".cyan().bold());\n    println!(\"{}\", \"\".repeat(50));\n\n    for (i, stmt) in program.statements.iter().enumerate() {\n        println!(\"{}. {:?}\", i + 1, stmt);\n    }\n\n    println!(\"{}\", \"\".repeat(50));\n    println!(\"Total: {} top-level statements\", program.statements.len());\n\n    Ok(())\n}\n\nfn read_file(path: &PathBuf) -> Result<String, String> {\n    // Check extension\n    if let Some(ext) = path.extension() {\n        if ext != \"braw\" {\n            eprintln!(\n                \"{}: File should have .braw extension, but got .{}\",\n                \"Warning\".yellow(),\n                ext.to_string_lossy()\n            );\n        }\n    }\n\n    fs::read_to_string(path)\n        .map_err(|e| format!(\"Dinnae be daft! Cannae read '{}': {}\", path.display(), e))\n}\n\nfn format_parse_error(source: &str, error: error::HaversError) -> String {\n    let mut msg = format!(\"{}\", error);\n\n    if let Some(line) = error.line() {\n        msg.push_str(\"\\n\\n\");\n        msg.push_str(&format_error_context(source, line));\n    }\n\n    // Add helpful suggestion if available\n    if let Some(suggestion) = error::get_error_suggestion(&error) {\n        msg.push('\\n');\n        msg.push_str(suggestion);\n    }\n\n    msg\n}\n\nfn format_runtime_error(source: &str, error: error::HaversError) -> String {\n    let mut msg = format!(\"{}\", error);\n\n    if let Some(line) = error.line() {\n        msg.push_str(\"\\n\\n\");\n        msg.push_str(&format_error_context(source, line));\n    }\n\n    // Add helpful suggestion if available\n    if let Some(suggestion) = error::get_error_suggestion(&error) {\n        msg.push('\\n');\n        msg.push_str(suggestion);\n    }\n\n    msg\n}\n","traces":[{"line":31,"address":[57557648],"length":1,"stats":{"Line":0}},{"line":33,"address":[57557652],"length":1,"stats":{"Line":0}},{"line":34,"address":[57557674],"length":1,"stats":{"Line":0}},{"line":35,"address":[54329991],"length":1,"stats":{"Line":0}},{"line":36,"address":[54330029],"length":1,"stats":{"Line":0}},{"line":37,"address":[54330261],"length":1,"stats":{"Line":0}},{"line":38,"address":[54330742,54330663],"length":1,"stats":{"Line":0}},{"line":40,"address":[54330723,54330330],"length":1,"stats":{"Line":0}},{"line":43,"address":[54330936,54330599],"length":1,"stats":{"Line":0}},{"line":44,"address":[54330952,54331174],"length":1,"stats":{"Line":0}},{"line":45,"address":[54331483,54331110],"length":1,"stats":{"Line":0}},{"line":46,"address":[54331499],"length":1,"stats":{"Line":0}},{"line":48,"address":[54331417],"length":1,"stats":{"Line":0}},{"line":49,"address":[54331895,54331461],"length":1,"stats":{"Line":0}},{"line":51,"address":[54331422],"length":1,"stats":{"Line":0}},{"line":54,"address":[54330016],"length":1,"stats":{"Line":0}},{"line":163,"address":[57560874,57559136,57558736],"length":1,"stats":{"Line":0}},{"line":165,"address":[57558743],"length":1,"stats":{"Line":0}},{"line":167,"address":[57558756],"length":1,"stats":{"Line":0}},{"line":169,"address":[57558774,57559144],"length":1,"stats":{"Line":0}},{"line":170,"address":[57559146,57559762],"length":1,"stats":{"Line":0}},{"line":171,"address":[57559828,57559195],"length":1,"stats":{"Line":0}},{"line":172,"address":[57559283,57559894],"length":1,"stats":{"Line":0}},{"line":173,"address":[57559899,57559293],"length":1,"stats":{"Line":0}},{"line":174,"address":[57559965,57559342],"length":1,"stats":{"Line":0}},{"line":175,"address":[57560031,57559405],"length":1,"stats":{"Line":0}},{"line":176,"address":[57560097,57559454],"length":1,"stats":{"Line":0}},{"line":177,"address":[57560163,57559503],"length":1,"stats":{"Line":0}},{"line":178,"address":[57559566,57560229],"length":1,"stats":{"Line":0}},{"line":179,"address":[57559706],"length":1,"stats":{"Line":0}},{"line":187,"address":[57558867],"length":1,"stats":{"Line":0}},{"line":188,"address":[57558948],"length":1,"stats":{"Line":0}},{"line":191,"address":[57559142,57558960],"length":1,"stats":{"Line":0}},{"line":196,"address":[57560361,57559093],"length":1,"stats":{"Line":0}},{"line":197,"address":[57560499,57560387],"length":1,"stats":{"Line":0}},{"line":198,"address":[57560771],"length":1,"stats":{"Line":0}},{"line":202,"address":[57562572,57560912,57562580],"length":1,"stats":{"Line":0}},{"line":203,"address":[57560951],"length":1,"stats":{"Line":0}},{"line":204,"address":[54332618,54332576],"length":1,"stats":{"Line":0}},{"line":205,"address":[57561449],"length":1,"stats":{"Line":0}},{"line":208,"address":[57561504],"length":1,"stats":{"Line":0}},{"line":210,"address":[54332448,54332481],"length":1,"stats":{"Line":0}},{"line":211,"address":[54332800,54332832],"length":1,"stats":{"Line":0}},{"line":212,"address":[57561739,57561660],"length":1,"stats":{"Line":0}},{"line":215,"address":[57561754],"length":1,"stats":{"Line":0}},{"line":216,"address":[57561901,57561951],"length":1,"stats":{"Line":0}},{"line":217,"address":[57561990],"length":1,"stats":{"Line":0}},{"line":222,"address":[57562122,57562038,57562524],"length":1,"stats":{"Line":0}},{"line":224,"address":[54332032,54332058],"length":1,"stats":{"Line":0}},{"line":226,"address":[57562225,57562299,57562503],"length":1,"stats":{"Line":0}},{"line":227,"address":[57562171],"length":1,"stats":{"Line":0}},{"line":228,"address":[54332224,54332266],"length":1,"stats":{"Line":0}},{"line":230,"address":[57562421],"length":1,"stats":{"Line":0}},{"line":233,"address":[57519335,57521320,57517600],"length":1,"stats":{"Line":0}},{"line":236,"address":[57517657],"length":1,"stats":{"Line":0}},{"line":237,"address":[54325616,54325658],"length":1,"stats":{"Line":0}},{"line":238,"address":[57518161],"length":1,"stats":{"Line":0}},{"line":241,"address":[57518215,57518229,57518239],"length":1,"stats":{"Line":0}},{"line":242,"address":[57518231],"length":1,"stats":{"Line":0}},{"line":244,"address":[57518221],"length":1,"stats":{"Line":0}},{"line":248,"address":[57518307],"length":1,"stats":{"Line":0}},{"line":249,"address":[57518466,57518525],"length":1,"stats":{"Line":0}},{"line":250,"address":[57518564],"length":1,"stats":{"Line":0}},{"line":254,"address":[57518483,57518581],"length":1,"stats":{"Line":0}},{"line":255,"address":[57518877],"length":1,"stats":{"Line":0}},{"line":261,"address":[57519070],"length":1,"stats":{"Line":0}},{"line":262,"address":[57519107,57519341],"length":1,"stats":{"Line":0}},{"line":264,"address":[57519076,57519141],"length":1,"stats":{"Line":0}},{"line":266,"address":[57519300,57519511],"length":1,"stats":{"Line":0}},{"line":267,"address":[57519776],"length":1,"stats":{"Line":0}},{"line":270,"address":[57519829],"length":1,"stats":{"Line":0}},{"line":271,"address":[57519861],"length":1,"stats":{"Line":0}},{"line":272,"address":[57519930,57520014,57521285],"length":1,"stats":{"Line":0}},{"line":274,"address":[54325866,54325840],"length":1,"stats":{"Line":0}},{"line":275,"address":[57520043],"length":1,"stats":{"Line":0}},{"line":278,"address":[57520213,57521268,57520139],"length":1,"stats":{"Line":0}},{"line":279,"address":[57520085],"length":1,"stats":{"Line":0}},{"line":280,"address":[54326032,54326074],"length":1,"stats":{"Line":0}},{"line":282,"address":[57520317],"length":1,"stats":{"Line":0}},{"line":283,"address":[57520362],"length":1,"stats":{"Line":0}},{"line":284,"address":[57520725],"length":1,"stats":{"Line":0}},{"line":288,"address":[57520884],"length":1,"stats":{"Line":0}},{"line":290,"address":[57521205],"length":1,"stats":{"Line":0}},{"line":293,"address":[57531284,57531376,57529808],"length":1,"stats":{"Line":0}},{"line":294,"address":[57529843,57531361,57529931],"length":1,"stats":{"Line":0}},{"line":295,"address":[54328394,54328352],"length":1,"stats":{"Line":0}},{"line":297,"address":[57530376],"length":1,"stats":{"Line":0}},{"line":298,"address":[54328972],"length":1,"stats":{"Line":0}},{"line":299,"address":[54328982],"length":1,"stats":{"Line":0}},{"line":300,"address":[54329042],"length":1,"stats":{"Line":0}},{"line":303,"address":[57530594,57530675,57530497],"length":1,"stats":{"Line":0}},{"line":304,"address":[57530571,57530643],"length":1,"stats":{"Line":0}},{"line":306,"address":[57530763,57530834],"length":1,"stats":{"Line":0}},{"line":313,"address":[57531211],"length":1,"stats":{"Line":0}},{"line":316,"address":[57531408,57533771,57533676],"length":1,"stats":{"Line":0}},{"line":317,"address":[57533753,57531455,57531543],"length":1,"stats":{"Line":0}},{"line":318,"address":[54329472,54329514],"length":1,"stats":{"Line":0}},{"line":321,"address":[54329825,54329831,54329696],"length":1,"stats":{"Line":0}},{"line":322,"address":[54329724],"length":1,"stats":{"Line":0}},{"line":323,"address":[54329734],"length":1,"stats":{"Line":0}},{"line":324,"address":[54329794],"length":1,"stats":{"Line":0}},{"line":327,"address":[57532218,57532302,57532121],"length":1,"stats":{"Line":0}},{"line":328,"address":[54329147,54329104],"length":1,"stats":{"Line":0}},{"line":330,"address":[57532327],"length":1,"stats":{"Line":0}},{"line":335,"address":[57532685],"length":1,"stats":{"Line":0}},{"line":336,"address":[57533016],"length":1,"stats":{"Line":0}},{"line":337,"address":[57533061],"length":1,"stats":{"Line":0}},{"line":338,"address":[57533251],"length":1,"stats":{"Line":0}},{"line":340,"address":[57533600],"length":1,"stats":{"Line":0}},{"line":396,"address":[57525712,57528266,57529773],"length":1,"stats":{"Line":0}},{"line":402,"address":[57525880,57525792,57529755],"length":1,"stats":{"Line":0}},{"line":403,"address":[57529741,57526038,57526129],"length":1,"stats":{"Line":0}},{"line":405,"address":[57526372],"length":1,"stats":{"Line":0}},{"line":407,"address":[57526453,57528323],"length":1,"stats":{"Line":0}},{"line":408,"address":[57528418,57528479,57529717],"length":1,"stats":{"Line":0}},{"line":409,"address":[57528372],"length":1,"stats":{"Line":0}},{"line":410,"address":[57528447,57528395],"length":1,"stats":{"Line":0}},{"line":412,"address":[57528584],"length":1,"stats":{"Line":0}},{"line":413,"address":[54327628],"length":1,"stats":{"Line":0}},{"line":414,"address":[54327638],"length":1,"stats":{"Line":0}},{"line":415,"address":[54327698],"length":1,"stats":{"Line":0}},{"line":418,"address":[57528886,57528802,57528705],"length":1,"stats":{"Line":0}},{"line":419,"address":[57528779,57528854],"length":1,"stats":{"Line":0}},{"line":421,"address":[57529048,57528977],"length":1,"stats":{"Line":0}},{"line":426,"address":[57529269],"length":1,"stats":{"Line":0}},{"line":429,"address":[54327072,54327204,54327198],"length":1,"stats":{"Line":0}},{"line":430,"address":[54327100],"length":1,"stats":{"Line":0}},{"line":431,"address":[54327119],"length":1,"stats":{"Line":0}},{"line":432,"address":[54327167],"length":1,"stats":{"Line":0}},{"line":435,"address":[57526510,57526572],"length":1,"stats":{"Line":0}},{"line":436,"address":[57526796,57526880],"length":1,"stats":{"Line":0}},{"line":437,"address":[57526587],"length":1,"stats":{"Line":0}},{"line":438,"address":[57526848,57526773],"length":1,"stats":{"Line":0}},{"line":440,"address":[57526994,57527117],"length":1,"stats":{"Line":0}},{"line":445,"address":[57527287],"length":1,"stats":{"Line":0}},{"line":446,"address":[57527642],"length":1,"stats":{"Line":0}},{"line":447,"address":[57527687],"length":1,"stats":{"Line":0}},{"line":448,"address":[57527877],"length":1,"stats":{"Line":0}},{"line":451,"address":[57528245],"length":1,"stats":{"Line":0}},{"line":454,"address":[57562608,57572786,57565052],"length":1,"stats":{"Line":0}},{"line":457,"address":[57562661],"length":1,"stats":{"Line":0}},{"line":458,"address":[57562990],"length":1,"stats":{"Line":0}},{"line":464,"address":[57563217],"length":1,"stats":{"Line":0}},{"line":465,"address":[57563411],"length":1,"stats":{"Line":0}},{"line":466,"address":[57563732],"length":1,"stats":{"Line":0}},{"line":467,"address":[57563826],"length":1,"stats":{"Line":0}},{"line":471,"address":[57563972],"length":1,"stats":{"Line":0}},{"line":473,"address":[54332960,54332944],"length":1,"stats":{"Line":0}},{"line":476,"address":[57564259],"length":1,"stats":{"Line":0}},{"line":477,"address":[57564334],"length":1,"stats":{"Line":0}},{"line":478,"address":[54332896,54332908],"length":1,"stats":{"Line":0}},{"line":480,"address":[57564379,57564462],"length":1,"stats":{"Line":0}},{"line":481,"address":[57564528],"length":1,"stats":{"Line":0}},{"line":484,"address":[57564497],"length":1,"stats":{"Line":0}},{"line":485,"address":[57564554],"length":1,"stats":{"Line":0}},{"line":486,"address":[57564562],"length":1,"stats":{"Line":0}},{"line":489,"address":[57564633,57564586],"length":1,"stats":{"Line":0}},{"line":490,"address":[57564823,57564725],"length":1,"stats":{"Line":0}},{"line":495,"address":[57564756],"length":1,"stats":{"Line":0}},{"line":496,"address":[57565089],"length":1,"stats":{"Line":0}},{"line":497,"address":[57565392,57565648],"length":1,"stats":{"Line":0}},{"line":499,"address":[57565361,57565426],"length":1,"stats":{"Line":0}},{"line":502,"address":[57565108,57565058],"length":1,"stats":{"Line":0}},{"line":504,"address":[57565946,57565335],"length":1,"stats":{"Line":0}},{"line":506,"address":[57565961],"length":1,"stats":{"Line":0}},{"line":507,"address":[57566048],"length":1,"stats":{"Line":0}},{"line":508,"address":[57566088,57566171],"length":1,"stats":{"Line":0}},{"line":510,"address":[57566242],"length":1,"stats":{"Line":0}},{"line":514,"address":[57566326,57566289],"length":1,"stats":{"Line":0}},{"line":517,"address":[57566441,57566343],"length":1,"stats":{"Line":0}},{"line":518,"address":[57566457,57566561],"length":1,"stats":{"Line":0}},{"line":519,"address":[57566523,57571153],"length":1,"stats":{"Line":0}},{"line":522,"address":[57566790,57566710],"length":1,"stats":{"Line":0}},{"line":523,"address":[57566776,57571148],"length":1,"stats":{"Line":0}},{"line":526,"address":[57566806,57566905],"length":1,"stats":{"Line":0}},{"line":527,"address":[57571124,57566872],"length":1,"stats":{"Line":0}},{"line":530,"address":[57566921,57567009],"length":1,"stats":{"Line":0}},{"line":531,"address":[57570380,57566995,57570387],"length":1,"stats":{"Line":0}},{"line":532,"address":[57570488],"length":1,"stats":{"Line":0}},{"line":533,"address":[57570702,57570587],"length":1,"stats":{"Line":0}},{"line":535,"address":[57570618],"length":1,"stats":{"Line":0}},{"line":536,"address":[57570626],"length":1,"stats":{"Line":0}},{"line":537,"address":[57570644],"length":1,"stats":{"Line":0}},{"line":538,"address":[57570931],"length":1,"stats":{"Line":0}},{"line":541,"address":[57567105,57567025],"length":1,"stats":{"Line":0}},{"line":543,"address":[57570367,57567091],"length":1,"stats":{"Line":0}},{"line":546,"address":[57567201,57567121],"length":1,"stats":{"Line":0}},{"line":548,"address":[57567187,57570362],"length":1,"stats":{"Line":0}},{"line":551,"address":[57567217,57567297],"length":1,"stats":{"Line":0}},{"line":552,"address":[57570357,57567283],"length":1,"stats":{"Line":0}},{"line":555,"address":[57567313,57567428],"length":1,"stats":{"Line":0}},{"line":556,"address":[57567379],"length":1,"stats":{"Line":0}},{"line":557,"address":[57567397],"length":1,"stats":{"Line":0}},{"line":558,"address":[57567405,57569925,57569935],"length":1,"stats":{"Line":0}},{"line":559,"address":[57569927],"length":1,"stats":{"Line":0}},{"line":561,"address":[57569917],"length":1,"stats":{"Line":0}},{"line":563,"address":[57569958],"length":1,"stats":{"Line":0}},{"line":564,"address":[57569999],"length":1,"stats":{"Line":0}},{"line":569,"address":[57570033,57569968],"length":1,"stats":{"Line":0}},{"line":573,"address":[57567444,57567553],"length":1,"stats":{"Line":0}},{"line":574,"address":[57567510],"length":1,"stats":{"Line":0}},{"line":575,"address":[57567518],"length":1,"stats":{"Line":0}},{"line":576,"address":[57567539],"length":1,"stats":{"Line":0}},{"line":577,"address":[57569755],"length":1,"stats":{"Line":0}},{"line":583,"address":[57567747,57567659],"length":1,"stats":{"Line":0}},{"line":584,"address":[57567733,57569700],"length":1,"stats":{"Line":0}},{"line":591,"address":[57567876],"length":1,"stats":{"Line":0}},{"line":592,"address":[57568112,57568009],"length":1,"stats":{"Line":0}},{"line":593,"address":[57568238],"length":1,"stats":{"Line":0}},{"line":595,"address":[57568302],"length":1,"stats":{"Line":0}},{"line":596,"address":[57568334,57568421],"length":1,"stats":{"Line":0}},{"line":599,"address":[57568140],"length":1,"stats":{"Line":0}},{"line":600,"address":[57568992,57568204],"length":1,"stats":{"Line":0}},{"line":603,"address":[57567911],"length":1,"stats":{"Line":0}},{"line":604,"address":[57567975,57569321],"length":1,"stats":{"Line":0}},{"line":609,"address":[57571515,57571711],"length":1,"stats":{"Line":0}},{"line":612,"address":[57571484,57571549],"length":1,"stats":{"Line":0}},{"line":615,"address":[57571426],"length":1,"stats":{"Line":0}},{"line":616,"address":[57571984,57571450],"length":1,"stats":{"Line":0}},{"line":623,"address":[57572297],"length":1,"stats":{"Line":0}},{"line":624,"address":[57572347,57572469],"length":1,"stats":{"Line":0}},{"line":627,"address":[57572396],"length":1,"stats":{"Line":0}},{"line":630,"address":[57533808,57542920,57542926],"length":1,"stats":{"Line":0}},{"line":631,"address":[57533830],"length":1,"stats":{"Line":0}},{"line":632,"address":[57533879],"length":1,"stats":{"Line":0}},{"line":636,"address":[57534151],"length":1,"stats":{"Line":0}},{"line":640,"address":[57534345],"length":1,"stats":{"Line":0}},{"line":644,"address":[57534494],"length":1,"stats":{"Line":0}},{"line":646,"address":[57534543],"length":1,"stats":{"Line":0}},{"line":647,"address":[57534770],"length":1,"stats":{"Line":0}},{"line":648,"address":[57534964],"length":1,"stats":{"Line":0}},{"line":649,"address":[57535158],"length":1,"stats":{"Line":0}},{"line":650,"address":[57535352],"length":1,"stats":{"Line":0}},{"line":651,"address":[57535546],"length":1,"stats":{"Line":0}},{"line":652,"address":[57535740],"length":1,"stats":{"Line":0}},{"line":653,"address":[57535934],"length":1,"stats":{"Line":0}},{"line":654,"address":[57536128],"length":1,"stats":{"Line":0}},{"line":655,"address":[57536322],"length":1,"stats":{"Line":0}},{"line":656,"address":[57536516],"length":1,"stats":{"Line":0}},{"line":657,"address":[57536710],"length":1,"stats":{"Line":0}},{"line":658,"address":[57536904],"length":1,"stats":{"Line":0}},{"line":659,"address":[57537098],"length":1,"stats":{"Line":0}},{"line":660,"address":[57537292],"length":1,"stats":{"Line":0}},{"line":661,"address":[57537486],"length":1,"stats":{"Line":0}},{"line":662,"address":[57537680],"length":1,"stats":{"Line":0}},{"line":663,"address":[57537874],"length":1,"stats":{"Line":0}},{"line":664,"address":[57538068],"length":1,"stats":{"Line":0}},{"line":665,"address":[57538262],"length":1,"stats":{"Line":0}},{"line":667,"address":[57538311],"length":1,"stats":{"Line":0}},{"line":668,"address":[57538538],"length":1,"stats":{"Line":0}},{"line":669,"address":[57538732],"length":1,"stats":{"Line":0}},{"line":670,"address":[57538926],"length":1,"stats":{"Line":0}},{"line":671,"address":[57539120],"length":1,"stats":{"Line":0}},{"line":672,"address":[57539314],"length":1,"stats":{"Line":0}},{"line":674,"address":[57539363],"length":1,"stats":{"Line":0}},{"line":675,"address":[57539590],"length":1,"stats":{"Line":0}},{"line":676,"address":[57539784],"length":1,"stats":{"Line":0}},{"line":677,"address":[57539978],"length":1,"stats":{"Line":0}},{"line":678,"address":[57540172],"length":1,"stats":{"Line":0}},{"line":679,"address":[57540366],"length":1,"stats":{"Line":0}},{"line":680,"address":[57540554],"length":1,"stats":{"Line":0}},{"line":681,"address":[57540742],"length":1,"stats":{"Line":0}},{"line":683,"address":[57540785],"length":1,"stats":{"Line":0}},{"line":684,"address":[57541000],"length":1,"stats":{"Line":0}},{"line":685,"address":[57541188],"length":1,"stats":{"Line":0}},{"line":686,"address":[57541376],"length":1,"stats":{"Line":0}},{"line":687,"address":[57541564],"length":1,"stats":{"Line":0}},{"line":688,"address":[57541752],"length":1,"stats":{"Line":0}},{"line":689,"address":[57541940],"length":1,"stats":{"Line":0}},{"line":690,"address":[57542128],"length":1,"stats":{"Line":0}},{"line":691,"address":[57542355],"length":1,"stats":{"Line":0}},{"line":695,"address":[57542504],"length":1,"stats":{"Line":0}},{"line":696,"address":[57542692],"length":1,"stats":{"Line":0}},{"line":697,"address":[57542877],"length":1,"stats":{"Line":0}},{"line":700,"address":[57551840,57551834,57547888],"length":1,"stats":{"Line":0}},{"line":702,"address":[57547895,57547998],"length":1,"stats":{"Line":0}},{"line":703,"address":[57547919],"length":1,"stats":{"Line":0}},{"line":704,"address":[57547958],"length":1,"stats":{"Line":0}},{"line":705,"address":[57547993],"length":1,"stats":{"Line":0}},{"line":707,"address":[57549086],"length":1,"stats":{"Line":0}},{"line":760,"address":[57548708],"length":1,"stats":{"Line":0}},{"line":765,"address":[57548816],"length":1,"stats":{"Line":0}},{"line":766,"address":[57548870],"length":1,"stats":{"Line":0}},{"line":775,"address":[57549032],"length":1,"stats":{"Line":0}},{"line":778,"address":[57550366,57550599],"length":1,"stats":{"Line":0}},{"line":779,"address":[57550490],"length":1,"stats":{"Line":0}},{"line":780,"address":[57550617,57550572],"length":1,"stats":{"Line":0}},{"line":784,"address":[57550747],"length":1,"stats":{"Line":0}},{"line":785,"address":[57551001],"length":1,"stats":{"Line":0}},{"line":789,"address":[57551150],"length":1,"stats":{"Line":0}},{"line":790,"address":[57551203],"length":1,"stats":{"Line":0}},{"line":791,"address":[57551406],"length":1,"stats":{"Line":0}},{"line":792,"address":[57551449],"length":1,"stats":{"Line":0}},{"line":793,"address":[57551791],"length":1,"stats":{"Line":0}},{"line":796,"address":[57558681,57558687,57557712],"length":1,"stats":{"Line":0}},{"line":797,"address":[57557719],"length":1,"stats":{"Line":0}},{"line":798,"address":[57557756],"length":1,"stats":{"Line":0}},{"line":799,"address":[57557835],"length":1,"stats":{"Line":0}},{"line":803,"address":[57557984],"length":1,"stats":{"Line":0}},{"line":804,"address":[57558199],"length":1,"stats":{"Line":0}},{"line":808,"address":[57558387],"length":1,"stats":{"Line":0}},{"line":809,"address":[57558438],"length":1,"stats":{"Line":0}},{"line":810,"address":[57558638],"length":1,"stats":{"Line":0}},{"line":813,"address":[57551856,57556849,57556855],"length":1,"stats":{"Line":0}},{"line":814,"address":[57551863],"length":1,"stats":{"Line":0}},{"line":815,"address":[57551912],"length":1,"stats":{"Line":0}},{"line":819,"address":[57552106],"length":1,"stats":{"Line":0}},{"line":820,"address":[57552378],"length":1,"stats":{"Line":0}},{"line":824,"address":[57552527],"length":1,"stats":{"Line":0}},{"line":826,"address":[57552576],"length":1,"stats":{"Line":0}},{"line":827,"address":[57552803],"length":1,"stats":{"Line":0}},{"line":828,"address":[57552997],"length":1,"stats":{"Line":0}},{"line":829,"address":[57553191],"length":1,"stats":{"Line":0}},{"line":830,"address":[57553385],"length":1,"stats":{"Line":0}},{"line":832,"address":[57553434],"length":1,"stats":{"Line":0}},{"line":833,"address":[57553706],"length":1,"stats":{"Line":0}},{"line":837,"address":[57553900],"length":1,"stats":{"Line":0}},{"line":841,"address":[57554049],"length":1,"stats":{"Line":0}},{"line":843,"address":[57554098],"length":1,"stats":{"Line":0}},{"line":844,"address":[57554325],"length":1,"stats":{"Line":0}},{"line":845,"address":[57554519],"length":1,"stats":{"Line":0}},{"line":846,"address":[57554713],"length":1,"stats":{"Line":0}},{"line":848,"address":[57554756],"length":1,"stats":{"Line":0}},{"line":849,"address":[57554977],"length":1,"stats":{"Line":0}},{"line":853,"address":[57555165],"length":1,"stats":{"Line":0}},{"line":854,"address":[57555353],"length":1,"stats":{"Line":0}},{"line":856,"address":[57555396],"length":1,"stats":{"Line":0}},{"line":857,"address":[57555611],"length":1,"stats":{"Line":0}},{"line":861,"address":[57555838],"length":1,"stats":{"Line":0}},{"line":865,"address":[57555987],"length":1,"stats":{"Line":0}},{"line":867,"address":[57556030],"length":1,"stats":{"Line":0}},{"line":868,"address":[57556245],"length":1,"stats":{"Line":0}},{"line":869,"address":[57556433],"length":1,"stats":{"Line":0}},{"line":870,"address":[57556621],"length":1,"stats":{"Line":0}},{"line":871,"address":[57556806],"length":1,"stats":{"Line":0}},{"line":874,"address":[57545608,57547092,57542944],"length":1,"stats":{"Line":0}},{"line":875,"address":[57542962],"length":1,"stats":{"Line":0}},{"line":877,"address":[57543049,57542983],"length":1,"stats":{"Line":0}},{"line":878,"address":[57543099],"length":1,"stats":{"Line":0}},{"line":882,"address":[57543258],"length":1,"stats":{"Line":0}},{"line":883,"address":[57543506],"length":1,"stats":{"Line":0}},{"line":887,"address":[57543665],"length":1,"stats":{"Line":0}},{"line":889,"address":[57543718],"length":1,"stats":{"Line":0}},{"line":890,"address":[57543776],"length":1,"stats":{"Line":0}},{"line":896,"address":[54329870,54329856],"length":1,"stats":{"Line":0}},{"line":897,"address":[57543927,57544006],"length":1,"stats":{"Line":0}},{"line":899,"address":[57544168,57544107],"length":1,"stats":{"Line":0}},{"line":900,"address":[57544174,57544230],"length":1,"stats":{"Line":0}},{"line":901,"address":[57544424],"length":1,"stats":{"Line":0}},{"line":903,"address":[57544711,57544638],"length":1,"stats":{"Line":0}},{"line":904,"address":[57544759,57544844],"length":1,"stats":{"Line":0}},{"line":906,"address":[57544725,57544798],"length":1,"stats":{"Line":0}},{"line":908,"address":[57545141,57545073],"length":1,"stats":{"Line":0}},{"line":915,"address":[57544653],"length":1,"stats":{"Line":0}},{"line":918,"address":[57544213,57545621,57546375],"length":1,"stats":{"Line":0}},{"line":920,"address":[57545635,57545680],"length":1,"stats":{"Line":0}},{"line":921,"address":[57545766,57545829],"length":1,"stats":{"Line":0}},{"line":923,"address":[57545854],"length":1,"stats":{"Line":0}},{"line":924,"address":[57546263,57546071],"length":1,"stats":{"Line":0}},{"line":925,"address":[57546321,57546647],"length":1,"stats":{"Line":0}},{"line":927,"address":[57546356],"length":1,"stats":{"Line":0}},{"line":928,"address":[57546380],"length":1,"stats":{"Line":0}},{"line":932,"address":[57547052,57546861],"length":1,"stats":{"Line":0}},{"line":935,"address":[57517544,57517580,57515840],"length":1,"stats":{"Line":0}},{"line":936,"address":[57515870],"length":1,"stats":{"Line":0}},{"line":939,"address":[54325210,54325168],"length":1,"stats":{"Line":0}},{"line":940,"address":[57516406,57516327],"length":1,"stats":{"Line":0}},{"line":943,"address":[54325392,54325434],"length":1,"stats":{"Line":0}},{"line":944,"address":[57516892,57516963],"length":1,"stats":{"Line":0}},{"line":946,"address":[57517199,57517302],"length":1,"stats":{"Line":0}},{"line":952,"address":[57517487],"length":1,"stats":{"Line":0}},{"line":955,"address":[57521344,57522584,57523441],"length":1,"stats":{"Line":0}},{"line":956,"address":[57521401],"length":1,"stats":{"Line":0}},{"line":959,"address":[57521602,57523436,57521681],"length":1,"stats":{"Line":0}},{"line":962,"address":[57521924],"length":1,"stats":{"Line":0}},{"line":964,"address":[57521972,57522632,57523401,57523077],"length":1,"stats":{"Line":0}},{"line":965,"address":[57523161,57523090],"length":1,"stats":{"Line":0}},{"line":970,"address":[57523388],"length":1,"stats":{"Line":0}},{"line":972,"address":[57522711,57522638],"length":1,"stats":{"Line":0}},{"line":973,"address":[57523003],"length":1,"stats":{"Line":0}},{"line":977,"address":[57521944,57522074,57522158],"length":1,"stats":{"Line":0}},{"line":978,"address":[57522126,57522051],"length":1,"stats":{"Line":0}},{"line":980,"address":[57522371,57522266],"length":1,"stats":{"Line":0}},{"line":986,"address":[57522549],"length":1,"stats":{"Line":0}},{"line":990,"address":[57523456,57524962,57525688],"length":1,"stats":{"Line":0}},{"line":991,"address":[57523481],"length":1,"stats":{"Line":0}},{"line":992,"address":[54326890,54326848],"length":1,"stats":{"Line":0}},{"line":994,"address":[57523959,57524030],"length":1,"stats":{"Line":0}},{"line":995,"address":[57524213],"length":1,"stats":{"Line":0}},{"line":997,"address":[57524412],"length":1,"stats":{"Line":0}},{"line":998,"address":[57525192,57525093,57524540,57525272],"length":1,"stats":{"Line":0}},{"line":1007,"address":[57524582],"length":1,"stats":{"Line":0}},{"line":1008,"address":[57524781],"length":1,"stats":{"Line":0}},{"line":1010,"address":[57524917],"length":1,"stats":{"Line":0}},{"line":1013,"address":[57572800,57574609,57574390],"length":1,"stats":{"Line":0}},{"line":1014,"address":[57572825],"length":1,"stats":{"Line":0}},{"line":1015,"address":[57573008,57573084],"length":1,"stats":{"Line":0}},{"line":1017,"address":[57573282,57573353],"length":1,"stats":{"Line":0}},{"line":1018,"address":[57573536],"length":1,"stats":{"Line":0}},{"line":1020,"address":[57573735],"length":1,"stats":{"Line":0}},{"line":1021,"address":[57574401,57573989],"length":1,"stats":{"Line":0}},{"line":1024,"address":[57574015],"length":1,"stats":{"Line":0}},{"line":1025,"address":[57574214],"length":1,"stats":{"Line":0}},{"line":1027,"address":[57574348],"length":1,"stats":{"Line":0}},{"line":1030,"address":[57574624,57575134,57575140],"length":1,"stats":{"Line":0}},{"line":1032,"address":[57574662],"length":1,"stats":{"Line":0}},{"line":1033,"address":[57574737],"length":1,"stats":{"Line":0}},{"line":1034,"address":[57574812],"length":1,"stats":{"Line":0}},{"line":1042,"address":[57574763],"length":1,"stats":{"Line":0}},{"line":1043,"address":[54333467,54333424],"length":1,"stats":{"Line":0}},{"line":1046,"address":[57547870,57547655,57547120],"length":1,"stats":{"Line":0}},{"line":1047,"address":[57547228,57547184],"length":1,"stats":{"Line":0}},{"line":1049,"address":[57547398,57547330],"length":1,"stats":{"Line":0}},{"line":1050,"address":[57547449],"length":1,"stats":{"Line":0}},{"line":1051,"address":[57547528],"length":1,"stats":{"Line":0}},{"line":1055,"address":[57547671,57547485],"length":1,"stats":{"Line":0}},{"line":1056,"address":[57547759],"length":1,"stats":{"Line":0}},{"line":1057,"address":[57547849],"length":1,"stats":{"Line":0}},{"line":1060,"address":[57547793],"length":1,"stats":{"Line":0}},{"line":1063,"address":[57556880,57557415,57557630],"length":1,"stats":{"Line":0}},{"line":1064,"address":[57556988,57556944],"length":1,"stats":{"Line":0}},{"line":1066,"address":[57557090,57557158],"length":1,"stats":{"Line":0}},{"line":1067,"address":[57557209],"length":1,"stats":{"Line":0}},{"line":1068,"address":[57557288],"length":1,"stats":{"Line":0}},{"line":1072,"address":[57557245,57557431],"length":1,"stats":{"Line":0}},{"line":1073,"address":[57557519],"length":1,"stats":{"Line":0}},{"line":1074,"address":[57557609],"length":1,"stats":{"Line":0}},{"line":1077,"address":[57557553],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":428},{"path":["/","home","md","language","mdhavers","src","parser.rs"],"content":"use crate::ast::{LogLevel, *};\nuse crate::error::{HaversError, HaversResult};\nuse crate::token::{Token, TokenKind};\n\n/// The parser - turns tokens intae an AST\npub struct Parser {\n    tokens: Vec<Token>,\n    current: usize,\n}\n\nimpl Parser {\n    pub fn new(tokens: Vec<Token>) -> Self {\n        Parser { tokens, current: 0 }\n    }\n\n    /// Parse the tokens intae a program\n    pub fn parse(&mut self) -> HaversResult<Program> {\n        let mut statements = Vec::new();\n\n        self.skip_newlines();\n\n        while !self.is_at_end() {\n            statements.push(self.declaration()?);\n            self.skip_newlines();\n        }\n\n        Ok(Program::new(statements))\n    }\n\n    // === Declaration parsing ===\n\n    fn declaration(&mut self) -> HaversResult<Stmt> {\n        if self.check(&TokenKind::Ken) {\n            self.var_declaration()\n        } else if self.check(&TokenKind::Dae) {\n            self.function_declaration()\n        } else if self.check(&TokenKind::Kin) {\n            self.class_declaration()\n        } else if self.check(&TokenKind::Thing) {\n            self.struct_declaration()\n        } else if self.check(&TokenKind::Fetch) {\n            self.import_declaration()\n        } else {\n            self.statement()\n        }\n    }\n\n    fn var_declaration(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'ken'\n\n        // Check fer destructuring pattern: ken [a, b, c] = ...\n        if self.check(&TokenKind::LeftBracket) {\n            return self.destructure_declaration(span);\n        }\n\n        let name = self.expect_identifier(\"variable name\")?;\n\n        let initializer = if self.match_token(&TokenKind::Equals) {\n            Some(self.expression()?)\n        } else {\n            None\n        };\n\n        self.expect_statement_end()?;\n\n        Ok(Stmt::VarDecl {\n            name,\n            initializer,\n            span,\n        })\n    }\n\n    /// Parse a destructuring pattern: ken [a, b, ...rest] = list\n    fn destructure_declaration(&mut self, span: Span) -> HaversResult<Stmt> {\n        self.expect(&TokenKind::LeftBracket, \"[\")?;\n\n        let mut patterns = Vec::new();\n        let mut seen_rest = false;\n\n        while !self.check(&TokenKind::RightBracket) && !self.is_at_end() {\n            // Check fer rest pattern: ...name\n            if self.match_token(&TokenKind::DotDotDot) {\n                if seen_rest {\n                    return Err(HaversError::ParseError {\n                        message: \"Ye can only hae ane rest pattern (...) in a destructure\"\n                            .to_string(),\n                        line: span.line,\n                    });\n                }\n                let name = self.expect_identifier(\"rest variable name\")?;\n                patterns.push(DestructPattern::Rest(name));\n                seen_rest = true;\n            } else if self.match_token(&TokenKind::Underscore) {\n                // Ignore pattern: _\n                patterns.push(DestructPattern::Ignore);\n            } else {\n                // Regular variable\n                let name = self.expect_identifier(\"variable name\")?;\n                patterns.push(DestructPattern::Variable(name));\n            }\n\n            if !self.match_token(&TokenKind::Comma) {\n                break;\n            }\n        }\n\n        self.expect(&TokenKind::RightBracket, \"]\")?;\n        self.expect(&TokenKind::Equals, \"=\")?;\n\n        let value = self.expression()?;\n\n        self.expect_statement_end()?;\n\n        Ok(Stmt::Destructure {\n            patterns,\n            value,\n            span,\n        })\n    }\n\n    fn function_declaration(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'dae'\n\n        let name = self.expect_identifier(\"function name\")?;\n        self.expect(&TokenKind::LeftParen, \"(\")?;\n\n        let mut params = Vec::new();\n        let mut seen_default = false;\n\n        if !self.check(&TokenKind::RightParen) {\n            loop {\n                let param_name = self.expect_identifier(\"parameter name\")?;\n\n                // Check for default value: param = value\n                let default = if self.match_token(&TokenKind::Equals) {\n                    seen_default = true;\n                    Some(self.expression()?)\n                } else {\n                    // Params wi' defaults must come efter params wi'oot\n                    if seen_default {\n                        return Err(HaversError::ParseError {\n                            message:\n                                \"Och! Params wi'oot defaults cannae come efter params wi' defaults\"\n                                    .to_string(),\n                            line: span.line,\n                        });\n                    }\n                    None\n                };\n\n                params.push(Param {\n                    name: param_name,\n                    default,\n                });\n\n                if !self.match_token(&TokenKind::Comma) {\n                    break;\n                }\n            }\n        }\n\n        self.expect(&TokenKind::RightParen, \")\")?;\n        self.skip_newlines();\n        self.expect(&TokenKind::LeftBrace, \"{\")?;\n\n        let body = self.block_statements()?;\n\n        Ok(Stmt::Function {\n            name,\n            params,\n            body,\n            span,\n        })\n    }\n\n    fn class_declaration(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'kin'\n\n        let name = self.expect_identifier(\"class name\")?;\n\n        let superclass = if self.match_token(&TokenKind::Fae) {\n            Some(self.expect_identifier(\"superclass name\")?)\n        } else {\n            None\n        };\n\n        self.skip_newlines();\n        self.expect(&TokenKind::LeftBrace, \"{\")?;\n\n        let mut methods = Vec::new();\n        self.skip_newlines();\n        while !self.check(&TokenKind::RightBrace) && !self.is_at_end() {\n            if self.check(&TokenKind::Dae) {\n                methods.push(self.function_declaration()?);\n            } else {\n                return Err(HaversError::ParseError {\n                    message: \"Expected method definition in class\".to_string(),\n                    line: self.current_line(),\n                });\n            }\n            self.skip_newlines();\n        }\n\n        self.expect(&TokenKind::RightBrace, \"}\")?;\n\n        Ok(Stmt::Class {\n            name,\n            superclass,\n            methods,\n            span,\n        })\n    }\n\n    fn struct_declaration(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'thing'\n\n        let name = self.expect_identifier(\"struct name\")?;\n        self.skip_newlines();\n        self.expect(&TokenKind::LeftBrace, \"{\")?;\n        self.skip_newlines();\n\n        let mut fields = Vec::new();\n        while !self.check(&TokenKind::RightBrace) && !self.is_at_end() {\n            fields.push(self.expect_identifier(\"field name\")?);\n            if !self.match_token(&TokenKind::Comma) {\n                self.skip_newlines();\n                break;\n            }\n            self.skip_newlines();\n        }\n\n        self.expect(&TokenKind::RightBrace, \"}\")?;\n\n        Ok(Stmt::Struct { name, fields, span })\n    }\n\n    fn import_declaration(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'fetch'\n\n        let path = self.expect_string(\"module path\")?;\n\n        let alias = if self.match_token(&TokenKind::Tae) {\n            Some(self.expect_identifier(\"alias name\")?)\n        } else {\n            None\n        };\n\n        self.expect_statement_end()?;\n\n        Ok(Stmt::Import { path, alias, span })\n    }\n\n    // === Statement parsing ===\n\n    fn statement(&mut self) -> HaversResult<Stmt> {\n        if self.check(&TokenKind::Gin) {\n            self.if_statement()\n        } else if self.check(&TokenKind::Whiles) {\n            self.while_statement()\n        } else if self.check(&TokenKind::Fer) {\n            self.for_statement()\n        } else if self.check(&TokenKind::Gie) {\n            self.return_statement()\n        } else if self.check(&TokenKind::Blether) {\n            self.print_statement()\n        } else if self.check(&TokenKind::Brak) {\n            self.break_statement()\n        } else if self.check(&TokenKind::Haud) {\n            self.continue_statement()\n        } else if self.check(&TokenKind::HaeABash) {\n            self.try_catch_statement()\n        } else if self.check(&TokenKind::Keek) {\n            self.match_statement()\n        } else if self.check(&TokenKind::MakSiccar) {\n            self.assert_statement()\n        } else if self.check(&TokenKind::LogWhisper) {\n            self.log_statement(LogLevel::Whisper)\n        } else if self.check(&TokenKind::LogMutter) {\n            self.log_statement(LogLevel::Mutter)\n        } else if self.check(&TokenKind::LogBlether) {\n            self.log_statement(LogLevel::Blether)\n        } else if self.check(&TokenKind::LogHoller) {\n            self.log_statement(LogLevel::Holler)\n        } else if self.check(&TokenKind::LogRoar) {\n            self.log_statement(LogLevel::Roar)\n        } else if self.check(&TokenKind::Hurl) {\n            self.hurl_statement()\n        } else if self.check(&TokenKind::LeftBrace) {\n            self.block()\n        } else {\n            self.expression_statement()\n        }\n    }\n\n    fn if_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'gin'\n\n        let condition = self.expression()?;\n        self.skip_newlines();\n        let then_branch = Box::new(self.block()?);\n\n        let else_branch = if self.match_token(&TokenKind::Ither) {\n            self.skip_newlines();\n            if self.check(&TokenKind::Gin) {\n                // else if\n                Some(Box::new(self.if_statement()?))\n            } else {\n                Some(Box::new(self.block()?))\n            }\n        } else {\n            None\n        };\n\n        Ok(Stmt::If {\n            condition,\n            then_branch,\n            else_branch,\n            span,\n        })\n    }\n\n    fn while_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'whiles'\n\n        let condition = self.expression()?;\n        self.skip_newlines();\n        let body = Box::new(self.block()?);\n\n        Ok(Stmt::While {\n            condition,\n            body,\n            span,\n        })\n    }\n\n    fn for_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'fer'\n\n        let variable = self.expect_identifier(\"loop variable\")?;\n        self.expect(&TokenKind::In, \"in\")?;\n        let iterable = self.expression()?;\n        self.skip_newlines();\n        let body = Box::new(self.block()?);\n\n        Ok(Stmt::For {\n            variable,\n            iterable,\n            body,\n            span,\n        })\n    }\n\n    fn return_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'gie'\n\n        let value = if self.check(&TokenKind::Newline) || self.check(&TokenKind::Eof) {\n            None\n        } else {\n            Some(self.expression()?)\n        };\n\n        self.expect_statement_end()?;\n\n        Ok(Stmt::Return { value, span })\n    }\n\n    fn print_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'blether'\n\n        let value = self.expression()?;\n        self.expect_statement_end()?;\n\n        Ok(Stmt::Print { value, span })\n    }\n\n    fn break_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'brak'\n        self.expect_statement_end()?;\n        Ok(Stmt::Break { span })\n    }\n\n    fn continue_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'haud'\n        self.expect_statement_end()?;\n        Ok(Stmt::Continue { span })\n    }\n\n    fn try_catch_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'hae_a_bash'\n\n        self.skip_newlines();\n        let try_block = Box::new(self.block()?);\n\n        self.skip_newlines();\n        self.expect(&TokenKind::GinItGangsWrang, \"gin_it_gangs_wrang\")?;\n\n        let error_name = self.expect_identifier(\"error variable name\")?;\n        self.skip_newlines();\n        let catch_block = Box::new(self.block()?);\n\n        Ok(Stmt::TryCatch {\n            try_block,\n            error_name,\n            catch_block,\n            span,\n        })\n    }\n\n    fn match_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'keek'\n\n        let value = self.expression()?;\n        self.skip_newlines();\n        self.expect(&TokenKind::LeftBrace, \"{\")?;\n        self.skip_newlines();\n\n        let mut arms = Vec::new();\n        while !self.check(&TokenKind::RightBrace) && !self.is_at_end() {\n            arms.push(self.match_arm()?);\n            self.skip_newlines();\n        }\n\n        self.expect(&TokenKind::RightBrace, \"}\")?;\n\n        Ok(Stmt::Match { value, arms, span })\n    }\n\n    fn assert_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'mak_siccar'\n\n        let condition = self.expression()?;\n\n        // Optional message after comma\n        let message = if self.match_token(&TokenKind::Comma) {\n            Some(self.expression()?)\n        } else {\n            None\n        };\n\n        Ok(Stmt::Assert {\n            condition,\n            message,\n            span,\n        })\n    }\n\n    fn log_statement(&mut self, level: LogLevel) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'log_whisper', 'log_mutter', etc.\n\n        let message = self.expression()?;\n        self.expect_statement_end()?;\n\n        Ok(Stmt::Log {\n            level,\n            message,\n            span,\n        })\n    }\n\n    fn hurl_statement(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.advance(); // consume 'hurl'\n\n        let message = self.expression()?;\n        self.expect_statement_end()?;\n\n        Ok(Stmt::Hurl { message, span })\n    }\n\n    fn match_arm(&mut self) -> HaversResult<MatchArm> {\n        let span = self.current_span();\n        self.expect(&TokenKind::Whan, \"whan\")?;\n\n        let pattern = self.pattern()?;\n        self.expect(&TokenKind::Arrow, \"->\")?;\n        self.skip_newlines();\n\n        // Match arms can have blocks, statements, or expressions\n        let body = if self.check(&TokenKind::LeftBrace) {\n            self.block()?\n        } else if self.check(&TokenKind::Blether) {\n            self.print_statement()?\n        } else if self.check(&TokenKind::Gie) {\n            self.return_statement()?\n        } else if self.check(&TokenKind::Brak) {\n            self.break_statement()?\n        } else if self.check(&TokenKind::Haud) {\n            self.continue_statement()?\n        } else {\n            let expr = self.expression()?;\n            Stmt::Expression {\n                span: expr.span(),\n                expr,\n            }\n        };\n\n        Ok(MatchArm {\n            pattern,\n            body,\n            span,\n        })\n    }\n\n    fn pattern(&mut self) -> HaversResult<Pattern> {\n        let token = self.peek().clone();\n        match &token.kind {\n            TokenKind::Integer(n) => {\n                let n = *n;\n                self.advance();\n                if self.match_token(&TokenKind::DotDot) {\n                    let end = self.expression()?;\n                    Ok(Pattern::Range {\n                        start: Box::new(Expr::Literal {\n                            value: Literal::Integer(n),\n                            span: Span::new(token.line, token.column),\n                        }),\n                        end: Box::new(end),\n                    })\n                } else {\n                    Ok(Pattern::Literal(Literal::Integer(n)))\n                }\n            }\n            TokenKind::Float(n) => {\n                let n = *n;\n                self.advance();\n                Ok(Pattern::Literal(Literal::Float(n)))\n            }\n            TokenKind::String(s) | TokenKind::SingleQuoteString(s) => {\n                let s = process_escapes(s);\n                self.advance();\n                Ok(Pattern::Literal(Literal::String(s)))\n            }\n            TokenKind::Aye => {\n                self.advance();\n                Ok(Pattern::Literal(Literal::Bool(true)))\n            }\n            TokenKind::Nae => {\n                self.advance();\n                Ok(Pattern::Literal(Literal::Bool(false)))\n            }\n            TokenKind::Naething => {\n                self.advance();\n                Ok(Pattern::Literal(Literal::Nil))\n            }\n            TokenKind::Underscore => {\n                self.advance();\n                Ok(Pattern::Wildcard)\n            }\n            TokenKind::Identifier(name) if name == \"_\" => {\n                self.advance();\n                Ok(Pattern::Wildcard)\n            }\n            TokenKind::Identifier(name) => {\n                let name = name.clone();\n                self.advance();\n                Ok(Pattern::Identifier(name))\n            }\n            _ => Err(HaversError::ParseError {\n                message: format!(\"Expected pattern, got {}\", token.kind),\n                line: token.line,\n            }),\n        }\n    }\n\n    fn block(&mut self) -> HaversResult<Stmt> {\n        let span = self.current_span();\n        self.expect(&TokenKind::LeftBrace, \"{\")?;\n        let statements = self.block_statements()?;\n        Ok(Stmt::Block { statements, span })\n    }\n\n    fn block_statements(&mut self) -> HaversResult<Vec<Stmt>> {\n        let mut statements = Vec::new();\n        self.skip_newlines();\n\n        while !self.check(&TokenKind::RightBrace) && !self.is_at_end() {\n            statements.push(self.declaration()?);\n            self.skip_newlines();\n        }\n\n        self.expect(&TokenKind::RightBrace, \"}\")?;\n        Ok(statements)\n    }\n\n    fn expression_statement(&mut self) -> HaversResult<Stmt> {\n        let expr = self.expression()?;\n        let span = expr.span();\n        self.expect_statement_end()?;\n        Ok(Stmt::Expression { expr, span })\n    }\n\n    // === Expression parsing (precedence climbing) ===\n\n    fn expression(&mut self) -> HaversResult<Expr> {\n        self.assignment()\n    }\n\n    fn assignment(&mut self) -> HaversResult<Expr> {\n        let expr = self.pipe_expr()?;\n\n        if self.match_token(&TokenKind::Equals) {\n            let span = self.current_span();\n            let value = self.assignment()?;\n\n            match expr {\n                Expr::Variable { name, .. } => {\n                    return Ok(Expr::Assign {\n                        name,\n                        value: Box::new(value),\n                        span,\n                    });\n                }\n                Expr::Get {\n                    object, property, ..\n                } => {\n                    return Ok(Expr::Set {\n                        object,\n                        property,\n                        value: Box::new(value),\n                        span,\n                    });\n                }\n                Expr::Index { object, index, .. } => {\n                    return Ok(Expr::IndexSet {\n                        object,\n                        index,\n                        value: Box::new(value),\n                        span,\n                    });\n                }\n                _ => {\n                    return Err(HaversError::ParseError {\n                        message: \"Invalid assignment target\".to_string(),\n                        line: span.line,\n                    });\n                }\n            }\n        }\n\n        // Handle compound assignment operators\n        let compound_op = if self.match_token(&TokenKind::PlusEquals) {\n            Some(BinaryOp::Add)\n        } else if self.match_token(&TokenKind::MinusEquals) {\n            Some(BinaryOp::Subtract)\n        } else if self.match_token(&TokenKind::StarEquals) {\n            Some(BinaryOp::Multiply)\n        } else if self.match_token(&TokenKind::SlashEquals) {\n            Some(BinaryOp::Divide)\n        } else {\n            None\n        };\n\n        if let Some(op) = compound_op {\n            let span = expr.span();\n            let value = self.assignment()?;\n\n            match expr {\n                Expr::Variable { name, .. } => {\n                    return Ok(Expr::Assign {\n                        name: name.clone(),\n                        value: Box::new(Expr::Binary {\n                            left: Box::new(Expr::Variable { name, span }),\n                            operator: op,\n                            right: Box::new(value),\n                            span,\n                        }),\n                        span,\n                    });\n                }\n                _ => {\n                    return Err(HaversError::ParseError {\n                        message: \"Invalid compound assignment target\".to_string(),\n                        line: span.line,\n                    });\n                }\n            }\n        }\n\n        Ok(expr)\n    }\n\n    /// Pipe expression: left |> right (means call right with left as argument)\n    fn pipe_expr(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.ternary()?;\n\n        while self.match_token(&TokenKind::PipeForward) {\n            let span = self.current_span();\n            let right = self.ternary()?;\n            expr = Expr::Pipe {\n                left: Box::new(expr),\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    /// Ternary expression: gin condition than truthy ither falsy\n    fn ternary(&mut self) -> HaversResult<Expr> {\n        // Check fer ternary expression starting wi' 'gin'\n        if self.match_token(&TokenKind::Gin) {\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n\n            // Parse the condition\n            let condition = self.or()?;\n\n            // Expect 'than'\n            self.expect(&TokenKind::Than, \"than\")?;\n\n            // Parse the 'then' expression (truthy case)\n            let then_expr = self.or()?;\n\n            // Expect 'ither'\n            self.expect(&TokenKind::Ither, \"ither\")?;\n\n            // Parse the 'else' expression (falsy case)\n            let else_expr = self.ternary()?; // Right-associative\n\n            return Ok(Expr::Ternary {\n                condition: Box::new(condition),\n                then_expr: Box::new(then_expr),\n                else_expr: Box::new(else_expr),\n                span,\n            });\n        }\n\n        self.or()\n    }\n\n    fn or(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.and()?;\n\n        while self.match_token(&TokenKind::Or) {\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let right = self.and()?;\n            expr = Expr::Logical {\n                left: Box::new(expr),\n                operator: LogicalOp::Or,\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn and(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.equality()?;\n\n        while self.match_token(&TokenKind::An) {\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let right = self.equality()?;\n            expr = Expr::Logical {\n                left: Box::new(expr),\n                operator: LogicalOp::And,\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn equality(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.comparison()?;\n\n        loop {\n            let op = if self.match_token(&TokenKind::EqualsEquals) {\n                BinaryOp::Equal\n            } else if self.match_token(&TokenKind::BangEquals) {\n                BinaryOp::NotEqual\n            } else {\n                break;\n            };\n\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let right = self.comparison()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                operator: op,\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn comparison(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.term()?;\n\n        loop {\n            let op = if self.match_token(&TokenKind::Less) {\n                BinaryOp::Less\n            } else if self.match_token(&TokenKind::LessEquals) {\n                BinaryOp::LessEqual\n            } else if self.match_token(&TokenKind::Greater) {\n                BinaryOp::Greater\n            } else if self.match_token(&TokenKind::GreaterEquals) {\n                BinaryOp::GreaterEqual\n            } else {\n                break;\n            };\n\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let right = self.term()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                operator: op,\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn term(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.factor()?;\n\n        loop {\n            let op = if self.match_token(&TokenKind::Plus) {\n                BinaryOp::Add\n            } else if self.match_token(&TokenKind::Minus) {\n                BinaryOp::Subtract\n            } else {\n                break;\n            };\n\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let right = self.factor()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                operator: op,\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn factor(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.unary()?;\n\n        loop {\n            let op = if self.match_token(&TokenKind::Star) {\n                BinaryOp::Multiply\n            } else if self.match_token(&TokenKind::Slash) {\n                BinaryOp::Divide\n            } else if self.match_token(&TokenKind::Percent) {\n                BinaryOp::Modulo\n            } else {\n                break;\n            };\n\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let right = self.unary()?;\n            expr = Expr::Binary {\n                left: Box::new(expr),\n                operator: op,\n                right: Box::new(right),\n                span,\n            };\n        }\n\n        Ok(expr)\n    }\n\n    fn unary(&mut self) -> HaversResult<Expr> {\n        if self.match_token(&TokenKind::Minus) {\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let operand = self.unary()?;\n            return Ok(Expr::Unary {\n                operator: UnaryOp::Negate,\n                operand: Box::new(operand),\n                span,\n            });\n        }\n\n        // For `nae`, we need to distinguish between:\n        // - `nae` as a boolean literal (when not followed by an operand)\n        // - `nae x` as a NOT operator (when followed by an operand)\n        if self.check(&TokenKind::Nae) {\n            // Look ahead to see if there's an operand\n            if self.is_nae_followed_by_operand() {\n                self.advance(); // consume nae\n                let span = self\n                    .previous()\n                    .map(|t| Span::new(t.line, t.column))\n                    .unwrap_or(self.current_span());\n                let operand = self.unary()?;\n                return Ok(Expr::Unary {\n                    operator: UnaryOp::Not,\n                    operand: Box::new(operand),\n                    span,\n                });\n            }\n            // Otherwise, let it be parsed as a literal in primary()\n        }\n\n        if self.match_token(&TokenKind::Bang) {\n            let span = self\n                .previous()\n                .map(|t| Span::new(t.line, t.column))\n                .unwrap_or(self.current_span());\n            let operand = self.unary()?;\n            return Ok(Expr::Unary {\n                operator: UnaryOp::Not,\n                operand: Box::new(operand),\n                span,\n            });\n        }\n\n        self.call()\n    }\n\n    /// Check if `nae` is followed by something that could be an operand\n    fn is_nae_followed_by_operand(&self) -> bool {\n        if self.current + 1 >= self.tokens.len() {\n            return false;\n        }\n        let next = &self.tokens[self.current + 1];\n        matches!(\n            next.kind,\n            TokenKind::Integer(_)\n                | TokenKind::Float(_)\n                | TokenKind::String(_)\n                | TokenKind::SingleQuoteString(_)\n                | TokenKind::Identifier(_)\n                | TokenKind::LeftParen\n                | TokenKind::LeftBracket\n                | TokenKind::LeftBrace\n                | TokenKind::Minus\n                | TokenKind::Bang\n                | TokenKind::Aye\n                | TokenKind::Naething\n                | TokenKind::Masel\n                | TokenKind::Speir\n                | TokenKind::Pipe\n        )\n    }\n\n    fn call(&mut self) -> HaversResult<Expr> {\n        let mut expr = self.primary()?;\n\n        loop {\n            if self.match_token(&TokenKind::LeftParen) {\n                expr = self.finish_call(expr)?;\n            } else if self.match_token(&TokenKind::Dot) {\n                let property = self.expect_identifier(\"property name\")?;\n                let span = self.current_span();\n                expr = Expr::Get {\n                    object: Box::new(expr),\n                    property,\n                    span,\n                };\n            } else if self.match_token(&TokenKind::LeftBracket) {\n                let span = self.current_span();\n\n                // Check fer slice syntax: [start:end:step], [:end], [start:], [::step], etc.\n                if self.check(&TokenKind::Colon) {\n                    // [:end] or [:] or [:end:step] or [::step]\n                    self.advance(); // consume the first colon\n\n                    let end =\n                        if self.check(&TokenKind::Colon) || self.check(&TokenKind::RightBracket) {\n                            None\n                        } else {\n                            Some(Box::new(self.expression()?))\n                        };\n\n                    // Check fer step\n                    let step = if self.match_token(&TokenKind::Colon) {\n                        if self.check(&TokenKind::RightBracket) {\n                            None\n                        } else {\n                            Some(Box::new(self.expression()?))\n                        }\n                    } else {\n                        None\n                    };\n\n                    self.expect(&TokenKind::RightBracket, \"]\")?;\n                    expr = Expr::Slice {\n                        object: Box::new(expr),\n                        start: None,\n                        end,\n                        step,\n                        span,\n                    };\n                } else {\n                    // Could be [index] or [start:end] or [start:] or [start:end:step]\n                    let first = self.expression()?;\n\n                    if self.match_token(&TokenKind::Colon) {\n                        // It's a slice: [start:end] or [start:] or [start:end:step] or [start::step]\n                        let end = if self.check(&TokenKind::Colon)\n                            || self.check(&TokenKind::RightBracket)\n                        {\n                            None\n                        } else {\n                            Some(Box::new(self.expression()?))\n                        };\n\n                        // Check fer step\n                        let step = if self.match_token(&TokenKind::Colon) {\n                            if self.check(&TokenKind::RightBracket) {\n                                None\n                            } else {\n                                Some(Box::new(self.expression()?))\n                            }\n                        } else {\n                            None\n                        };\n\n                        self.expect(&TokenKind::RightBracket, \"]\")?;\n                        expr = Expr::Slice {\n                            object: Box::new(expr),\n                            start: Some(Box::new(first)),\n                            end,\n                            step,\n                            span,\n                        };\n                    } else {\n                        // Regular index access\n                        self.expect(&TokenKind::RightBracket, \"]\")?;\n                        expr = Expr::Index {\n                            object: Box::new(expr),\n                            index: Box::new(first),\n                            span,\n                        };\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn finish_call(&mut self, callee: Expr) -> HaversResult<Expr> {\n        let span = callee.span();\n        let mut arguments = Vec::new();\n\n        if !self.check(&TokenKind::RightParen) {\n            loop {\n                // Check for spread operator in function arguments\n                if self.match_token(&TokenKind::DotDotDot) {\n                    let spread_span = self.current_span();\n                    let expr = self.expression()?;\n                    arguments.push(Expr::Spread {\n                        expr: Box::new(expr),\n                        span: spread_span,\n                    });\n                } else {\n                    arguments.push(self.expression()?);\n                }\n                if !self.match_token(&TokenKind::Comma) {\n                    break;\n                }\n            }\n        }\n\n        self.expect(&TokenKind::RightParen, \")\")?;\n\n        Ok(Expr::Call {\n            callee: Box::new(callee),\n            arguments,\n            span,\n        })\n    }\n\n    fn primary(&mut self) -> HaversResult<Expr> {\n        let token = self.peek().clone();\n        let span = Span::new(token.line, token.column);\n\n        match &token.kind {\n            TokenKind::Integer(n) => {\n                let n = *n;\n                self.advance();\n                self.maybe_range(Expr::Literal {\n                    value: Literal::Integer(n),\n                    span,\n                })\n            }\n            TokenKind::Float(n) => {\n                let n = *n;\n                self.advance();\n                Ok(Expr::Literal {\n                    value: Literal::Float(n),\n                    span,\n                })\n            }\n            TokenKind::String(s) | TokenKind::SingleQuoteString(s) => {\n                let s = process_escapes(s);\n                self.advance();\n                Ok(Expr::Literal {\n                    value: Literal::String(s),\n                    span,\n                })\n            }\n            TokenKind::FString(s) => {\n                let s = s.clone();\n                self.advance();\n                self.parse_fstring(&s, span)\n            }\n            TokenKind::Aye => {\n                self.advance();\n                Ok(Expr::Literal {\n                    value: Literal::Bool(true),\n                    span,\n                })\n            }\n            TokenKind::Nae => {\n                self.advance();\n                Ok(Expr::Literal {\n                    value: Literal::Bool(false),\n                    span,\n                })\n            }\n            TokenKind::Naething => {\n                self.advance();\n                Ok(Expr::Literal {\n                    value: Literal::Nil,\n                    span,\n                })\n            }\n            TokenKind::Masel => {\n                self.advance();\n                Ok(Expr::Masel { span })\n            }\n            TokenKind::Speir => {\n                self.advance();\n                let prompt = self.expression()?;\n                Ok(Expr::Input {\n                    prompt: Box::new(prompt),\n                    span,\n                })\n            }\n            TokenKind::Identifier(name) => {\n                let name = name.clone();\n                self.advance();\n                let expr = Expr::Variable { name, span };\n                self.maybe_range(expr)\n            }\n            TokenKind::LeftParen => {\n                self.advance();\n                let expr = self.expression()?;\n                self.expect(&TokenKind::RightParen, \")\")?;\n                // Check for range after grouping: (x+1)..10\n                self.maybe_range(Expr::Grouping {\n                    expr: Box::new(expr),\n                    span,\n                })\n            }\n            TokenKind::LeftBracket => {\n                self.advance();\n                let mut elements = Vec::new();\n                self.skip_newlines(); // Allow newline after [\n                if !self.check(&TokenKind::RightBracket) {\n                    loop {\n                        // Check for spread operator (skail = scatter)\n                        if self.match_token(&TokenKind::DotDotDot) {\n                            let spread_span = self.current_span();\n                            let expr = self.expression()?;\n                            elements.push(Expr::Spread {\n                                expr: Box::new(expr),\n                                span: spread_span,\n                            });\n                        } else {\n                            elements.push(self.expression()?);\n                        }\n                        self.skip_newlines(); // Allow newline after element\n                        if !self.match_token(&TokenKind::Comma) {\n                            break;\n                        }\n                        self.skip_newlines(); // Allow newline after comma\n                    }\n                }\n                self.expect(&TokenKind::RightBracket, \"]\")?;\n                Ok(Expr::List { elements, span })\n            }\n            TokenKind::LeftBrace => {\n                self.advance();\n                let mut pairs = Vec::new();\n                self.skip_newlines();\n                if !self.check(&TokenKind::RightBrace) {\n                    loop {\n                        let key = self.expression()?;\n                        self.expect(&TokenKind::Colon, \":\")?;\n                        let value = self.expression()?;\n                        pairs.push((key, value));\n                        self.skip_newlines();\n                        if !self.match_token(&TokenKind::Comma) {\n                            break;\n                        }\n                        self.skip_newlines();\n                    }\n                }\n                self.expect(&TokenKind::RightBrace, \"}\")?;\n                Ok(Expr::Dict { pairs, span })\n            }\n            // Lambda expressions: |x, y| x + y\n            TokenKind::Pipe => {\n                self.advance();\n                let mut params = Vec::new();\n                if !self.check(&TokenKind::Pipe) {\n                    loop {\n                        params.push(self.expect_identifier(\"parameter name\")?);\n                        if !self.match_token(&TokenKind::Comma) {\n                            break;\n                        }\n                    }\n                }\n                self.expect(&TokenKind::Pipe, \"|\")?;\n                let body = self.expression()?;\n                Ok(Expr::Lambda {\n                    params,\n                    body: Box::new(body),\n                    span,\n                })\n            }\n            _ => Err(HaversError::ParseError {\n                message: format!(\"Unexpected token: {}\", token.kind),\n                line: token.line,\n            }),\n        }\n    }\n\n    fn maybe_range(&mut self, start_expr: Expr) -> HaversResult<Expr> {\n        if self.match_token(&TokenKind::DotDot) {\n            let span = start_expr.span();\n            let end = self.term()?;\n            Ok(Expr::Range {\n                start: Box::new(start_expr),\n                end: Box::new(end),\n                inclusive: false,\n                span,\n            })\n        } else {\n            Ok(start_expr)\n        }\n    }\n\n    // === Helper methods ===\n\n    fn peek(&self) -> &Token {\n        self.tokens\n            .get(self.current)\n            .unwrap_or(&self.tokens[self.tokens.len() - 1])\n    }\n\n    fn previous(&self) -> Option<&Token> {\n        if self.current > 0 {\n            self.tokens.get(self.current - 1)\n        } else {\n            None\n        }\n    }\n\n    fn is_at_end(&self) -> bool {\n        matches!(self.peek().kind, TokenKind::Eof)\n    }\n\n    fn advance(&mut self) -> &Token {\n        if !self.is_at_end() {\n            self.current += 1;\n        }\n        self.previous().unwrap()\n    }\n\n    fn check(&self, kind: &TokenKind) -> bool {\n        if self.is_at_end() {\n            false\n        } else {\n            std::mem::discriminant(&self.peek().kind) == std::mem::discriminant(kind)\n        }\n    }\n\n    fn match_token(&mut self, kind: &TokenKind) -> bool {\n        if self.check(kind) {\n            self.advance();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn expect(&mut self, kind: &TokenKind, expected: &str) -> HaversResult<()> {\n        if self.check(kind) {\n            self.advance();\n            Ok(())\n        } else {\n            Err(HaversError::UnexpectedToken {\n                expected: expected.to_string(),\n                found: self.peek().kind.to_string(),\n                line: self.peek().line,\n            })\n        }\n    }\n\n    fn expect_identifier(&mut self, context: &str) -> HaversResult<String> {\n        let token = self.peek().clone();\n        if let TokenKind::Identifier(name) = &token.kind {\n            let name = name.clone();\n            self.advance();\n            Ok(name)\n        } else {\n            Err(HaversError::UnexpectedToken {\n                expected: context.to_string(),\n                found: token.kind.to_string(),\n                line: token.line,\n            })\n        }\n    }\n\n    fn expect_string(&mut self, context: &str) -> HaversResult<String> {\n        let token = self.peek().clone();\n        if let TokenKind::String(s) | TokenKind::SingleQuoteString(s) = &token.kind {\n            let s = s.clone();\n            self.advance();\n            Ok(s)\n        } else {\n            Err(HaversError::UnexpectedToken {\n                expected: context.to_string(),\n                found: token.kind.to_string(),\n                line: token.line,\n            })\n        }\n    }\n\n    fn expect_statement_end(&mut self) -> HaversResult<()> {\n        if self.is_at_end() || self.check(&TokenKind::RightBrace) {\n            return Ok(());\n        }\n\n        if self.match_token(&TokenKind::Newline) {\n            return Ok(());\n        }\n\n        if self.match_token(&TokenKind::Semicolon) {\n            self.skip_newlines();\n            return Ok(());\n        }\n\n        // Be lenient - if the next token starts a new statement, that's fine\n        let next = &self.peek().kind;\n        if matches!(\n            next,\n            TokenKind::Ken\n                | TokenKind::Dae\n                | TokenKind::Gin\n                | TokenKind::Whiles\n                | TokenKind::Fer\n                | TokenKind::Gie\n                | TokenKind::Blether\n                | TokenKind::Brak\n                | TokenKind::Haud\n                | TokenKind::Kin\n                | TokenKind::Thing\n                | TokenKind::Fetch\n                | TokenKind::LogWhisper\n                | TokenKind::LogMutter\n                | TokenKind::LogBlether\n                | TokenKind::LogHoller\n                | TokenKind::LogRoar\n        ) {\n            return Ok(());\n        }\n\n        Err(HaversError::UnexpectedToken {\n            expected: \"newline or ';'\".to_string(),\n            found: self.peek().kind.to_string(),\n            line: self.peek().line,\n        })\n    }\n\n    fn skip_newlines(&mut self) {\n        while self.match_token(&TokenKind::Newline) {}\n    }\n\n    fn current_span(&self) -> Span {\n        let token = self.peek();\n        Span::new(token.line, token.column)\n    }\n\n    fn current_line(&self) -> usize {\n        self.peek().line\n    }\n\n    /// Parse an f-string like f\"Hello {name}!\" into parts\n    fn parse_fstring(&mut self, content: &str, span: Span) -> HaversResult<Expr> {\n        let mut parts = Vec::new();\n        let mut current_text = String::new();\n        let mut chars = content.chars().peekable();\n\n        while let Some(c) = chars.next() {\n            if c == '{' {\n                // Check for escaped brace {{\n                if chars.peek() == Some(&'{') {\n                    chars.next();\n                    current_text.push('{');\n                    continue;\n                }\n\n                // Save current text if any (process escapes)\n                if !current_text.is_empty() {\n                    parts.push(FStringPart::Text(process_escapes(&current_text)));\n                    current_text.clear();\n                }\n\n                // Extract expression inside {}\n                let mut expr_str = String::new();\n                let mut brace_depth = 1;\n                while let Some(c) = chars.next() {\n                    if c == '{' {\n                        brace_depth += 1;\n                        expr_str.push(c);\n                    } else if c == '}' {\n                        brace_depth -= 1;\n                        if brace_depth == 0 {\n                            break;\n                        }\n                        expr_str.push(c);\n                    } else if c == '\\\\' {\n                        // Handle escape sequences in the expression part\n                        // This allows things like f\"test {func(\\\"hello\\\")}\"\n                        if let Some(&next) = chars.peek() {\n                            match next {\n                                '\"' => {\n                                    chars.next();\n                                    expr_str.push('\"');\n                                }\n                                '\\\\' => {\n                                    chars.next();\n                                    expr_str.push('\\\\');\n                                }\n                                _ => {\n                                    // Keep the backslash for other escapes\n                                    expr_str.push(c);\n                                }\n                            }\n                        } else {\n                            expr_str.push(c);\n                        }\n                    } else {\n                        expr_str.push(c);\n                    }\n                }\n\n                // Parse the expression\n                let expr_tokens = crate::lexer::lex(&expr_str)?;\n                let mut expr_parser = Parser::new(expr_tokens);\n                let expr = expr_parser.expression()?;\n                parts.push(FStringPart::Expr(Box::new(expr)));\n            } else if c == '}' {\n                // Check for escaped brace }}\n                if chars.peek() == Some(&'}') {\n                    chars.next();\n                    current_text.push('}');\n                    continue;\n                }\n                // Single } without matching { - just add it\n                current_text.push(c);\n            } else {\n                current_text.push(c);\n            }\n        }\n\n        // Don't forget remaining text (process escapes)\n        if !current_text.is_empty() {\n            parts.push(FStringPart::Text(process_escapes(&current_text)));\n        }\n\n        Ok(Expr::FString { parts, span })\n    }\n}\n\n/// Process escape sequences in a string\n/// Handles \\n, \\t, \\r, \\\\, \\\", \\0, \\xNN (hex), etc.\nfn process_escapes(s: &str) -> String {\n    let mut result = String::with_capacity(s.len());\n    let mut chars = s.chars().peekable();\n\n    while let Some(c) = chars.next() {\n        if c == '\\\\' {\n            match chars.next() {\n                Some('n') => result.push('\\n'),\n                Some('t') => result.push('\\t'),\n                Some('r') => result.push('\\r'),\n                Some('\\\\') => result.push('\\\\'),\n                Some('\"') => result.push('\"'),\n                Some('\\'') => result.push('\\''),\n                Some('0') => result.push('\\0'),\n                Some('x') | Some('X') => {\n                    // Hex escape: \\xNN where NN is two hex digits\n                    let mut hex = String::new();\n                    for _ in 0..2 {\n                        if let Some(&c) = chars.peek() {\n                            if c.is_ascii_hexdigit() {\n                                hex.push(chars.next().unwrap());\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    if hex.len() == 2 {\n                        if let Ok(byte) = u8::from_str_radix(&hex, 16) {\n                            result.push(byte as char);\n                        } else {\n                            // Invalid hex - keep as-is\n                            result.push_str(\"\\\\x\");\n                            result.push_str(&hex);\n                        }\n                    } else {\n                        // Not enough hex digits - keep as-is\n                        result.push_str(\"\\\\x\");\n                        result.push_str(&hex);\n                    }\n                }\n                Some(other) => {\n                    // Unknown escape - keep as-is\n                    result.push('\\\\');\n                    result.push(other);\n                }\n                None => result.push('\\\\'),\n            }\n        } else {\n            result.push(c);\n        }\n    }\n\n    result\n}\n\n/// Convenience function tae parse source code\npub fn parse(source: &str) -> HaversResult<Program> {\n    let tokens = crate::lexer::lex(source)?;\n    let mut parser = Parser::new(tokens);\n    parser.parse()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_var_declaration() {\n        let program = parse(\"ken x = 5\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::VarDecl { .. }));\n    }\n\n    #[test]\n    fn test_function_declaration() {\n        let program = parse(\"dae greet(name) {\\n  blether name\\n}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::Function { .. }));\n    }\n\n    #[test]\n    fn test_if_statement() {\n        let program =\n            parse(\"gin x > 5 {\\n  blether \\\"big\\\"\\n} ither {\\n  blether \\\"wee\\\"\\n}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::If { .. }));\n    }\n\n    #[test]\n    fn test_while_loop() {\n        let program = parse(\"whiles x < 10 {\\n  x = x + 1\\n}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::While { .. }));\n    }\n\n    #[test]\n    fn test_for_loop() {\n        let program = parse(\"fer i in 1..10 {\\n  blether i\\n}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::For { .. }));\n    }\n\n    #[test]\n    fn test_expressions() {\n        let program = parse(\"ken x = 5 + 3 * 2\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_list_literal() {\n        let program = parse(\"ken arr = [1, 2, 3]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_dict_literal() {\n        let program = parse(\"ken d = {\\\"a\\\": 1, \\\"b\\\": 2}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_multiline_list() {\n        let program = parse(\"ken arr = [\\n  1,\\n  2,\\n  3\\n]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        if let Stmt::VarDecl {\n            initializer: Some(expr),\n            ..\n        } = &program.statements[0]\n        {\n            assert!(matches!(expr, Expr::List { elements, .. } if elements.len() == 3));\n        } else {\n            panic!(\"Expected VarDecl with List\");\n        }\n    }\n\n    #[test]\n    fn test_multiline_dict() {\n        let program = parse(\"ken d = {\\n  \\\"a\\\": 1,\\n  \\\"b\\\": 2\\n}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_fstring_with_escaped_quotes() {\n        // The lexer handles escapes in f-strings, parser should handle the interpolation\n        let program = parse(r#\"blether f\"test {\\\"hello\\\"}\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_lambda_expression() {\n        let program = parse(\"ken f = |x| x * 2\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_ternary_expression() {\n        let program = parse(\"ken x = gin aye than 1 ither 2\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_match_statement() {\n        let program = parse(\n            \"keek x {\\n  whan 1 -> { blether \\\"one\\\" }\\n  whan _ -> { blether \\\"other\\\" }\\n}\",\n        )\n        .unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::Match { .. }));\n    }\n\n    #[test]\n    fn test_class_declaration() {\n        let program =\n            parse(\"kin Dug {\\n  dae init(name) {\\n    masel.name = name\\n  }\\n}\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::Class { .. }));\n    }\n\n    #[test]\n    fn test_spread_operator() {\n        let program = parse(\"ken arr = [...other, 4, 5]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_slice_syntax() {\n        let program = parse(\"ken slice = arr[1:3]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_pipe_operator() {\n        let program = parse(\"ken result = x |> f |> g\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== Error Cases ====================\n\n    #[test]\n    fn test_destructure_multiple_rest_error() {\n        let result = parse(\"ken [...a, ...b] = [1, 2, 3]\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_param_defaults_ordering_error() {\n        let result = parse(\"dae foo(a = 1, b) { gie a + b }\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_destructure_with_ignore() {\n        let program = parse(\"ken [a, _, c] = [1, 2, 3]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_destructure_with_rest() {\n        let program = parse(\"ken [first, ...rest] = [1, 2, 3, 4]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_function_with_default_params() {\n        let program =\n            parse(\"dae greet(name, greeting = \\\"Hello\\\") { gie greeting + name }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_function_with_all_default_params() {\n        let program = parse(\"dae foo(a = 1, b = 2, c = 3) { gie a + b + c }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== Escape Sequences ====================\n\n    #[test]\n    fn test_escape_newline() {\n        let program = parse(r#\"ken s = \"hello\\nworld\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_tab() {\n        let program = parse(r#\"ken s = \"hello\\tworld\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_carriage_return() {\n        let program = parse(r#\"ken s = \"hello\\rworld\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_backslash() {\n        let program = parse(r#\"ken s = \"C:\\\\Users\\\\path\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_double_quote() {\n        let program = parse(r#\"ken s = \"say \\\"hello\\\"\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_single_quote() {\n        let program = parse(r#\"ken s = \"it\\'s fine\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_null() {\n        let program = parse(r#\"ken s = \"null\\0byte\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_hex() {\n        let program = parse(r#\"ken s = \"\\x41\\x42\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_unknown() {\n        // Unknown escapes are kept as-is\n        let program = parse(r#\"ken s = \"hello\\zworld\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_escape_trailing_backslash() {\n        let program = parse(r#\"ken s = \"hello\\\\\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== F-String Tests ====================\n\n    #[test]\n    fn test_fstring_basic() {\n        let program = parse(r#\"ken s = f\"Hello {name}!\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_fstring_multiple_exprs() {\n        let program = parse(r#\"ken s = f\"{a} + {b} = {a + b}\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_fstring_escaped_braces() {\n        let program = parse(r#\"ken s = f\"Use {{braces}} here\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_fstring_nested_expr() {\n        let program = parse(r#\"ken s = f\"Result: {gin x > 0 than x ither -x}\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== More Statement Tests ====================\n\n    #[test]\n    fn test_struct_declaration() {\n        let program = parse(\"thing Point { x, y }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::Struct { .. }));\n    }\n\n    #[test]\n    fn test_import_statement() {\n        let program = parse(r#\"fetch \"math\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::Import { .. }));\n    }\n\n    #[test]\n    fn test_try_catch() {\n        let program = parse(\"hae_a_bash { risky() } gin_it_gangs_wrang e { blether e }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::TryCatch { .. }));\n    }\n\n    #[test]\n    fn test_assert_statement() {\n        let program = parse(\"mak_siccar x > 0\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::Assert { .. }));\n    }\n\n    #[test]\n    fn test_assert_with_message() {\n        let program = parse(r#\"mak_siccar x > 0 , \"x must be positive\"\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_class_with_inheritance() {\n        let program = parse(\"kin Dog fae Animal { dae bark() { gie \\\"woof\\\" } }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_match_with_range_pattern() {\n        let program =\n            parse(\"keek x {\\n  whan 1..10 -> blether \\\"small\\\"\\n  whan _ -> blether \\\"big\\\"\\n}\")\n                .unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== Expression Tests ====================\n\n    #[test]\n    fn test_lambda_syntax() {\n        let program = parse(\"ken add = |a, b| a + b\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_range_inclusive() {\n        let program = parse(\"ken r = 1..10\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_range_exclusive() {\n        let program = parse(\"ken r = 1..10\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_slice_with_step() {\n        let program = parse(\"ken s = arr[::2]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_slice_reverse() {\n        let program = parse(\"ken s = arr[::-1]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_compound_assignment_plus() {\n        let program = parse(\"x += 5\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_compound_assignment_minus() {\n        let program = parse(\"x -= 5\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_compound_assignment_multiply() {\n        let program = parse(\"x *= 5\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_compound_assignment_divide() {\n        let program = parse(\"x /= 5\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_logical_not() {\n        let program = parse(\"ken b = no(aye)\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_unary_negate() {\n        let program = parse(\"ken n = -42\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_method_call_chain() {\n        let program = parse(\"obj.method1().method2().field\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_masel_reference() {\n        let program = parse(\"kin Foo { dae bar() { gie masel.x } }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_dict_literal_syntax() {\n        let program = parse(r#\"ken d = {\"key\": \"value\", \"num\": 42}\"#).unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_list_literal_syntax() {\n        let program = parse(\"ken l = [1, 2, 3, 4, 5]\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_grouping_expression() {\n        let program = parse(\"ken n = (1 + 2) * 3\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== Control Flow Tests ====================\n\n    #[test]\n    fn test_while_loop_parse() {\n        let program = parse(\"whiles x > 0 { x = x - 1 }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::While { .. }));\n    }\n\n    #[test]\n    fn test_for_loop_parse() {\n        let program = parse(\"fer i in 1..10 { blether i }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n        assert!(matches!(program.statements[0], Stmt::For { .. }));\n    }\n\n    #[test]\n    fn test_break_statement() {\n        let program = parse(\"whiles aye { brak }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_continue_statement() {\n        let program = parse(\"fer i in 1..10 { haud }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_return_with_value() {\n        let program = parse(\"dae foo() { gie 42 }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_return_without_value() {\n        let program = parse(\"dae foo() { gie naething }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_if_else() {\n        let program =\n            parse(\"gin x > 0 { blether \\\"positive\\\" } ither { blether \\\"not positive\\\" }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_if_else_if() {\n        let program = parse(\"gin x > 0 { blether \\\"pos\\\" } ither gin x < 0 { blether \\\"neg\\\" } ither { blether \\\"zero\\\" }\").unwrap();\n        assert_eq!(program.statements.len(), 1);\n    }\n\n    // ==================== Error Recovery Tests ====================\n\n    #[test]\n    fn test_unexpected_token_error() {\n        let result = parse(\"ken = 42\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_missing_closing_brace() {\n        let result = parse(\"gin aye { blether \\\"hi\\\"\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_missing_closing_bracket() {\n        let result = parse(\"ken l = [1, 2, 3\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_assignment_target() {\n        let result = parse(\"42 = x\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":12,"address":[53184352],"length":1,"stats":{"Line":45}},{"line":17,"address":[55428499,55427872,55428474],"length":1,"stats":{"Line":44}},{"line":18,"address":[55427902],"length":1,"stats":{"Line":65}},{"line":20,"address":[55427981,55427933],"length":1,"stats":{"Line":86}},{"line":22,"address":[53192328],"length":1,"stats":{"Line":61}},{"line":23,"address":[53192362,53192433],"length":1,"stats":{"Line":48}},{"line":24,"address":[107684432,107683952,107684501,107683728,107684046,107683768],"length":1,"stats":{"Line":6}},{"line":27,"address":[108545213,108544963,108545667],"length":1,"stats":{"Line":11}},{"line":32,"address":[108315376],"length":1,"stats":{"Line":62}},{"line":33,"address":[54047248],"length":1,"stats":{"Line":43}},{"line":34,"address":[107644433],"length":1,"stats":{"Line":27}},{"line":35,"address":[54047269],"length":1,"stats":{"Line":36}},{"line":36,"address":[54229740],"length":1,"stats":{"Line":7}},{"line":37,"address":[54047312],"length":1,"stats":{"Line":20}},{"line":38,"address":[108315566],"length":1,"stats":{"Line":3}},{"line":39,"address":[107644741],"length":1,"stats":{"Line":28}},{"line":40,"address":[55385468],"length":1,"stats":{"Line":2}},{"line":41,"address":[55385440],"length":1,"stats":{"Line":16}},{"line":42,"address":[54229854],"length":1,"stats":{"Line":2}},{"line":44,"address":[54047437],"length":1,"stats":{"Line":26}},{"line":48,"address":[53163907,53163899,53162784],"length":1,"stats":{"Line":26}},{"line":49,"address":[54061590],"length":1,"stats":{"Line":24}},{"line":50,"address":[54061626],"length":1,"stats":{"Line":17}},{"line":53,"address":[53162868],"length":1,"stats":{"Line":24}},{"line":54,"address":[54061748],"length":1,"stats":{"Line":6}},{"line":57,"address":[55399405,55399305],"length":1,"stats":{"Line":13}},{"line":59,"address":[55399848,55399515,55399602,55399578],"length":1,"stats":{"Line":49}},{"line":60,"address":[54243969,54244015,54244647],"length":1,"stats":{"Line":28}},{"line":62,"address":[55399584],"length":1,"stats":{"Line":3}},{"line":65,"address":[55399637,55399909],"length":1,"stats":{"Line":25}},{"line":67,"address":[108505281],"length":1,"stats":{"Line":8}},{"line":68,"address":[53163644],"length":1,"stats":{"Line":8}},{"line":69,"address":[107644095],"length":1,"stats":{"Line":17}},{"line":70,"address":[4234350],"length":1,"stats":{"Line":0}},{"line":75,"address":[4234264,4234317],"length":1,"stats":{"Line":6}},{"line":76,"address":[53178696],"length":1,"stats":{"Line":6}},{"line":78,"address":[54259251],"length":1,"stats":{"Line":6}},{"line":79,"address":[54259264],"length":1,"stats":{"Line":6}},{"line":81,"address":[53178930,53178999,53178864],"length":1,"stats":{"Line":18}},{"line":83,"address":[53179010,53180104],"length":1,"stats":{"Line":8}},{"line":84,"address":[54259470],"length":1,"stats":{"Line":2}},{"line":85,"address":[53180171],"length":1,"stats":{"Line":2}},{"line":86,"address":[108505968],"length":1,"stats":{"Line":0}},{"line":87,"address":[53179674],"length":1,"stats":{"Line":2}},{"line":91,"address":[53179708,53179647],"length":1,"stats":{"Line":4}},{"line":92,"address":[55415965],"length":1,"stats":{"Line":2}},{"line":93,"address":[54260468],"length":1,"stats":{"Line":2}},{"line":94,"address":[54078864,54078894,54078916,54077811,54077852,54078819],"length":1,"stats":{"Line":14}},{"line":96,"address":[54077890,54078408],"length":1,"stats":{"Line":4}},{"line":99,"address":[54259504,54259592],"length":1,"stats":{"Line":8}},{"line":100,"address":[53179396],"length":1,"stats":{"Line":4}},{"line":103,"address":[55415605,55416141],"length":1,"stats":{"Line":8}},{"line":104,"address":[4240528],"length":1,"stats":{"Line":0}},{"line":108,"address":[53180284,53181412,53178957],"length":1,"stats":{"Line":8}},{"line":109,"address":[107644556],"length":1,"stats":{"Line":4}},{"line":111,"address":[54261007,54261742],"length":1,"stats":{"Line":4}},{"line":113,"address":[54261300,54261363],"length":1,"stats":{"Line":12}},{"line":115,"address":[54261566],"length":1,"stats":{"Line":6}},{"line":116,"address":[54261492],"length":1,"stats":{"Line":6}},{"line":117,"address":[4240632],"length":1,"stats":{"Line":6}},{"line":118,"address":[4240639],"length":1,"stats":{"Line":0}},{"line":122,"address":[54077382,54076432,54074672],"length":1,"stats":{"Line":7}},{"line":123,"address":[54074710],"length":1,"stats":{"Line":7}},{"line":124,"address":[53175986],"length":1,"stats":{"Line":8}},{"line":126,"address":[55412124],"length":1,"stats":{"Line":8}},{"line":127,"address":[55414674,55412302,55412394],"length":1,"stats":{"Line":18}},{"line":129,"address":[54256883],"length":1,"stats":{"Line":9}},{"line":130,"address":[53176429],"length":1,"stats":{"Line":9}},{"line":132,"address":[54076377,54075205,54075271],"length":1,"stats":{"Line":24}},{"line":133,"address":[55413712],"length":1,"stats":{"Line":6}},{"line":134,"address":[53176584,53177670,53176514],"length":1,"stats":{"Line":18}},{"line":137,"address":[108314960],"length":1,"stats":{"Line":32}},{"line":138,"address":[108505225],"length":1,"stats":{"Line":3}},{"line":139,"address":[55413018,55413471,55413717],"length":1,"stats":{"Line":6}},{"line":142,"address":[54257337],"length":1,"stats":{"Line":9}},{"line":143,"address":[53177227],"length":1,"stats":{"Line":2}},{"line":145,"address":[4244390,4243803],"length":1,"stats":{"Line":0}},{"line":146,"address":[54075714],"length":1,"stats":{"Line":2}},{"line":147,"address":[108315337],"length":1,"stats":{"Line":0}},{"line":150,"address":[53176926],"length":1,"stats":{"Line":9}},{"line":153,"address":[55413186],"length":1,"stats":{"Line":11}},{"line":154,"address":[54257434],"length":1,"stats":{"Line":11}},{"line":155,"address":[54075788],"length":1,"stats":{"Line":11}},{"line":158,"address":[4240370],"length":1,"stats":{"Line":11}},{"line":159,"address":[4240381],"length":1,"stats":{"Line":0}},{"line":164,"address":[109928377],"length":1,"stats":{"Line":14}},{"line":165,"address":[54258282],"length":1,"stats":{"Line":7}},{"line":166,"address":[108505692],"length":1,"stats":{"Line":7}},{"line":168,"address":[55414135,55414646],"length":1,"stats":{"Line":7}},{"line":170,"address":[54258789],"length":1,"stats":{"Line":11}},{"line":171,"address":[55414350],"length":1,"stats":{"Line":10}},{"line":172,"address":[55414389],"length":1,"stats":{"Line":10}},{"line":174,"address":[4243074],"length":1,"stats":{"Line":0}},{"line":178,"address":[54065968,54067326,54068231],"length":1,"stats":{"Line":3}},{"line":179,"address":[54247894],"length":1,"stats":{"Line":3}},{"line":180,"address":[54247930],"length":1,"stats":{"Line":4}},{"line":182,"address":[54066052],"length":1,"stats":{"Line":4}},{"line":184,"address":[53167527,53167551,53167849,53167464],"length":1,"stats":{"Line":16}},{"line":185,"address":[54066326,54066368,54068229],"length":1,"stats":{"Line":6}},{"line":187,"address":[53167533],"length":1,"stats":{"Line":3}},{"line":190,"address":[53167590],"length":1,"stats":{"Line":3}},{"line":191,"address":[54250052,54248549],"length":1,"stats":{"Line":5}},{"line":193,"address":[54248737],"length":1,"stats":{"Line":5}},{"line":194,"address":[54066934,54066883],"length":1,"stats":{"Line":10}},{"line":195,"address":[54248803,54248894],"length":1,"stats":{"Line":10}},{"line":196,"address":[4237728],"length":1,"stats":{"Line":5}},{"line":197,"address":[109928016],"length":1,"stats":{"Line":9}},{"line":199,"address":[53168428],"length":1,"stats":{"Line":0}},{"line":200,"address":[108315116],"length":1,"stats":{"Line":0}},{"line":201,"address":[54067130],"length":1,"stats":{"Line":0}},{"line":204,"address":[54067661],"length":1,"stats":{"Line":4}},{"line":207,"address":[53168910,53168222,53169422],"length":1,"stats":{"Line":8}},{"line":209,"address":[55405467],"length":1,"stats":{"Line":4}},{"line":210,"address":[54067846],"length":1,"stats":{"Line":4}},{"line":211,"address":[108506057],"length":1,"stats":{"Line":4}},{"line":212,"address":[54249771],"length":1,"stats":{"Line":4}},{"line":213,"address":[108506076],"length":1,"stats":{"Line":0}},{"line":217,"address":[54253578,54253586,54252144],"length":1,"stats":{"Line":2}},{"line":218,"address":[54070358],"length":1,"stats":{"Line":2}},{"line":219,"address":[55407866],"length":1,"stats":{"Line":2}},{"line":221,"address":[53171636],"length":1,"stats":{"Line":2}},{"line":222,"address":[54252406],"length":1,"stats":{"Line":2}},{"line":223,"address":[55408107,55409232],"length":1,"stats":{"Line":2}},{"line":224,"address":[54070830],"length":1,"stats":{"Line":2}},{"line":226,"address":[4238408],"length":1,"stats":{"Line":2}},{"line":227,"address":[55408460,55408325,55408391],"length":1,"stats":{"Line":6}},{"line":228,"address":[4238423],"length":1,"stats":{"Line":2}},{"line":229,"address":[107683326,107682954,107683216,107683283,107682912],"length":1,"stats":{"Line":2}},{"line":230,"address":[53172525,53172544],"length":1,"stats":{"Line":4}},{"line":231,"address":[108354211],"length":1,"stats":{"Line":0}},{"line":233,"address":[55408771,55408759],"length":1,"stats":{"Line":4}},{"line":236,"address":[55408816,55409208,55408418],"length":1,"stats":{"Line":4}},{"line":238,"address":[54253312],"length":1,"stats":{"Line":2}},{"line":241,"address":[54070298,54069136,54070290],"length":1,"stats":{"Line":2}},{"line":242,"address":[54251014],"length":1,"stats":{"Line":2}},{"line":243,"address":[108506272],"length":1,"stats":{"Line":2}},{"line":245,"address":[54251060],"length":1,"stats":{"Line":2}},{"line":247,"address":[55406886,55406949,55407271,55406973],"length":1,"stats":{"Line":8}},{"line":248,"address":[54069494,54070296,54069544],"length":1,"stats":{"Line":4}},{"line":250,"address":[109929096],"length":1,"stats":{"Line":2}},{"line":253,"address":[108506595,108506886,108506902],"length":1,"stats":{"Line":4}},{"line":255,"address":[4239335],"length":1,"stats":{"Line":2}},{"line":260,"address":[110015662],"length":1,"stats":{"Line":16}},{"line":261,"address":[4239724,4239347,4239736],"length":1,"stats":{"Line":27}},{"line":262,"address":[53217233],"length":1,"stats":{"Line":7}},{"line":263,"address":[55452309],"length":1,"stats":{"Line":22}},{"line":264,"address":[4239391],"length":1,"stats":{"Line":6}},{"line":265,"address":[53217248],"length":1,"stats":{"Line":20}},{"line":266,"address":[53217319],"length":1,"stats":{"Line":3}},{"line":267,"address":[109825975],"length":1,"stats":{"Line":16}},{"line":268,"address":[54116130],"length":1,"stats":{"Line":5}},{"line":269,"address":[54296790],"length":1,"stats":{"Line":18}},{"line":270,"address":[54296861],"length":1,"stats":{"Line":4}},{"line":271,"address":[54116145],"length":1,"stats":{"Line":16}},{"line":272,"address":[110016225],"length":1,"stats":{"Line":3}},{"line":273,"address":[55452524],"length":1,"stats":{"Line":16}},{"line":274,"address":[54116259],"length":1,"stats":{"Line":3}},{"line":275,"address":[53217463],"length":1,"stats":{"Line":16}},{"line":276,"address":[54116302],"length":1,"stats":{"Line":3}},{"line":277,"address":[110827539],"length":1,"stats":{"Line":16}},{"line":278,"address":[53217577],"length":1,"stats":{"Line":6}},{"line":279,"address":[53217549],"length":1,"stats":{"Line":16}},{"line":280,"address":[53217620],"length":1,"stats":{"Line":4}},{"line":281,"address":[54116360],"length":1,"stats":{"Line":12}},{"line":282,"address":[54297119],"length":1,"stats":{"Line":0}},{"line":283,"address":[4239209],"length":1,"stats":{"Line":12}},{"line":284,"address":[53217711],"length":1,"stats":{"Line":0}},{"line":285,"address":[54297139],"length":1,"stats":{"Line":12}},{"line":286,"address":[54297215],"length":1,"stats":{"Line":0}},{"line":287,"address":[53217731],"length":1,"stats":{"Line":12}},{"line":288,"address":[54116575],"length":1,"stats":{"Line":0}},{"line":289,"address":[54297235],"length":1,"stats":{"Line":12}},{"line":290,"address":[4239422,4239498,4239560],"length":1,"stats":{"Line":0}},{"line":291,"address":[54116592],"length":1,"stats":{"Line":12}},{"line":292,"address":[54297353],"length":1,"stats":{"Line":1}},{"line":293,"address":[53217869],"length":1,"stats":{"Line":12}},{"line":294,"address":[54297387],"length":1,"stats":{"Line":2}},{"line":296,"address":[110827375],"length":1,"stats":{"Line":10}},{"line":300,"address":[109824512],"length":1,"stats":{"Line":7}},{"line":301,"address":[54232870],"length":1,"stats":{"Line":7}},{"line":302,"address":[54232906],"length":1,"stats":{"Line":7}},{"line":304,"address":[55388564],"length":1,"stats":{"Line":7}},{"line":305,"address":[110014918,110015129],"length":1,"stats":{"Line":8}},{"line":306,"address":[53152152,53153568],"length":1,"stats":{"Line":10}},{"line":308,"address":[54051325,54051343,54051259],"length":1,"stats":{"Line":24}},{"line":309,"address":[55389280],"length":1,"stats":{"Line":5}},{"line":310,"address":[54051542,54051940,54052294],"length":1,"stats":{"Line":13}},{"line":312,"address":[55389899,55389533,55390214],"length":1,"stats":{"Line":6}},{"line":314,"address":[53152845,53153177,53152815],"length":1,"stats":{"Line":10}},{"line":317,"address":[54233613],"length":1,"stats":{"Line":6}},{"line":320,"address":[4244464],"length":1,"stats":{"Line":9}},{"line":321,"address":[4244487],"length":1,"stats":{"Line":6}},{"line":322,"address":[4244619],"length":1,"stats":{"Line":6}},{"line":323,"address":[110826273,110826004],"length":1,"stats":{"Line":6}},{"line":328,"address":[110015115],"length":1,"stats":{"Line":6}},{"line":329,"address":[54062726],"length":1,"stats":{"Line":6}},{"line":330,"address":[55400394],"length":1,"stats":{"Line":6}},{"line":332,"address":[54244756],"length":1,"stats":{"Line":6}},{"line":333,"address":[54063001],"length":1,"stats":{"Line":6}},{"line":334,"address":[4236406],"length":1,"stats":{"Line":6}},{"line":336,"address":[54063417],"length":1,"stats":{"Line":6}},{"line":337,"address":[55401008],"length":1,"stats":{"Line":6}},{"line":338,"address":[4236413],"length":1,"stats":{"Line":0}},{"line":343,"address":[55392346,55392336,55390912],"length":1,"stats":{"Line":3}},{"line":344,"address":[54053046],"length":1,"stats":{"Line":3}},{"line":345,"address":[55390986],"length":1,"stats":{"Line":3}},{"line":347,"address":[53154324],"length":1,"stats":{"Line":3}},{"line":348,"address":[54235526,54235618,54236696],"length":1,"stats":{"Line":6}},{"line":349,"address":[54236694,54235760],"length":1,"stats":{"Line":3}},{"line":350,"address":[54053807],"length":1,"stats":{"Line":3}},{"line":351,"address":[54236105],"length":1,"stats":{"Line":3}},{"line":353,"address":[53155500],"length":1,"stats":{"Line":3}},{"line":354,"address":[53155435],"length":1,"stats":{"Line":3}},{"line":355,"address":[4236568],"length":1,"stats":{"Line":3}},{"line":357,"address":[4236591],"length":1,"stats":{"Line":0}},{"line":361,"address":[53166496,53167167,53167173],"length":1,"stats":{"Line":5}},{"line":362,"address":[54065302],"length":1,"stats":{"Line":5}},{"line":363,"address":[54247242],"length":1,"stats":{"Line":5}},{"line":365,"address":[4241325],"length":1,"stats":{"Line":7}},{"line":366,"address":[53166619],"length":1,"stats":{"Line":2}},{"line":368,"address":[55402964],"length":1,"stats":{"Line":5}},{"line":371,"address":[54247558,54247485],"length":1,"stats":{"Line":12}},{"line":373,"address":[54247684],"length":1,"stats":{"Line":7}},{"line":376,"address":[4241504],"length":1,"stats":{"Line":6}},{"line":377,"address":[54242918],"length":1,"stats":{"Line":4}},{"line":378,"address":[54242954],"length":1,"stats":{"Line":6}},{"line":380,"address":[54242964],"length":1,"stats":{"Line":4}},{"line":381,"address":[54243199,54243259],"length":1,"stats":{"Line":11}},{"line":383,"address":[4241824,4241544],"length":1,"stats":{"Line":7}},{"line":386,"address":[54059136],"length":1,"stats":{"Line":3}},{"line":387,"address":[4241871],"length":1,"stats":{"Line":3}},{"line":388,"address":[55396921],"length":1,"stats":{"Line":3}},{"line":389,"address":[4242187,4242070,4242258],"length":1,"stats":{"Line":3}},{"line":390,"address":[53160566],"length":1,"stats":{"Line":3}},{"line":393,"address":[53170096],"length":1,"stats":{"Line":3}},{"line":394,"address":[54068901],"length":1,"stats":{"Line":3}},{"line":395,"address":[53170169],"length":1,"stats":{"Line":3}},{"line":396,"address":[54068947],"length":1,"stats":{"Line":3}},{"line":397,"address":[55406548],"length":1,"stats":{"Line":3}},{"line":400,"address":[54253600,54255044,54255054],"length":1,"stats":{"Line":3}},{"line":401,"address":[55409286],"length":1,"stats":{"Line":3}},{"line":402,"address":[4242409],"length":1,"stats":{"Line":3}},{"line":404,"address":[4242320],"length":1,"stats":{"Line":3}},{"line":405,"address":[53173134],"length":1,"stats":{"Line":3}},{"line":407,"address":[53173401],"length":1,"stats":{"Line":3}},{"line":408,"address":[55409652,55410700],"length":1,"stats":{"Line":3}},{"line":410,"address":[55410698,55409837],"length":1,"stats":{"Line":3}},{"line":411,"address":[54072664],"length":1,"stats":{"Line":3}},{"line":412,"address":[53173960],"length":1,"stats":{"Line":3}},{"line":414,"address":[55410532],"length":1,"stats":{"Line":3}},{"line":415,"address":[4242338],"length":1,"stats":{"Line":3}},{"line":416,"address":[53174314],"length":1,"stats":{"Line":3}},{"line":418,"address":[4236672],"length":1,"stats":{"Line":0}},{"line":422,"address":[54241472,54242847,54242855],"length":1,"stats":{"Line":6}},{"line":423,"address":[55397158],"length":1,"stats":{"Line":7}},{"line":424,"address":[55397194],"length":1,"stats":{"Line":7}},{"line":426,"address":[54241556],"length":1,"stats":{"Line":6}},{"line":427,"address":[55397443],"length":1,"stats":{"Line":7}},{"line":428,"address":[54241844,54242853],"length":1,"stats":{"Line":6}},{"line":429,"address":[54059979],"length":1,"stats":{"Line":7}},{"line":431,"address":[4236960],"length":1,"stats":{"Line":6}},{"line":432,"address":[4236970],"length":1,"stats":{"Line":20}},{"line":433,"address":[55397856,55398084],"length":1,"stats":{"Line":6}},{"line":434,"address":[55398072],"length":1,"stats":{"Line":5}},{"line":437,"address":[54060105,54060430,54060812],"length":1,"stats":{"Line":8}},{"line":439,"address":[53161815],"length":1,"stats":{"Line":5}},{"line":442,"address":[54245536,54246342,54246348],"length":1,"stats":{"Line":4}},{"line":443,"address":[4236938,4237006],"length":1,"stats":{"Line":4}},{"line":444,"address":[53164890],"length":1,"stats":{"Line":4}},{"line":446,"address":[54063668],"length":1,"stats":{"Line":4}},{"line":449,"address":[55401960,55401495,55401578,55401554],"length":1,"stats":{"Line":11}},{"line":450,"address":[54064168,54063999],"length":1,"stats":{"Line":4}},{"line":452,"address":[55401560],"length":1,"stats":{"Line":2}},{"line":455,"address":[55401652],"length":1,"stats":{"Line":4}},{"line":456,"address":[55401603],"length":1,"stats":{"Line":2}},{"line":457,"address":[55401626],"length":1,"stats":{"Line":3}},{"line":462,"address":[4237031],"length":1,"stats":{"Line":0}},{"line":463,"address":[55392418],"length":1,"stats":{"Line":0}},{"line":464,"address":[55392454],"length":1,"stats":{"Line":0}},{"line":466,"address":[55392464],"length":1,"stats":{"Line":0}},{"line":467,"address":[54237110,54237050],"length":1,"stats":{"Line":0}},{"line":469,"address":[54055055],"length":1,"stats":{"Line":0}},{"line":471,"address":[53156260],"length":1,"stats":{"Line":0}},{"line":476,"address":[54240528,54241181,54241187],"length":1,"stats":{"Line":1}},{"line":477,"address":[55396214],"length":1,"stats":{"Line":1}},{"line":478,"address":[53159754],"length":1,"stats":{"Line":1}},{"line":480,"address":[53159764],"length":1,"stats":{"Line":1}},{"line":481,"address":[53160049,53160001],"length":1,"stats":{"Line":2}},{"line":483,"address":[54058970],"length":1,"stats":{"Line":1}},{"line":486,"address":[54295350,54294241,54292640],"length":1,"stats":{"Line":7}},{"line":487,"address":[4238059],"length":1,"stats":{"Line":7}},{"line":488,"address":[55448362],"length":1,"stats":{"Line":7}},{"line":490,"address":[55448496],"length":1,"stats":{"Line":7}},{"line":491,"address":[54293035,54293126,54295345],"length":1,"stats":{"Line":8}},{"line":492,"address":[53213724],"length":1,"stats":{"Line":5}},{"line":495,"address":[55450970,55448920],"length":1,"stats":{"Line":7}},{"line":496,"address":[55448984,55450783,55450988],"length":1,"stats":{"Line":4}},{"line":497,"address":[4238138],"length":1,"stats":{"Line":18}},{"line":498,"address":[55450570,55450762,55449040],"length":1,"stats":{"Line":12}},{"line":499,"address":[54114169,54112593,54112638],"length":1,"stats":{"Line":4}},{"line":500,"address":[54112680,54113958,54114174],"length":1,"stats":{"Line":0}},{"line":501,"address":[4240878],"length":1,"stats":{"Line":4}},{"line":502,"address":[54293504,54294688,54294496],"length":1,"stats":{"Line":0}},{"line":503,"address":[4241026],"length":1,"stats":{"Line":5}},{"line":504,"address":[54112789,54113732,54113516],"length":1,"stats":{"Line":0}},{"line":506,"address":[4241227,4241093],"length":1,"stats":{"Line":8}},{"line":508,"address":[54293848],"length":1,"stats":{"Line":3}},{"line":513,"address":[55449741],"length":1,"stats":{"Line":9}},{"line":514,"address":[54113251],"length":1,"stats":{"Line":8}},{"line":515,"address":[55449715],"length":1,"stats":{"Line":5}},{"line":516,"address":[4234469],"length":1,"stats":{"Line":0}},{"line":520,"address":[4234574],"length":1,"stats":{"Line":7}},{"line":521,"address":[55432582],"length":1,"stats":{"Line":7}},{"line":522,"address":[54277203,54277181,54276960],"length":1,"stats":{"Line":9}},{"line":523,"address":[53197174],"length":1,"stats":{"Line":4}},{"line":524,"address":[55432735],"length":1,"stats":{"Line":4}},{"line":525,"address":[54277105],"length":1,"stats":{"Line":4}},{"line":526,"address":[55433422,55434403,55433605],"length":1,"stats":{"Line":9}},{"line":527,"address":[53198080],"length":1,"stats":{"Line":2}},{"line":528,"address":[54278652],"length":1,"stats":{"Line":2}},{"line":529,"address":[53198495,53198631],"length":1,"stats":{"Line":4}},{"line":530,"address":[4234606],"length":1,"stats":{"Line":2}},{"line":531,"address":[55433942],"length":1,"stats":{"Line":2}},{"line":533,"address":[54097407],"length":1,"stats":{"Line":2}},{"line":536,"address":[54096689],"length":1,"stats":{"Line":3}},{"line":539,"address":[53197220],"length":1,"stats":{"Line":2}},{"line":540,"address":[4234125,4234160,4234168],"length":1,"stats":{"Line":2}},{"line":541,"address":[4234148],"length":1,"stats":{"Line":2}},{"line":542,"address":[55434474],"length":1,"stats":{"Line":2}},{"line":544,"address":[4244752,4244702],"length":1,"stats":{"Line":2}},{"line":545,"address":[54278969],"length":1,"stats":{"Line":2}},{"line":546,"address":[55434674],"length":1,"stats":{"Line":2}},{"line":547,"address":[55434730],"length":1,"stats":{"Line":2}},{"line":550,"address":[53197144],"length":1,"stats":{"Line":2}},{"line":551,"address":[54277476],"length":1,"stats":{"Line":2}},{"line":554,"address":[53197129],"length":1,"stats":{"Line":0}},{"line":555,"address":[54096191],"length":1,"stats":{"Line":0}},{"line":558,"address":[53197159],"length":1,"stats":{"Line":2}},{"line":559,"address":[55433279],"length":1,"stats":{"Line":2}},{"line":562,"address":[54096135],"length":1,"stats":{"Line":4}},{"line":563,"address":[55435321],"length":1,"stats":{"Line":4}},{"line":565,"address":[54098208,54096076],"length":1,"stats":{"Line":4}},{"line":566,"address":[53199490],"length":1,"stats":{"Line":0}},{"line":567,"address":[54279592],"length":1,"stats":{"Line":0}},{"line":569,"address":[54098214],"length":1,"stats":{"Line":2}},{"line":570,"address":[55434969],"length":1,"stats":{"Line":2}},{"line":571,"address":[54279363],"length":1,"stats":{"Line":2}},{"line":572,"address":[55435071],"length":1,"stats":{"Line":2}},{"line":574,"address":[54279854],"length":1,"stats":{"Line":0}},{"line":575,"address":[4235203,4234887],"length":1,"stats":{"Line":0}},{"line":576,"address":[54098756],"length":1,"stats":{"Line":0}},{"line":581,"address":[4235350,4235452,4235020],"length":1,"stats":{"Line":7}},{"line":582,"address":[54090390],"length":1,"stats":{"Line":4}},{"line":583,"address":[53191658],"length":1,"stats":{"Line":7}},{"line":584,"address":[55427466],"length":1,"stats":{"Line":4}},{"line":585,"address":[55427647],"length":1,"stats":{"Line":13}},{"line":588,"address":[54065234,54065240,54064432],"length":1,"stats":{"Line":7}},{"line":589,"address":[54064462],"length":1,"stats":{"Line":7}},{"line":590,"address":[55402061,55402105],"length":1,"stats":{"Line":14}},{"line":592,"address":[54064627,54064536],"length":1,"stats":{"Line":18}},{"line":593,"address":[54246574,54246877],"length":1,"stats":{"Line":11}},{"line":594,"address":[53166181],"length":1,"stats":{"Line":10}},{"line":597,"address":[54246910,54247136,54246513],"length":1,"stats":{"Line":33}},{"line":598,"address":[55402689],"length":1,"stats":{"Line":16}},{"line":601,"address":[54073952,54074646,54074652],"length":1,"stats":{"Line":10}},{"line":602,"address":[4235948],"length":1,"stats":{"Line":10}},{"line":603,"address":[53175450,53175532],"length":1,"stats":{"Line":12}},{"line":604,"address":[54256058],"length":1,"stats":{"Line":6}},{"line":605,"address":[55411858],"length":1,"stats":{"Line":6}},{"line":610,"address":[4235977],"length":1,"stats":{"Line":8}},{"line":611,"address":[55385249],"length":1,"stats":{"Line":8}},{"line":614,"address":[54225438,54223328,54227782],"length":1,"stats":{"Line":10}},{"line":615,"address":[55379015],"length":1,"stats":{"Line":12}},{"line":617,"address":[55379525,55379376],"length":1,"stats":{"Line":86}},{"line":618,"address":[55379568,55381431],"length":1,"stats":{"Line":8}},{"line":619,"address":[54225823,54227573],"length":1,"stats":{"Line":4}},{"line":621,"address":[53144848],"length":1,"stats":{"Line":4}},{"line":622,"address":[54043733],"length":1,"stats":{"Line":4}},{"line":623,"address":[55382470],"length":1,"stats":{"Line":4}},{"line":624,"address":[53145005],"length":1,"stats":{"Line":4}},{"line":625,"address":[54226303],"length":1,"stats":{"Line":4}},{"line":629,"address":[55382046],"length":1,"stats":{"Line":3}},{"line":632,"address":[53145800],"length":1,"stats":{"Line":3}},{"line":633,"address":[54043968],"length":1,"stats":{"Line":3}},{"line":634,"address":[55382118],"length":1,"stats":{"Line":3}},{"line":635,"address":[55382150],"length":1,"stats":{"Line":3}},{"line":639,"address":[54226597],"length":1,"stats":{"Line":3}},{"line":640,"address":[54044786],"length":1,"stats":{"Line":3}},{"line":641,"address":[54226645],"length":1,"stats":{"Line":3}},{"line":642,"address":[54226653],"length":1,"stats":{"Line":3}},{"line":643,"address":[55382309],"length":1,"stats":{"Line":3}},{"line":648,"address":[54044962],"length":1,"stats":{"Line":2}},{"line":649,"address":[53144931],"length":1,"stats":{"Line":2}},{"line":657,"address":[55379601,55379641,55379539],"length":1,"stats":{"Line":85}},{"line":658,"address":[54041443],"length":1,"stats":{"Line":2}},{"line":659,"address":[54223967,54223999,54224039],"length":1,"stats":{"Line":86}},{"line":660,"address":[55379679],"length":1,"stats":{"Line":2}},{"line":661,"address":[54041543,54041471,54041503],"length":1,"stats":{"Line":87}},{"line":662,"address":[54224077],"length":1,"stats":{"Line":2}},{"line":663,"address":[53142749,53142781,53142795],"length":1,"stats":{"Line":144}},{"line":664,"address":[53142797],"length":1,"stats":{"Line":2}},{"line":666,"address":[53142787],"length":1,"stats":{"Line":28}},{"line":669,"address":[55379763],"length":1,"stats":{"Line":28}},{"line":670,"address":[55380010,55379816],"length":1,"stats":{"Line":4}},{"line":671,"address":[54224402,54225651],"length":1,"stats":{"Line":2}},{"line":673,"address":[54042091],"length":1,"stats":{"Line":2}},{"line":674,"address":[53143375],"length":1,"stats":{"Line":2}},{"line":675,"address":[55380932],"length":1,"stats":{"Line":2}},{"line":676,"address":[53143423],"length":1,"stats":{"Line":2}},{"line":677,"address":[53143889],"length":1,"stats":{"Line":2}},{"line":678,"address":[54224840,54225015],"length":1,"stats":{"Line":4}},{"line":680,"address":[54225023],"length":1,"stats":{"Line":2}},{"line":687,"address":[53144235],"length":1,"stats":{"Line":0}},{"line":688,"address":[54042225],"length":1,"stats":{"Line":0}},{"line":695,"address":[54224188],"length":1,"stats":{"Line":57}},{"line":699,"address":[55452220,55451024,55452165],"length":1,"stats":{"Line":19}},{"line":700,"address":[54295406],"length":1,"stats":{"Line":16}},{"line":702,"address":[55451254,55452160,55451317],"length":1,"stats":{"Line":88}},{"line":703,"address":[54295760,54295805],"length":1,"stats":{"Line":4}},{"line":704,"address":[54115127],"length":1,"stats":{"Line":2}},{"line":705,"address":[53216949],"length":1,"stats":{"Line":2}},{"line":706,"address":[55451910,55451781],"length":1,"stats":{"Line":4}},{"line":707,"address":[53216796],"length":1,"stats":{"Line":2}},{"line":712,"address":[54114957],"length":1,"stats":{"Line":58}},{"line":716,"address":[54110087,54110224,54107984],"length":1,"stats":{"Line":24}},{"line":718,"address":[54288902],"length":1,"stats":{"Line":17}},{"line":721,"address":[55622908,55622896],"length":1,"stats":{"Line":9}},{"line":722,"address":[54288990],"length":1,"stats":{"Line":3}},{"line":725,"address":[54289116,54289039],"length":1,"stats":{"Line":3}},{"line":728,"address":[54289399,54289307,54291008],"length":1,"stats":{"Line":6}},{"line":731,"address":[54290994,54289541],"length":1,"stats":{"Line":3}},{"line":734,"address":[53210206,53210282,53211361],"length":1,"stats":{"Line":6}},{"line":737,"address":[53211347,53210448],"length":1,"stats":{"Line":3}},{"line":739,"address":[54109969],"length":1,"stats":{"Line":3}},{"line":740,"address":[53210880,53210744],"length":1,"stats":{"Line":6}},{"line":741,"address":[55446144,55446281],"length":1,"stats":{"Line":6}},{"line":742,"address":[53211041],"length":1,"stats":{"Line":3}},{"line":747,"address":[54288952],"length":1,"stats":{"Line":24}},{"line":750,"address":[53182978,53181664,53182918],"length":1,"stats":{"Line":19}},{"line":751,"address":[54080462],"length":1,"stats":{"Line":26}},{"line":753,"address":[54080727,54081681,54080664],"length":1,"stats":{"Line":81}},{"line":754,"address":[54080943],"length":1,"stats":{"Line":3}},{"line":756,"address":[54639904,54639916],"length":1,"stats":{"Line":9}},{"line":757,"address":[55418066],"length":1,"stats":{"Line":3}},{"line":758,"address":[53182215],"length":1,"stats":{"Line":3}},{"line":759,"address":[53182808],"length":1,"stats":{"Line":3}},{"line":760,"address":[53182647,53182511],"length":1,"stats":{"Line":6}},{"line":762,"address":[55418601],"length":1,"stats":{"Line":3}},{"line":767,"address":[54080733],"length":1,"stats":{"Line":24}},{"line":770,"address":[54083030,54083090,54081776],"length":1,"stats":{"Line":19}},{"line":771,"address":[55418974],"length":1,"stats":{"Line":26}},{"line":773,"address":[54082071,54082008,54083025],"length":1,"stats":{"Line":79}},{"line":774,"address":[54082287],"length":1,"stats":{"Line":3}},{"line":776,"address":[55122864,55122876],"length":1,"stats":{"Line":9}},{"line":777,"address":[55419378],"length":1,"stats":{"Line":3}},{"line":778,"address":[55419485],"length":1,"stats":{"Line":3}},{"line":779,"address":[55420058],"length":1,"stats":{"Line":3}},{"line":780,"address":[54082759,54082623],"length":1,"stats":{"Line":6}},{"line":782,"address":[53183999],"length":1,"stats":{"Line":3}},{"line":787,"address":[54263595],"length":1,"stats":{"Line":52}},{"line":790,"address":[53212816,53212876,53211488],"length":1,"stats":{"Line":19}},{"line":791,"address":[55446750],"length":1,"stats":{"Line":29}},{"line":793,"address":[55448013],"length":1,"stats":{"Line":3}},{"line":794,"address":[53211783,53211920,53211720,53211820],"length":1,"stats":{"Line":91}},{"line":795,"address":[54291394],"length":1,"stats":{"Line":3}},{"line":796,"address":[54291408,54291376],"length":1,"stats":{"Line":89}},{"line":797,"address":[54110680],"length":1,"stats":{"Line":3}},{"line":802,"address":[53212052],"length":1,"stats":{"Line":3}},{"line":804,"address":[54291547],"length":1,"stats":{"Line":9}},{"line":805,"address":[54110749],"length":1,"stats":{"Line":3}},{"line":806,"address":[53212092],"length":1,"stats":{"Line":3}},{"line":807,"address":[54292260],"length":1,"stats":{"Line":3}},{"line":808,"address":[54292089,54291954],"length":1,"stats":{"Line":6}},{"line":809,"address":[54111303],"length":1,"stats":{"Line":3}},{"line":810,"address":[54111314],"length":1,"stats":{"Line":3}},{"line":815,"address":[54110600],"length":1,"stats":{"Line":24}},{"line":818,"address":[54229502,54229557,54228112],"length":1,"stats":{"Line":22}},{"line":819,"address":[54045694],"length":1,"stats":{"Line":29}},{"line":821,"address":[54229497],"length":1,"stats":{"Line":12}},{"line":822,"address":[54045996,54045896,54045959],"length":1,"stats":{"Line":73}},{"line":823,"address":[55384082],"length":1,"stats":{"Line":4}},{"line":824,"address":[54045970,54046042,54046005],"length":1,"stats":{"Line":83}},{"line":825,"address":[55384128],"length":1,"stats":{"Line":5}},{"line":826,"address":[53147420,53147248,53147283,53147320],"length":1,"stats":{"Line":90}},{"line":827,"address":[55384174],"length":1,"stats":{"Line":8}},{"line":828,"address":[53147294,53147326],"length":1,"stats":{"Line":81}},{"line":829,"address":[54046180],"length":1,"stats":{"Line":3}},{"line":834,"address":[54228758],"length":1,"stats":{"Line":8}},{"line":836,"address":[53147457],"length":1,"stats":{"Line":26}},{"line":837,"address":[53147481],"length":1,"stats":{"Line":10}},{"line":838,"address":[54046360],"length":1,"stats":{"Line":10}},{"line":839,"address":[54229392],"length":1,"stats":{"Line":10}},{"line":840,"address":[54229086,54229221],"length":1,"stats":{"Line":20}},{"line":841,"address":[55384877],"length":1,"stats":{"Line":10}},{"line":842,"address":[55384888],"length":1,"stats":{"Line":12}},{"line":847,"address":[55384194],"length":1,"stats":{"Line":47}},{"line":850,"address":[53190160,53191488,53191548],"length":1,"stats":{"Line":22}},{"line":851,"address":[55425902],"length":1,"stats":{"Line":29}},{"line":853,"address":[54271517],"length":1,"stats":{"Line":9}},{"line":854,"address":[54089260,54089160,54089223,54089360],"length":1,"stats":{"Line":80}},{"line":855,"address":[55426194],"length":1,"stats":{"Line":5}},{"line":856,"address":[54270528,54270560],"length":1,"stats":{"Line":67}},{"line":857,"address":[54089352],"length":1,"stats":{"Line":5}},{"line":862,"address":[54270778],"length":1,"stats":{"Line":6}},{"line":864,"address":[53190629],"length":1,"stats":{"Line":17}},{"line":865,"address":[54089421],"length":1,"stats":{"Line":6}},{"line":866,"address":[54089532],"length":1,"stats":{"Line":7}},{"line":867,"address":[55427060],"length":1,"stats":{"Line":9}},{"line":868,"address":[55426754,55426889],"length":1,"stats":{"Line":16}},{"line":869,"address":[54271249],"length":1,"stats":{"Line":9}},{"line":870,"address":[53191218],"length":1,"stats":{"Line":9}},{"line":875,"address":[54089272],"length":1,"stats":{"Line":34}},{"line":878,"address":[55432352,55431008,55432407],"length":1,"stats":{"Line":28}},{"line":879,"address":[55431038],"length":1,"stats":{"Line":31}},{"line":881,"address":[54095545],"length":1,"stats":{"Line":7}},{"line":882,"address":[53195703,53195740,53195640],"length":1,"stats":{"Line":47}},{"line":883,"address":[55431330],"length":1,"stats":{"Line":4}},{"line":884,"address":[54275736,54275664,54275699,54275836],"length":1,"stats":{"Line":65}},{"line":885,"address":[54275728],"length":1,"stats":{"Line":4}},{"line":886,"address":[54275742,54275710],"length":1,"stats":{"Line":59}},{"line":887,"address":[53195878],"length":1,"stats":{"Line":4}},{"line":892,"address":[53196018],"length":1,"stats":{"Line":4}},{"line":894,"address":[55431529],"length":1,"stats":{"Line":12}},{"line":895,"address":[55431541],"length":1,"stats":{"Line":4}},{"line":896,"address":[55431648],"length":1,"stats":{"Line":5}},{"line":897,"address":[53196672],"length":1,"stats":{"Line":7}},{"line":898,"address":[54095122,54095261],"length":1,"stats":{"Line":12}},{"line":899,"address":[54276431],"length":1,"stats":{"Line":7}},{"line":900,"address":[53196512],"length":1,"stats":{"Line":7}},{"line":905,"address":[54094566],"length":1,"stats":{"Line":35}},{"line":908,"address":[53194014,53192880,53193982],"length":1,"stats":{"Line":31}},{"line":909,"address":[55428550],"length":1,"stats":{"Line":31}},{"line":912,"address":[55122960,55122972],"length":1,"stats":{"Line":9}},{"line":913,"address":[55428648],"length":1,"stats":{"Line":4}},{"line":914,"address":[54093257,54091835],"length":1,"stats":{"Line":4}},{"line":915,"address":[54274791],"length":1,"stats":{"Line":4}},{"line":917,"address":[54274638],"length":1,"stats":{"Line":4}},{"line":925,"address":[55428595],"length":1,"stats":{"Line":35}},{"line":927,"address":[54091942],"length":1,"stats":{"Line":4}},{"line":928,"address":[54091958],"length":1,"stats":{"Line":3}},{"line":931,"address":[53193208],"length":1,"stats":{"Line":9}},{"line":932,"address":[54273207],"length":1,"stats":{"Line":3}},{"line":933,"address":[54092048,54092788],"length":1,"stats":{"Line":3}},{"line":934,"address":[53194370],"length":1,"stats":{"Line":3}},{"line":936,"address":[54092981],"length":1,"stats":{"Line":3}},{"line":943,"address":[54273125],"length":1,"stats":{"Line":34}},{"line":946,"address":[55955120,55955132],"length":1,"stats":{"Line":3}},{"line":947,"address":[55429029],"length":1,"stats":{"Line":1}},{"line":948,"address":[53193535,53193457],"length":1,"stats":{"Line":1}},{"line":949,"address":[54092653],"length":1,"stats":{"Line":1}},{"line":951,"address":[54092496],"length":1,"stats":{"Line":1}},{"line":956,"address":[53193362],"length":1,"stats":{"Line":35}},{"line":960,"address":[53181440],"length":1,"stats":{"Line":4}},{"line":961,"address":[55417438],"length":1,"stats":{"Line":4}},{"line":962,"address":[54261877],"length":1,"stats":{"Line":0}},{"line":964,"address":[54261948,54261854,54261894],"length":1,"stats":{"Line":10}},{"line":965,"address":[53181583,53181630],"length":1,"stats":{"Line":10}},{"line":966,"address":[54261911],"length":1,"stats":{"Line":5}},{"line":985,"address":[54084987,54088744,54083168],"length":1,"stats":{"Line":34}},{"line":986,"address":[55420343],"length":1,"stats":{"Line":35}},{"line":989,"address":[53189937,53184650,53184719],"length":1,"stats":{"Line":21}},{"line":990,"address":[55420664,55425676,55425478],"length":1,"stats":{"Line":10}},{"line":991,"address":[54083501,54083635,54088478],"length":1,"stats":{"Line":29}},{"line":992,"address":[55424868,55425457,55420812],"length":1,"stats":{"Line":6}},{"line":993,"address":[54269424,54269495],"length":1,"stats":{"Line":6}},{"line":994,"address":[54088354],"length":1,"stats":{"Line":5}},{"line":995,"address":[54269526],"length":1,"stats":{"Line":4}},{"line":996,"address":[54269632],"length":1,"stats":{"Line":5}},{"line":999,"address":[54265135,54265201,54269441],"length":1,"stats":{"Line":29}},{"line":1000,"address":[54083881,54083818],"length":1,"stats":{"Line":7}},{"line":1003,"address":[55422088,55424829,55421053],"length":1,"stats":{"Line":10}},{"line":1005,"address":[53185216],"length":1,"stats":{"Line":2}},{"line":1007,"address":[54086609,54086543],"length":1,"stats":{"Line":4}},{"line":1009,"address":[53187829],"length":1,"stats":{"Line":2}},{"line":1011,"address":[55423678,55423953],"length":1,"stats":{"Line":2}},{"line":1015,"address":[55423935,55424002,55424020],"length":1,"stats":{"Line":6}},{"line":1016,"address":[55424030,55424139,55424383,55424098],"length":1,"stats":{"Line":6}},{"line":1017,"address":[53188337],"length":1,"stats":{"Line":0}},{"line":1019,"address":[54087098,54087378,54087119],"length":1,"stats":{"Line":4}},{"line":1022,"address":[54086986],"length":1,"stats":{"Line":2}},{"line":1025,"address":[54268408,54268816],"length":1,"stats":{"Line":4}},{"line":1026,"address":[54087735],"length":1,"stats":{"Line":2}},{"line":1027,"address":[54268948],"length":1,"stats":{"Line":2}},{"line":1029,"address":[54087719],"length":1,"stats":{"Line":2}},{"line":1030,"address":[54269069],"length":1,"stats":{"Line":2}},{"line":1035,"address":[54265455,54265496,54267904],"length":1,"stats":{"Line":8}},{"line":1037,"address":[54086455,54084294,54084363],"length":1,"stats":{"Line":12}},{"line":1039,"address":[55422170,55421546,55422126],"length":1,"stats":{"Line":8}},{"line":1040,"address":[54266531,54266492],"length":1,"stats":{"Line":8}},{"line":1042,"address":[55422158],"length":1,"stats":{"Line":2}},{"line":1044,"address":[53186618,53186331],"length":1,"stats":{"Line":2}},{"line":1048,"address":[55422458,55422543,55422525],"length":1,"stats":{"Line":10}},{"line":1049,"address":[53186767,53186699,53186808,53187064],"length":1,"stats":{"Line":8}},{"line":1050,"address":[53186796],"length":1,"stats":{"Line":0}},{"line":1052,"address":[53186810,53187069,53186789],"length":1,"stats":{"Line":6}},{"line":1055,"address":[54266883],"length":1,"stats":{"Line":4}},{"line":1058,"address":[55422987,55422579],"length":1,"stats":{"Line":8}},{"line":1059,"address":[53187579],"length":1,"stats":{"Line":4}},{"line":1060,"address":[54267471],"length":1,"stats":{"Line":4}},{"line":1061,"address":[53187402],"length":1,"stats":{"Line":4}},{"line":1062,"address":[54267729],"length":1,"stats":{"Line":4}},{"line":1063,"address":[54267737],"length":1,"stats":{"Line":4}},{"line":1068,"address":[54265938,54265855,54266451],"length":1,"stats":{"Line":8}},{"line":1069,"address":[54266340],"length":1,"stats":{"Line":4}},{"line":1070,"address":[53185832],"length":1,"stats":{"Line":4}},{"line":1071,"address":[53185947],"length":1,"stats":{"Line":4}},{"line":1081,"address":[55420855],"length":1,"stats":{"Line":14}},{"line":1084,"address":[54048797,54047472,54049276],"length":1,"stats":{"Line":5}},{"line":1085,"address":[54047515,54047617],"length":1,"stats":{"Line":12}},{"line":1086,"address":[54230053],"length":1,"stats":{"Line":5}},{"line":1088,"address":[54047673,54047739],"length":1,"stats":{"Line":10}},{"line":1091,"address":[55385851,55386757,55385786],"length":1,"stats":{"Line":12}},{"line":1092,"address":[54230234,54230553],"length":1,"stats":{"Line":4}},{"line":1093,"address":[54230593],"length":1,"stats":{"Line":2}},{"line":1094,"address":[54231029],"length":1,"stats":{"Line":2}},{"line":1095,"address":[54048517],"length":1,"stats":{"Line":2}},{"line":1099,"address":[54047834,54048142,54047866],"length":1,"stats":{"Line":10}},{"line":1101,"address":[54231118,54230497],"length":1,"stats":{"Line":10}},{"line":1107,"address":[54231184,54230161,54231598],"length":1,"stats":{"Line":10}},{"line":1109,"address":[54231461],"length":1,"stats":{"Line":5}},{"line":1110,"address":[55386966],"length":1,"stats":{"Line":5}},{"line":1111,"address":[53150305],"length":1,"stats":{"Line":5}},{"line":1116,"address":[55435616,55436982,55444499],"length":1,"stats":{"Line":35}},{"line":1117,"address":[53200177],"length":1,"stats":{"Line":41}},{"line":1118,"address":[54280213,54280118],"length":1,"stats":{"Line":77}},{"line":1120,"address":[55436198,55435899,55436223],"length":1,"stats":{"Line":42}},{"line":1121,"address":[55436073],"length":1,"stats":{"Line":10}},{"line":1122,"address":[54099365],"length":1,"stats":{"Line":17}},{"line":1123,"address":[54280462],"length":1,"stats":{"Line":12}},{"line":1124,"address":[54282043],"length":1,"stats":{"Line":12}},{"line":1125,"address":[53202191],"length":1,"stats":{"Line":19}},{"line":1129,"address":[54099404],"length":1,"stats":{"Line":3}},{"line":1130,"address":[54280496],"length":1,"stats":{"Line":3}},{"line":1131,"address":[54280520],"length":1,"stats":{"Line":4}},{"line":1132,"address":[54282176],"length":1,"stats":{"Line":4}},{"line":1133,"address":[54101091],"length":1,"stats":{"Line":4}},{"line":1137,"address":[53200686,53200711],"length":1,"stats":{"Line":6}},{"line":1138,"address":[54101242],"length":1,"stats":{"Line":6}},{"line":1139,"address":[53202532],"length":1,"stats":{"Line":9}},{"line":1140,"address":[53202703],"length":1,"stats":{"Line":10}},{"line":1141,"address":[54101375],"length":1,"stats":{"Line":10}},{"line":1145,"address":[55436228],"length":1,"stats":{"Line":3}},{"line":1146,"address":[54099520],"length":1,"stats":{"Line":3}},{"line":1147,"address":[54282661],"length":1,"stats":{"Line":3}},{"line":1148,"address":[54282720],"length":1,"stats":{"Line":3}},{"line":1151,"address":[53200527],"length":1,"stats":{"Line":6}},{"line":1152,"address":[55437238],"length":1,"stats":{"Line":6}},{"line":1153,"address":[54100506],"length":1,"stats":{"Line":6}},{"line":1158,"address":[54280353],"length":1,"stats":{"Line":5}},{"line":1159,"address":[54281416],"length":1,"stats":{"Line":5}},{"line":1160,"address":[53201564],"length":1,"stats":{"Line":5}},{"line":1165,"address":[55436037],"length":1,"stats":{"Line":4}},{"line":1166,"address":[54100698],"length":1,"stats":{"Line":4}},{"line":1167,"address":[54100680],"length":1,"stats":{"Line":4}},{"line":1172,"address":[55436055],"length":1,"stats":{"Line":3}},{"line":1173,"address":[54100846],"length":1,"stats":{"Line":3}},{"line":1176,"address":[54099259],"length":1,"stats":{"Line":2}},{"line":1177,"address":[54280758],"length":1,"stats":{"Line":2}},{"line":1178,"address":[54100147],"length":1,"stats":{"Line":2}},{"line":1179,"address":[55436697],"length":1,"stats":{"Line":2}},{"line":1183,"address":[53200781],"length":1,"stats":{"Line":15}},{"line":1184,"address":[54101758,54099565],"length":1,"stats":{"Line":30}},{"line":1185,"address":[53202998],"length":1,"stats":{"Line":13}},{"line":1186,"address":[54101846],"length":1,"stats":{"Line":17}},{"line":1187,"address":[54101960],"length":1,"stats":{"Line":13}},{"line":1190,"address":[53200834],"length":1,"stats":{"Line":3}},{"line":1191,"address":[53204046,53203250],"length":1,"stats":{"Line":3}},{"line":1192,"address":[54102325,54102401],"length":1,"stats":{"Line":6}},{"line":1194,"address":[53203922],"length":1,"stats":{"Line":3}},{"line":1195,"address":[55439247],"length":1,"stats":{"Line":3}},{"line":1200,"address":[53200870],"length":1,"stats":{"Line":6}},{"line":1201,"address":[53205997],"length":1,"stats":{"Line":6}},{"line":1202,"address":[55441406],"length":1,"stats":{"Line":6}},{"line":1203,"address":[54285813],"length":1,"stats":{"Line":7}},{"line":1206,"address":[54286830,54285849,54285917],"length":1,"stats":{"Line":17}},{"line":1207,"address":[54104992,54105325],"length":1,"stats":{"Line":6}},{"line":1208,"address":[55441959],"length":1,"stats":{"Line":3}},{"line":1209,"address":[54105816],"length":1,"stats":{"Line":3}},{"line":1210,"address":[53206896],"length":1,"stats":{"Line":3}},{"line":1214,"address":[55441638,55441881,55441587],"length":1,"stats":{"Line":14}},{"line":1216,"address":[55441871],"length":1,"stats":{"Line":7}},{"line":1217,"address":[53207145],"length":1,"stats":{"Line":7}},{"line":1220,"address":[53207184],"length":1,"stats":{"Line":7}},{"line":1223,"address":[53207583,53207231,53206145],"length":1,"stats":{"Line":16}},{"line":1224,"address":[54287097],"length":1,"stats":{"Line":7}},{"line":1227,"address":[54280696],"length":1,"stats":{"Line":3}},{"line":1228,"address":[55439502],"length":1,"stats":{"Line":3}},{"line":1229,"address":[54283869],"length":1,"stats":{"Line":3}},{"line":1230,"address":[54102902,54104260],"length":1,"stats":{"Line":6}},{"line":1231,"address":[54104296],"length":1,"stats":{"Line":3}},{"line":1232,"address":[54284037,54283968,54285366],"length":1,"stats":{"Line":6}},{"line":1233,"address":[55440053,55440984,55439961],"length":1,"stats":{"Line":6}},{"line":1234,"address":[55440201],"length":1,"stats":{"Line":3}},{"line":1235,"address":[53205078],"length":1,"stats":{"Line":3}},{"line":1236,"address":[55440843],"length":1,"stats":{"Line":3}},{"line":1237,"address":[55440858],"length":1,"stats":{"Line":3}},{"line":1240,"address":[54285267],"length":1,"stats":{"Line":3}},{"line":1243,"address":[54102961,54104408,54104760],"length":1,"stats":{"Line":6}},{"line":1244,"address":[55441206],"length":1,"stats":{"Line":3}},{"line":1248,"address":[53200888],"length":1,"stats":{"Line":3}},{"line":1249,"address":[53207588],"length":1,"stats":{"Line":3}},{"line":1250,"address":[54287301,54287372],"length":1,"stats":{"Line":6}},{"line":1252,"address":[53207773,53208035,53207700],"length":1,"stats":{"Line":6}},{"line":1253,"address":[54106768],"length":1,"stats":{"Line":3}},{"line":1258,"address":[54288588,54287753,54287421],"length":1,"stats":{"Line":6}},{"line":1259,"address":[54106999],"length":1,"stats":{"Line":3}},{"line":1260,"address":[55444043],"length":1,"stats":{"Line":3}},{"line":1261,"address":[53208530],"length":1,"stats":{"Line":3}},{"line":1262,"address":[54288232],"length":1,"stats":{"Line":3}},{"line":1266,"address":[54107874],"length":1,"stats":{"Line":2}},{"line":1267,"address":[53208990,53200453],"length":1,"stats":{"Line":4}},{"line":1268,"address":[54288752],"length":1,"stats":{"Line":2}},{"line":1273,"address":[54050422,54049376,54050373],"length":1,"stats":{"Line":20}},{"line":1274,"address":[55387403,55387566,55387490,55388328],"length":1,"stats":{"Line":82}},{"line":1275,"address":[53150821,53150870],"length":1,"stats":{"Line":6}},{"line":1276,"address":[53150910],"length":1,"stats":{"Line":3}},{"line":1277,"address":[55388220],"length":1,"stats":{"Line":3}},{"line":1278,"address":[54049973,54050098],"length":1,"stats":{"Line":6}},{"line":1279,"address":[54232426],"length":1,"stats":{"Line":3}},{"line":1284,"address":[54049517],"length":1,"stats":{"Line":18}},{"line":1290,"address":[55425744],"length":1,"stats":{"Line":66}},{"line":1291,"address":[54088798],"length":1,"stats":{"Line":45}},{"line":1292,"address":[55425774],"length":1,"stats":{"Line":66}},{"line":1293,"address":[54088835,54088901],"length":1,"stats":{"Line":45}},{"line":1296,"address":[53212912],"length":1,"stats":{"Line":26}},{"line":1297,"address":[54292494,54292478],"length":1,"stats":{"Line":26}},{"line":1298,"address":[54292501,54292573],"length":1,"stats":{"Line":62}},{"line":1300,"address":[53212933],"length":1,"stats":{"Line":0}},{"line":1304,"address":[54111824],"length":1,"stats":{"Line":66}},{"line":1305,"address":[55448261],"length":1,"stats":{"Line":45}},{"line":1308,"address":[54095648],"length":1,"stats":{"Line":26}},{"line":1309,"address":[55432525,55432446],"length":1,"stats":{"Line":52}},{"line":1310,"address":[54095676,54095738,54095744],"length":1,"stats":{"Line":52}},{"line":1312,"address":[54276839],"length":1,"stats":{"Line":26}},{"line":1315,"address":[54272112],"length":1,"stats":{"Line":66}},{"line":1316,"address":[54272135],"length":1,"stats":{"Line":45}},{"line":1317,"address":[53192191],"length":1,"stats":{"Line":7}},{"line":1319,"address":[54272148],"length":1,"stats":{"Line":66}},{"line":1323,"address":[54231648],"length":1,"stats":{"Line":66}},{"line":1324,"address":[53150563,53150577],"length":1,"stats":{"Line":106}},{"line":1325,"address":[54231688],"length":1,"stats":{"Line":26}},{"line":1326,"address":[55387341],"length":1,"stats":{"Line":26}},{"line":1328,"address":[54049340],"length":1,"stats":{"Line":42}},{"line":1332,"address":[53195388,53194960,53195394],"length":1,"stats":{"Line":11}},{"line":1333,"address":[55430645,55430720],"length":1,"stats":{"Line":28}},{"line":1334,"address":[54275055],"length":1,"stats":{"Line":11}},{"line":1335,"address":[55430713],"length":1,"stats":{"Line":11}},{"line":1337,"address":[54275213],"length":1,"stats":{"Line":3}},{"line":1338,"address":[54275016],"length":1,"stats":{"Line":2}},{"line":1339,"address":[55430686,55430782],"length":1,"stats":{"Line":6}},{"line":1340,"address":[54275209,54275146],"length":1,"stats":{"Line":6}},{"line":1345,"address":[55406324,55405744,55406105],"length":1,"stats":{"Line":18}},{"line":1346,"address":[55405808],"length":1,"stats":{"Line":19}},{"line":1347,"address":[53169570,53170072],"length":1,"stats":{"Line":33}},{"line":1348,"address":[55405847],"length":1,"stats":{"Line":20}},{"line":1349,"address":[53169692],"length":1,"stats":{"Line":31}},{"line":1350,"address":[55405994],"length":1,"stats":{"Line":20}},{"line":1352,"address":[53169938],"length":1,"stats":{"Line":2}},{"line":1353,"address":[55405880],"length":1,"stats":{"Line":2}},{"line":1354,"address":[55406124],"length":1,"stats":{"Line":2}},{"line":1355,"address":[54068701],"length":1,"stats":{"Line":2}},{"line":1360,"address":[55390256,55390669,55390888],"length":1,"stats":{"Line":2}},{"line":1361,"address":[53153647],"length":1,"stats":{"Line":2}},{"line":1362,"address":[54052495,54052988,54052433],"length":1,"stats":{"Line":4}},{"line":1363,"address":[55390429],"length":1,"stats":{"Line":2}},{"line":1364,"address":[54234854],"length":1,"stats":{"Line":2}},{"line":1365,"address":[55390555],"length":1,"stats":{"Line":2}},{"line":1367,"address":[53154086],"length":1,"stats":{"Line":0}},{"line":1368,"address":[54234729],"length":1,"stats":{"Line":0}},{"line":1369,"address":[54235040],"length":1,"stats":{"Line":0}},{"line":1370,"address":[54235096],"length":1,"stats":{"Line":0}},{"line":1375,"address":[55411307,55411313,55410720],"length":1,"stats":{"Line":6}},{"line":1376,"address":[53174598],"length":1,"stats":{"Line":4}},{"line":1377,"address":[54073403],"length":1,"stats":{"Line":2}},{"line":1380,"address":[53174652],"length":1,"stats":{"Line":21}},{"line":1381,"address":[55410856],"length":1,"stats":{"Line":9}},{"line":1384,"address":[54073441],"length":1,"stats":{"Line":2}},{"line":1385,"address":[54073566],"length":1,"stats":{"Line":0}},{"line":1386,"address":[53174808],"length":1,"stats":{"Line":0}},{"line":1390,"address":[54073481],"length":1,"stats":{"Line":2}},{"line":1391,"address":[54255246,54255332],"length":1,"stats":{"Line":4}},{"line":1392,"address":[54255238],"length":1,"stats":{"Line":2}},{"line":1411,"address":[53174887],"length":1,"stats":{"Line":0}},{"line":1414,"address":[55411190],"length":1,"stats":{"Line":2}},{"line":1415,"address":[54073607],"length":1,"stats":{"Line":2}},{"line":1416,"address":[53174870,53174945],"length":1,"stats":{"Line":4}},{"line":1417,"address":[55411186,55411125],"length":1,"stats":{"Line":4}},{"line":1421,"address":[53159632],"length":1,"stats":{"Line":65}},{"line":1422,"address":[54058419],"length":1,"stats":{"Line":44}},{"line":1425,"address":[54050480],"length":1,"stats":{"Line":17}},{"line":1426,"address":[54232793],"length":1,"stats":{"Line":27}},{"line":1427,"address":[54050499],"length":1,"stats":{"Line":24}},{"line":1430,"address":[55388416],"length":1,"stats":{"Line":0}},{"line":1431,"address":[55388421],"length":1,"stats":{"Line":0}},{"line":1435,"address":[55396093,55395397,55393072],"length":1,"stats":{"Line":3}},{"line":1436,"address":[53156543],"length":1,"stats":{"Line":3}},{"line":1437,"address":[54237572],"length":1,"stats":{"Line":3}},{"line":1438,"address":[54055432,54055512],"length":1,"stats":{"Line":6}},{"line":1440,"address":[55393389],"length":1,"stats":{"Line":3}},{"line":1441,"address":[54237820],"length":1,"stats":{"Line":3}},{"line":1443,"address":[54237895,54237857],"length":1,"stats":{"Line":6}},{"line":1444,"address":[54237966],"length":1,"stats":{"Line":2}},{"line":1445,"address":[54239881],"length":1,"stats":{"Line":2}},{"line":1450,"address":[55393595,55393628],"length":1,"stats":{"Line":6}},{"line":1451,"address":[54055810,54055860],"length":1,"stats":{"Line":6}},{"line":1452,"address":[55393769],"length":1,"stats":{"Line":3}},{"line":1456,"address":[54238019],"length":1,"stats":{"Line":3}},{"line":1457,"address":[54055950],"length":1,"stats":{"Line":3}},{"line":1458,"address":[53157193,53157264],"length":1,"stats":{"Line":6}},{"line":1459,"address":[53157319],"length":1,"stats":{"Line":3}},{"line":1460,"address":[54238298,54238366,54238337],"length":1,"stats":{"Line":0}},{"line":1461,"address":[54238386,54238344],"length":1,"stats":{"Line":0}},{"line":1462,"address":[54238322],"length":1,"stats":{"Line":3}},{"line":1463,"address":[53157505,53157447,53157482],"length":1,"stats":{"Line":6}},{"line":1464,"address":[54056257],"length":1,"stats":{"Line":3}},{"line":1467,"address":[55394119],"length":1,"stats":{"Line":0}},{"line":1468,"address":[54056239],"length":1,"stats":{"Line":3}},{"line":1471,"address":[54056380,54056322],"length":1,"stats":{"Line":4}},{"line":1472,"address":[55394260],"length":1,"stats":{"Line":2}},{"line":1474,"address":[53157745],"length":1,"stats":{"Line":2}},{"line":1475,"address":[53157783],"length":1,"stats":{"Line":2}},{"line":1478,"address":[53157764],"length":1,"stats":{"Line":0}},{"line":1479,"address":[54238744],"length":1,"stats":{"Line":0}},{"line":1483,"address":[53157847,53157723],"length":1,"stats":{"Line":0}},{"line":1487,"address":[54238781,54238634],"length":1,"stats":{"Line":0}},{"line":1490,"address":[53157857,53157582],"length":1,"stats":{"Line":6}},{"line":1495,"address":[54238809,54238278,54239823],"length":1,"stats":{"Line":6}},{"line":1496,"address":[54056887],"length":1,"stats":{"Line":3}},{"line":1497,"address":[54057059,54057011],"length":1,"stats":{"Line":6}},{"line":1498,"address":[55395132,55395270],"length":1,"stats":{"Line":6}},{"line":1499,"address":[55393808,55395224,55395403,55395326,55393524,55394747,55395426,55394819],"length":1,"stats":{"Line":6}},{"line":1501,"address":[54057866,54057805],"length":1,"stats":{"Line":4}},{"line":1502,"address":[54240051],"length":1,"stats":{"Line":2}},{"line":1503,"address":[55395711],"length":1,"stats":{"Line":2}},{"line":1507,"address":[55395669,55395706],"length":1,"stats":{"Line":0}},{"line":1509,"address":[54057836,54057999],"length":1,"stats":{"Line":6}},{"line":1514,"address":[55393483,55395752],"length":1,"stats":{"Line":6}},{"line":1515,"address":[54058022,54058262],"length":1,"stats":{"Line":6}},{"line":1518,"address":[53159297],"length":1,"stats":{"Line":3}},{"line":1524,"address":[53141492,53139952,53141534],"length":1,"stats":{"Line":6}},{"line":1525,"address":[54221389],"length":1,"stats":{"Line":6}},{"line":1526,"address":[54221426,54221517],"length":1,"stats":{"Line":16}},{"line":1528,"address":[54038938],"length":1,"stats":{"Line":8}},{"line":1529,"address":[54039020],"length":1,"stats":{"Line":8}},{"line":1530,"address":[55377326,55377370],"length":1,"stats":{"Line":6}},{"line":1531,"address":[53140534,53140744],"length":1,"stats":{"Line":4}},{"line":1532,"address":[53140564,53140749],"length":1,"stats":{"Line":4}},{"line":1533,"address":[55377750,55377590],"length":1,"stats":{"Line":4}},{"line":1534,"address":[54039527,54039392],"length":1,"stats":{"Line":4}},{"line":1535,"address":[53140764,53140651],"length":1,"stats":{"Line":9}},{"line":1536,"address":[55377674,55377765],"length":1,"stats":{"Line":4}},{"line":1537,"address":[54222053,54222122],"length":1,"stats":{"Line":4}},{"line":1540,"address":[55377733],"length":1,"stats":{"Line":2}},{"line":1541,"address":[53140779,53140857],"length":1,"stats":{"Line":4}},{"line":1542,"address":[53140908,53140957],"length":1,"stats":{"Line":4}},{"line":1543,"address":[54222365],"length":1,"stats":{"Line":2}},{"line":1544,"address":[54222779,54222394],"length":1,"stats":{"Line":4}},{"line":1550,"address":[54222413,54222284],"length":1,"stats":{"Line":4}},{"line":1551,"address":[53141087,53141250,53141156],"length":1,"stats":{"Line":6}},{"line":1552,"address":[55378256],"length":1,"stats":{"Line":2}},{"line":1555,"address":[54222556],"length":1,"stats":{"Line":0}},{"line":1556,"address":[55378310],"length":1,"stats":{"Line":0}},{"line":1560,"address":[53141104],"length":1,"stats":{"Line":0}},{"line":1561,"address":[53141381],"length":1,"stats":{"Line":0}},{"line":1564,"address":[55377482],"length":1,"stats":{"Line":2}},{"line":1566,"address":[53140504],"length":1,"stats":{"Line":2}},{"line":1567,"address":[54040270],"length":1,"stats":{"Line":2}},{"line":1569,"address":[54221802],"length":1,"stats":{"Line":0}},{"line":1572,"address":[54221693,54222869],"length":1,"stats":{"Line":16}},{"line":1576,"address":[53140275],"length":1,"stats":{"Line":9}},{"line":1580,"address":[55378947,55378544,55378941],"length":1,"stats":{"Line":36}},{"line":1581,"address":[54223046,54222928],"length":1,"stats":{"Line":83}},{"line":1582,"address":[54223106],"length":1,"stats":{"Line":66}},{"line":1583,"address":[54223213],"length":1,"stats":{"Line":65}}],"covered":807,"coverable":874},{"path":["/","home","md","language","mdhavers","src","token.rs"],"content":"use logos::Logos;\nuse std::fmt;\n\n/// Aw the different kinds o' tokens in mdhavers\n#[derive(Logos, Debug, Clone, PartialEq)]\n#[logos(skip r\"[ \\t\\r]+\")] // Skip whitespace but nae newlines\npub enum TokenKind {\n    // === Scots Keywords ===\n    /// ken - variable declaration (I know/understand)\n    #[token(\"ken\")]\n    Ken,\n\n    /// gin - if statement (if/when)\n    #[token(\"gin\")]\n    Gin,\n\n    /// ither - else\n    #[token(\"ither\")]\n    Ither,\n\n    /// than - then (for ternary expressions: gin x than y ither z)\n    #[token(\"than\")]\n    Than,\n\n    /// whiles - while loop\n    #[token(\"whiles\")]\n    Whiles,\n\n    /// fer - for loop\n    #[token(\"fer\")]\n    Fer,\n\n    /// gie - return (give back)\n    #[token(\"gie\")]\n    Gie,\n\n    /// blether - print (chat/talk)\n    #[token(\"blether\")]\n    Blether,\n\n    /// speir - input (ask)\n    #[token(\"speir\")]\n    Speir,\n\n    /// fae - from\n    #[token(\"fae\")]\n    Fae,\n\n    /// tae - to\n    #[token(\"tae\")]\n    Tae,\n\n    /// an - and (logical)\n    #[token(\"an\")]\n    An,\n\n    /// or - or (logical)\n    #[token(\"or\")]\n    Or,\n\n    /// nae - not / false\n    #[token(\"nae\")]\n    Nae,\n\n    /// aye - true\n    #[token(\"aye\")]\n    Aye,\n\n    /// naething - null/none/nil\n    #[token(\"naething\")]\n    Naething,\n\n    /// dae - function definition (do)\n    #[token(\"dae\")]\n    Dae,\n\n    /// thing - struct definition\n    #[token(\"thing\")]\n    Thing,\n\n    /// fetch - import\n    #[token(\"fetch\")]\n    Fetch,\n\n    /// kin - class (family/type)\n    #[token(\"kin\")]\n    Kin,\n\n    /// brak - break\n    #[token(\"brak\")]\n    Brak,\n\n    /// haud - continue (hold on)\n    #[token(\"haud\")]\n    Haud,\n\n    /// in - in (for loops)\n    #[token(\"in\")]\n    In,\n\n    /// is - is (type checking/comparison)\n    #[token(\"is\")]\n    Is,\n\n    /// self/this reference\n    #[token(\"masel\")]\n    Masel,\n\n    /// try block\n    #[token(\"hae_a_bash\")]\n    HaeABash,\n\n    /// catch block\n    #[token(\"gin_it_gangs_wrang\")]\n    GinItGangsWrang,\n\n    /// match/switch statement\n    #[token(\"keek\")]\n    Keek,\n\n    /// case in match\n    #[token(\"whan\")]\n    Whan,\n\n    /// assert - mak_siccar (make sure - famously said by Robert the Bruce!)\n    #[token(\"mak_siccar\")]\n    MakSiccar,\n\n    // === Logging Keywords ===\n    /// log_whisper - TRACE level (most verbose)\n    #[token(\"log_whisper\")]\n    LogWhisper,\n\n    /// log_mutter - DEBUG level\n    #[token(\"log_mutter\")]\n    LogMutter,\n\n    /// log_blether - INFO level\n    #[token(\"log_blether\")]\n    LogBlether,\n\n    /// log_holler - WARN level\n    #[token(\"log_holler\")]\n    LogHoller,\n\n    /// log_roar - ERROR level\n    #[token(\"log_roar\")]\n    LogRoar,\n\n    /// hurl - throw/raise an exception\n    #[token(\"hurl\")]\n    Hurl,\n\n    // === Literals ===\n    #[regex(r\"[0-9]+\", |lex| lex.slice().parse::<i64>().ok())]\n    Integer(i64),\n\n    #[regex(r\"[0-9]+\\.[0-9]+\", |lex| lex.slice().parse::<f64>().ok())]\n    Float(f64),\n\n    // String with double quotes\n    #[regex(r#\"\"([^\"\\\\]|\\\\.)*\"\"#, |lex| {\n        let s = lex.slice();\n        Some(s[1..s.len()-1].to_string())\n    })]\n    String(String),\n\n    // String with single quotes (fer use inside f-strings and general convenience)\n    #[regex(r#\"'([^'\\\\]|\\\\.)*'\"#, |lex| {\n        let s = lex.slice();\n        Some(s[1..s.len()-1].to_string())\n    })]\n    SingleQuoteString(String),\n\n    // F-string (format string) with interpolation: f\"Hello {name}!\"\n    #[regex(r#\"f\"([^\"\\\\]|\\\\.)*\"\"#, |lex| {\n        let s = lex.slice();\n        Some(s[2..s.len()-1].to_string())  // Skip 'f\"' and '\"'\n    })]\n    FString(String),\n\n    // Identifiers\n    #[regex(r\"[a-zA-Z_][a-zA-Z0-9_]*\", |lex| lex.slice().to_string())]\n    Identifier(String),\n\n    // === Operators ===\n    #[token(\"+\")]\n    Plus,\n\n    #[token(\"-\")]\n    Minus,\n\n    #[token(\"*\")]\n    Star,\n\n    #[token(\"/\")]\n    Slash,\n\n    #[token(\"%\")]\n    Percent,\n\n    #[token(\"=\")]\n    Equals,\n\n    #[token(\"==\")]\n    EqualsEquals,\n\n    #[token(\"!=\")]\n    BangEquals,\n\n    #[token(\"<\")]\n    Less,\n\n    #[token(\"<=\")]\n    LessEquals,\n\n    #[token(\">\")]\n    Greater,\n\n    #[token(\">=\")]\n    GreaterEquals,\n\n    #[token(\"!\")]\n    Bang,\n\n    #[token(\"+=\")]\n    PlusEquals,\n\n    #[token(\"-=\")]\n    MinusEquals,\n\n    #[token(\"*=\")]\n    StarEquals,\n\n    #[token(\"/=\")]\n    SlashEquals,\n\n    #[token(\"...\")]\n    DotDotDot, // Spread operator (skail = scatter in Scots)\n\n    #[token(\"..\")]\n    DotDot,\n\n    #[token(\".\")]\n    Dot,\n\n    #[token(\"_\", priority = 3)]\n    Underscore, // Wildcard/ignore pattern\n\n    // === Delimiters ===\n    #[token(\"(\")]\n    LeftParen,\n\n    #[token(\")\")]\n    RightParen,\n\n    #[token(\"{\")]\n    LeftBrace,\n\n    #[token(\"}\")]\n    RightBrace,\n\n    #[token(\"[\")]\n    LeftBracket,\n\n    #[token(\"]\")]\n    RightBracket,\n\n    #[token(\",\")]\n    Comma,\n\n    #[token(\":\")]\n    Colon,\n\n    #[token(\";\")]\n    Semicolon,\n\n    #[token(\"->\")]\n    Arrow,\n\n    #[token(\"|>\")]\n    PipeForward, // Pipe operator fer chaining: x |> f means f(x)\n\n    #[token(\"|\")]\n    Pipe,\n\n    // Newlines are significant in mdhavers (like Python)\n    #[token(\"\\n\")]\n    Newline,\n\n    // Comments - skip them\n    #[regex(r\"#[^\\n]*\", logos::skip)]\n    Comment,\n\n    // End of file\n    Eof,\n}\n\nimpl fmt::Display for TokenKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            TokenKind::Ken => write!(f, \"ken\"),\n            TokenKind::Gin => write!(f, \"gin\"),\n            TokenKind::Ither => write!(f, \"ither\"),\n            TokenKind::Than => write!(f, \"than\"),\n            TokenKind::Whiles => write!(f, \"whiles\"),\n            TokenKind::Fer => write!(f, \"fer\"),\n            TokenKind::Gie => write!(f, \"gie\"),\n            TokenKind::Blether => write!(f, \"blether\"),\n            TokenKind::Speir => write!(f, \"speir\"),\n            TokenKind::Fae => write!(f, \"fae\"),\n            TokenKind::Tae => write!(f, \"tae\"),\n            TokenKind::An => write!(f, \"an\"),\n            TokenKind::Or => write!(f, \"or\"),\n            TokenKind::Nae => write!(f, \"nae\"),\n            TokenKind::Aye => write!(f, \"aye\"),\n            TokenKind::Naething => write!(f, \"naething\"),\n            TokenKind::Dae => write!(f, \"dae\"),\n            TokenKind::Thing => write!(f, \"thing\"),\n            TokenKind::Fetch => write!(f, \"fetch\"),\n            TokenKind::Kin => write!(f, \"kin\"),\n            TokenKind::Brak => write!(f, \"brak\"),\n            TokenKind::Haud => write!(f, \"haud\"),\n            TokenKind::In => write!(f, \"in\"),\n            TokenKind::Is => write!(f, \"is\"),\n            TokenKind::Masel => write!(f, \"masel\"),\n            TokenKind::HaeABash => write!(f, \"hae_a_bash\"),\n            TokenKind::GinItGangsWrang => write!(f, \"gin_it_gangs_wrang\"),\n            TokenKind::Keek => write!(f, \"keek\"),\n            TokenKind::Whan => write!(f, \"whan\"),\n            TokenKind::MakSiccar => write!(f, \"mak_siccar\"),\n            TokenKind::LogWhisper => write!(f, \"log_whisper\"),\n            TokenKind::LogMutter => write!(f, \"log_mutter\"),\n            TokenKind::LogBlether => write!(f, \"log_blether\"),\n            TokenKind::LogHoller => write!(f, \"log_holler\"),\n            TokenKind::LogRoar => write!(f, \"log_roar\"),\n            TokenKind::Hurl => write!(f, \"hurl\"),\n            TokenKind::Integer(n) => write!(f, \"{}\", n),\n            TokenKind::Float(n) => write!(f, \"{}\", n),\n            TokenKind::String(s) => write!(f, \"\\\"{}\\\"\", s),\n            TokenKind::SingleQuoteString(s) => write!(f, \"'{}'\", s),\n            TokenKind::FString(s) => write!(f, \"f\\\"{}\\\"\", s),\n            TokenKind::Identifier(s) => write!(f, \"{}\", s),\n            TokenKind::Plus => write!(f, \"+\"),\n            TokenKind::Minus => write!(f, \"-\"),\n            TokenKind::Star => write!(f, \"*\"),\n            TokenKind::Slash => write!(f, \"/\"),\n            TokenKind::Percent => write!(f, \"%\"),\n            TokenKind::Equals => write!(f, \"=\"),\n            TokenKind::EqualsEquals => write!(f, \"==\"),\n            TokenKind::BangEquals => write!(f, \"!=\"),\n            TokenKind::Less => write!(f, \"<\"),\n            TokenKind::LessEquals => write!(f, \"<=\"),\n            TokenKind::Greater => write!(f, \">\"),\n            TokenKind::GreaterEquals => write!(f, \">=\"),\n            TokenKind::Bang => write!(f, \"!\"),\n            TokenKind::PlusEquals => write!(f, \"+=\"),\n            TokenKind::MinusEquals => write!(f, \"-=\"),\n            TokenKind::StarEquals => write!(f, \"*=\"),\n            TokenKind::SlashEquals => write!(f, \"/=\"),\n            TokenKind::DotDotDot => write!(f, \"...\"),\n            TokenKind::DotDot => write!(f, \"..\"),\n            TokenKind::Dot => write!(f, \".\"),\n            TokenKind::Underscore => write!(f, \"_\"),\n            TokenKind::LeftParen => write!(f, \"(\"),\n            TokenKind::RightParen => write!(f, \")\"),\n            TokenKind::LeftBrace => write!(f, \"{{\"),\n            TokenKind::RightBrace => write!(f, \"}}\"),\n            TokenKind::LeftBracket => write!(f, \"[\"),\n            TokenKind::RightBracket => write!(f, \"]\"),\n            TokenKind::Comma => write!(f, \",\"),\n            TokenKind::Colon => write!(f, \":\"),\n            TokenKind::Semicolon => write!(f, \";\"),\n            TokenKind::Arrow => write!(f, \"->\"),\n            TokenKind::PipeForward => write!(f, \"|>\"),\n            TokenKind::Pipe => write!(f, \"|\"),\n            TokenKind::Newline => write!(f, \"newline\"),\n            TokenKind::Comment => write!(f, \"comment\"),\n            TokenKind::Eof => write!(f, \"end of file\"),\n        }\n    }\n}\n\n/// A token wi' its position in the source\n#[derive(Debug, Clone, PartialEq)]\npub struct Token {\n    pub kind: TokenKind,\n    pub lexeme: String,\n    pub line: usize,\n    pub column: usize,\n}\n\nimpl Token {\n    pub fn new(kind: TokenKind, lexeme: String, line: usize, column: usize) -> Self {\n        Token {\n            kind,\n            lexeme,\n            line,\n            column,\n        }\n    }\n\n    pub fn eof(line: usize) -> Self {\n        Token {\n            kind: TokenKind::Eof,\n            lexeme: String::new(),\n            line,\n            column: 0,\n        }\n    }\n}\n\nimpl fmt::Display for Token {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} at line {}\", self.kind, self.line)\n    }\n}\n\n#[cfg(test)]\n#[allow(clippy::approx_constant)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_token_kind_display_keywords() {\n        assert_eq!(format!(\"{}\", TokenKind::Ken), \"ken\");\n        assert_eq!(format!(\"{}\", TokenKind::Gin), \"gin\");\n        assert_eq!(format!(\"{}\", TokenKind::Ither), \"ither\");\n        assert_eq!(format!(\"{}\", TokenKind::Than), \"than\");\n        assert_eq!(format!(\"{}\", TokenKind::Whiles), \"whiles\");\n        assert_eq!(format!(\"{}\", TokenKind::Fer), \"fer\");\n        assert_eq!(format!(\"{}\", TokenKind::Gie), \"gie\");\n        assert_eq!(format!(\"{}\", TokenKind::Blether), \"blether\");\n        assert_eq!(format!(\"{}\", TokenKind::Speir), \"speir\");\n        assert_eq!(format!(\"{}\", TokenKind::Fae), \"fae\");\n        assert_eq!(format!(\"{}\", TokenKind::Tae), \"tae\");\n        assert_eq!(format!(\"{}\", TokenKind::An), \"an\");\n        assert_eq!(format!(\"{}\", TokenKind::Or), \"or\");\n        assert_eq!(format!(\"{}\", TokenKind::Nae), \"nae\");\n        assert_eq!(format!(\"{}\", TokenKind::Aye), \"aye\");\n        assert_eq!(format!(\"{}\", TokenKind::Naething), \"naething\");\n        assert_eq!(format!(\"{}\", TokenKind::Dae), \"dae\");\n        assert_eq!(format!(\"{}\", TokenKind::Thing), \"thing\");\n        assert_eq!(format!(\"{}\", TokenKind::Fetch), \"fetch\");\n        assert_eq!(format!(\"{}\", TokenKind::Kin), \"kin\");\n        assert_eq!(format!(\"{}\", TokenKind::Brak), \"brak\");\n        assert_eq!(format!(\"{}\", TokenKind::Haud), \"haud\");\n        assert_eq!(format!(\"{}\", TokenKind::In), \"in\");\n        assert_eq!(format!(\"{}\", TokenKind::Is), \"is\");\n        assert_eq!(format!(\"{}\", TokenKind::Masel), \"masel\");\n        assert_eq!(format!(\"{}\", TokenKind::HaeABash), \"hae_a_bash\");\n        assert_eq!(\n            format!(\"{}\", TokenKind::GinItGangsWrang),\n            \"gin_it_gangs_wrang\"\n        );\n        assert_eq!(format!(\"{}\", TokenKind::Keek), \"keek\");\n        assert_eq!(format!(\"{}\", TokenKind::Whan), \"whan\");\n        assert_eq!(format!(\"{}\", TokenKind::MakSiccar), \"mak_siccar\");\n    }\n\n    #[test]\n    fn test_token_kind_display_literals() {\n        assert_eq!(format!(\"{}\", TokenKind::Integer(42)), \"42\");\n        assert_eq!(format!(\"{}\", TokenKind::Integer(-17)), \"-17\");\n        assert_eq!(format!(\"{}\", TokenKind::Float(3.14)), \"3.14\");\n        assert_eq!(\n            format!(\"{}\", TokenKind::String(\"hello\".to_string())),\n            \"\\\"hello\\\"\"\n        );\n        assert_eq!(\n            format!(\"{}\", TokenKind::SingleQuoteString(\"world\".to_string())),\n            \"'world'\"\n        );\n        assert_eq!(\n            format!(\"{}\", TokenKind::FString(\"Hi {name}\".to_string())),\n            \"f\\\"Hi {name}\\\"\"\n        );\n        assert_eq!(\n            format!(\"{}\", TokenKind::Identifier(\"my_var\".to_string())),\n            \"my_var\"\n        );\n    }\n\n    #[test]\n    fn test_token_kind_display_operators() {\n        assert_eq!(format!(\"{}\", TokenKind::Plus), \"+\");\n        assert_eq!(format!(\"{}\", TokenKind::Minus), \"-\");\n        assert_eq!(format!(\"{}\", TokenKind::Star), \"*\");\n        assert_eq!(format!(\"{}\", TokenKind::Slash), \"/\");\n        assert_eq!(format!(\"{}\", TokenKind::Percent), \"%\");\n        assert_eq!(format!(\"{}\", TokenKind::Equals), \"=\");\n        assert_eq!(format!(\"{}\", TokenKind::EqualsEquals), \"==\");\n        assert_eq!(format!(\"{}\", TokenKind::BangEquals), \"!=\");\n        assert_eq!(format!(\"{}\", TokenKind::Less), \"<\");\n        assert_eq!(format!(\"{}\", TokenKind::LessEquals), \"<=\");\n        assert_eq!(format!(\"{}\", TokenKind::Greater), \">\");\n        assert_eq!(format!(\"{}\", TokenKind::GreaterEquals), \">=\");\n        assert_eq!(format!(\"{}\", TokenKind::Bang), \"!\");\n        assert_eq!(format!(\"{}\", TokenKind::PlusEquals), \"+=\");\n        assert_eq!(format!(\"{}\", TokenKind::MinusEquals), \"-=\");\n        assert_eq!(format!(\"{}\", TokenKind::StarEquals), \"*=\");\n        assert_eq!(format!(\"{}\", TokenKind::SlashEquals), \"/=\");\n        assert_eq!(format!(\"{}\", TokenKind::DotDotDot), \"...\");\n        assert_eq!(format!(\"{}\", TokenKind::DotDot), \"..\");\n        assert_eq!(format!(\"{}\", TokenKind::Dot), \".\");\n        assert_eq!(format!(\"{}\", TokenKind::Underscore), \"_\");\n    }\n\n    #[test]\n    fn test_token_kind_display_delimiters() {\n        assert_eq!(format!(\"{}\", TokenKind::LeftParen), \"(\");\n        assert_eq!(format!(\"{}\", TokenKind::RightParen), \")\");\n        assert_eq!(format!(\"{}\", TokenKind::LeftBrace), \"{\");\n        assert_eq!(format!(\"{}\", TokenKind::RightBrace), \"}\");\n        assert_eq!(format!(\"{}\", TokenKind::LeftBracket), \"[\");\n        assert_eq!(format!(\"{}\", TokenKind::RightBracket), \"]\");\n        assert_eq!(format!(\"{}\", TokenKind::Comma), \",\");\n        assert_eq!(format!(\"{}\", TokenKind::Colon), \":\");\n        assert_eq!(format!(\"{}\", TokenKind::Semicolon), \";\");\n        assert_eq!(format!(\"{}\", TokenKind::Arrow), \"->\");\n        assert_eq!(format!(\"{}\", TokenKind::PipeForward), \"|>\");\n        assert_eq!(format!(\"{}\", TokenKind::Pipe), \"|\");\n    }\n\n    #[test]\n    fn test_token_kind_display_special() {\n        assert_eq!(format!(\"{}\", TokenKind::Newline), \"newline\");\n        assert_eq!(format!(\"{}\", TokenKind::Comment), \"comment\");\n        assert_eq!(format!(\"{}\", TokenKind::Eof), \"end of file\");\n    }\n\n    #[test]\n    fn test_token_new() {\n        let token = Token::new(TokenKind::Ken, \"ken\".to_string(), 1, 5);\n        assert_eq!(token.kind, TokenKind::Ken);\n        assert_eq!(token.lexeme, \"ken\");\n        assert_eq!(token.line, 1);\n        assert_eq!(token.column, 5);\n    }\n\n    #[test]\n    fn test_token_eof() {\n        let token = Token::eof(10);\n        assert_eq!(token.kind, TokenKind::Eof);\n        assert_eq!(token.lexeme, \"\");\n        assert_eq!(token.line, 10);\n        assert_eq!(token.column, 0);\n    }\n\n    #[test]\n    fn test_token_display() {\n        let token = Token::new(TokenKind::Ken, \"ken\".to_string(), 5, 1);\n        assert_eq!(format!(\"{}\", token), \"ken at line 5\");\n\n        let token2 = Token::new(TokenKind::Integer(42), \"42\".to_string(), 3, 10);\n        assert_eq!(format!(\"{}\", token2), \"42 at line 3\");\n    }\n}\n","traces":[{"line":300,"address":[52834864],"length":1,"stats":{"Line":2}},{"line":301,"address":[55866721],"length":1,"stats":{"Line":2}},{"line":302,"address":[57378160],"length":1,"stats":{"Line":2}},{"line":303,"address":[57378204],"length":1,"stats":{"Line":2}},{"line":304,"address":[57378248],"length":1,"stats":{"Line":2}},{"line":305,"address":[57378298],"length":1,"stats":{"Line":2}},{"line":306,"address":[57378348],"length":1,"stats":{"Line":2}},{"line":307,"address":[55866990],"length":1,"stats":{"Line":2}},{"line":308,"address":[52835216],"length":1,"stats":{"Line":2}},{"line":309,"address":[57378498],"length":1,"stats":{"Line":2}},{"line":310,"address":[55035028],"length":1,"stats":{"Line":2}},{"line":311,"address":[52835366],"length":1,"stats":{"Line":2}},{"line":312,"address":[57378648],"length":1,"stats":{"Line":2}},{"line":313,"address":[52835466],"length":1,"stats":{"Line":2}},{"line":314,"address":[52835516],"length":1,"stats":{"Line":2}},{"line":315,"address":[55867390],"length":1,"stats":{"Line":2}},{"line":316,"address":[55035328],"length":1,"stats":{"Line":2}},{"line":317,"address":[52835666],"length":1,"stats":{"Line":2}},{"line":318,"address":[52835716],"length":1,"stats":{"Line":2}},{"line":319,"address":[52835766],"length":1,"stats":{"Line":2}},{"line":320,"address":[57379048],"length":1,"stats":{"Line":2}},{"line":321,"address":[55035578],"length":1,"stats":{"Line":2}},{"line":322,"address":[55035628],"length":1,"stats":{"Line":2}},{"line":323,"address":[55035678],"length":1,"stats":{"Line":2}},{"line":324,"address":[55867840],"length":1,"stats":{"Line":2}},{"line":325,"address":[55035778],"length":1,"stats":{"Line":2}},{"line":326,"address":[52836116],"length":1,"stats":{"Line":2}},{"line":327,"address":[52836166],"length":1,"stats":{"Line":2}},{"line":328,"address":[55035928],"length":1,"stats":{"Line":2}},{"line":329,"address":[52836266],"length":1,"stats":{"Line":2}},{"line":330,"address":[55036028],"length":1,"stats":{"Line":2}},{"line":331,"address":[55036078],"length":1,"stats":{"Line":2}},{"line":332,"address":[52836416],"length":1,"stats":{"Line":0}},{"line":333,"address":[52836466],"length":1,"stats":{"Line":0}},{"line":334,"address":[55036228],"length":1,"stats":{"Line":0}},{"line":335,"address":[55036278],"length":1,"stats":{"Line":0}},{"line":336,"address":[57379848],"length":1,"stats":{"Line":0}},{"line":337,"address":[55868490],"length":1,"stats":{"Line":0}},{"line":338,"address":[57379953],"length":1,"stats":{"Line":2}},{"line":339,"address":[57380082],"length":1,"stats":{"Line":2}},{"line":340,"address":[57380210],"length":1,"stats":{"Line":2}},{"line":341,"address":[52837106],"length":1,"stats":{"Line":2}},{"line":342,"address":[52837235],"length":1,"stats":{"Line":2}},{"line":343,"address":[55037078],"length":1,"stats":{"Line":2}},{"line":344,"address":[55037202],"length":1,"stats":{"Line":2}},{"line":345,"address":[52837538],"length":1,"stats":{"Line":2}},{"line":346,"address":[55869414],"length":1,"stats":{"Line":2}},{"line":347,"address":[52837638],"length":1,"stats":{"Line":2}},{"line":348,"address":[55869514],"length":1,"stats":{"Line":2}},{"line":349,"address":[55869564],"length":1,"stats":{"Line":2}},{"line":350,"address":[55869614],"length":1,"stats":{"Line":2}},{"line":351,"address":[52837838],"length":1,"stats":{"Line":2}},{"line":352,"address":[52837888],"length":1,"stats":{"Line":2}},{"line":353,"address":[57381171],"length":1,"stats":{"Line":2}},{"line":354,"address":[57381221],"length":1,"stats":{"Line":2}},{"line":355,"address":[55869864],"length":1,"stats":{"Line":2}},{"line":356,"address":[55037802],"length":1,"stats":{"Line":2}},{"line":357,"address":[57381371],"length":1,"stats":{"Line":2}},{"line":358,"address":[55037902],"length":1,"stats":{"Line":2}},{"line":359,"address":[55037952],"length":1,"stats":{"Line":2}},{"line":360,"address":[55038002],"length":1,"stats":{"Line":2}},{"line":361,"address":[55038052],"length":1,"stats":{"Line":2}},{"line":362,"address":[57381621],"length":1,"stats":{"Line":2}},{"line":363,"address":[55038152],"length":1,"stats":{"Line":2}},{"line":364,"address":[52838488],"length":1,"stats":{"Line":2}},{"line":365,"address":[55870364],"length":1,"stats":{"Line":2}},{"line":366,"address":[52838588],"length":1,"stats":{"Line":2}},{"line":367,"address":[55038352],"length":1,"stats":{"Line":2}},{"line":368,"address":[57381921],"length":1,"stats":{"Line":2}},{"line":369,"address":[57381971],"length":1,"stats":{"Line":2}},{"line":370,"address":[55038502],"length":1,"stats":{"Line":2}},{"line":371,"address":[57382071],"length":1,"stats":{"Line":2}},{"line":372,"address":[52838888],"length":1,"stats":{"Line":2}},{"line":373,"address":[52838938],"length":1,"stats":{"Line":2}},{"line":374,"address":[55038702],"length":1,"stats":{"Line":2}},{"line":375,"address":[55870864],"length":1,"stats":{"Line":2}},{"line":376,"address":[57382321],"length":1,"stats":{"Line":2}},{"line":377,"address":[57382371],"length":1,"stats":{"Line":2}},{"line":378,"address":[52839185],"length":1,"stats":{"Line":2}},{"line":379,"address":[52839232],"length":1,"stats":{"Line":3}},{"line":394,"address":[55039776],"length":1,"stats":{"Line":64}},{"line":403,"address":[57383104,57383275,57383269],"length":1,"stats":{"Line":23}},{"line":406,"address":[52839893],"length":1,"stats":{"Line":23}},{"line":414,"address":[52830000],"length":1,"stats":{"Line":2}},{"line":415,"address":[52830034],"length":1,"stats":{"Line":2}}],"covered":79,"coverable":85},{"path":["/","home","md","language","mdhavers","src","value.rs"],"content":"use std::cell::RefCell;\nuse std::collections::{HashMap, HashSet};\nuse std::fmt;\nuse std::rc::Rc;\n\nuse crate::ast::{Expr, Stmt};\n\n/// Runtime values in mdhavers\n#[derive(Debug, Clone)]\npub enum Value {\n    /// Integer number\n    Integer(i64),\n    /// Floating point number\n    Float(f64),\n    /// String\n    String(String),\n    /// Boolean (aye/nae)\n    Bool(bool),\n    /// Null value (naething)\n    Nil,\n    /// List/Array\n    List(Rc<RefCell<Vec<Value>>>),\n    /// Dictionary/Map\n    Dict(Rc<RefCell<HashMap<String, Value>>>),\n    /// Set (creel = basket/set in Scots)\n    Set(Rc<RefCell<HashSet<String>>>),\n    /// Function\n    Function(Rc<HaversFunction>),\n    /// Native/built-in function\n    NativeFunction(Rc<NativeFunction>),\n    /// Class\n    Class(Rc<HaversClass>),\n    /// Instance of a class\n    Instance(Rc<RefCell<HaversInstance>>),\n    /// Struct definition\n    Struct(Rc<HaversStruct>),\n    /// Range iterator\n    Range(RangeValue),\n}\n\nimpl Value {\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            Value::Integer(_) => \"integer\",\n            Value::Float(_) => \"float\",\n            Value::String(_) => \"string\",\n            Value::Bool(_) => \"bool\",\n            Value::Nil => \"naething\",\n            Value::List(_) => \"list\",\n            Value::Dict(_) => \"dict\",\n            Value::Set(_) => \"creel\",\n            Value::Function(_) => \"function\",\n            Value::NativeFunction(_) => \"native function\",\n            Value::Class(_) => \"class\",\n            Value::Instance(_) => \"instance\",\n            Value::Struct(_) => \"struct\",\n            Value::Range(_) => \"range\",\n        }\n    }\n\n    pub fn is_truthy(&self) -> bool {\n        match self {\n            Value::Bool(b) => *b,\n            Value::Nil => false,\n            Value::Integer(0) => false,\n            Value::Float(f) if *f == 0.0 => false,\n            Value::String(s) if s.is_empty() => false,\n            Value::List(l) if l.borrow().is_empty() => false,\n            Value::Set(s) if s.borrow().is_empty() => false,\n            _ => true,\n        }\n    }\n\n    pub fn as_integer(&self) -> Option<i64> {\n        match self {\n            Value::Integer(n) => Some(*n),\n            Value::Float(f) => Some(*f as i64),\n            _ => None,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn as_float(&self) -> Option<f64> {\n        match self {\n            Value::Float(f) => Some(*f),\n            Value::Integer(n) => Some(*n as f64),\n            _ => None,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn as_string(&self) -> Option<&str> {\n        match self {\n            Value::String(s) => Some(s),\n            _ => None,\n        }\n    }\n}\n\nimpl fmt::Display for Value {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Value::Integer(n) => write!(f, \"{}\", n),\n            Value::Float(n) => write!(f, \"{}\", n),\n            Value::String(s) => write!(f, \"{}\", s),\n            Value::Bool(true) => write!(f, \"aye\"),\n            Value::Bool(false) => write!(f, \"nae\"),\n            Value::Nil => write!(f, \"naething\"),\n            Value::List(items) => {\n                let items = items.borrow();\n                let strs: Vec<String> = items.iter().map(|v| format!(\"{}\", v)).collect();\n                write!(f, \"[{}]\", strs.join(\", \"))\n            }\n            Value::Dict(map) => {\n                let map = map.borrow();\n                let strs: Vec<String> = map\n                    .iter()\n                    .map(|(k, v)| format!(\"\\\"{}\\\": {}\", k, v))\n                    .collect();\n                write!(f, \"{{{}}}\", strs.join(\", \"))\n            }\n            Value::Set(set) => {\n                let set = set.borrow();\n                let mut strs: Vec<&String> = set.iter().collect();\n                strs.sort(); // Sort fer consistent display\n                write!(\n                    f,\n                    \"creel{{{}}}\",\n                    strs.iter()\n                        .map(|s| format!(\"\\\"{}\\\"\", s))\n                        .collect::<Vec<_>>()\n                        .join(\", \")\n                )\n            }\n            Value::Function(func) => write!(f, \"<dae {}>\", func.name),\n            Value::NativeFunction(func) => write!(f, \"<native dae {}>\", func.name),\n            Value::Class(class) => write!(f, \"<kin {}>\", class.name),\n            Value::Instance(inst) => write!(f, \"<{} instance>\", inst.borrow().class.name),\n            Value::Struct(s) => write!(f, \"<thing {}>\", s.name),\n            Value::Range(r) => write!(f, \"{}..{}\", r.start, r.end),\n        }\n    }\n}\n\nimpl PartialEq for Value {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (Value::Integer(a), Value::Integer(b)) => a == b,\n            (Value::Float(a), Value::Float(b)) => a == b,\n            (Value::Integer(a), Value::Float(b)) => (*a as f64) == *b,\n            (Value::Float(a), Value::Integer(b)) => *a == (*b as f64),\n            (Value::String(a), Value::String(b)) => a == b,\n            (Value::Bool(a), Value::Bool(b)) => a == b,\n            (Value::Nil, Value::Nil) => true,\n            (Value::List(a), Value::List(b)) => *a.borrow() == *b.borrow(),\n            _ => false,\n        }\n    }\n}\n\n/// A function parameter with optional default value (fer runtime)\n#[derive(Debug, Clone)]\npub struct FunctionParam {\n    pub name: String,\n    pub default: Option<Expr>,\n}\n\n/// A user-defined function\n#[derive(Debug)]\npub struct HaversFunction {\n    pub name: String,\n    pub params: Vec<FunctionParam>,\n    pub body: Vec<Stmt>,\n    pub closure: Option<Rc<RefCell<Environment>>>,\n}\n\nimpl HaversFunction {\n    pub fn new(\n        name: String,\n        params: Vec<FunctionParam>,\n        body: Vec<Stmt>,\n        closure: Option<Rc<RefCell<Environment>>>,\n    ) -> Self {\n        HaversFunction {\n            name,\n            params,\n            body,\n            closure,\n        }\n    }\n\n    /// Count the minimum number of required arguments (those wi'oot defaults)\n    pub fn min_arity(&self) -> usize {\n        self.params.iter().filter(|p| p.default.is_none()).count()\n    }\n\n    /// Maximum number of arguments (all params)\n    pub fn max_arity(&self) -> usize {\n        self.params.len()\n    }\n}\n\n/// A native/built-in function\npub struct NativeFunction {\n    pub name: String,\n    pub arity: usize,\n    pub func: Box<dyn Fn(Vec<Value>) -> Result<Value, String>>,\n}\n\nimpl NativeFunction {\n    pub fn new<F>(name: &str, arity: usize, func: F) -> Self\n    where\n        F: Fn(Vec<Value>) -> Result<Value, String> + 'static,\n    {\n        NativeFunction {\n            name: name.to_string(),\n            arity,\n            func: Box::new(func),\n        }\n    }\n}\n\nimpl fmt::Debug for NativeFunction {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"NativeFunction({})\", self.name)\n    }\n}\n\n/// A class definition\n#[derive(Debug)]\npub struct HaversClass {\n    pub name: String,\n    pub superclass: Option<Rc<HaversClass>>,\n    pub methods: HashMap<String, Rc<HaversFunction>>,\n}\n\nimpl HaversClass {\n    pub fn new(name: String, superclass: Option<Rc<HaversClass>>) -> Self {\n        HaversClass {\n            name,\n            superclass,\n            methods: HashMap::new(),\n        }\n    }\n\n    pub fn find_method(&self, name: &str) -> Option<Rc<HaversFunction>> {\n        if let Some(method) = self.methods.get(name) {\n            return Some(method.clone());\n        }\n        if let Some(superclass) = &self.superclass {\n            return superclass.find_method(name);\n        }\n        None\n    }\n}\n\n/// An instance of a class\n#[derive(Debug)]\npub struct HaversInstance {\n    pub class: Rc<HaversClass>,\n    pub fields: HashMap<String, Value>,\n}\n\nimpl HaversInstance {\n    pub fn new(class: Rc<HaversClass>) -> Self {\n        HaversInstance {\n            class,\n            fields: HashMap::new(),\n        }\n    }\n\n    pub fn get(&self, name: &str) -> Option<Value> {\n        if let Some(value) = self.fields.get(name) {\n            return Some(value.clone());\n        }\n        if let Some(method) = self.class.find_method(name) {\n            return Some(Value::Function(method));\n        }\n        None\n    }\n\n    pub fn set(&mut self, name: String, value: Value) {\n        self.fields.insert(name, value);\n    }\n}\n\n/// A struct definition\n#[derive(Debug)]\npub struct HaversStruct {\n    pub name: String,\n    pub fields: Vec<String>,\n}\n\nimpl HaversStruct {\n    pub fn new(name: String, fields: Vec<String>) -> Self {\n        HaversStruct { name, fields }\n    }\n}\n\n/// A range value\n#[derive(Debug, Clone)]\npub struct RangeValue {\n    pub start: i64,\n    pub end: i64,\n    pub inclusive: bool,\n}\n\nimpl RangeValue {\n    pub fn new(start: i64, end: i64, inclusive: bool) -> Self {\n        RangeValue {\n            start,\n            end,\n            inclusive,\n        }\n    }\n\n    pub fn iter(&self) -> RangeIterator {\n        RangeIterator {\n            current: self.start,\n            end: self.end,\n            inclusive: self.inclusive,\n        }\n    }\n}\n\npub struct RangeIterator {\n    current: i64,\n    end: i64,\n    inclusive: bool,\n}\n\nimpl Iterator for RangeIterator {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let should_yield = if self.inclusive {\n            self.current <= self.end\n        } else {\n            self.current < self.end\n        };\n\n        if should_yield {\n            let val = self.current;\n            self.current += 1;\n            Some(val)\n        } else {\n            None\n        }\n    }\n}\n\n/// Environment for variable bindings\n#[derive(Debug)]\npub struct Environment {\n    values: HashMap<String, Value>,\n    enclosing: Option<Rc<RefCell<Environment>>>,\n}\n\nimpl Environment {\n    pub fn new() -> Self {\n        Environment {\n            values: HashMap::new(),\n            enclosing: None,\n        }\n    }\n\n    pub fn with_enclosing(enclosing: Rc<RefCell<Environment>>) -> Self {\n        Environment {\n            values: HashMap::new(),\n            enclosing: Some(enclosing),\n        }\n    }\n\n    pub fn define(&mut self, name: String, value: Value) {\n        self.values.insert(name, value);\n    }\n\n    pub fn get(&self, name: &str) -> Option<Value> {\n        if let Some(value) = self.values.get(name) {\n            return Some(value.clone());\n        }\n        if let Some(enclosing) = &self.enclosing {\n            return enclosing.borrow().get(name);\n        }\n        None\n    }\n\n    pub fn assign(&mut self, name: &str, value: Value) -> bool {\n        if self.values.contains_key(name) {\n            self.values.insert(name.to_string(), value);\n            return true;\n        }\n        if let Some(enclosing) = &self.enclosing {\n            return enclosing.borrow_mut().assign(name, value);\n        }\n        false\n    }\n\n    /// Get all values defined in this environment (not including enclosing)\n    /// Used fer module exports\n    pub fn get_exports(&self) -> HashMap<String, Value> {\n        self.values.clone()\n    }\n}\n\nimpl Default for Environment {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\n#[allow(clippy::approx_constant)]\nmod tests {\n    use super::*;\n\n    // ==================== Value::type_name() Tests ====================\n\n    #[test]\n    fn test_value_type_name_all_types() {\n        assert_eq!(Value::Integer(42).type_name(), \"integer\");\n        assert_eq!(Value::Float(3.14).type_name(), \"float\");\n        assert_eq!(Value::String(\"hello\".to_string()).type_name(), \"string\");\n        assert_eq!(Value::Bool(true).type_name(), \"bool\");\n        assert_eq!(Value::Bool(false).type_name(), \"bool\");\n        assert_eq!(Value::Nil.type_name(), \"naething\");\n\n        let list = Value::List(Rc::new(RefCell::new(vec![Value::Integer(1)])));\n        assert_eq!(list.type_name(), \"list\");\n\n        let dict = Value::Dict(Rc::new(RefCell::new(HashMap::new())));\n        assert_eq!(dict.type_name(), \"dict\");\n\n        let set = Value::Set(Rc::new(RefCell::new(HashSet::new())));\n        assert_eq!(set.type_name(), \"creel\");\n\n        let func = HaversFunction::new(\"test\".to_string(), vec![], vec![], None);\n        assert_eq!(Value::Function(Rc::new(func)).type_name(), \"function\");\n\n        let native = NativeFunction::new(\"native\", 0, |_| Ok(Value::Nil));\n        assert_eq!(\n            Value::NativeFunction(Rc::new(native)).type_name(),\n            \"native function\"\n        );\n\n        let class = HaversClass::new(\"TestClass\".to_string(), None);\n        assert_eq!(Value::Class(Rc::new(class)).type_name(), \"class\");\n\n        let class2 = Rc::new(HaversClass::new(\"TestClass\".to_string(), None));\n        let instance = HaversInstance::new(class2);\n        assert_eq!(\n            Value::Instance(Rc::new(RefCell::new(instance))).type_name(),\n            \"instance\"\n        );\n\n        let strct = HaversStruct::new(\"TestStruct\".to_string(), vec![]);\n        assert_eq!(Value::Struct(Rc::new(strct)).type_name(), \"struct\");\n\n        let range = RangeValue::new(0, 10, false);\n        assert_eq!(Value::Range(range).type_name(), \"range\");\n    }\n\n    // ==================== Value::is_truthy() Tests ====================\n\n    #[test]\n    fn test_value_is_truthy() {\n        // Booleans\n        assert!(Value::Bool(true).is_truthy());\n        assert!(!Value::Bool(false).is_truthy());\n\n        // Nil is always falsy\n        assert!(!Value::Nil.is_truthy());\n\n        // Integer 0 is falsy, others truthy\n        assert!(!Value::Integer(0).is_truthy());\n        assert!(Value::Integer(1).is_truthy());\n        assert!(Value::Integer(-1).is_truthy());\n        assert!(Value::Integer(42).is_truthy());\n\n        // Float 0.0 is falsy, others truthy\n        assert!(!Value::Float(0.0).is_truthy());\n        assert!(Value::Float(0.1).is_truthy());\n        assert!(Value::Float(-0.1).is_truthy());\n        assert!(Value::Float(3.14).is_truthy());\n\n        // Empty string is falsy, non-empty truthy\n        assert!(!Value::String(\"\".to_string()).is_truthy());\n        assert!(Value::String(\"hello\".to_string()).is_truthy());\n        assert!(Value::String(\" \".to_string()).is_truthy());\n\n        // Empty list is falsy, non-empty truthy\n        let empty_list = Value::List(Rc::new(RefCell::new(vec![])));\n        let non_empty_list = Value::List(Rc::new(RefCell::new(vec![Value::Integer(1)])));\n        assert!(!empty_list.is_truthy());\n        assert!(non_empty_list.is_truthy());\n\n        // Empty set is falsy, non-empty truthy\n        let empty_set = Value::Set(Rc::new(RefCell::new(HashSet::new())));\n        let mut non_empty = HashSet::new();\n        non_empty.insert(\"item\".to_string());\n        let non_empty_set = Value::Set(Rc::new(RefCell::new(non_empty)));\n        assert!(!empty_set.is_truthy());\n        assert!(non_empty_set.is_truthy());\n\n        // Dict is always truthy (even if empty - default case)\n        let empty_dict = Value::Dict(Rc::new(RefCell::new(HashMap::new())));\n        assert!(empty_dict.is_truthy());\n\n        // Functions are truthy\n        let func = HaversFunction::new(\"test\".to_string(), vec![], vec![], None);\n        assert!(Value::Function(Rc::new(func)).is_truthy());\n\n        // Classes and instances are truthy\n        let class = Rc::new(HaversClass::new(\"Test\".to_string(), None));\n        assert!(Value::Class(class.clone()).is_truthy());\n        let instance = HaversInstance::new(class);\n        assert!(Value::Instance(Rc::new(RefCell::new(instance))).is_truthy());\n    }\n\n    // ==================== Value::as_* Conversion Tests ====================\n\n    #[test]\n    fn test_value_as_integer() {\n        assert_eq!(Value::Integer(42).as_integer(), Some(42));\n        assert_eq!(Value::Float(3.7).as_integer(), Some(3)); // truncates\n        assert_eq!(Value::Float(3.2).as_integer(), Some(3));\n        assert_eq!(Value::String(\"hello\".to_string()).as_integer(), None);\n        assert_eq!(Value::Bool(true).as_integer(), None);\n        assert_eq!(Value::Nil.as_integer(), None);\n    }\n\n    #[test]\n    fn test_value_as_float() {\n        assert_eq!(Value::Float(3.14).as_float(), Some(3.14));\n        assert_eq!(Value::Integer(42).as_float(), Some(42.0));\n        assert_eq!(Value::String(\"hello\".to_string()).as_float(), None);\n        assert_eq!(Value::Bool(true).as_float(), None);\n        assert_eq!(Value::Nil.as_float(), None);\n    }\n\n    #[test]\n    fn test_value_as_string() {\n        assert_eq!(\n            Value::String(\"hello\".to_string()).as_string(),\n            Some(\"hello\")\n        );\n        assert_eq!(Value::Integer(42).as_string(), None);\n        assert_eq!(Value::Float(3.14).as_string(), None);\n        assert_eq!(Value::Bool(true).as_string(), None);\n        assert_eq!(Value::Nil.as_string(), None);\n    }\n\n    // ==================== Value Display Tests ====================\n\n    #[test]\n    fn test_value_display_primitives() {\n        assert_eq!(format!(\"{}\", Value::Integer(42)), \"42\");\n        assert_eq!(format!(\"{}\", Value::Integer(-123)), \"-123\");\n        assert_eq!(format!(\"{}\", Value::Float(3.14)), \"3.14\");\n        assert_eq!(format!(\"{}\", Value::String(\"hello\".to_string())), \"hello\");\n        assert_eq!(format!(\"{}\", Value::Bool(true)), \"aye\");\n        assert_eq!(format!(\"{}\", Value::Bool(false)), \"nae\");\n        assert_eq!(format!(\"{}\", Value::Nil), \"naething\");\n    }\n\n    #[test]\n    fn test_value_display_list() {\n        let empty = Value::List(Rc::new(RefCell::new(vec![])));\n        assert_eq!(format!(\"{}\", empty), \"[]\");\n\n        let single = Value::List(Rc::new(RefCell::new(vec![Value::Integer(42)])));\n        assert_eq!(format!(\"{}\", single), \"[42]\");\n\n        let multi = Value::List(Rc::new(RefCell::new(vec![\n            Value::Integer(1),\n            Value::Integer(2),\n            Value::Integer(3),\n        ])));\n        assert_eq!(format!(\"{}\", multi), \"[1, 2, 3]\");\n\n        // Nested list\n        let inner = Value::List(Rc::new(RefCell::new(vec![\n            Value::Integer(1),\n            Value::Integer(2),\n        ])));\n        let outer = Value::List(Rc::new(RefCell::new(vec![inner, Value::Integer(3)])));\n        assert_eq!(format!(\"{}\", outer), \"[[1, 2], 3]\");\n    }\n\n    #[test]\n    fn test_value_display_dict() {\n        let empty = Value::Dict(Rc::new(RefCell::new(HashMap::new())));\n        assert_eq!(format!(\"{}\", empty), \"{}\");\n\n        let mut map = HashMap::new();\n        map.insert(\"a\".to_string(), Value::Integer(1));\n        let single = Value::Dict(Rc::new(RefCell::new(map)));\n        assert_eq!(format!(\"{}\", single), \"{\\\"a\\\": 1}\");\n    }\n\n    #[test]\n    fn test_value_display_set() {\n        let empty = Value::Set(Rc::new(RefCell::new(HashSet::new())));\n        assert_eq!(format!(\"{}\", empty), \"creel{}\");\n\n        let mut set = HashSet::new();\n        set.insert(\"a\".to_string());\n        let single = Value::Set(Rc::new(RefCell::new(set)));\n        assert_eq!(format!(\"{}\", single), \"creel{\\\"a\\\"}\");\n\n        let mut multi_set = HashSet::new();\n        multi_set.insert(\"a\".to_string());\n        multi_set.insert(\"b\".to_string());\n        let multi = Value::Set(Rc::new(RefCell::new(multi_set)));\n        // Sorted output\n        assert_eq!(format!(\"{}\", multi), \"creel{\\\"a\\\", \\\"b\\\"}\");\n    }\n\n    #[test]\n    fn test_value_display_function() {\n        let func = HaversFunction::new(\"add\".to_string(), vec![], vec![], None);\n        let val = Value::Function(Rc::new(func));\n        assert_eq!(format!(\"{}\", val), \"<dae add>\");\n    }\n\n    #[test]\n    fn test_value_display_native_function() {\n        let native = NativeFunction::new(\"len\", 1, |_| Ok(Value::Nil));\n        let val = Value::NativeFunction(Rc::new(native));\n        assert_eq!(format!(\"{}\", val), \"<native dae len>\");\n    }\n\n    #[test]\n    fn test_value_display_class() {\n        let class = HaversClass::new(\"Person\".to_string(), None);\n        let val = Value::Class(Rc::new(class));\n        assert_eq!(format!(\"{}\", val), \"<kin Person>\");\n    }\n\n    #[test]\n    fn test_value_display_instance() {\n        let class = Rc::new(HaversClass::new(\"Dog\".to_string(), None));\n        let instance = HaversInstance::new(class);\n        let val = Value::Instance(Rc::new(RefCell::new(instance)));\n        assert_eq!(format!(\"{}\", val), \"<Dog instance>\");\n    }\n\n    #[test]\n    fn test_value_display_struct() {\n        let strct = HaversStruct::new(\"Point\".to_string(), vec![\"x\".to_string(), \"y\".to_string()]);\n        let val = Value::Struct(Rc::new(strct));\n        assert_eq!(format!(\"{}\", val), \"<thing Point>\");\n    }\n\n    #[test]\n    fn test_value_display_range() {\n        let range = RangeValue::new(0, 10, false);\n        let val = Value::Range(range);\n        assert_eq!(format!(\"{}\", val), \"0..10\");\n\n        let inclusive = RangeValue::new(1, 5, true);\n        let val2 = Value::Range(inclusive);\n        assert_eq!(format!(\"{}\", val2), \"1..5\");\n    }\n\n    // ==================== Value PartialEq Tests ====================\n\n    #[test]\n    fn test_value_equality_integers() {\n        assert_eq!(Value::Integer(42), Value::Integer(42));\n        assert_ne!(Value::Integer(42), Value::Integer(43));\n    }\n\n    #[test]\n    fn test_value_equality_floats() {\n        assert_eq!(Value::Float(3.14), Value::Float(3.14));\n        assert_ne!(Value::Float(3.14), Value::Float(3.15));\n    }\n\n    #[test]\n    fn test_value_equality_mixed_numeric() {\n        assert_eq!(Value::Integer(42), Value::Float(42.0));\n        assert_eq!(Value::Float(42.0), Value::Integer(42));\n        assert_ne!(Value::Integer(42), Value::Float(42.5));\n    }\n\n    #[test]\n    fn test_value_equality_strings() {\n        assert_eq!(\n            Value::String(\"hello\".to_string()),\n            Value::String(\"hello\".to_string())\n        );\n        assert_ne!(\n            Value::String(\"hello\".to_string()),\n            Value::String(\"world\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_value_equality_bools() {\n        assert_eq!(Value::Bool(true), Value::Bool(true));\n        assert_eq!(Value::Bool(false), Value::Bool(false));\n        assert_ne!(Value::Bool(true), Value::Bool(false));\n    }\n\n    #[test]\n    fn test_value_equality_nil() {\n        assert_eq!(Value::Nil, Value::Nil);\n    }\n\n    #[test]\n    fn test_value_equality_lists() {\n        let list1 = Value::List(Rc::new(RefCell::new(vec![\n            Value::Integer(1),\n            Value::Integer(2),\n        ])));\n        let list2 = Value::List(Rc::new(RefCell::new(vec![\n            Value::Integer(1),\n            Value::Integer(2),\n        ])));\n        let list3 = Value::List(Rc::new(RefCell::new(vec![\n            Value::Integer(1),\n            Value::Integer(3),\n        ])));\n\n        assert_eq!(list1, list2);\n        assert_ne!(list1, list3);\n    }\n\n    #[test]\n    fn test_value_equality_different_types() {\n        assert_ne!(Value::Integer(42), Value::String(\"42\".to_string()));\n        assert_ne!(Value::Bool(true), Value::Integer(1));\n        assert_ne!(Value::Nil, Value::Integer(0));\n        assert_ne!(Value::Nil, Value::Bool(false));\n    }\n\n    // ==================== FunctionParam Tests ====================\n\n    #[test]\n    fn test_function_param() {\n        let param_no_default = FunctionParam {\n            name: \"x\".to_string(),\n            default: None,\n        };\n        assert_eq!(param_no_default.name, \"x\");\n        assert!(param_no_default.default.is_none());\n    }\n\n    // ==================== HaversFunction Tests ====================\n\n    #[test]\n    fn test_havers_function_new() {\n        let func = HaversFunction::new(\"test\".to_string(), vec![], vec![], None);\n        assert_eq!(func.name, \"test\");\n        assert!(func.params.is_empty());\n        assert!(func.body.is_empty());\n        assert!(func.closure.is_none());\n    }\n\n    #[test]\n    fn test_havers_function_arity_no_defaults() {\n        let params = vec![\n            FunctionParam {\n                name: \"a\".to_string(),\n                default: None,\n            },\n            FunctionParam {\n                name: \"b\".to_string(),\n                default: None,\n            },\n            FunctionParam {\n                name: \"c\".to_string(),\n                default: None,\n            },\n        ];\n        let func = HaversFunction::new(\"add\".to_string(), params, vec![], None);\n        assert_eq!(func.min_arity(), 3);\n        assert_eq!(func.max_arity(), 3);\n    }\n\n    #[test]\n    fn test_havers_function_arity_with_defaults() {\n        use crate::ast::{Expr, Literal, Span};\n\n        let default_expr = Expr::Literal {\n            value: Literal::Integer(0),\n            span: Span::new(1, 1),\n        };\n        let params = vec![\n            FunctionParam {\n                name: \"a\".to_string(),\n                default: None,\n            },\n            FunctionParam {\n                name: \"b\".to_string(),\n                default: Some(default_expr.clone()),\n            },\n            FunctionParam {\n                name: \"c\".to_string(),\n                default: Some(default_expr),\n            },\n        ];\n        let func = HaversFunction::new(\"test\".to_string(), params, vec![], None);\n        assert_eq!(func.min_arity(), 1); // Only 'a' required\n        assert_eq!(func.max_arity(), 3); // All three can be provided\n    }\n\n    #[test]\n    fn test_havers_function_with_closure() {\n        let env = Rc::new(RefCell::new(Environment::new()));\n        env.borrow_mut().define(\"x\".to_string(), Value::Integer(42));\n\n        let func = HaversFunction::new(\n            \"closure_test\".to_string(),\n            vec![],\n            vec![],\n            Some(env.clone()),\n        );\n        assert!(func.closure.is_some());\n    }\n\n    // ==================== NativeFunction Tests ====================\n\n    #[test]\n    fn test_native_function_new() {\n        let native = NativeFunction::new(\"len\", 1, |args| {\n            if let Value::String(s) = &args[0] {\n                Ok(Value::Integer(s.len() as i64))\n            } else {\n                Err(\"Expected string\".to_string())\n            }\n        });\n        assert_eq!(native.name, \"len\");\n        assert_eq!(native.arity, 1);\n    }\n\n    #[test]\n    fn test_native_function_call() {\n        let native = NativeFunction::new(\"double\", 1, |args| {\n            if let Value::Integer(n) = &args[0] {\n                Ok(Value::Integer(n * 2))\n            } else {\n                Err(\"Expected integer\".to_string())\n            }\n        });\n\n        let result = (native.func)(vec![Value::Integer(21)]);\n        assert_eq!(result, Ok(Value::Integer(42)));\n\n        let error = (native.func)(vec![Value::String(\"x\".to_string())]);\n        assert!(error.is_err());\n    }\n\n    #[test]\n    fn test_native_function_debug() {\n        let native = NativeFunction::new(\"test\", 0, |_| Ok(Value::Nil));\n        let debug_str = format!(\"{:?}\", native);\n        assert_eq!(debug_str, \"NativeFunction(test)\");\n    }\n\n    // ==================== HaversClass Tests ====================\n\n    #[test]\n    fn test_havers_class_new() {\n        let class = HaversClass::new(\"Animal\".to_string(), None);\n        assert_eq!(class.name, \"Animal\");\n        assert!(class.superclass.is_none());\n        assert!(class.methods.is_empty());\n    }\n\n    #[test]\n    fn test_havers_class_with_methods() {\n        let mut class = HaversClass::new(\"Calculator\".to_string(), None);\n        let method = Rc::new(HaversFunction::new(\"add\".to_string(), vec![], vec![], None));\n        class.methods.insert(\"add\".to_string(), method);\n\n        assert!(class.find_method(\"add\").is_some());\n        assert!(class.find_method(\"subtract\").is_none());\n    }\n\n    #[test]\n    fn test_havers_class_inheritance() {\n        // Parent class with a method\n        let mut parent = HaversClass::new(\"Animal\".to_string(), None);\n        let speak = Rc::new(HaversFunction::new(\n            \"speak\".to_string(),\n            vec![],\n            vec![],\n            None,\n        ));\n        parent.methods.insert(\"speak\".to_string(), speak);\n        let parent_rc = Rc::new(parent);\n\n        // Child class inheriting from parent\n        let child = HaversClass::new(\"Dog\".to_string(), Some(parent_rc));\n\n        // Child should find parent's method\n        assert!(child.find_method(\"speak\").is_some());\n        assert!(child.find_method(\"nonexistent\").is_none());\n    }\n\n    #[test]\n    fn test_havers_class_method_override() {\n        // Parent class\n        let mut parent = HaversClass::new(\"Parent\".to_string(), None);\n        let parent_method = Rc::new(HaversFunction::new(\n            \"greet\".to_string(),\n            vec![],\n            vec![],\n            None,\n        ));\n        parent.methods.insert(\"greet\".to_string(), parent_method);\n        let parent_rc = Rc::new(parent);\n\n        // Child class with overridden method\n        let mut child = HaversClass::new(\"Child\".to_string(), Some(parent_rc));\n        let child_method = Rc::new(HaversFunction::new(\n            \"greet_child\".to_string(),\n            vec![],\n            vec![],\n            None,\n        ));\n        child.methods.insert(\"greet\".to_string(), child_method);\n\n        // Child's method should take precedence\n        let found = child.find_method(\"greet\").unwrap();\n        assert_eq!(found.name, \"greet_child\");\n    }\n\n    // ==================== HaversInstance Tests ====================\n\n    #[test]\n    fn test_havers_instance_new() {\n        let class = Rc::new(HaversClass::new(\"Person\".to_string(), None));\n        let instance = HaversInstance::new(class.clone());\n        assert_eq!(instance.class.name, \"Person\");\n        assert!(instance.fields.is_empty());\n    }\n\n    #[test]\n    fn test_havers_instance_set_get() {\n        let class = Rc::new(HaversClass::new(\"Person\".to_string(), None));\n        let mut instance = HaversInstance::new(class);\n\n        instance.set(\"name\".to_string(), Value::String(\"Alice\".to_string()));\n        instance.set(\"age\".to_string(), Value::Integer(30));\n\n        assert_eq!(\n            instance.get(\"name\"),\n            Some(Value::String(\"Alice\".to_string()))\n        );\n        assert_eq!(instance.get(\"age\"), Some(Value::Integer(30)));\n        assert_eq!(instance.get(\"nonexistent\"), None);\n    }\n\n    #[test]\n    fn test_havers_instance_get_method() {\n        let mut class = HaversClass::new(\"Calculator\".to_string(), None);\n        let method = Rc::new(HaversFunction::new(\n            \"calculate\".to_string(),\n            vec![],\n            vec![],\n            None,\n        ));\n        class.methods.insert(\"calculate\".to_string(), method);\n        let class_rc = Rc::new(class);\n\n        let instance = HaversInstance::new(class_rc);\n\n        // Should find method through class\n        let found = instance.get(\"calculate\");\n        assert!(found.is_some());\n        if let Some(Value::Function(f)) = found {\n            assert_eq!(f.name, \"calculate\");\n        } else {\n            panic!(\"Expected function\");\n        }\n    }\n\n    #[test]\n    fn test_havers_instance_field_shadows_method() {\n        let mut class = HaversClass::new(\"Test\".to_string(), None);\n        let method = Rc::new(HaversFunction::new(\n            \"value\".to_string(),\n            vec![],\n            vec![],\n            None,\n        ));\n        class.methods.insert(\"value\".to_string(), method);\n        let class_rc = Rc::new(class);\n\n        let mut instance = HaversInstance::new(class_rc);\n\n        // Before setting field, get returns method\n        let before = instance.get(\"value\");\n        assert!(matches!(before, Some(Value::Function(_))));\n\n        // After setting field, field takes precedence\n        instance.set(\"value\".to_string(), Value::Integer(42));\n        let after = instance.get(\"value\");\n        assert_eq!(after, Some(Value::Integer(42)));\n    }\n\n    // ==================== HaversStruct Tests ====================\n\n    #[test]\n    fn test_havers_struct_new() {\n        let strct = HaversStruct::new(\"Point\".to_string(), vec![\"x\".to_string(), \"y\".to_string()]);\n        assert_eq!(strct.name, \"Point\");\n        assert_eq!(strct.fields, vec![\"x\", \"y\"]);\n    }\n\n    #[test]\n    fn test_havers_struct_empty_fields() {\n        let strct = HaversStruct::new(\"Empty\".to_string(), vec![]);\n        assert_eq!(strct.name, \"Empty\");\n        assert!(strct.fields.is_empty());\n    }\n\n    // ==================== RangeValue Tests ====================\n\n    #[test]\n    fn test_range_value_new() {\n        let range = RangeValue::new(0, 10, false);\n        assert_eq!(range.start, 0);\n        assert_eq!(range.end, 10);\n        assert!(!range.inclusive);\n\n        let inclusive = RangeValue::new(1, 5, true);\n        assert!(inclusive.inclusive);\n    }\n\n    #[test]\n    fn test_range_iterator_exclusive() {\n        let range = RangeValue::new(0, 5, false);\n        let values: Vec<i64> = range.iter().collect();\n        assert_eq!(values, vec![0, 1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_range_iterator_inclusive() {\n        let range = RangeValue::new(0, 5, true);\n        let values: Vec<i64> = range.iter().collect();\n        assert_eq!(values, vec![0, 1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_range_iterator_empty() {\n        // Exclusive range where start == end\n        let range = RangeValue::new(5, 5, false);\n        let values: Vec<i64> = range.iter().collect();\n        assert!(values.is_empty());\n    }\n\n    #[test]\n    fn test_range_iterator_single_inclusive() {\n        // Inclusive range where start == end\n        let range = RangeValue::new(5, 5, true);\n        let values: Vec<i64> = range.iter().collect();\n        assert_eq!(values, vec![5]);\n    }\n\n    #[test]\n    fn test_range_iterator_negative() {\n        let range = RangeValue::new(-3, 2, false);\n        let values: Vec<i64> = range.iter().collect();\n        assert_eq!(values, vec![-3, -2, -1, 0, 1]);\n    }\n\n    // ==================== Environment Tests ====================\n\n    #[test]\n    fn test_environment_new() {\n        let env = Environment::new();\n        assert!(env.enclosing.is_none());\n    }\n\n    #[test]\n    fn test_environment_default() {\n        let env = Environment::default();\n        assert!(env.enclosing.is_none());\n    }\n\n    #[test]\n    fn test_environment_define_get() {\n        let mut env = Environment::new();\n        env.define(\"x\".to_string(), Value::Integer(42));\n\n        assert_eq!(env.get(\"x\"), Some(Value::Integer(42)));\n        assert_eq!(env.get(\"y\"), None);\n    }\n\n    #[test]\n    fn test_environment_with_enclosing() {\n        let outer = Rc::new(RefCell::new(Environment::new()));\n        outer\n            .borrow_mut()\n            .define(\"outer_var\".to_string(), Value::Integer(1));\n\n        let inner = Environment::with_enclosing(outer.clone());\n\n        // Inner should find outer's variable\n        assert_eq!(inner.get(\"outer_var\"), Some(Value::Integer(1)));\n        assert_eq!(inner.get(\"nonexistent\"), None);\n    }\n\n    #[test]\n    fn test_environment_shadowing() {\n        let outer = Rc::new(RefCell::new(Environment::new()));\n        outer\n            .borrow_mut()\n            .define(\"x\".to_string(), Value::Integer(1));\n\n        let mut inner = Environment::with_enclosing(outer.clone());\n        inner.define(\"x\".to_string(), Value::Integer(2));\n\n        // Inner's x shadows outer's x\n        assert_eq!(inner.get(\"x\"), Some(Value::Integer(2)));\n        // Outer's x unchanged\n        assert_eq!(outer.borrow().get(\"x\"), Some(Value::Integer(1)));\n    }\n\n    #[test]\n    fn test_environment_assign_local() {\n        let mut env = Environment::new();\n        env.define(\"x\".to_string(), Value::Integer(1));\n\n        let result = env.assign(\"x\", Value::Integer(2));\n        assert!(result);\n        assert_eq!(env.get(\"x\"), Some(Value::Integer(2)));\n    }\n\n    #[test]\n    fn test_environment_assign_nonexistent() {\n        let mut env = Environment::new();\n\n        let result = env.assign(\"x\", Value::Integer(1));\n        assert!(!result);\n        assert_eq!(env.get(\"x\"), None);\n    }\n\n    #[test]\n    fn test_environment_assign_enclosing() {\n        let outer = Rc::new(RefCell::new(Environment::new()));\n        outer\n            .borrow_mut()\n            .define(\"x\".to_string(), Value::Integer(1));\n\n        let mut inner = Environment::with_enclosing(outer.clone());\n\n        // Assign to outer's variable from inner\n        let result = inner.assign(\"x\", Value::Integer(2));\n        assert!(result);\n\n        // Both should see the new value\n        assert_eq!(inner.get(\"x\"), Some(Value::Integer(2)));\n        assert_eq!(outer.borrow().get(\"x\"), Some(Value::Integer(2)));\n    }\n\n    #[test]\n    fn test_environment_get_exports() {\n        let mut env = Environment::new();\n        env.define(\"a\".to_string(), Value::Integer(1));\n        env.define(\"b\".to_string(), Value::Integer(2));\n\n        let exports = env.get_exports();\n        assert_eq!(exports.len(), 2);\n        assert_eq!(exports.get(\"a\"), Some(&Value::Integer(1)));\n        assert_eq!(exports.get(\"b\"), Some(&Value::Integer(2)));\n    }\n\n    #[test]\n    fn test_environment_get_exports_excludes_enclosing() {\n        let outer = Rc::new(RefCell::new(Environment::new()));\n        outer\n            .borrow_mut()\n            .define(\"outer\".to_string(), Value::Integer(1));\n\n        let mut inner = Environment::with_enclosing(outer);\n        inner.define(\"inner\".to_string(), Value::Integer(2));\n\n        let exports = inner.get_exports();\n        assert_eq!(exports.len(), 1);\n        assert!(exports.contains_key(\"inner\"));\n        assert!(!exports.contains_key(\"outer\"));\n    }\n}\n","traces":[{"line":42,"address":[55807808],"length":1,"stats":{"Line":3}},{"line":43,"address":[55615893],"length":1,"stats":{"Line":3}},{"line":44,"address":[55807844],"length":1,"stats":{"Line":3}},{"line":45,"address":[55615950],"length":1,"stats":{"Line":4}},{"line":46,"address":[55615976],"length":1,"stats":{"Line":3}},{"line":47,"address":[54975810],"length":1,"stats":{"Line":3}},{"line":48,"address":[54473292],"length":1,"stats":{"Line":2}},{"line":49,"address":[55616054],"length":1,"stats":{"Line":3}},{"line":50,"address":[54473344],"length":1,"stats":{"Line":2}},{"line":51,"address":[55616106],"length":1,"stats":{"Line":2}},{"line":52,"address":[55616132],"length":1,"stats":{"Line":2}},{"line":53,"address":[54975963],"length":1,"stats":{"Line":2}},{"line":54,"address":[55616178],"length":1,"stats":{"Line":2}},{"line":55,"address":[54976009],"length":1,"stats":{"Line":2}},{"line":56,"address":[55616224],"length":1,"stats":{"Line":2}},{"line":57,"address":[54976055],"length":1,"stats":{"Line":2}},{"line":61,"address":[54975571,54975024,54975577],"length":1,"stats":{"Line":4}},{"line":62,"address":[54975041,54975091],"length":1,"stats":{"Line":9}},{"line":63,"address":[54472716],"length":1,"stats":{"Line":4}},{"line":64,"address":[54975257],"length":1,"stats":{"Line":2}},{"line":66,"address":[55615339],"length":1,"stats":{"Line":2}},{"line":67,"address":[55615402],"length":1,"stats":{"Line":3}},{"line":68,"address":[55615674,55615496],"length":1,"stats":{"Line":3}},{"line":69,"address":[55615578,55615785],"length":1,"stats":{"Line":2}},{"line":70,"address":[55807188],"length":1,"stats":{"Line":3}},{"line":74,"address":[55614768],"length":1,"stats":{"Line":3}},{"line":75,"address":[55614778],"length":1,"stats":{"Line":3}},{"line":76,"address":[55614822],"length":1,"stats":{"Line":6}},{"line":77,"address":[54974635],"length":1,"stats":{"Line":2}},{"line":78,"address":[55614806],"length":1,"stats":{"Line":2}},{"line":83,"address":[55806912],"length":1,"stats":{"Line":2}},{"line":84,"address":[54472298],"length":1,"stats":{"Line":2}},{"line":85,"address":[55615118],"length":1,"stats":{"Line":2}},{"line":86,"address":[54472342],"length":1,"stats":{"Line":2}},{"line":87,"address":[55615062],"length":1,"stats":{"Line":2}},{"line":92,"address":[54472432],"length":1,"stats":{"Line":2}},{"line":93,"address":[54472445],"length":1,"stats":{"Line":2}},{"line":94,"address":[54974970],"length":1,"stats":{"Line":2}},{"line":95,"address":[54974996],"length":1,"stats":{"Line":2}},{"line":101,"address":[55799523,55799529,55797056],"length":1,"stats":{"Line":4}},{"line":102,"address":[55606016,55605559],"length":1,"stats":{"Line":7}},{"line":103,"address":[55605604],"length":1,"stats":{"Line":3}},{"line":104,"address":[54965166],"length":1,"stats":{"Line":3}},{"line":105,"address":[54965304],"length":1,"stats":{"Line":3}},{"line":106,"address":[55798837],"length":1,"stats":{"Line":3}},{"line":107,"address":[55607194],"length":1,"stats":{"Line":3}},{"line":108,"address":[54965457],"length":1,"stats":{"Line":3}},{"line":109,"address":[55797633],"length":1,"stats":{"Line":4}},{"line":110,"address":[54463372],"length":1,"stats":{"Line":4}},{"line":111,"address":[54966830,54965577],"length":1,"stats":{"Line":16}},{"line":112,"address":[54464840,54464943,54464745],"length":1,"stats":{"Line":12}},{"line":114,"address":[54463442],"length":1,"stats":{"Line":3}},{"line":115,"address":[55797739],"length":1,"stats":{"Line":5}},{"line":116,"address":[55606233],"length":1,"stats":{"Line":5}},{"line":118,"address":[54664448,54664489],"length":1,"stats":{"Line":15}},{"line":120,"address":[55608216,55608113,55608030],"length":1,"stats":{"Line":15}},{"line":122,"address":[54463524],"length":1,"stats":{"Line":10}},{"line":123,"address":[55606271],"length":1,"stats":{"Line":9}},{"line":124,"address":[55797877,55800134],"length":1,"stats":{"Line":20}},{"line":125,"address":[55800180,55800263],"length":1,"stats":{"Line":21}},{"line":126,"address":[55608884,55608820],"length":1,"stats":{"Line":16}},{"line":129,"address":[54968282,54968162],"length":1,"stats":{"Line":19}},{"line":130,"address":[54465932],"length":1,"stats":{"Line":38}},{"line":131,"address":[55608702],"length":1,"stats":{"Line":10}},{"line":132,"address":[55608788],"length":1,"stats":{"Line":7}},{"line":135,"address":[55606341],"length":1,"stats":{"Line":5}},{"line":136,"address":[54965942],"length":1,"stats":{"Line":2}},{"line":137,"address":[55606617],"length":1,"stats":{"Line":2}},{"line":138,"address":[54464020,54466452],"length":1,"stats":{"Line":3}},{"line":139,"address":[54966314],"length":1,"stats":{"Line":2}},{"line":140,"address":[54464240],"length":1,"stats":{"Line":2}},{"line":146,"address":[54466640,54467625,54467619],"length":1,"stats":{"Line":3}},{"line":147,"address":[54969025,54969075],"length":1,"stats":{"Line":7}},{"line":148,"address":[55801366],"length":1,"stats":{"Line":9}},{"line":149,"address":[54969456],"length":1,"stats":{"Line":4}},{"line":150,"address":[55801418],"length":1,"stats":{"Line":2}},{"line":151,"address":[54969385],"length":1,"stats":{"Line":2}},{"line":152,"address":[54969517],"length":1,"stats":{"Line":3}},{"line":153,"address":[54467231],"length":1,"stats":{"Line":2}},{"line":155,"address":[55801763],"length":1,"stats":{"Line":2}},{"line":156,"address":[54969060],"length":1,"stats":{"Line":3}},{"line":178,"address":[54471328],"length":1,"stats":{"Line":4}},{"line":193,"address":[54973936],"length":1,"stats":{"Line":3}},{"line":194,"address":[55806053],"length":1,"stats":{"Line":9}},{"line":198,"address":[55806016],"length":1,"stats":{"Line":3}},{"line":199,"address":[55614165],"length":1,"stats":{"Line":3}},{"line":211,"address":[53498281,53522995,53525904,53517024,53496595,53506195,53474995,53500681,53516304,53476704,53475481,53527801,53484835,53488435,53493715,53532841,53533321,53527081,53533584,53501881,53514864,53519664,53525875,53511475,53474304,53504761,53512675,53517955,53488441,53519424,53522064,53490144,53499715,53528521,53475001,53532144,53510041,53533104,53493264,53533801,53498755,53504544,53506681,53514121,53521344,53521561,53516515,53533795,53516035,53528995,53534515,53483641,53477881,53476224,53507664,53504995,53501641,53514595,53492995,53492064,53508361,53474544,53499481,53482195,53508864,53516761,53524224,53503344,53527561,53529984,53484384,53509584,53507395,53503081,53530201,53533315,53492304,53510035,53511235,53521315,53518704,53495424,53485321,53507401,53520115,53531635,53513664,53521555,53529744,53513641,53484355,53491795,53489904,53498064,53518464,53481721,53512441,53523001,53504275,53490355,53505001,53481955,53472841,53530915,53474755,53498521,53507881,53478361,53508144,53514835,53506915,53498041,53524704,53479795,53483155,53498544,53505024,53515344,53471155,53486995,53484601,53508601,53513635,53515801,53531395,53493744,53485561,53521321,53506921,53491584,53512435,53497315,53530464,53528275,53519904,53474521,53529481,53475955,53521104,53520841,53516755,53529241,53515315,53520864,53471635,53494921,53492281,53485344,53503561,53480995,53505984,53519395,53516281,53497081,53499504,53480515,53519875,53503555,53471395,53487024,53499024,53512681,53498275,53525424,53477155,53527555,53508355,53518915,53529024,53473344,53481235,53514624,53520121,53504515,53507635,53504755,53523024,53483184,53522035,53483424,53494704,53500195,53530704,53513155,53483881,53482675,53527104,53528761,53488224,53476441,53473801,53497321,53471424,53498035,53499984,53504304,53487241,53497795,53486521,53517475,53480304,53490121,53496624,53505961,53524921,53530675,53525635,53474035,53480275,53486761,53500464,53492515,53504064,53515824,53517241,53520595,53487715,53493475,53495641,53504784,53530435,53530944,53534064,53501401,53509104,53477424,53502841,53512464,53523235,53528041,53524435,53470921,53484841,53518201,53511024,53503321,53477664,53485584,53518224,53519155,53522755,53523984,53509081,53471875,53496361,53496841,53476944,53476435,53510544,53490624,53511264,53521801,53520144,53521824,53530921,53533555,53486064,53472361,53493235,53534275,53495184,53528064,53529001,53499955,53519641,53526355,53500921,53470944,53489161,53529961,53480035,53519401,53485824,53476681,53479081,53505264,53483664,53525155,53527584,53518921,53493481,53524201,53475235,53502601,53481264,53496601,53501161,53502144,53476675,53486275,53494441,53502355,53530441,53517481,53534035,53526121,53478384,53489635,53473555,53496144,53496121,53494201,53505235,53477401,53487001,53532835,53503795,53509344,53524675,53509315,53482464,53478115,53496115,53495395,53504521,53506224,53485075,53500675,53474275,53528304,53480784,53526144,53505481,53516521,53485315,53519881,53489641,53497075,53479561,53488201,53482224,53500441,53499744,53499961,53502624,53479824,53523481,53528515,53491321,53501664,53503584,53479321,53487475,53512921,53513184,53522544,53482441,53487961,53493721,53491104,53493984,53524195,53513424,53527075,53523721,53488704,53498784,53526595,53528784,53531155,53482435,53528035,53499475,53525881,53472595,53507155,53497104,53523475,53532601,53486544,53471401,53477635,53482201,53510275,53497561,53478835,53496384,53479344,53474041,53475264,53481001,53470704,53489424,53502121,53510761,53515584,53492761,53509561,53521081,53477904,53488195,53492784,53472624,53494675,53483161,53501155,53524464,53533081,53483904,53490864,53528544,53498761,53511481,53498304,53503801,53503824,53490115,53483635,53485104,53508624,53475961,53510521,53513161,53511715,53518435,53529504,53502835,53529955,53530195,53484864,53473321,53485555,53493955,53494224,53507875,53515075,53488675,53522281,53531904,53532355,53532384,53534041,53534281,53473075,53477184,53508835,53515104,53504041,53515321,53531401,53505475,53510281,53510995,53516275,53478864,53482915,53491824,53523241,53472835,53485081,53479075,53514115,53500915,53520384,53491561,53526384,53517715,53473561,53478144,53478841,53483401,53492041,53493024,53495875,53492521,53496835,53474761,53491315,53487984,53501424,53511241,53514841,53527321,53490595,53516041,53480544,53481961,53517984,53482704,53501395,53497344,53474784,53478601,53505715,53513875,53486515,53524441,53526115,53518195,53530224,53481715,53508115,53505721,53475024,53514384,53487481,53493001,53517235,53531161,53514361,53484595,53492544,53518441,53509555,53513881,53517961,53510064,53531881,53483875,53519161,53521795,53533075,53479315,53512201,53529264,53491555,53482944,53476464,53497824,53523264,53485795,53473795,53478595,53509321,53509795,53523504,53476915,53482921,53490384,53517504,53526624,53530681,53506704,53515561,53487955,53502595,53504035,53498995,53507184,53510515,53531875,53506675,53481744,53534304,53503075,53534521,53516995,53475744,53529235,53529715,53471161,53475475,53479104,53506435,53512224,53520355,53475504,53481504,53529721,53533344,53523955,53474281,53476921,53505504,53476201,53518675,53491344,53495155,53473104,53526835,53472864,53481024,53487264,53473081,53473824,53480281,53487744,53499001,53511984,53508384,53500944,53488921,53512944,53491081,53512915,53502361,53506944,53505241,53522275,53532595,53504281,53509075,53532624,53511955,53505744,53495881,53517744,53500704,53520361,53522304,53525395,53475984,53527344,53477875,53486784,53513395,53486281,53481984,53489155,53520835,53472601,53509824,53525664,53518681,53499235,53531664,53487721,53494915,53500224,53522515,53498515,53501904,53472144,53497801,53500201,53511961,53517264,53480521,53533824,53496355,53484144,53531184,53489875,53506441,53507904,53508595,53481475,53475241,53480064,53479555,53484624,53488944,53489395,53489664,53490841,53493961,53516784,53477161,53517001,53518944,53471664,53481481,53522761,53523961,53486035,53507424,53525161,53501875,53522041,53526601,53515795,53497584,53490361,53489184,53493504,53508121,53510784,53513401,53520601,53499721,53496864,53507641,53507161,53525401,53526864,53510304,53527315,53473315,53506201,53490601,53514601,53519635,53527824,53529475,53531641,53528281,53532121,53503104,53494464,53486041,53488681,53492035,53495664,53508841,53511744,53517721,53489401,53520624,53523744,53525641,53513904,53532361,53533561,53494944,53491801,53532864,53489881,53525184,53473584,53524915,53482681,53527795,53497555,53492755,53475721,53486755,53492275,53509801,53521075,53478355,53523715,53472384,53478624,53501184,53505955,53486304,53479584,53495635,53500435,53494681,53526841,53474515,53487235,53512195,53528755,53511504,53512704,53484121,53502384,53485801,53502864,53516064,53511001,53474064,53481241,53491075,53472121,53499264,53514144,53524944,53531424,53487504,53501635,53526361,53532115,53470915,53477395,53514355,53515081,53472115,53480761,53471881,53471904,53475715,53480041,53484361,53495401,53495904,53506464,53522521,53471641,53522784,53524681,53515555,53521584,53493241,53483395,53484115,53476195,53478121,53479801,53472355,53488915,53499241,53495161,53471184,53494195,53480755,53502115,53488464,53490835,53503315,53511721,53516544,53477641,53510755,53494435,53519184],"length":1,"stats":{"Line":6041}},{"line":216,"address":[53471938,53526418,53471698,53500978,53529538,53506738,53481058,53534098,53512978,53482498,53486098,53501938,53521378,53523058,53490658,53507218,53484898,53479618,53530018,53531698,53487058,53497138,53531218,53497618,53519938,53524738,53503138,53511298,53504338,53518018,53503378,53527618,53491858,53484178,53499538,53512498,53530258,53524258,53510578,53487298,53508898,53476978,53479138,53481538,53512018,53530978,53475538,53511778,53508658,53476498,53521138,53533858,53510338,53498098,53472658,53502898,53509138,53523298,53485858,53492338,53525938,53515618,53523778,53499298,53517058,53478418,53477938,53517538,53487538,53492818,53473858,53481778,53531938,53476258,53488738,53513938,53520898,53475298,53476018,53470738,53501458,53506498,53517298,53483938,53475058,53496898,53505538,53521858,53482738,53480578,53471458,53488018,53516338,53520418,53525698,53524018,53495698,53522338,53473618,53480818,53499778,53534338,53514418,53478658,53487778,53515378,53516578,53502178,53514658,53494498,53485138,53526658,53491618,53500258,53533618,53472418,53474098,53472898,53486338,53496418,53492098,53518978,53472178,53507458,53501698,53507698,53495458,53509618,53493778,53500018,53528098,53522818,53493298,53514178,53476738,53473378,53480338,53522098,53510098,53480098,53509858,53477218,53489218,53488498,53495218,53483218,53500738,53505298,53515858,53525218,53520178,53492578,53513698,53470978,53517778,53511538,53533378,53527858,53498578,53486818,53512738,53497378,53513218,53518258,53523538,53497858,53495938,53502658,53527378,53499058,53526898,53515138,53508178,53532178,53500498,53496178,53477458,53501218,53471218,53473138,53490178,53522578,53507938,53521618,53479378,53486578,53474818,53504578,53519698,53479858,53484658,53494018,53510818,53530738,53474578,53518738,53485378,53494258,53489698,53485618,53498338,53529298,53489458,53488978,53504818,53530498,53484418,53474338,53494978,53494738,53516098,53482978,53509378,53533138,53528818,53506258,53524498,53503618,53489938,53493538,53519458,53529058,53490898,53506978,53475778,53532898,53498818,53508418,53518498,53505058,53478178,53532658,53491378,53504098,53505778,53516818,53478898,53520658,53491138,53512258,53477698,53481298,53482018,53514898,53524978,53529778,53488258,53502418,53519218,53527138,53493058,53482258,53528578,53532418,53526178,53490418,53483698,53513458,53503858,53483458,53511058,53531458,53525458,53528338,53496658,53506018],"length":1,"stats":{"Line":6801}},{"line":218,"address":[53509436,53523836,53494556,53525756,53502716,53479436,53478236,53527916,53470796,53499116,53532236,53501036,53520236,53500796,53512076,53474636,53512316,53492396,53519516,53476076,53515676,53518076,53486156,53525516,53486636,53481596,53534156,53509916,53485436,53504876,53496716,53476556,53489036,53528636,53530076,53471276,53487116,53516876,53521436,53475356,53484476,53480876,53484956,53502956,53488076,53507036,53529116,53531276,53472236,53526716,53478476,53472716,53515196,53495036,53491676,53483276,53505836,53520476,53477996,53490956,53500076,53508716,53510396,53513276,53473436,53523116,53518316,53523596,53526236,53526476,53506556,53493836,53533676,53513516,53527196,53487836,53482316,53475836,53479196,53522396,53511116,53486876,53504636,53525996,53501756,53499356,53504396,53518556,53524796,53483756,53517836,53528396,53482556,53490716,53507756,53476316,53514956,53483036,53473916,53487356,53529356,53498156,53497196,53475596,53481356,53522876,53516396,53528876,53496956,53530556,53492156,53513996,53508956,53507516,53513036,53519036,53531516,53481116,53501516,53483996,53478716,53522636,53514716,53503196,53480396,53503436,53495276,53524556,53479676,53499596,53500556,53474876,53508236,53510156,53506796,53489516,53520716,53496476,53524076,53527676,53501996,53487596,53510636,53489756,53503916,53500316,53491916,53493356,53485196,53507276,53503676,53475116,53506316,53529836,53530796,53515916,53488556,53477756,53473676,53474156,53485916,53494316,53530316,53534396,53484236,53472476,53477516,53520956,53495756,53505596,53515436,53509196,53493596,53507996,53471996,53490476,53532956,53525276,53532716,53498396,53518796,53525036,53477036,53510876,53531756,53514476,53497676,53491436,53484716,53516636,53490236,53517116,53511836,53486396,53482796,53526956,53523356,53529596,53488796,53511356,53531036,53532476,53509676,53489276,53505356,53501276,53524316,53527436,53472956,53489996,53495516,53478956,53506076,53483516,53476796,53471756,53473196,53491196,53496236,53512556,53511596,53521196,53477276,53521676,53516156,53494796,53533436,53482076,53502236,53519756,53495996,53480636,53497916,53499836,53479916,53494076,53498636,53502476,53498876,53508476,53485676,53488316,53514236,53522156,53492636,53517356,53521916,53480156,53471036,53513756,53517596,53519276,53531996,53504156,53471516,53533196,53519996,53481836,53492876,53533916,53493116,53505116,53497436,53474396,53528156,53512796],"length":1,"stats":{"Line":6060}},{"line":224,"address":[54971328],"length":1,"stats":{"Line":2}},{"line":225,"address":[54971352],"length":1,"stats":{"Line":2}},{"line":238,"address":[55805820,55805664,55805842],"length":1,"stats":{"Line":3}},{"line":242,"address":[55613853],"length":1,"stats":{"Line":3}},{"line":246,"address":[54973344],"length":1,"stats":{"Line":3}},{"line":247,"address":[54470898],"length":1,"stats":{"Line":6}},{"line":248,"address":[54973431],"length":1,"stats":{"Line":3}},{"line":250,"address":[54973449,54973503],"length":1,"stats":{"Line":10}},{"line":251,"address":[54973508],"length":1,"stats":{"Line":5}},{"line":253,"address":[55805652],"length":1,"stats":{"Line":2}},{"line":265,"address":[55614592,55614704,55614698],"length":1,"stats":{"Line":5}},{"line":268,"address":[55806488],"length":1,"stats":{"Line":5}},{"line":272,"address":[55614240],"length":1,"stats":{"Line":5}},{"line":273,"address":[54471584],"length":1,"stats":{"Line":5}},{"line":274,"address":[54471639],"length":1,"stats":{"Line":5}},{"line":276,"address":[55614508,55614432],"length":1,"stats":{"Line":6}},{"line":277,"address":[54471785],"length":1,"stats":{"Line":4}},{"line":279,"address":[55614573],"length":1,"stats":{"Line":2}},{"line":282,"address":[55614720],"length":1,"stats":{"Line":8}},{"line":283,"address":[54472002],"length":1,"stats":{"Line":6}},{"line":295,"address":[54471264],"length":1,"stats":{"Line":7}},{"line":309,"address":[55612208],"length":1,"stats":{"Line":3}},{"line":317,"address":[55804016],"length":1,"stats":{"Line":3}},{"line":319,"address":[55804027],"length":1,"stats":{"Line":3}},{"line":320,"address":[54971918],"length":1,"stats":{"Line":3}},{"line":321,"address":[55612274],"length":1,"stats":{"Line":3}},{"line":335,"address":[55612016],"length":1,"stats":{"Line":3}},{"line":336,"address":[54469321,54469294],"length":1,"stats":{"Line":6}},{"line":337,"address":[55612064],"length":1,"stats":{"Line":3}},{"line":339,"address":[55612041],"length":1,"stats":{"Line":3}},{"line":342,"address":[55803941,55803840,55803856],"length":1,"stats":{"Line":9}},{"line":343,"address":[55612103],"length":1,"stats":{"Line":3}},{"line":344,"address":[55612116,55612183,55612164],"length":1,"stats":{"Line":6}},{"line":345,"address":[54971815],"length":1,"stats":{"Line":3}},{"line":347,"address":[54469351],"length":1,"stats":{"Line":3}},{"line":360,"address":[54972576],"length":1,"stats":{"Line":8}},{"line":362,"address":[54972590],"length":1,"stats":{"Line":8}},{"line":367,"address":[55804239,55804112,55804233],"length":1,"stats":{"Line":3}},{"line":369,"address":[55804131],"length":1,"stats":{"Line":3}},{"line":370,"address":[54469664],"length":1,"stats":{"Line":3}},{"line":374,"address":[54470816],"length":1,"stats":{"Line":12}},{"line":375,"address":[55613570],"length":1,"stats":{"Line":7}},{"line":378,"address":[54972552,54972144,54972546],"length":1,"stats":{"Line":18}},{"line":379,"address":[55612554],"length":1,"stats":{"Line":14}},{"line":380,"address":[55804382],"length":1,"stats":{"Line":18}},{"line":382,"address":[55804439,55804498],"length":1,"stats":{"Line":6}},{"line":383,"address":[54972462,54972394],"length":1,"stats":{"Line":3}},{"line":385,"address":[54470044],"length":1,"stats":{"Line":2}},{"line":388,"address":[55613524,55612960,55613433],"length":1,"stats":{"Line":3}},{"line":389,"address":[54470347,54470275],"length":1,"stats":{"Line":6}},{"line":390,"address":[54973174,54972845],"length":1,"stats":{"Line":6}},{"line":391,"address":[55805362],"length":1,"stats":{"Line":3}},{"line":393,"address":[55613169,55613094],"length":1,"stats":{"Line":6}},{"line":394,"address":[54470441,54470478],"length":1,"stats":{"Line":6}},{"line":396,"address":[54972898],"length":1,"stats":{"Line":2}},{"line":401,"address":[54469568],"length":1,"stats":{"Line":2}},{"line":402,"address":[54971969],"length":1,"stats":{"Line":2}},{"line":407,"address":[55611984],"length":1,"stats":{"Line":2}},{"line":408,"address":[55611992],"length":1,"stats":{"Line":2}}],"covered":148,"coverable":148},{"path":["/","home","md","language","mdhavers","src","wasm_compiler.rs"],"content":"//! WebAssembly compiler fer mdhavers\n//! Generates WAT (WebAssembly Text Format) that can be compiled tae WASM\n//!\n//! This is a basic WASM compiler that supports:\n//! - Integer and float arithmetic\n//! - Variables (local)\n//! - Functions\n//! - Basic control flow (if/while)\n//!\n//! Note: This is an experimental feature - no' aw mdhavers features are supported!\n\nuse crate::ast::*;\nuse crate::error::{HaversError, HaversResult};\n\n/// The WASM compiler\npub struct WasmCompiler {\n    output: String,\n    indent: usize,\n    local_vars: Vec<String>,\n    func_params: Vec<String>,\n    string_data: Vec<String>,\n}\n\nimpl Default for WasmCompiler {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl WasmCompiler {\n    pub fn new() -> Self {\n        WasmCompiler {\n            output: String::new(),\n            indent: 0,\n            local_vars: Vec::new(),\n            func_params: Vec::new(),\n            string_data: Vec::new(),\n        }\n    }\n\n    /// Compile a program tae WAT (WebAssembly Text Format)\n    pub fn compile(&mut self, program: &Program) -> HaversResult<String> {\n        self.output.clear();\n        self.string_data.clear();\n\n        // Start the module\n        self.emit(\"(module\");\n        self.indent += 1;\n\n        // Import memory and print functions from the host\n        self.emit_line(\"\");\n        self.emit_line(\";; Imports fae the host environment\");\n        self.emit_line(\"(import \\\"env\\\" \\\"memory\\\" (memory 1))\");\n        self.emit_line(\"(import \\\"env\\\" \\\"print_i32\\\" (func $print_i32 (param i32)))\");\n        self.emit_line(\"(import \\\"env\\\" \\\"print_f64\\\" (func $print_f64 (param f64)))\");\n        self.emit_line(\"(import \\\"env\\\" \\\"print_str\\\" (func $print_str (param i32 i32)))\");\n        self.emit_line(\"\");\n\n        // Collect all function declarations first\n        let mut functions: Vec<&Stmt> = Vec::new();\n        let mut main_stmts: Vec<&Stmt> = Vec::new();\n\n        for stmt in &program.statements {\n            match stmt {\n                Stmt::Function { .. } => functions.push(stmt),\n                _ => main_stmts.push(stmt),\n            }\n        }\n\n        // Compile functions\n        for func in &functions {\n            self.compile_function(func)?;\n        }\n\n        // Compile main code as start function\n        if !main_stmts.is_empty() {\n            self.compile_main(&main_stmts)?;\n        }\n\n        // Export the main function\n        self.emit_line(\"\");\n        self.emit_line(\"(export \\\"main\\\" (func $main))\");\n\n        // Add string data section if we have strings\n        if !self.string_data.is_empty() {\n            self.emit_line(\"\");\n            self.emit_line(\";; String data\");\n            let mut offset = 0;\n            // Collect string data first to avoid borrow issues\n            let string_lines: Vec<String> = self\n                .string_data\n                .iter()\n                .map(|s| {\n                    let line =\n                        format!(\"(data (i32.const {}) \\\"{}\\\")\", offset, escape_wat_string(s));\n                    offset += s.len() as i32 + 1; // +1 for null terminator\n                    line\n                })\n                .collect();\n            for line in string_lines {\n                self.emit_line(&line);\n            }\n        }\n\n        self.indent -= 1;\n        self.emit_line(\")\");\n\n        Ok(self.output.clone())\n    }\n\n    fn compile_function(&mut self, stmt: &Stmt) -> HaversResult<()> {\n        if let Stmt::Function {\n            name, params, body, ..\n        } = stmt\n        {\n            self.local_vars.clear();\n            self.func_params.clear();\n\n            // Build parameter list\n            let mut param_types = String::new();\n            for p in params {\n                self.func_params.push(p.name.clone());\n                param_types.push_str(&format!(\"(param ${} i64) \", p.name));\n            }\n\n            // Start function\n            self.emit_line(&format!(\"(func ${} {}(result i64)\", name, param_types));\n            self.indent += 1;\n\n            // Collect locals from body\n            self.collect_locals(body);\n\n            // Declare locals (collect first to avoid borrow issues)\n            let local_decls: Vec<String> = self\n                .local_vars\n                .iter()\n                .map(|var| format!(\"(local ${} i64)\", var))\n                .collect();\n            for decl in local_decls {\n                self.emit_line(&decl);\n            }\n\n            // Compile body\n            for s in body {\n                self.compile_stmt(s)?;\n            }\n\n            // Default return value\n            self.emit_line(\"(i64.const 0)\");\n\n            self.indent -= 1;\n            self.emit_line(\")\");\n            self.emit_line(\"\");\n        }\n        Ok(())\n    }\n\n    fn compile_main(&mut self, stmts: &[&Stmt]) -> HaversResult<()> {\n        self.local_vars.clear();\n        self.func_params.clear();\n\n        self.emit_line(\"(func $main (result i64)\");\n        self.indent += 1;\n\n        // Collect all locals\n        for stmt in stmts {\n            self.collect_locals_stmt(stmt);\n        }\n\n        // Declare locals\n        for var in &self.local_vars.clone() {\n            self.emit_line(&format!(\"(local ${} i64)\", var));\n        }\n\n        // Compile statements\n        for stmt in stmts {\n            self.compile_stmt(stmt)?;\n        }\n\n        // Return 0\n        self.emit_line(\"(i64.const 0)\");\n\n        self.indent -= 1;\n        self.emit_line(\")\");\n        Ok(())\n    }\n\n    fn collect_locals(&mut self, body: &[Stmt]) {\n        for stmt in body {\n            self.collect_locals_stmt(stmt);\n        }\n    }\n\n    fn collect_locals_stmt(&mut self, stmt: &Stmt) {\n        match stmt {\n            Stmt::VarDecl { name, .. } => {\n                if !self.func_params.contains(name) && !self.local_vars.contains(name) {\n                    self.local_vars.push(name.clone());\n                }\n            }\n            Stmt::Block { statements, .. } => {\n                for s in statements {\n                    self.collect_locals_stmt(s);\n                }\n            }\n            Stmt::If {\n                then_branch,\n                else_branch,\n                ..\n            } => {\n                self.collect_locals_stmt(then_branch);\n                if let Some(eb) = else_branch {\n                    self.collect_locals_stmt(eb);\n                }\n            }\n            Stmt::While { body, .. } => {\n                self.collect_locals_stmt(body);\n            }\n            Stmt::For { variable, body, .. } => {\n                if !self.func_params.contains(variable) && !self.local_vars.contains(variable) {\n                    self.local_vars.push(variable.clone());\n                }\n                self.collect_locals_stmt(body);\n            }\n            _ => {}\n        }\n    }\n\n    fn compile_stmt(&mut self, stmt: &Stmt) -> HaversResult<()> {\n        match stmt {\n            Stmt::VarDecl {\n                name, initializer, ..\n            } => {\n                if let Some(init) = initializer {\n                    self.compile_expr(init)?;\n                } else {\n                    self.emit_line(\"(i64.const 0)\");\n                }\n                self.emit_line(&format!(\"(local.set ${})\", name));\n            }\n\n            Stmt::Expression { expr, .. } => {\n                self.compile_expr(expr)?;\n                self.emit_line(\"(drop)\");\n            }\n\n            Stmt::Block { statements, .. } => {\n                for s in statements {\n                    self.compile_stmt(s)?;\n                }\n            }\n\n            Stmt::If {\n                condition,\n                then_branch,\n                else_branch,\n                ..\n            } => {\n                // Compile condition\n                self.compile_expr(condition)?;\n                self.emit_line(\"(i32.wrap_i64)\");\n\n                self.emit_line(\"(if\");\n                self.indent += 1;\n                self.emit_line(\"(then\");\n                self.indent += 1;\n                self.compile_stmt(then_branch)?;\n                self.indent -= 1;\n                self.emit_line(\")\");\n\n                if let Some(eb) = else_branch {\n                    self.emit_line(\"(else\");\n                    self.indent += 1;\n                    self.compile_stmt(eb)?;\n                    self.indent -= 1;\n                    self.emit_line(\")\");\n                }\n\n                self.indent -= 1;\n                self.emit_line(\")\");\n            }\n\n            Stmt::While {\n                condition, body, ..\n            } => {\n                self.emit_line(\"(block $break\");\n                self.indent += 1;\n                self.emit_line(\"(loop $continue\");\n                self.indent += 1;\n\n                // Check condition\n                self.compile_expr(condition)?;\n                self.emit_line(\"(i32.wrap_i64)\");\n                self.emit_line(\"(i32.eqz)\");\n                self.emit_line(\"(br_if $break)\");\n\n                // Body\n                self.compile_stmt(body)?;\n\n                // Loop back\n                self.emit_line(\"(br $continue)\");\n\n                self.indent -= 1;\n                self.emit_line(\")\");\n                self.indent -= 1;\n                self.emit_line(\")\");\n            }\n\n            Stmt::Return { value, .. } => {\n                if let Some(val) = value {\n                    self.compile_expr(val)?;\n                } else {\n                    self.emit_line(\"(i64.const 0)\");\n                }\n                self.emit_line(\"(return)\");\n            }\n\n            Stmt::Print { value, .. } => {\n                // For now, only support printing integers\n                self.compile_expr(value)?;\n                self.emit_line(\"(i32.wrap_i64)\");\n                self.emit_line(\"(call $print_i32)\");\n            }\n\n            Stmt::Break { .. } => {\n                self.emit_line(\"(br $break)\");\n            }\n\n            Stmt::Continue { .. } => {\n                self.emit_line(\"(br $continue)\");\n            }\n\n            _ => {\n                // Unsupported statement type\n                return Err(HaversError::InternalError(\n                    \"This statement type isnae supported in WASM yet!\".to_string(),\n                ));\n            }\n        }\n        Ok(())\n    }\n\n    fn compile_expr(&mut self, expr: &Expr) -> HaversResult<()> {\n        match expr {\n            Expr::Literal { value, .. } => {\n                match value {\n                    Literal::Integer(n) => {\n                        self.emit_line(&format!(\"(i64.const {})\", n));\n                    }\n                    Literal::Float(f) => {\n                        // Convert float to i64 bits for now (simplified)\n                        self.emit_line(&format!(\"(i64.const {})\", (*f as i64)));\n                    }\n                    Literal::Bool(b) => {\n                        self.emit_line(&format!(\"(i64.const {})\", if *b { 1 } else { 0 }));\n                    }\n                    Literal::Nil => {\n                        self.emit_line(\"(i64.const 0)\");\n                    }\n                    Literal::String(s) => {\n                        // Store string in data section and return offset\n                        let offset = self.string_data.iter().map(|s| s.len() + 1).sum::<usize>();\n                        self.string_data.push(s.clone());\n                        self.emit_line(&format!(\"(i64.const {})\", offset));\n                    }\n                }\n            }\n\n            Expr::Variable { name, .. } => {\n                self.emit_line(&format!(\"(local.get ${})\", name));\n            }\n\n            Expr::Assign { name, value, .. } => {\n                self.compile_expr(value)?;\n                self.emit_line(&format!(\"(local.tee ${})\", name));\n            }\n\n            Expr::Binary {\n                left,\n                operator,\n                right,\n                ..\n            } => {\n                self.compile_expr(left)?;\n                self.compile_expr(right)?;\n\n                match operator {\n                    BinaryOp::Add => self.emit_line(\"(i64.add)\"),\n                    BinaryOp::Subtract => self.emit_line(\"(i64.sub)\"),\n                    BinaryOp::Multiply => self.emit_line(\"(i64.mul)\"),\n                    BinaryOp::Divide => self.emit_line(\"(i64.div_s)\"),\n                    BinaryOp::Modulo => self.emit_line(\"(i64.rem_s)\"),\n                    BinaryOp::Equal => {\n                        self.emit_line(\"(i64.eq)\");\n                        self.emit_line(\"(i64.extend_i32_u)\");\n                    }\n                    BinaryOp::NotEqual => {\n                        self.emit_line(\"(i64.ne)\");\n                        self.emit_line(\"(i64.extend_i32_u)\");\n                    }\n                    BinaryOp::Less => {\n                        self.emit_line(\"(i64.lt_s)\");\n                        self.emit_line(\"(i64.extend_i32_u)\");\n                    }\n                    BinaryOp::LessEqual => {\n                        self.emit_line(\"(i64.le_s)\");\n                        self.emit_line(\"(i64.extend_i32_u)\");\n                    }\n                    BinaryOp::Greater => {\n                        self.emit_line(\"(i64.gt_s)\");\n                        self.emit_line(\"(i64.extend_i32_u)\");\n                    }\n                    BinaryOp::GreaterEqual => {\n                        self.emit_line(\"(i64.ge_s)\");\n                        self.emit_line(\"(i64.extend_i32_u)\");\n                    }\n                }\n            }\n\n            Expr::Unary {\n                operator, operand, ..\n            } => match operator {\n                UnaryOp::Negate => {\n                    self.emit_line(\"(i64.const 0)\");\n                    self.compile_expr(operand)?;\n                    self.emit_line(\"(i64.sub)\");\n                }\n                UnaryOp::Not => {\n                    self.compile_expr(operand)?;\n                    self.emit_line(\"(i64.eqz)\");\n                    self.emit_line(\"(i64.extend_i32_u)\");\n                }\n            },\n\n            Expr::Logical {\n                left,\n                operator,\n                right,\n                ..\n            } => match operator {\n                LogicalOp::And => {\n                    self.compile_expr(left)?;\n                    self.emit_line(\"(i32.wrap_i64)\");\n                    self.emit_line(\"(if (result i64)\");\n                    self.indent += 1;\n                    self.emit_line(\"(then\");\n                    self.indent += 1;\n                    self.compile_expr(right)?;\n                    self.indent -= 1;\n                    self.emit_line(\")\");\n                    self.emit_line(\"(else (i64.const 0))\");\n                    self.indent -= 1;\n                    self.emit_line(\")\");\n                }\n                LogicalOp::Or => {\n                    self.compile_expr(left)?;\n                    self.emit_line(\"(i32.wrap_i64)\");\n                    self.emit_line(\"(if (result i64)\");\n                    self.indent += 1;\n                    self.emit_line(\"(then (i64.const 1))\");\n                    self.emit_line(\"(else\");\n                    self.indent += 1;\n                    self.compile_expr(right)?;\n                    self.indent -= 1;\n                    self.emit_line(\")\");\n                    self.indent -= 1;\n                    self.emit_line(\")\");\n                }\n            },\n\n            Expr::Call {\n                callee, arguments, ..\n            } => {\n                // Compile arguments\n                for arg in arguments {\n                    self.compile_expr(arg)?;\n                }\n\n                // Get function name\n                if let Expr::Variable { name, .. } = callee.as_ref() {\n                    self.emit_line(&format!(\"(call ${})\", name));\n                } else {\n                    return Err(HaversError::InternalError(\n                        \"Only direct function calls are supported in WASM\".to_string(),\n                    ));\n                }\n            }\n\n            Expr::Grouping { expr, .. } => {\n                self.compile_expr(expr)?;\n            }\n\n            _ => {\n                return Err(HaversError::InternalError(\n                    \"This expression type isnae supported in WASM yet!\".to_string(),\n                ));\n            }\n        }\n        Ok(())\n    }\n\n    fn emit(&mut self, s: &str) {\n        self.output.push_str(&\"  \".repeat(self.indent));\n        self.output.push_str(s);\n    }\n\n    fn emit_line(&mut self, s: &str) {\n        self.emit(s);\n        self.output.push('\\n');\n    }\n}\n\n/// Escape a string fer WAT data section\nfn escape_wat_string(s: &str) -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n        match c {\n            '\"' => result.push_str(\"\\\\\\\"\"),\n            '\\\\' => result.push_str(\"\\\\\\\\\"),\n            '\\n' => result.push_str(\"\\\\n\"),\n            '\\r' => result.push_str(\"\\\\r\"),\n            '\\t' => result.push_str(\"\\\\t\"),\n            c if c.is_ascii_graphic() || c == ' ' => result.push(c),\n            c => result.push_str(&format!(\"\\\\{:02x}\", c as u32)),\n        }\n    }\n    result\n}\n\n/// Compile source code tae WAT\npub fn compile_to_wat(source: &str) -> HaversResult<String> {\n    let program = crate::parser::parse(source)?;\n    let mut compiler = WasmCompiler::new();\n    compiler.compile(&program)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_wasm_compile() {\n        let source = \"ken x = 42\";\n        let result = compile_to_wat(source);\n        assert!(result.is_ok());\n        let wat = result.unwrap();\n        assert!(wat.contains(\"(module\"));\n        assert!(wat.contains(\"i64.const 42\"));\n    }\n\n    #[test]\n    fn test_arithmetic_wasm() {\n        let source = \"ken x = 10 + 20\";\n        let result = compile_to_wat(source);\n        assert!(result.is_ok());\n        let wat = result.unwrap();\n        assert!(wat.contains(\"i64.add\"));\n    }\n\n    #[test]\n    fn test_function_wasm() {\n        let source = r#\"\n            dae add(a, b) {\n                gie a + b\n            }\n        \"#;\n        let result = compile_to_wat(source);\n        assert!(result.is_ok());\n        let wat = result.unwrap();\n        assert!(wat.contains(\"(func $add\"));\n    }\n\n    #[test]\n    fn test_if_wasm() {\n        let source = r#\"\n            ken x = 5\n            gin x > 3 {\n                blether x\n            }\n        \"#;\n        let result = compile_to_wat(source);\n        assert!(result.is_ok());\n        let wat = result.unwrap();\n        assert!(wat.contains(\"(if\"));\n    }\n\n    #[test]\n    fn test_while_wasm() {\n        let source = r#\"\n            ken x = 0\n            whiles x < 10 {\n                x = x + 1\n            }\n        \"#;\n        let result = compile_to_wat(source);\n        assert!(result.is_ok());\n        let wat = result.unwrap();\n        assert!(wat.contains(\"(loop\"));\n        assert!(wat.contains(\"(block\"));\n    }\n\n    // ==================== Arithmetic Operations ====================\n\n    #[test]\n    fn test_subtraction_wasm() {\n        let source = \"ken x = 50 - 8\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.sub\"));\n    }\n\n    #[test]\n    fn test_multiplication_wasm() {\n        let source = \"ken x = 6 * 7\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.mul\"));\n    }\n\n    #[test]\n    fn test_division_wasm() {\n        let source = \"ken x = 84 / 2\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.div_s\"));\n    }\n\n    #[test]\n    fn test_modulo_wasm() {\n        let source = \"ken x = 10 % 3\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.rem_s\"));\n    }\n\n    // ==================== Comparison Operations ====================\n\n    #[test]\n    fn test_greater_than_wasm() {\n        let source = \"ken b = 5 > 3\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.gt_s\"));\n    }\n\n    #[test]\n    fn test_less_than_wasm() {\n        let source = \"ken b = 3 < 5\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.lt_s\"));\n    }\n\n    #[test]\n    fn test_greater_equal_wasm() {\n        let source = \"ken b = 5 >= 5\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.ge_s\"));\n    }\n\n    #[test]\n    fn test_less_equal_wasm() {\n        let source = \"ken b = 3 <= 5\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.le_s\"));\n    }\n\n    #[test]\n    fn test_equal_wasm() {\n        let source = \"ken b = 5 == 5\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.eq\"));\n    }\n\n    #[test]\n    fn test_not_equal_wasm() {\n        let source = \"ken b = 5 != 3\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.ne\"));\n    }\n\n    // ==================== Logical Operations ====================\n\n    #[test]\n    fn test_logical_and_wasm() {\n        let source = \"ken b = aye an nae\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n\n    #[test]\n    fn test_logical_or_wasm() {\n        let source = \"ken b = aye or nae\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n\n    #[test]\n    fn test_logical_not_wasm() {\n        // \"no\" requires parentheses and may not be fully supported in WASM\n        let source = \"ken b = no aye\";\n        let result = compile_to_wat(source);\n        // Just verify it doesn't panic - may or may not be supported\n        assert!(result.is_ok() || result.is_err());\n    }\n\n    // ==================== Unary Operations ====================\n\n    #[test]\n    fn test_negate_wasm() {\n        let source = \"ken x = -42\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.const 0\"));\n        assert!(result.contains(\"i64.sub\"));\n    }\n\n    // ==================== Control Flow ====================\n\n    #[test]\n    fn test_if_else_wasm() {\n        let source = r#\"\n            ken x = 5\n            gin x > 3 {\n                blether x\n            } ither {\n                blether 0\n            }\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(if\"));\n        assert!(result.contains(\"(then\"));\n        assert!(result.contains(\"(else\"));\n    }\n\n    #[test]\n    fn test_for_loop_wasm() {\n        let source = r#\"\n            fer i in 1..5 {\n                blether i\n            }\n        \"#;\n        let result = compile_to_wat(source);\n        // For loops may not be supported in WASM yet\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_return_wasm() {\n        let source = r#\"\n            dae answer() {\n                gie 42\n            }\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(return\"));\n    }\n\n    #[test]\n    fn test_return_implicit_wasm() {\n        let source = r#\"\n            dae answer() {\n                gie\n            }\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(return\"));\n    }\n\n    // ==================== Literals ====================\n\n    #[test]\n    fn test_boolean_true_wasm() {\n        let source = \"ken b = aye\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.const 1\"));\n    }\n\n    #[test]\n    fn test_boolean_false_wasm() {\n        let source = \"ken b = nae\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.const 0\"));\n    }\n\n    #[test]\n    fn test_nil_wasm() {\n        let source = \"ken n = naething\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"i64.const 0\"));\n    }\n\n    #[test]\n    fn test_float_wasm() {\n        let source = \"ken f = 3.14\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n\n    #[test]\n    fn test_string_wasm() {\n        let source = r#\"ken s = \"Hello\"\"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(data\"));\n    }\n\n    // ==================== String Escape ====================\n\n    #[test]\n    fn test_string_escape_newline() {\n        let source = r#\"ken s = \"hello\\nworld\"\"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(data\"));\n    }\n\n    #[test]\n    fn test_string_escape_tab() {\n        let source = r#\"ken s = \"hello\\tworld\"\"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(data\"));\n    }\n\n    // ==================== Multiple Statements ====================\n\n    #[test]\n    fn test_multiple_vars_wasm() {\n        let source = r#\"\n            ken a = 1\n            ken b = 2\n            ken c = a + b\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n\n    #[test]\n    fn test_function_with_params_wasm() {\n        let source = r#\"\n            dae multiply(a, b) {\n                gie a * b\n            }\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(func $multiply\"));\n        assert!(result.contains(\"(param\"));\n    }\n\n    // ==================== Variable Operations ====================\n\n    #[test]\n    fn test_variable_assignment_wasm() {\n        let source = r#\"\n            ken x = 1\n            x = 42\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"local.set\"));\n    }\n\n    #[test]\n    fn test_variable_get_wasm() {\n        let source = r#\"\n            ken x = 42\n            ken y = x\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"local.get\"));\n    }\n\n    // ==================== Block ====================\n\n    #[test]\n    fn test_block_wasm() {\n        let source = r#\"\n            {\n                ken x = 1\n                ken y = 2\n            }\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n\n    #[test]\n    fn test_nested_blocks_wasm() {\n        let source = r#\"\n            {\n                ken x = 1\n                {\n                    ken y = 2\n                }\n            }\n        \"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n\n    // ==================== Print ====================\n\n    #[test]\n    fn test_print_wasm() {\n        let source = \"blether 42\";\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"call $print\"));\n    }\n\n    #[test]\n    fn test_print_string_wasm() {\n        let source = r#\"blether \"Hello\"\"#;\n        let result = compile_to_wat(source).unwrap();\n        assert!(result.contains(\"(module\"));\n    }\n}\n","traces":[{"line":25,"address":[55956128],"length":1,"stats":{"Line":0}},{"line":26,"address":[55956136],"length":1,"stats":{"Line":0}},{"line":31,"address":[53345100,53344784,53345106],"length":1,"stats":{"Line":5}},{"line":33,"address":[53304310],"length":1,"stats":{"Line":6}},{"line":35,"address":[57105355],"length":1,"stats":{"Line":4}},{"line":36,"address":[55971905],"length":1,"stats":{"Line":4}},{"line":37,"address":[53304420],"length":1,"stats":{"Line":5}},{"line":42,"address":[57107633,57105872,57108048],"length":1,"stats":{"Line":5}},{"line":43,"address":[55972434],"length":1,"stats":{"Line":4}},{"line":44,"address":[55972447],"length":1,"stats":{"Line":5}},{"line":47,"address":[57105968],"length":1,"stats":{"Line":4}},{"line":48,"address":[53345450,53345738],"length":1,"stats":{"Line":5}},{"line":51,"address":[55972563],"length":1,"stats":{"Line":8}},{"line":52,"address":[53345536],"length":1,"stats":{"Line":9}},{"line":53,"address":[53345561],"length":1,"stats":{"Line":8}},{"line":54,"address":[55972626],"length":1,"stats":{"Line":9}},{"line":55,"address":[53305130],"length":1,"stats":{"Line":16}},{"line":56,"address":[53345647],"length":1,"stats":{"Line":15}},{"line":57,"address":[55972728],"length":1,"stats":{"Line":16}},{"line":60,"address":[53345693],"length":1,"stats":{"Line":17}},{"line":61,"address":[57106257],"length":1,"stats":{"Line":18}},{"line":63,"address":[53345803,53345887],"length":1,"stats":{"Line":43}},{"line":64,"address":[53345998],"length":1,"stats":{"Line":20}},{"line":65,"address":[55974593,55974650],"length":1,"stats":{"Line":8}},{"line":66,"address":[53306972,53306999],"length":1,"stats":{"Line":40}},{"line":71,"address":[57106566],"length":1,"stats":{"Line":24}},{"line":72,"address":[57106697,57107828],"length":1,"stats":{"Line":8}},{"line":76,"address":[53305686],"length":1,"stats":{"Line":20}},{"line":77,"address":[57106755,57106825],"length":1,"stats":{"Line":42}},{"line":81,"address":[57106789],"length":1,"stats":{"Line":9}},{"line":82,"address":[57107005],"length":1,"stats":{"Line":17}},{"line":85,"address":[53346556],"length":1,"stats":{"Line":9}},{"line":86,"address":[53346602],"length":1,"stats":{"Line":4}},{"line":87,"address":[53346656],"length":1,"stats":{"Line":4}},{"line":88,"address":[55973723],"length":1,"stats":{"Line":4}},{"line":90,"address":[53346694],"length":1,"stats":{"Line":5}},{"line":93,"address":[57107252],"length":1,"stats":{"Line":13}},{"line":95,"address":[55413667],"length":1,"stats":{"Line":7}},{"line":96,"address":[55413938,55413996,55414112],"length":1,"stats":{"Line":12}},{"line":97,"address":[54697502],"length":1,"stats":{"Line":8}},{"line":100,"address":[55973854,55974016],"length":1,"stats":{"Line":16}},{"line":101,"address":[55974093,55974194],"length":1,"stats":{"Line":16}},{"line":105,"address":[53346617,53347202,53347225],"length":1,"stats":{"Line":26}},{"line":106,"address":[53306612],"length":1,"stats":{"Line":18}},{"line":108,"address":[55974293],"length":1,"stats":{"Line":10}},{"line":111,"address":[55968432,55970689,55970399],"length":1,"stats":{"Line":4}},{"line":112,"address":[53301015],"length":1,"stats":{"Line":3}},{"line":113,"address":[53301082],"length":1,"stats":{"Line":4}},{"line":116,"address":[53301140],"length":1,"stats":{"Line":4}},{"line":117,"address":[53301157],"length":1,"stats":{"Line":4}},{"line":120,"address":[53341623],"length":1,"stats":{"Line":4}},{"line":121,"address":[55968676,55968783],"length":1,"stats":{"Line":8}},{"line":122,"address":[57103906,57102448],"length":1,"stats":{"Line":8}},{"line":123,"address":[57103940],"length":1,"stats":{"Line":4}},{"line":127,"address":[53301457],"length":1,"stats":{"Line":3}},{"line":128,"address":[55969273,55969349],"length":1,"stats":{"Line":4}},{"line":131,"address":[53342350,53342285],"length":1,"stats":{"Line":8}},{"line":134,"address":[53342365],"length":1,"stats":{"Line":4}},{"line":137,"address":[55955469,55955440],"length":1,"stats":{"Line":4}},{"line":139,"address":[53302156,53302022],"length":1,"stats":{"Line":8}},{"line":140,"address":[57103863,57103273],"length":1,"stats":{"Line":0}},{"line":144,"address":[55969807],"length":1,"stats":{"Line":4}},{"line":145,"address":[53343081,53342914],"length":1,"stats":{"Line":7}},{"line":149,"address":[53342932],"length":1,"stats":{"Line":3}},{"line":151,"address":[57103500,57103558],"length":1,"stats":{"Line":3}},{"line":152,"address":[53302499],"length":1,"stats":{"Line":3}},{"line":153,"address":[53302556],"length":1,"stats":{"Line":3}},{"line":155,"address":[55968711],"length":1,"stats":{"Line":5}},{"line":158,"address":[57097971,57097977,57096880],"length":1,"stats":{"Line":22}},{"line":159,"address":[53295904],"length":1,"stats":{"Line":21}},{"line":160,"address":[57096958],"length":1,"stats":{"Line":9}},{"line":162,"address":[57096972],"length":1,"stats":{"Line":21}},{"line":163,"address":[53296016,53295954],"length":1,"stats":{"Line":9}},{"line":166,"address":[53296029,53295999],"length":1,"stats":{"Line":30}},{"line":167,"address":[53296099],"length":1,"stats":{"Line":21}},{"line":171,"address":[53336647,53336534],"length":1,"stats":{"Line":22}},{"line":172,"address":[55963787,55964182],"length":1,"stats":{"Line":21}},{"line":176,"address":[55963841,55963863],"length":1,"stats":{"Line":26}},{"line":177,"address":[53337088,53336897],"length":1,"stats":{"Line":13}},{"line":181,"address":[53296546],"length":1,"stats":{"Line":8}},{"line":183,"address":[57097612,57097679],"length":1,"stats":{"Line":15}},{"line":184,"address":[55964071],"length":1,"stats":{"Line":6}},{"line":185,"address":[55964093],"length":1,"stats":{"Line":15}},{"line":188,"address":[55968288],"length":1,"stats":{"Line":4}},{"line":189,"address":[53300881,53300866],"length":1,"stats":{"Line":8}},{"line":190,"address":[55968413],"length":1,"stats":{"Line":3}},{"line":194,"address":[53343664],"length":1,"stats":{"Line":9}},{"line":195,"address":[57104241],"length":1,"stats":{"Line":21}},{"line":196,"address":[57104332],"length":1,"stats":{"Line":9}},{"line":197,"address":[55971133,55970845],"length":1,"stats":{"Line":26}},{"line":198,"address":[53344138],"length":1,"stats":{"Line":17}},{"line":201,"address":[53343846],"length":1,"stats":{"Line":2}},{"line":202,"address":[57104401,57104733],"length":1,"stats":{"Line":4}},{"line":203,"address":[53303770],"length":1,"stats":{"Line":3}},{"line":206,"address":[53303407],"length":1,"stats":{"Line":3}},{"line":211,"address":[57104822,57104913,57104467],"length":1,"stats":{"Line":6}},{"line":212,"address":[53344343,53344392],"length":1,"stats":{"Line":5}},{"line":213,"address":[57104939],"length":1,"stats":{"Line":2}},{"line":216,"address":[53343958],"length":1,"stats":{"Line":2}},{"line":217,"address":[53303475,53304000],"length":1,"stats":{"Line":4}},{"line":219,"address":[57104553],"length":1,"stats":{"Line":2}},{"line":220,"address":[53303550,53304078],"length":1,"stats":{"Line":4}},{"line":221,"address":[57105185],"length":1,"stats":{"Line":2}},{"line":223,"address":[53304115,53304206],"length":1,"stats":{"Line":4}},{"line":229,"address":[57098000,57099427,57099421],"length":1,"stats":{"Line":16}},{"line":230,"address":[57098055],"length":1,"stats":{"Line":11}},{"line":231,"address":[53337635],"length":1,"stats":{"Line":16}},{"line":234,"address":[57098297,57098994],"length":1,"stats":{"Line":27}},{"line":235,"address":[57099002,57099093],"length":1,"stats":{"Line":11}},{"line":237,"address":[55965495],"length":1,"stats":{"Line":0}},{"line":239,"address":[53338534,53338703],"length":1,"stats":{"Line":7}},{"line":242,"address":[53337731],"length":1,"stats":{"Line":2}},{"line":243,"address":[55965862,55964783],"length":1,"stats":{"Line":2}},{"line":244,"address":[55965930],"length":1,"stats":{"Line":2}},{"line":247,"address":[53337823],"length":1,"stats":{"Line":2}},{"line":248,"address":[53298486,53297418],"length":1,"stats":{"Line":4}},{"line":249,"address":[53338990],"length":1,"stats":{"Line":2}},{"line":253,"address":[53297460],"length":1,"stats":{"Line":3}},{"line":260,"address":[53339117,53337936],"length":1,"stats":{"Line":3}},{"line":261,"address":[55966225],"length":1,"stats":{"Line":3}},{"line":263,"address":[55966250],"length":1,"stats":{"Line":3}},{"line":264,"address":[55966361,55966275],"length":1,"stats":{"Line":3}},{"line":265,"address":[55966313],"length":1,"stats":{"Line":3}},{"line":266,"address":[57099968,57099911,57099992],"length":1,"stats":{"Line":6}},{"line":267,"address":[53339359,53339397],"length":1,"stats":{"Line":6}},{"line":268,"address":[53299259,53299167],"length":1,"stats":{"Line":3}},{"line":269,"address":[53339635],"length":1,"stats":{"Line":3}},{"line":271,"address":[57100271,57100328],"length":1,"stats":{"Line":5}},{"line":272,"address":[53339725],"length":1,"stats":{"Line":2}},{"line":273,"address":[57100361,57100444,57100468],"length":1,"stats":{"Line":4}},{"line":274,"address":[53299446,53299408],"length":1,"stats":{"Line":4}},{"line":275,"address":[57100744,57100683],"length":1,"stats":{"Line":2}},{"line":276,"address":[53340113],"length":1,"stats":{"Line":2}},{"line":279,"address":[55966821,55967201,55967227],"length":1,"stats":{"Line":4}},{"line":280,"address":[55967205],"length":1,"stats":{"Line":2}},{"line":283,"address":[53338024],"length":1,"stats":{"Line":2}},{"line":286,"address":[57098688],"length":1,"stats":{"Line":2}},{"line":287,"address":[57098713,57100825,57100877],"length":1,"stats":{"Line":4}},{"line":288,"address":[57100829],"length":1,"stats":{"Line":2}},{"line":289,"address":[53340245,53340371,53340302],"length":1,"stats":{"Line":4}},{"line":292,"address":[55967346,55967424],"length":1,"stats":{"Line":2}},{"line":293,"address":[55967492],"length":1,"stats":{"Line":2}},{"line":294,"address":[53300044],"length":1,"stats":{"Line":2}},{"line":295,"address":[55967542],"length":1,"stats":{"Line":2}},{"line":298,"address":[53340527],"length":1,"stats":{"Line":2}},{"line":301,"address":[53340749],"length":1,"stats":{"Line":2}},{"line":303,"address":[53300339,53300426],"length":1,"stats":{"Line":2}},{"line":304,"address":[53300378],"length":1,"stats":{"Line":2}},{"line":305,"address":[55967926,55967878,55967952],"length":1,"stats":{"Line":4}},{"line":306,"address":[53340890],"length":1,"stats":{"Line":2}},{"line":309,"address":[55965173],"length":1,"stats":{"Line":4}},{"line":310,"address":[55967981,55965196],"length":1,"stats":{"Line":8}},{"line":311,"address":[55968081,55967989],"length":1,"stats":{"Line":4}},{"line":313,"address":[57101626],"length":1,"stats":{"Line":2}},{"line":315,"address":[53300672],"length":1,"stats":{"Line":3}},{"line":318,"address":[53338214],"length":1,"stats":{"Line":4}},{"line":320,"address":[53341131,53338226],"length":1,"stats":{"Line":5}},{"line":321,"address":[57101801],"length":1,"stats":{"Line":4}},{"line":322,"address":[57101826],"length":1,"stats":{"Line":4}},{"line":326,"address":[53338306],"length":1,"stats":{"Line":0}},{"line":330,"address":[57098956],"length":1,"stats":{"Line":0}},{"line":335,"address":[53337544],"length":1,"stats":{"Line":2}},{"line":336,"address":[55964550],"length":1,"stats":{"Line":2}},{"line":340,"address":[53298372],"length":1,"stats":{"Line":9}},{"line":343,"address":[53329120,53331082,53331088],"length":1,"stats":{"Line":18}},{"line":344,"address":[57089831],"length":1,"stats":{"Line":12}},{"line":345,"address":[55956409],"length":1,"stats":{"Line":8}},{"line":346,"address":[53289024],"length":1,"stats":{"Line":4}},{"line":347,"address":[55957161],"length":1,"stats":{"Line":4}},{"line":348,"address":[57091623,57090788],"length":1,"stats":{"Line":17}},{"line":350,"address":[57090973],"length":1,"stats":{"Line":2}},{"line":352,"address":[53330333,53331101],"length":1,"stats":{"Line":2}},{"line":354,"address":[53330919],"length":1,"stats":{"Line":5}},{"line":355,"address":[53331280,53330934],"length":1,"stats":{"Line":7}},{"line":358,"address":[53290576],"length":1,"stats":{"Line":2}},{"line":360,"address":[53330580],"length":1,"stats":{"Line":2}},{"line":362,"address":[57091243],"length":1,"stats":{"Line":2}},{"line":363,"address":[53290289],"length":1,"stats":{"Line":5}},{"line":364,"address":[55957774,55958229],"length":1,"stats":{"Line":4}},{"line":369,"address":[53289096],"length":1,"stats":{"Line":3}},{"line":370,"address":[57090132,57092219],"length":1,"stats":{"Line":3}},{"line":373,"address":[53289293],"length":1,"stats":{"Line":2}},{"line":374,"address":[53289323,53291293],"length":1,"stats":{"Line":4}},{"line":375,"address":[53291488],"length":1,"stats":{"Line":2}},{"line":378,"address":[53289377],"length":1,"stats":{"Line":7}},{"line":384,"address":[53332163,53329791],"length":1,"stats":{"Line":13}},{"line":385,"address":[53332368],"length":1,"stats":{"Line":12}},{"line":387,"address":[55959642],"length":1,"stats":{"Line":6}},{"line":388,"address":[53292258],"length":1,"stats":{"Line":2}},{"line":389,"address":[53332675],"length":1,"stats":{"Line":2}},{"line":390,"address":[55959745],"length":1,"stats":{"Line":2}},{"line":391,"address":[57093376],"length":1,"stats":{"Line":2}},{"line":392,"address":[55959805],"length":1,"stats":{"Line":2}},{"line":394,"address":[55959835],"length":1,"stats":{"Line":2}},{"line":395,"address":[57093461],"length":1,"stats":{"Line":2}},{"line":398,"address":[55959890],"length":1,"stats":{"Line":2}},{"line":399,"address":[53332875],"length":1,"stats":{"Line":2}},{"line":402,"address":[57093546],"length":1,"stats":{"Line":2}},{"line":403,"address":[53332930],"length":1,"stats":{"Line":2}},{"line":406,"address":[53332960],"length":1,"stats":{"Line":2}},{"line":407,"address":[53292598],"length":1,"stats":{"Line":2}},{"line":410,"address":[53333015],"length":1,"stats":{"Line":2}},{"line":411,"address":[57093681],"length":1,"stats":{"Line":3}},{"line":414,"address":[57093711],"length":1,"stats":{"Line":2}},{"line":415,"address":[53292708],"length":1,"stats":{"Line":2}},{"line":420,"address":[53289500],"length":1,"stats":{"Line":2}},{"line":424,"address":[57093804],"length":1,"stats":{"Line":2}},{"line":425,"address":[53333188],"length":1,"stats":{"Line":2}},{"line":426,"address":[57094061],"length":1,"stats":{"Line":2}},{"line":429,"address":[57094091,57093766],"length":1,"stats":{"Line":0}},{"line":430,"address":[57094294],"length":1,"stats":{"Line":0}},{"line":431,"address":[53293291],"length":1,"stats":{"Line":0}},{"line":435,"address":[57090557],"length":1,"stats":{"Line":2}},{"line":442,"address":[53293359],"length":1,"stats":{"Line":2}},{"line":443,"address":[53293591],"length":1,"stats":{"Line":2}},{"line":444,"address":[57094644],"length":1,"stats":{"Line":2}},{"line":445,"address":[53293641,53293733],"length":1,"stats":{"Line":2}},{"line":446,"address":[57094713],"length":1,"stats":{"Line":2}},{"line":447,"address":[53334160,53334184,53334103],"length":1,"stats":{"Line":4}},{"line":448,"address":[55961204,55961242],"length":1,"stats":{"Line":4}},{"line":449,"address":[55961441,55961554],"length":1,"stats":{"Line":2}},{"line":450,"address":[55961480],"length":1,"stats":{"Line":2}},{"line":451,"address":[57095098],"length":1,"stats":{"Line":2}},{"line":452,"address":[57095199,57095123,57095173],"length":1,"stats":{"Line":4}},{"line":453,"address":[53294149],"length":1,"stats":{"Line":2}},{"line":456,"address":[55961627,55960752],"length":1,"stats":{"Line":4}},{"line":457,"address":[57095423],"length":1,"stats":{"Line":2}},{"line":458,"address":[55961857],"length":1,"stats":{"Line":2}},{"line":459,"address":[55961993,55961882],"length":1,"stats":{"Line":2}},{"line":460,"address":[53334880],"length":1,"stats":{"Line":2}},{"line":461,"address":[53294508],"length":1,"stats":{"Line":2}},{"line":462,"address":[57095561,57095618,57095642],"length":1,"stats":{"Line":4}},{"line":463,"address":[53334991,53335029],"length":1,"stats":{"Line":4}},{"line":464,"address":[53294917,53294829],"length":1,"stats":{"Line":2}},{"line":465,"address":[53335267],"length":1,"stats":{"Line":2}},{"line":466,"address":[57095971,57095921,57095997],"length":1,"stats":{"Line":4}},{"line":467,"address":[53335346],"length":1,"stats":{"Line":2}},{"line":471,"address":[57090651],"length":1,"stats":{"Line":0}},{"line":475,"address":[57090686,57096010],"length":1,"stats":{"Line":0}},{"line":476,"address":[57096086,57096601],"length":1,"stats":{"Line":0}},{"line":480,"address":[53335538],"length":1,"stats":{"Line":0}},{"line":481,"address":[53335617,53335887],"length":1,"stats":{"Line":0}},{"line":483,"address":[57096430],"length":1,"stats":{"Line":0}},{"line":484,"address":[53335770],"length":1,"stats":{"Line":0}},{"line":489,"address":[53330065],"length":1,"stats":{"Line":0}},{"line":490,"address":[53330080,53336043],"length":1,"stats":{"Line":0}},{"line":494,"address":[57089934],"length":1,"stats":{"Line":0}},{"line":495,"address":[57089900],"length":1,"stats":{"Line":0}},{"line":499,"address":[53290689],"length":1,"stats":{"Line":8}},{"line":502,"address":[53345311,53345120,53345317],"length":1,"stats":{"Line":7}},{"line":503,"address":[53304658],"length":1,"stats":{"Line":4}},{"line":504,"address":[53304798],"length":1,"stats":{"Line":7}},{"line":507,"address":[55974688],"length":1,"stats":{"Line":6}},{"line":508,"address":[53347672],"length":1,"stats":{"Line":8}},{"line":509,"address":[57108098],"length":1,"stats":{"Line":8}},{"line":514,"address":[53307456,53308382,53308371],"length":1,"stats":{"Line":7}},{"line":515,"address":[55975184],"length":1,"stats":{"Line":8}},{"line":516,"address":[53348227,53348159],"length":1,"stats":{"Line":15}},{"line":517,"address":[57108748],"length":1,"stats":{"Line":8}},{"line":518,"address":[53348654,53348499],"length":1,"stats":{"Line":0}},{"line":519,"address":[57108930,57109059],"length":1,"stats":{"Line":0}},{"line":520,"address":[57109064,57108961],"length":1,"stats":{"Line":4}},{"line":521,"address":[53307952,53308029],"length":1,"stats":{"Line":0}},{"line":522,"address":[55975663,55975714],"length":1,"stats":{"Line":4}},{"line":523,"address":[55975723,55976057,55975517],"length":1,"stats":{"Line":24}},{"line":524,"address":[53348728],"length":1,"stats":{"Line":0}},{"line":527,"address":[57108832],"length":1,"stats":{"Line":4}},{"line":531,"address":[53307422,53307088,53307428],"length":1,"stats":{"Line":3}},{"line":532,"address":[57108160],"length":1,"stats":{"Line":3}},{"line":533,"address":[53307282],"length":1,"stats":{"Line":4}},{"line":534,"address":[53307340],"length":1,"stats":{"Line":4}}],"covered":247,"coverable":271},{"path":["/","home","md","language","mdhavers","tests","golden_tests.rs"],"content":"//! Golden tests for mdhavers language\n//!\n//! Runs .braw files and compares output against .expected files.\n//! Tests both interpreter and LLVM native compilation.\n\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Discover all golden tests in a directory recursively\nfn discover_tests(dir: &Path) -> Vec<PathBuf> {\n    let mut tests = Vec::new();\n\n    if dir.is_dir() {\n        if let Ok(entries) = fs::read_dir(dir) {\n            for entry in entries.flatten() {\n                let path = entry.path();\n\n                if path.is_dir() {\n                    tests.extend(discover_tests(&path));\n                } else if path.extension().map_or(false, |e| e == \"braw\") {\n                    // Check if corresponding .expected file exists\n                    let expected = path.with_extension(\"expected\");\n                    if expected.exists() {\n                        tests.push(path);\n                    }\n                }\n            }\n        }\n    }\n\n    tests.sort();\n    tests\n}\n\n/// Check if a test should be skipped for a given mode\nfn should_skip(source: &str, mode: &str) -> bool {\n    match mode {\n        \"native\" => source.contains(\"// SKIP_NATIVE\") || source.contains(\"# SKIP_NATIVE\"),\n        \"interpreter\" => {\n            source.contains(\"// SKIP_INTERPRETER\") || source.contains(\"# SKIP_INTERPRETER\")\n        }\n        _ => false,\n    }\n}\n\n/// Compare actual output with expected output\nfn compare_output(actual: &str, expected: &str) -> Result<(), String> {\n    let actual_trimmed = actual.trim();\n    let expected_trimmed = expected.trim();\n\n    if actual_trimmed == expected_trimmed {\n        return Ok(());\n    }\n\n    let actual_lines: Vec<&str> = actual_trimmed.lines().collect();\n    let expected_lines: Vec<&str> = expected_trimmed.lines().collect();\n\n    let mut diff = String::new();\n    diff.push_str(\"Output mismatch:\\n\");\n    diff.push_str(\"--- Expected ---\\n\");\n    for line in &expected_lines {\n        diff.push_str(&format!(\"  {}\\n\", line));\n    }\n    diff.push_str(\"--- Actual ---\\n\");\n    for line in &actual_lines {\n        diff.push_str(&format!(\"  {}\\n\", line));\n    }\n    Err(diff)\n}\n\n/// Run a single golden test with interpreter\nfn run_interpreter_test(braw_path: &Path) -> Result<String, String> {\n    let source = fs::read_to_string(braw_path)\n        .map_err(|e| format!(\"Failed to read {}: {}\", braw_path.display(), e))?;\n\n    let (_value, output) =\n        mdhavers::run_with_output(&source).map_err(|e| format!(\"Interpreter error: {:?}\", e))?;\n\n    Ok(output.join(\"\\n\"))\n}\n\n/// Run a single golden test with LLVM native compilation\n#[cfg(feature = \"llvm\")]\nfn run_native_test(braw_path: &Path) -> Result<String, String> {\n    use std::process::Command;\n    use tempfile::tempdir;\n\n    let source = fs::read_to_string(braw_path)\n        .map_err(|e| format!(\"Failed to read {}: {}\", braw_path.display(), e))?;\n\n    let program = mdhavers::parse(&source).map_err(|e| format!(\"Parse error: {:?}\", e))?;\n\n    let dir = tempdir().map_err(|e| format!(\"Failed to create temp dir: {}\", e))?;\n    let exe_path = dir.path().join(\"test_exe\");\n\n    let compiler = mdhavers::LLVMCompiler::new();\n    compiler\n        .compile_to_native(&program, &exe_path, 2)\n        .map_err(|e| format!(\"Compile error: {:?}\", e))?;\n\n    let output = Command::new(&exe_path)\n        .output()\n        .map_err(|e| format!(\"Failed to run executable: {}\", e))?;\n\n    if !output.status.success() {\n        return Err(format!(\"Exit code: {:?}\", output.status.code()));\n    }\n\n    Ok(String::from_utf8_lossy(&output.stdout).to_string())\n}\n\n/// Main test function - runs all golden tests with interpreter\n#[test]\nfn golden_tests_interpreter() {\n    let golden_dir = Path::new(\"tests/golden\");\n    let tests = discover_tests(golden_dir);\n\n    if tests.is_empty() {\n        println!(\"No golden tests found in {}\", golden_dir.display());\n        return;\n    }\n\n    let mut failures = Vec::new();\n    let mut skipped = 0;\n\n    for test_path in &tests {\n        let source = fs::read_to_string(test_path).unwrap();\n\n        if should_skip(&source, \"interpreter\") {\n            skipped += 1;\n            continue;\n        }\n\n        let expected_path = test_path.with_extension(\"expected\");\n        let expected = fs::read_to_string(&expected_path).expect(\"Failed to read expected file\");\n\n        match run_interpreter_test(test_path) {\n            Ok(actual) => {\n                if let Err(diff) = compare_output(&actual, &expected) {\n                    failures.push((test_path.clone(), diff));\n                }\n            }\n            Err(e) => {\n                failures.push((test_path.clone(), e));\n            }\n        }\n    }\n\n    if !failures.is_empty() {\n        let mut msg = format!(\"\\n{} golden tests failed:\\n\\n\", failures.len());\n        for (path, error) in &failures {\n            msg.push_str(&format!(\"FAIL: {}\\n{}\\n\\n\", path.display(), error));\n        }\n        panic!(\"{}\", msg);\n    }\n\n    println!(\n        \"\\n {} golden tests passed (interpreter), {} skipped\",\n        tests.len() - skipped,\n        skipped\n    );\n}\n\n/// Run all golden tests with LLVM native compilation\n#[test]\n#[cfg(feature = \"llvm\")]\nfn golden_tests_native() {\n    let golden_dir = Path::new(\"tests/golden\");\n    let tests = discover_tests(golden_dir);\n\n    if tests.is_empty() {\n        println!(\"No golden tests found in {}\", golden_dir.display());\n        return;\n    }\n\n    let mut failures = Vec::new();\n    let mut skipped = 0;\n\n    for test_path in &tests {\n        let source = fs::read_to_string(test_path).unwrap();\n\n        if should_skip(&source, \"native\") {\n            skipped += 1;\n            continue;\n        }\n\n        let expected_path = test_path.with_extension(\"expected\");\n        let expected = fs::read_to_string(&expected_path).expect(\"Failed to read expected file\");\n\n        match run_native_test(test_path) {\n            Ok(actual) => {\n                if let Err(diff) = compare_output(&actual, &expected) {\n                    failures.push((test_path.clone(), diff));\n                }\n            }\n            Err(e) => {\n                failures.push((test_path.clone(), e));\n            }\n        }\n    }\n\n    if !failures.is_empty() {\n        let mut msg = format!(\"\\n{} golden tests failed:\\n\\n\", failures.len());\n        for (path, error) in &failures {\n            msg.push_str(&format!(\"FAIL: {}\\n{}\\n\\n\", path.display(), error));\n        }\n        panic!(\"{}\", msg);\n    }\n\n    println!(\n        \"\\n {} golden tests passed (native), {} skipped\",\n        tests.len() - skipped,\n        skipped\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","md","language","mdhavers","tests","llvm_standalone_tests.rs"],"content":"//! Integration tests for LLVM standalone executable compilation\n//!\n//! These tests verify that mdhavers produces standalone executables\n//! that only depend on system libraries (libc, ld-linux).\n\n#![cfg(feature = \"llvm\")]\n\nuse std::process::Command;\n\nuse mdhavers::{parse, LLVMCompiler};\nuse tempfile::tempdir;\n\n/// Helper to compile source code and run the resulting executable\nfn compile_and_run(source: &str) -> Result<String, String> {\n    let program = parse(source).map_err(|e| format!(\"Parse error: {:?}\", e))?;\n\n    let dir = tempdir().map_err(|e| format!(\"Failed to create temp dir: {}\", e))?;\n    let exe_path = dir.path().join(\"test_exe\");\n\n    let compiler = LLVMCompiler::new();\n    compiler\n        .compile_to_native(&program, &exe_path, 2)\n        .map_err(|e| format!(\"Compile error: {:?}\", e))?;\n\n    let output = Command::new(&exe_path)\n        .output()\n        .map_err(|e| format!(\"Failed to run executable: {}\", e))?;\n\n    if !output.status.success() {\n        return Err(format!(\n            \"Executable failed with exit code: {:?}\",\n            output.status.code()\n        ));\n    }\n\n    Ok(String::from_utf8_lossy(&output.stdout).to_string())\n}\n\n/// Helper to verify that an executable only has system dependencies\nfn verify_standalone(source: &str) -> Result<(), String> {\n    let program = parse(source).map_err(|e| format!(\"Parse error: {:?}\", e))?;\n\n    let dir = tempdir().map_err(|e| format!(\"Failed to create temp dir: {}\", e))?;\n    let exe_path = dir.path().join(\"test_exe\");\n\n    let compiler = LLVMCompiler::new();\n    compiler\n        .compile_to_native(&program, &exe_path, 2)\n        .map_err(|e| format!(\"Compile error: {:?}\", e))?;\n\n    // Run ldd on the executable\n    let output = Command::new(\"ldd\")\n        .arg(&exe_path)\n        .output()\n        .map_err(|e| format!(\"Failed to run ldd: {}\", e))?;\n\n    let ldd_output = String::from_utf8_lossy(&output.stdout);\n\n    // Check that we only have system libraries\n    for line in ldd_output.lines() {\n        let line = line.trim();\n        if line.is_empty() {\n            continue;\n        }\n\n        // Allowed dependencies: libc, ld-linux, linux-vdso, libm\n        let allowed = [\"libc.so\", \"ld-linux\", \"linux-vdso\", \"libm.so\"];\n\n        let is_allowed = allowed.iter().any(|lib| line.contains(lib));\n\n        if !is_allowed {\n            return Err(format!(\"Found unexpected dependency: {}\", line));\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_simple_print() {\n    let source = r#\"\n        ken x = 42\n        blether x\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"42\");\n}\n\n#[test]\nfn test_string_print() {\n    let source = r#\"\n        blether \"Hello, standalone!\"\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"Hello, standalone!\");\n}\n\n#[test]\nfn test_arithmetic_add() {\n    let source = r#\"\n        ken a = 10\n        ken b = 5\n        blether a + b\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"15\");\n}\n\n#[test]\nfn test_arithmetic_sub() {\n    let source = r#\"\n        ken a = 10\n        ken b = 3\n        blether a - b\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"7\");\n}\n\n#[test]\nfn test_arithmetic_mul() {\n    let source = r#\"\n        ken a = 6\n        ken b = 7\n        blether a * b\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"42\");\n}\n\n#[test]\nfn test_arithmetic_div() {\n    let source = r#\"\n        ken a = 20\n        ken b = 4\n        blether a / b\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"5\");\n}\n\n#[test]\nfn test_arithmetic_mod() {\n    let source = r#\"\n        ken a = 17\n        ken b = 5\n        blether a % b\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"2\");\n}\n\n#[test]\nfn test_conditional_true() {\n    let source = r#\"\n        ken x = 10\n        gin x > 5 {\n            blether \"big\"\n        } ither {\n            blether \"wee\"\n        }\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"big\");\n}\n\n#[test]\nfn test_conditional_false() {\n    let source = r#\"\n        ken x = 3\n        gin x > 5 {\n            blether \"big\"\n        } ither {\n            blether \"wee\"\n        }\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"wee\");\n}\n\n#[test]\nfn test_while_loop() {\n    let source = r#\"\n        ken i = 0\n        ken sum = 0\n        whiles i < 5 {\n            sum = sum + i\n            i = i + 1\n        }\n        blether sum\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"10\"); // 0+1+2+3+4 = 10\n}\n\n#[test]\nfn test_function_call() {\n    let source = r#\"\n        dae add(a, b) {\n            gie a + b\n        }\n\n        blether add(3, 4)\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"7\");\n}\n\n#[test]\nfn test_recursive_function() {\n    let source = r#\"\n        dae factorial(n) {\n            gin n <= 1 {\n                gie 1\n            }\n            gie n * factorial(n - 1)\n        }\n\n        blether factorial(5)\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"120\");\n}\n\n#[test]\nfn test_multiple_functions() {\n    let source = r#\"\n        dae double(x) {\n            gie x * 2\n        }\n\n        dae add_one(x) {\n            gie x + 1\n        }\n\n        ken result = double(add_one(5))\n        blether result\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"12\"); // (5+1)*2 = 12\n}\n\n#[test]\nfn test_negative_numbers() {\n    let source = r#\"\n        ken x = 5\n        ken y = 0 - x\n        blether y\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"-5\");\n}\n\n#[test]\nfn test_bool_true() {\n    let source = r#\"\n        blether aye\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"aye\");\n}\n\n#[test]\nfn test_bool_false() {\n    let source = r#\"\n        blether nae\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"nae\");\n}\n\n#[test]\nfn test_nil() {\n    let source = r#\"\n        blether naething\n    \"#;\n\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"naething\");\n}\n\n#[test]\nfn test_standalone_no_custom_deps() {\n    let source = r#\"\n        ken x = 42\n        blether x\n    \"#;\n\n    verify_standalone(source).expect(\"Executable has unexpected dependencies\");\n}\n\n#[test]\nfn test_complex_standalone() {\n    let source = r#\"\n        dae fibonacci(n) {\n            gin n <= 1 {\n                gie n\n            }\n            gie fibonacci(n - 1) + fibonacci(n - 2)\n        }\n\n        blether fibonacci(10)\n    \"#;\n\n    // First verify it's standalone\n    verify_standalone(source).expect(\"Executable has unexpected dependencies\");\n\n    // Then verify the output\n    let output = compile_and_run(source).expect(\"Compilation failed\");\n    assert_eq!(output.trim(), \"55\");\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":37.33352775347526,"covered":7681,"coverable":20574}