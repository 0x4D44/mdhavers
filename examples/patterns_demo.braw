# patterns_demo.braw - Demonstrate pattern matching in mdhavers
# "Patterns are like tartan - they repeat in bonnie ways!"

fetch "../stdlib/patterns"

blether ""
blether "═══════════════════════════════════════════════════"
blether "    PATTERN MATCHING DEMO"
blether "    'Findin' needles in haystacks, Scottish style!'"
blether "═══════════════════════════════════════════════════"
blether ""

# ===============================================================
# Basic Wildcard Matching
# ===============================================================

blether "=== Basic Wildcard Matching ==="
blether ""

# Test * wildcard (matches any sequence)
blether "Testing * wildcard (matches any sequence):"
ken tests_star = [
    ["hello", "hello", aye],
    ["hello", "h*o", aye],
    ["hello", "*", aye],
    ["hello", "he*", aye],
    ["hello", "*lo", aye],
    ["hello", "h*l*o", aye],
    ["hello", "world", nae],
    ["", "*", aye],
    ["abc", "a*c", aye]
]

fer test in tests_star {
    ken text = test[0]
    ken pattern = test[1]
    ken expected = test[2]
    ken result = matches(text, pattern)
    ken status = gin result == expected than "PASS" ither "FAIL"
    blether f"  matches(\"{text}\", \"{pattern}\") = {result} [{status}]"
}

blether ""

# Test ? wildcard (matches exactly one)
blether "Testing ? wildcard (matches exactly one):"
ken tests_question = [
    ["abc", "a?c", aye],
    ["abc", "???", aye],
    ["abc", "??", nae],
    ["abc", "????", nae],
    ["hello", "h?llo", aye],
    ["hello", "?ello", aye],
    ["hello", "hell?", aye]
]

fer test in tests_question {
    ken text = test[0]
    ken pattern = test[1]
    ken expected = test[2]
    ken result = matches(text, pattern)
    ken status = gin result == expected than "PASS" ither "FAIL"
    blether f"  matches(\"{text}\", \"{pattern}\") = {result} [{status}]"
}

blether ""

# Test character classes [...]
blether "Testing [...] character classes:"
ken tests_class = [
    ["cat", "[abc]at", aye],
    ["bat", "[abc]at", aye],
    ["hat", "[abc]at", nae],
    ["dog", "d[aeiou]g", aye],
    ["dig", "d[aeiou]g", aye],
    ["dug", "d[aeiou]g", aye]
]

fer test in tests_class {
    ken text = test[0]
    ken pattern = test[1]
    ken expected = test[2]
    ken result = matches(text, pattern)
    ken status = gin result == expected than "PASS" ither "FAIL"
    blether f"  matches(\"{text}\", \"{pattern}\") = {result} [{status}]"
}

blether ""

# ===============================================================
# Glob Pattern Matching (for filenames)
# ===============================================================

blether "=== Glob Pattern Matching (fer filenames) ==="
blether ""

ken filenames = [
    "haggis.braw",
    "whisky.braw",
    "neeps.txt",
    "tatties.txt",
    "ceilidh.braw",
    "README.md",
    "test_haggis.braw",
    "main.rs"
]

blether "Files: " + join(filenames, ", ")
blether ""

ken braw_files = glob_filter(filenames, "*.braw")
blether "*.braw matches: " + join(braw_files, ", ")

ken test_files = glob_filter(filenames, "test_*")
blether "test_* matches: " + join(test_files, ", ")

ken txt_files = glob_filter(filenames, "*.txt")
blether "*.txt matches: " + join(txt_files, ", ")

ken h_files = glob_filter(filenames, "h*")
blether "h* matches: " + join(h_files, ", ")

blether ""

# ===============================================================
# String Helpers
# ===============================================================

blether "=== String Helper Functions ==="
blether ""

ken test_str = "Hello, Scotland!"

blether f"Original string: \"{test_str}\""
blether f"  starts_with_str(\"Hello\"): {starts_with_str(test_str, 'Hello')}"
blether f"  starts_with_str(\"Goodbye\"): {starts_with_str(test_str, 'Goodbye')}"
blether f"  ends_with_str(\"land!\"): {ends_with_str(test_str, 'land!')}"
blether f"  ends_with_str(\".braw\"): {ends_with_str(test_str, '.braw')}"

blether ""

ken replaced = replace_all_str("haggis haggis haggis", "haggis", "whisky")
blether f"replace_all_str(\"haggis haggis haggis\", \"haggis\", \"whisky\") = \"{replaced}\""

blether ""

# ===============================================================
# Text Extraction
# ===============================================================

blether "=== Text Extraction ==="
blether ""

ken scottish_text = "Och! There were 42 highland coos and 17 wee lambs on the bonnie braes!"

blether f"Text: \"{scottish_text}\""
blether ""

ken words = extract_words(scottish_text)
blether f"Extracted words ({len(words)}): {join(words, ', ')}"

ken numbers = extract_numbers(scottish_text)
blether f"Extracted numbers ({len(numbers)}): {numbers}"

blether ""

# ===============================================================
# Pattern Validators
# ===============================================================

blether "=== Pattern Validators ==="
blether ""

# Test is_word
ken word_tests = ["hello", "Haggis", "123", "hello123", "hello world", "it's"]
blether "Testing is_word():"
fer w in word_tests {
    blether f"  is_word(\"{w}\"): {is_word(w)}"
}

blether ""

# Test looks_like_email
ken email_tests = ["jock@scotland.scot", "nae-at-sign", "missing@dot", "valid@example.com", "@nolocal.com", "nodomain@"]
blether "Testing looks_like_email():"
fer e in email_tests {
    blether f"  looks_like_email(\"{e}\"): {looks_like_email(e)}"
}

blether ""

# Test looks_like_url
ken url_tests = ["https://scotland.scot", "http://haggis.com", "ftp://notaurl", "just text"]
blether "Testing looks_like_url():"
fer u in url_tests {
    blether f"  looks_like_url(\"{u}\"): {looks_like_url(u)}"
}

blether ""

# ===============================================================
# Combined Examples
# ===============================================================

blether "=== Combined Examples ==="
blether ""

# Find pattern in text
blether "Finding patterns in text:"
ken haystack = "The bonnie lassie danced at the ceilidh"
ken needle = "lassie"
ken pos = find_pattern(haystack, needle)
blether f"  find_pattern(\"{haystack}\", \"{needle}\") = position {pos}"

ken needle2 = "haggis"
ken pos2 = find_pattern(haystack, needle2)
blether f"  find_pattern(\"{haystack}\", \"{needle2}\") = position {pos2}"

blether ""

# Pattern with wildcards
blether "Pattern matching with wildcards:"
ken texts = ["Edinburgh", "Glasgow", "Dundee", "Aberdeen", "Edinburra"]
fer t in texts {
    ken match1 = matches(t, "E*")
    ken match2 = matches(t, "*burgh")
    ken match3 = matches(t, "????ow")
    blether f"  \"{t}\": E*={match1}, *burgh={match2}, ????ow={match3}"
}

# ===============================================================
# Type Pattern Matchers (Functional Style)
# ===============================================================

blether ""
blether "=== Type Pattern Matchers ==="
blether ""

ken values = [42, "hello", 3.14, aye, [1, 2, 3], {"name": "Hamish"}, naething]

blether "Matching different types:"
fer val in values {
    ken type_msg = when_string(val, |s| f"String: \"{s}\"")
    gin type_msg == naething {
        type_msg = when_int(val, |n| f"Integer: {n}")
    }
    gin type_msg == naething {
        type_msg = when_float(val, |f| f"Float: {f}")
    }
    gin type_msg == naething {
        type_msg = when_bool(val, |b| f"Bool: {b}")
    }
    gin type_msg == naething {
        type_msg = when_list(val, |l| f"List with {len(l)} items")
    }
    gin type_msg == naething {
        type_msg = when_dict(val, |d| f"Dict with {len(keys(d))} keys")
    }
    gin type_msg == naething {
        type_msg = when_nil(val, || "Naething (nil)")
    }
    gin type_msg == naething {
        type_msg = "Unknown type"
    }
    blether f"  {val} -> {type_msg}"
}

# ===============================================================
# Numeric Pattern Matchers
# ===============================================================

blether ""
blether "=== Numeric Pattern Matchers ==="
blether ""

ken numbers = [-5, 0, 7, 42, 100]

blether "Testing numeric patterns:"
fer n in numbers {
    ken desc = []

    gin when_positive(n, |x| x) != naething {
        shove(desc, "positive")
    }
    gin when_negative(n, |x| x) != naething {
        shove(desc, "negative")
    }
    gin when_zero(n, |x| x) != naething {
        shove(desc, "zero")
    }
    gin when_even(n, |x| x) != naething {
        shove(desc, "even")
    }
    gin when_odd(n, |x| x) != naething {
        shove(desc, "odd")
    }
    gin when_between(n, 10, 50, |x| x) != naething {
        shove(desc, "between 10-50")
    }

    blether f"  {n}: {join(desc, \", \")}"
}

# ===============================================================
# List Pattern Matchers
# ===============================================================

blether ""
blether "=== List Pattern Matchers ==="
blether ""

ken lists = [[], [42], [1, 2], [1, 2, 3], [1, 2, 3, 4, 5]]

blether "List structure matching:"
fer lst in lists {
    ken desc = f"{lst}: "

    ken result = when_toom(lst, || "empty list")
    gin result == naething {
        result = when_single(lst, |x| f"single element: {x}")
    }
    gin result == naething {
        result = when_pair(lst, |a, b| f"pair [{a}, {b}]")
    }
    gin result == naething {
        result = when_triple(lst, |a, b, c| f"triple [{a}, {b}, {c}]")
    }
    gin result == naething {
        result = f"list with {len(lst)} elements"
    }

    blether f"  {desc}{result}"
}

# ===============================================================
# Some/None Pattern (Option Type)
# ===============================================================

blether ""
blether "=== Some/None (Option Type) ==="
blether ""

blether "Safe operations returning Some or None:"

# Safe division
ken div1 = safe_divide(10, 2)
ken div2 = safe_divide(10, 0)

blether f"  10 / 2 = {unwrap_or(div1, \"error\")}"
blether f"  10 / 0 = {unwrap_or(div2, \"cannae divide by zero!\")}"

# Safe list access
ken my_list = [10, 20, 30]
ken get1 = safe_get(my_list, 1)
ken get2 = safe_get(my_list, 10)

blether f"  my_list[1] = {unwrap_or(get1, \"oot o' bounds\")}"
blether f"  my_list[10] = {unwrap_or(get2, \"oot o' bounds\")}"

# Safe parsing
ken parse1 = safe_parse_int("42")
ken parse2 = safe_parse_int("hello")

blether f"  parse '42' = {unwrap_or(parse1, \"parse error\")}"
blether f"  parse 'hello' = {unwrap_or(parse2, \"parse error\")}"

# Mapping over Some
ken doubled = map_some(safe_parse_int("21"), |n| n * 2)
blether f"  parse and double '21' = {unwrap_or(doubled, \"error\")}"

# ===============================================================
# Left/Right Pattern (Either Type)
# ===============================================================

blether ""
blether "=== Left/Right (Either Type) ==="
blether ""

# Function that returns Either
dae parse_positive(s) {
    ken result = safe_parse_int(s)
    gin is_some(result) {
        ken n = unwrap_or(result, 0)
        gin n > 0 {
            gie right(n)
        } ither {
            gie left("Number must be positive")
        }
    } ither {
        gie left(f"Could not parse '{s}' as integer")
    }
}

ken inputs = ["42", "-5", "hello", "100"]

blether "Parsing positive integers:"
fer input in inputs {
    ken result = parse_positive(input)

    ken msg = when_right(result, |n| f"Success: {n}")
    gin msg == naething {
        msg = when_left(result, |err| f"Error: {err}")
    }

    blether f"  parse_positive('{input}'): {msg}"
}

blether ""
blether "═══════════════════════════════════════════════════"
blether "    Pattern matching demo complete!"
blether "    'Every tartan has its pattern'"
blether "═══════════════════════════════════════════════════"
blether ""
