# Functional Programming in mdhavers
# Demonstrating lambdas, higher-order functions, and pattern matching

blether "=== LAMBDAS ==="
# Lambdas use pipes: |params| body
ken double = |x| x * 2
ken add = |a, b| a + b

blether "double(5) = " + tae_string(double(5))
blether "add(3, 4) = " + tae_string(add(3, 4))

# Lambdas can be passed around
ken apply_twice = |f, x| f(f(x))
blether "apply_twice(double, 3) = " + tae_string(apply_twice(double, 3))

blether ""
blether "=== HIGHER-ORDER FUNCTIONS ==="
ken numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
blether "numbers = " + tae_string(numbers)

# gaun - map a function over a list (Scots: "going")
ken squares = gaun(numbers, |x| x * x)
blether "gaun(numbers, |x| x * x) = " + tae_string(squares)

# sieve - filter a list (keep what passes)
ken evens = sieve(numbers, |x| x % 2 == 0)
blether "sieve(numbers, |x| x % 2 == 0) = " + tae_string(evens)

ken odds = sieve(numbers, |x| x % 2 != 0)
blether "sieve(numbers, |x| x % 2 != 0) = " + tae_string(odds)

# tumble - reduce/fold a list (Scots: tumble together)
ken total = tumble(numbers, 0, |acc, x| acc + x)
blether "tumble(numbers, 0, |acc, x| acc + x) = " + tae_string(total)

ken product = tumble([1, 2, 3, 4, 5], 1, |acc, x| acc * x)
blether "tumble([1..5], 1, |acc, x| acc * x) = " + tae_string(product)

# hunt - find first matching element
ken first_even = hunt(numbers, |x| x % 2 == 0)
blether "hunt(numbers, |x| x % 2 == 0) = " + tae_string(first_even)

ken first_big = hunt(numbers, |x| x > 7)
blether "hunt(numbers, |x| x > 7) = " + tae_string(first_big)

# ony - check if any element matches (Scots: any)
ken has_ten = ony(numbers, |x| x == 10)
blether "ony(numbers, |x| x == 10) = " + tae_string(has_ten)

ken has_hundred = ony(numbers, |x| x == 100)
blether "ony(numbers, |x| x == 100) = " + tae_string(has_hundred)

# aw - check if all elements match (Scots: all)
ken all_positive = aw(numbers, |x| x > 0)
blether "aw(numbers, |x| x > 0) = " + tae_string(all_positive)

ken all_even = aw(numbers, |x| x % 2 == 0)
blether "aw(numbers, |x| x % 2 == 0) = " + tae_string(all_even)

# ilk - for each (side effects)
# Note: lambdas are expressions, so we use a helper function for printing
dae print_it(x) {
    blether x
}

blether ""
blether "ilk(evens, print_it):"
ilk(evens, print_it)

blether ""
blether "=== PATTERN MATCHING ==="
# keek/whan - match/when pattern matching

dae describe_number(n) {
    keek n {
        whan 0 -> gie "zero"
        whan 1 -> gie "one"
        whan 2 -> gie "two"
        whan x -> gie "some other number: " + tae_string(x)
    }
}

blether "describe_number(0) = " + describe_number(0)
blether "describe_number(1) = " + describe_number(1)
blether "describe_number(42) = " + describe_number(42)

# Pattern matching with strings
dae greet(lang) {
    keek lang {
        whan "scots" -> gie "Hullo!"
        whan "english" -> gie "Hello!"
        whan "french" -> gie "Bonjour!"
        whan _ -> gie "Ah dinnae ken that language!"
    }
}

blether ""
blether "greet(\"scots\") = " + greet("scots")
blether "greet(\"french\") = " + greet("french")
blether "greet(\"klingon\") = " + greet("klingon")

# Combined example: FizzBuzz with pattern matching
blether ""
blether "=== FIZZBUZZ WI' PATTERN MATCHING ==="

dae fizzbuzz(n) {
    ken mod3 = n % 3 == 0
    ken mod5 = n % 5 == 0

    gin mod3 an mod5 {
        gie "FizzBuzz"
    } ither gin mod3 {
        gie "Fizz"
    } ither gin mod5 {
        gie "Buzz"
    } ither {
        gie tae_string(n)
    }
}

# Use gaun to apply fizzbuzz to a range
ken fizzbuzz_results = gaun([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], fizzbuzz)
blether fizzbuzz_results

blether ""
blether "=== CHAINED OPERATIONS ==="
# Chain operations like a pipeline
ken data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Get squares of even numbers that are less than 50
# Step by step to show the pipeline
ken evens_data = sieve(data, |x| x % 2 == 0)
ken squared_evens = gaun(evens_data, |x| x * x)
ken result = sieve(squared_evens, |x| x < 50)
blether "Squares of evens < 50: " + tae_string(result)

# Sum of squares of odd numbers
ken odds_data = sieve(data, |x| x % 2 != 0)
ken squared_odds = gaun(odds_data, |x| x * x)
ken sum_odd_squares = tumble(squared_odds, 0, |a, b| a + b)
blether "Sum of odd squares: " + tae_string(sum_odd_squares)

blether ""
blether "That's yer lot! Functional programming in mdhavers."
