# LLVM Phase 3: String Operations Optimization

## Objective
Optimize string operations in the LLVM backend to close the performance gap with Rust. Current benchmarks show string operations are 5-176x slower than Rust equivalents.

## Current Performance Gaps

| Operation | mdhavers LLVM | Rust | Ratio | Priority |
|-----------|---------------|------|-------|----------|
| 1000x concat | 352 μs | 2 μs | 176x | CRITICAL |
| 1000x upper() | 130 μs | 9 μs | 14x | HIGH |
| 1000x lower() | 158 μs | 10 μs | 16x | HIGH |
| 1000x split() | 610 μs | 73 μs | 8x | MEDIUM |
| 1000x join() | 74 μs | 14 μs | 5x | LOW |

## Root Cause Analysis

### String Concatenation (176x slower)
Current implementation in `inline_add` (lines 1221-1287):
1. Calls `strlen` twice (one per operand)
2. Allocates with `malloc` for every single concatenation
3. Uses `strcpy` + `strcat` which traverse strings again
4. Building a string in a loop is O(n²) due to repeated copying

**Problem pattern:**
```
ken s = ""
whiles i < 1000 {
    s = s + "x"   // Each iteration: strlen(s) + malloc + strcpy + strcat
}
```

### upper/lower (14-16x slower)
Current implementation in `inline_upper` (lines 4019-4128) and `inline_lower`:
1. Calls `strlen` to get length
2. Allocates new buffer with `malloc`
3. Loops character-by-character calling `toupper`/`tolower` per char
4. No SIMD or batch processing

### split (8x slower)
Current implementation in `inline_split` (lines 7770+):
1. Uses `strstr` in a loop to find delimiters
2. Allocates separate string for each part
3. Fixed allocation of 100 elements initially
4. Multiple passes through the string

## Optimization Strategies

### Strategy 1: Fast String Concatenation with memcpy
**Target: Reduce concat from 176x to <20x**

Replace `strcpy` + `strcat` with direct `memcpy`:
- When both lengths are already known, use `memcpy` instead of string functions
- `memcpy` doesn't scan for null terminators, just copies N bytes directly

```rust
// BEFORE (current):
// strcpy(new_str, left_ptr)  // scans for \0 in left
// strcat(new_str, right_ptr) // scans for \0 in new_str, then right

// AFTER:
// memcpy(new_str, left_ptr, left_len)
// memcpy(new_str + left_len, right_ptr, right_len + 1)  // +1 for null
```

### Strategy 2: String Builder Pattern (Advanced)
**Target: Reduce loop concat from O(n²) to O(n)**

Like we did for lists, implement capacity-based string growth:
- String layout: `[capacity: i64][length: i64][data: char*]`
- When string grows beyond capacity, double the buffer
- Amortized O(1) append instead of O(n) per append

This requires a new internal string representation and would be a larger change.

### Strategy 3: Batch Processing for upper/lower
**Target: Reduce upper/lower from 14-16x to <5x**

Process multiple characters at once:

Option A: **Loop unrolling** - Process 4 or 8 characters per iteration:
```rust
// Process 8 chars per iteration when possible
while i + 8 <= len {
    // Load 8 bytes, process, store 8 bytes
    i += 8
}
// Handle remainder
```

Option B: **Use memcpy + ASCII math** for simple case conversion:
```rust
// For ASCII lowercase 'a'-'z' (97-122), uppercase is char - 32
// For ASCII uppercase 'A'-'Z' (65-90), lowercase is char + 32
// Can process without function calls
```

### Strategy 4: Optimized Split
**Target: Reduce split from 8x to <4x**

1. Single pass to count delimiters, then allocate exact size
2. Use capacity-based list (already implemented) for dynamic growth
3. Avoid strstr - scan with simple loop for single-char delimiter fast path

### Strategy 5: Type-Aware Fast Paths
When the compiler knows operand types at compile time, skip runtime type checks:
- Add `compile_string_concat_fast` for known string + string
- Add `compile_upper_fast` for known string input

## Implementation Order

### Phase 1: Quick Wins (memcpy optimization)
1. In `inline_add` string case, replace `strcpy`/`strcat` with `memcpy`
2. Expected improvement: 2-3x faster concat

### Phase 2: upper/lower optimization
1. Replace per-character `toupper`/`tolower` with inline ASCII math
2. Add loop unrolling for processing multiple characters
3. Expected improvement: 3-5x faster

### Phase 3: Fast paths for known types
1. Add type inference for string operations
2. Create `compile_string_concat_fast` that skips type checks
3. Expected improvement: Additional 20-30% for typed code

### Phase 4: String builder (if needed)
1. Implement capacity-based string representation
2. Add `StringBuilder` internal type
3. Detect loop concatenation patterns and optimize

## Key Files to Modify

- `src/llvm/codegen.rs`:
  - `inline_add` (lines 1221-1287): String concatenation
  - `inline_upper` (lines 4019-4128): Uppercase conversion
  - `inline_lower` (lines 4131-4238): Lowercase conversion
  - `inline_split` (lines 7770+): String splitting
  - `inline_join` (lines 8228+): String joining
  - `compile_binary_op`: Add fast path detection

## Testing

Run after each optimization:
```bash
./target/release/mdhavers build benchmarks/stress/computational/string_stress.braw -o /tmp/string_stress && /tmp/string_stress
```

Compare with Rust baseline:
```bash
benchmarks/stress/rust/string_stress
```

## Success Criteria

| Operation | Current | Target | Stretch |
|-----------|---------|--------|---------|
| concat | 176x | <20x | <10x |
| upper | 14x | <5x | <3x |
| lower | 16x | <5x | <3x |
| split | 8x | <4x | <3x |
| join | 5x | <3x | <2x |

## Notes

- The libc functions (strlen, strcpy, strcat, strstr, toupper, tolower) are already declared in `self.libc`
- memcpy should be added to libc declarations if not present
- Focus on the most impactful changes first (concat is 176x!)
- Don't over-engineer - simple optimizations often yield best results
