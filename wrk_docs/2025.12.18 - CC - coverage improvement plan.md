# Coverage Improvement Plan (mdhavers → 98% lines)
**Date:** 2025-12-18  
**Baseline:** 97.87% lines (853 missed / 39,989 total)  
**Target:** 98.00% lines  
**Current:** 98.00% lines (801 missed / 40,073 total) ✅  
**Delta required (from baseline):** eliminated 52 missed lines (net)  

## Guiding principles
- Prefer **real execution coverage** via tests over excluding code.
- Use `#[cfg(coverage)]` for heavyweight “coverage-driving” tests to keep normal `cargo test` fast.
- Only exclude code under `#[cfg(not(coverage))]` if it is **truly untestable** (TTY/OS interaction) or **provably dead** (cannot be reached given the current lexer/parser invariants).
- Keep each stage measurable: re-run `cargo llvm-cov --tests --summary-only` after each stage.

## Stage 1 — Reach 98% quickly (parser + test hygiene) ✅ Completed
**Goal:** remove ≥54 missed lines with minimal risk by targeting 0-hit `src/parser.rs` branches.

Actions:
1. **Add parser unit tests for uncovered error paths**
   - Class bodies containing non-method statements (covers `Expected method definition in class` parse error).
   - Pattern parsing failures:
     - `Identifier(\"_\")` wildcard compatibility (crafted token stream).
     - `-` pattern not followed by number.
     - “Expected pattern” fallthrough.
   - Invalid compound assignment target (e.g., `1 += 2`).
   - Invalid import path type (e.g., `fetch 123`).
2. **Add parser unit tests for uncovered edge syntax**
   - Slice syntax where `step` is explicitly present but empty: `arr[::]`, `arr[1::]`.
   - “Lenient” statement termination: `ken x = 1 ken y = 2` without newline/semicolon.
3. **Close f-string + escape-sequence gaps**
   - F-string interpolation containing nested braces (e.g., dict literals inside `{...}`) to drive `brace_depth` handling.
   - F-string interpolation escape handling for backslashes (`\\\\`) and “other escapes” (`\\n` style sequences).
   - Escape parsing for incomplete hex sequences (`\\x`, `\\xZ`, `\\x1`).
4. **Remove coverage-hostile test lines**
   - Avoid explicit `else { panic!(...) }` blocks in unit tests when the branch is never expected to execute (they become permanent missed lines).

**Expected outcome:** `src/parser.rs` missed lines falls substantially (ideally close to single digits). This alone should push TOTAL line coverage to ≥98.00%.

Implemented highlights:
- `src/parser.rs`: added focused unit tests for uncovered branches and reduced permanently-missed test-only lines.
- `src/lexer.rs`, `src/lib.rs`: tightened tests to avoid coverage artifacts and reached 100% line coverage in both files.

## Stage 2 — Stabilize (keep 98% from regressing)
**Goal:** make 98% “sticky” and reduce future whack-a-mole.

Actions:
1. Add a local guard command (optional):
   - `cargo llvm-cov --tests --fail-under-lines 98`
2. Keep heavy “coverage-driving” tests under `#[cfg(coverage)]` when they involve process spawning / large fixtures.

## Stage 3 — Post-98 deepening (optional but high ROI)
**Goal:** reduce the biggest remaining missed-line pools to improve confidence (and make 98% easier to maintain).

Actions:
1. **Interpreter:** add targeted snippet tests for error-path heavy areas (wrong-arity, not-callable, module-load failures).
2. **LLVM codegen:** add compile-only tests that exercise scattered guards and rarely-executed builders.
3. **CLI/LSP:** add tests for remaining subcommands/handlers and malformed input handling.
