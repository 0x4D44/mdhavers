# Multi-stage implementation plan: mdhavers runtime for multi-threaded SIP/RTP

Date: 2025.12.19
Source: wrk_docs/2025.12.19 - SIP-RTP runtime design.md

## Overview

This plan sequences the runtime changes required to support a real multi-threaded SIP/RTP stack. Each stage is deliverable, testable, and additive. Earlier stages focus on primitives (bytes, time, sockets), while later stages add concurrency and crypto.

---

## Stage 0 — Prep and scaffolding (1–2 days)

### Goals
- Establish baseline for runtime changes and testing harnesses.
- Define new value tag for bytes and shared runtime structs.

### Tasks
- Add `MDH_TAG_BYTES` constant in:
  - `runtime/mdh_runtime.h`
  - `src/llvm/types.rs`
  - `src/value.rs` (if needed)
- Add placeholder runtime functions to `runtime/mdh_runtime.h` (no implementation yet).
- Add declarations to `src/llvm/runtime.rs` (no codegen calls yet).
- Add interpreter stubs in `src/interpreter.rs` returning “not implemented”.
- Add a simple test module in `tests/` to assert `bytes` tag plumbing.

### Exit criteria
- Build succeeds with new tag and runtime declarations.
- Tests pass (even if runtime functions are stubbed).

---

## Stage 1 — Bytes + monotonic time (2–4 days)

### Goals
- Introduce efficient byte buffers and endian helpers.
- Add monotonic time APIs for RTP jitter/RTT.

### Tasks
- Implement `MdhBytes` in `runtime/mdh_runtime.c`:
  - `__mdh_bytes_new`, `__mdh_bytes_len`, `__mdh_bytes_get/set`, `__mdh_bytes_slice`, `__mdh_bytes_append`.
  - Endian helpers: `read/write_u16be`, `read/write_u32be`.
- Add `__mdh_mono_ms`, `__mdh_mono_ns` using `CLOCK_MONOTONIC`.
- Wire LLVM codegen builtins to runtime functions.
- Implement interpreter `Value::Bytes(Vec<u8>)` and matching builtins.
- Add stdlib module `stdlib/bytes.braw` wrappers.

### Tests
- Unit tests: bounds checking, endian conversions, slices.
- Cross-check interpreter vs LLVM outputs for bytes ops.

### Exit criteria
- Bytes are usable in mdhavers code with correct behavior and performance.
- `mono_ms` and `mono_ns` return increasing values.

---

## Stage 2 — UDP/TCP sockets + DNS (A/AAAA) (4–7 days)

### Goals
- Provide real sockets for SIP and RTP.
- Basic DNS resolution for A/AAAA.

### Tasks
- Implement socket runtime in `runtime/mdh_runtime.c`:
  - `__mdh_socket_udp`, `__mdh_socket_tcp`, `bind`, `connect`, `listen`, `accept`, `close`.
  - `udp_send_to`, `udp_recv_from`, `tcp_send`, `tcp_recv`.
  - `set_nonblocking`, `set_reuseaddr`, `set_reuseport`, `set_ttl`, `set_nodelay`.
- Implement `__mdh_dns_lookup` using `getaddrinfo`.
- Add LLVM builtins and interpreter support.
- Add stdlib `network_real.braw` wrappers.

### Tests
- UDP loopback echo.
- TCP server/client loopback echo.
- DNS lookup for `localhost` and a known domain.

### Exit criteria
- SIP over UDP/TCP is feasible at low level.

---

## Stage 3 — Event loop + timers (4–8 days)

### Goals
- Provide non-blocking I/O multiplexing and timer scheduling.

### Tasks
- Implement `MdhEventLoop` with:
  - Selector: `epoll` (Linux) / `kqueue` (macOS) / `poll` fallback.
  - `watch_read`, `watch_write`, `unwatch`.
  - Timer min-heap and `timer_after`, `timer_every`, `timer_cancel`.
- Add LLVM builtins and interpreter fallback (simple `poll` loop).
- Add stdlib `event_loop.braw` convenience wrappers.

### Tests
- Timer firing accuracy (within tolerance).
- Socket readability triggers callback.
- Concurrent read + timer.

### Exit criteria
- Event-driven SIP/RTP loop works on local sockets.

---

## Stage 4 — Threads + synchronization + channels (5–10 days)

### Goals
- Enable multi-threaded call handling and media processing.

### Tasks
- Runtime threading:
  - `__mdh_thread_spawn`, `__mdh_thread_join`, `__mdh_thread_detach`.
  - Register threads with Boehm GC.
- Mutex/condvar/atomic primitives:
  - `__mdh_mutex_*`, `__mdh_condvar_*`, `__mdh_atomic_*`.
- Channels:
  - `__mdh_chan_new`, `__mdh_chan_send`, `__mdh_chan_recv`, `__mdh_chan_try_recv`, `__mdh_chan_close`.
- LLVM + interpreter builtins.
- Stdlib `concurrency.braw` wrappers.

### Tests
- Thread join and shared state with mutex.
- Condvar wait/signal.
- Channel send/recv across threads.

### Exit criteria
- Multiple SIP sessions can be processed concurrently with message passing.

---

## Stage 5 — DNS SRV/NAPTR + SIP helpers (5–8 days)

### Goals
- SIP-specific resolution and convenience helpers.

### Tasks
- Implement `__mdh_dns_srv`, `__mdh_dns_naptr` in Rust using `trust-dns-resolver` (FFI).
- Add stdlib `sip_resolve(domain, transport)` helper.
- Add SIP message parsing/serialization helpers (string + bytes).

### Tests
- DNS SRV/NAPTR queries for a known domain.
- SIP resolve fallback chain test (NAPTR->SRV->A/AAAA).

### Exit criteria
- SIP endpoint discovery works with real DNS.

---

## Stage 6 — TLS/DTLS/SRTP (8–15 days)

### Goals
- Secure SIP transport and SRTP media.

### Tasks
- Rust TLS implementation (rustls or openssl binding):
  - `tls_client_new`, `tls_connect`, `tls_send`, `tls_recv`, `tls_close`.
- DTLS handshake wrapper for SRTP keying.
- SRTP protect/unprotect using a Rust library or FFI.
- Add stdlib `tls.braw` and `srtp.braw` wrappers.

### Tests
- TLS client/server loopback.
- DTLS handshake with test certs.
- SRTP protect/unprotect round-trip.

### Exit criteria
- SIP over TLS and SRTP media path works in local testbed.

---

## Stage 7 — SIP/RTP reference stack (optional, 6–12 days)

### Goals
- Provide reference implementations and demos.

### Tasks
- `sip.braw`: parser, transaction state, retransmit logic.
- `rtp.braw`: header parsing, seq/timestamp helpers.
- `rtcp.braw`: basic receiver reports.
- Demo: minimal SIP REGISTER + RTP echo server.

### Exit criteria
- End-to-end demo on loopback works with timers and event loop.

---

## Cross-cutting concerns

- **Error handling**: unify runtime result dicts (`{ok, value, error, code}`).
- **Docs**: update `docs/src/reference/builtins.md` and new stdlib docs.
- **Parity**: ensure interpreter and LLVM behavior match for all new builtins.
- **Performance**: add profiling hooks for bytes and socket operations.

---

## Suggested build order (critical path)

1) Stage 1 (Bytes + monotonic time)
2) Stage 2 (Sockets + DNS A/AAAA)
3) Stage 3 (Event loop + timers)
4) Stage 4 (Threads + sync + channels)
5) Stage 5 (DNS SRV/NAPTR + SIP helpers)
6) Stage 6 (TLS/DTLS/SRTP)
7) Stage 7 (Reference SIP/RTP stack)

---

End of plan.
