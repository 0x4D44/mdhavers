# mdhavers LLVM Backend Deep Optimization

## Objective

Continue optimizing the LLVM backend to further close the performance gap with Rust. Current state: ~1,900x slower than Rust on Fibonacci. Target: <500x slower.

## Current Bottlenecks Analysis

From the previous optimization round, we achieved ~19% improvement by:
1. Direct condition compilation (skip bool boxing in if/while)
2. Type tracking for variables
3. Integer fast path for arithmetic

But we're still loading/storing boxed MdhValue structs on every operation. The key insight: **we're boxing and unboxing on every loop iteration**.

## Phase 1: Analyze Current Hot Path

### 1.1 Profile the Fibonacci Loop

Look at the generated IR for fib_iter:
```
./target/release/mdhavers build benchmarks/large_scale/fib_large.braw --emit-llvm
cat /tmp/fib_large.ll
```

Identify:
- How many loads/stores per iteration?
- Are we still creating MdhValue structs unnecessarily?
- What's the critical path through the loop?

### 1.2 Compare to Optimal

An optimal Fibonacci loop in LLVM IR should be roughly:
```llvm
loop:
  %cmp = icmp sle i64 %i, %n
  br i1 %cmp, label %body, label %exit
body:
  %temp = add i64 %a, %b
  ; swap: a=b, b=temp, i++
  br label %loop
```

But we're likely generating:
```llvm
loop:
  ; Load i as MdhValue, extract data, compare
  ; Load a as MdhValue, extract data
  ; Load b as MdhValue, extract data
  ; Add (with or without type check)
  ; Create new MdhValue for result
  ; Store to temp
  ; Similar for a=b, b=temp, i=i+1
```

## Phase 2: Unboxed Loop Variables

### 2.1 Loop Counter Optimization

For `whiles i < n` where `i` starts as integer:
- Keep a shadow i64 variable for the counter
- Only box when the variable is used in a context requiring MdhValue
- Increment the i64 directly

Implementation approach:
```rust
// In compile_while, detect integer loop pattern:
// - Condition is VAR < EXPR or VAR <= EXPR
// - VAR is assigned integer initially
// - VAR is only modified by VAR = VAR + INTEGER

// Generate:
// 1. Unboxed i64 counter alongside MdhValue
// 2. Use i64 for condition check
// 3. Use i64 for increment
// 4. Only sync to MdhValue when needed
```

### 2.2 Loop Body Variable Unboxing

For variables used only within a loop body that are known integers:
- Track which variables are "hot" (used frequently in loop)
- Generate unboxed i64 shadows for them
- Sync at loop exit if needed

## Phase 3: Function Inlining and Specialization

### 3.1 LLVM Inlining Hints

Add `alwaysinline` attribute to small functions:
```rust
// For functions with body < N statements
function.add_attribute(AttributeLoc::Function,
    context.create_string_attribute("alwaysinline", ""));
```

### 3.2 Type-Specialized Function Variants

When a function is called with known-type arguments:
- Generate a specialized version that skips type checks
- Name it `funcname_i64_i64` or similar
- Call the specialized version instead

### 3.3 Tail Call Optimization

Ensure recursive calls use proper tail call:
```rust
call_site.set_tail_call(true);
```

## Phase 4: LLVM Optimization Passes

### 4.1 Check Current Optimization Level

Verify we're using `-O3` equivalent passes:
```rust
// In compiler.rs, check PassManager configuration
pass_manager.add_instruction_combining_pass();
pass_manager.add_reassociate_pass();
pass_manager.add_gvn_pass();
pass_manager.add_cfg_simplification_pass();
pass_manager.add_licm_pass();  // Loop-invariant code motion
```

### 4.2 Add Missing Passes

Consider adding:
- Loop unrolling
- Loop vectorization (for array operations)
- Dead store elimination
- Memory to register promotion

### 4.3 Module-Level Optimization

Run optimization passes on the whole module:
```rust
let pass_manager = PassManager::create(());
pass_manager.add_always_inliner_pass();
pass_manager.add_global_optimizer_pass();
pass_manager.run_on(&module);
```

## Phase 5: Reduce Memory Operations

### 5.1 Register Allocation Hints

For loop variables, try to keep them in registers:
- Use fewer alloca instructions
- Pass values directly instead of through memory

### 5.2 Escape Analysis

Variables that don't escape their scope can be:
- Kept completely unboxed
- Never stored to memory
- Passed in registers

### 5.3 Copy Elimination

Avoid copying MdhValue structs:
- Pass by reference where possible
- Use phi nodes instead of stores for SSA

## Phase 6: Benchmark Each Change

After each optimization:

```bash
# Build and benchmark
./target/release/mdhavers build benchmarks/large_scale/fib_large.braw -o /tmp/fib_test
/tmp/fib_test

# Compare to Rust
./benchmarks/large_scale/rust/fib_stress
```

Track improvements in a table:
| Optimization | fib(100K) | vs Rust | Change |
|--------------|-----------|---------|--------|
| Baseline | 72,000 μs | 1,891x | - |
| Unboxed loop counter | ? | ? | ? |
| ... | | | |

## Phase 7: Advanced Optimizations (if time permits)

### 7.1 JIT-style Optimization
- Detect hot loops at compile time
- Generate multiple versions with different optimizations
- Use guards to select best version

### 7.2 Whole-Program Analysis
- Analyze all call sites to infer parameter types
- Generate specialized code based on actual usage

### 7.3 Native Integer Mode
- Add optional type annotations: `ken x: int = 0`
- Generate completely unboxed code for annotated variables

## Success Criteria

| Metric | Current | Target |
|--------|---------|--------|
| fib_iter(100K) vs Rust | 1,891x | <500x |
| Loop body instructions | ~50+ | <20 |
| Memory ops per iteration | ~8+ | <4 |

## Completion Promise

Complete when:
1. At least one Phase 2-4 optimization implemented
2. Measurable improvement beyond current 72,000 μs baseline
3. Closer to 500x Rust ratio (currently 1,891x)

## Key Files

- `src/llvm/codegen.rs` - Main code generation
- `src/llvm/compiler.rs` - LLVM pass configuration
- `benchmarks/large_scale/fib_large.braw` - Main benchmark

## Reference: Current fib_iter IR Pattern

The current loop likely looks like:
```llvm
loop:
  ; Load boxed values (~3 loads)
  %i1 = load { i8, i64 }, ptr %i
  %a1 = load { i8, i64 }, ptr %a
  %b1 = load { i8, i64 }, ptr %b

  ; Extract data (~3 extracts)
  %i_data = extractvalue { i8, i64 } %i1, 1
  %a_data = extractvalue { i8, i64 } %a1, 1
  %b_data = extractvalue { i8, i64 } %b1, 1

  ; Compute
  %cmp = icmp sle i64 %i_data, %n_data
  %temp = add i64 %a_data, %b_data

  ; Create new boxed values (~3 insertvalues)
  ; Store results (~3 stores)
  ...
```

Target:
```llvm
loop:
  ; Use phi nodes for registers, no loads/stores in hot path
  %i = phi i64 [%i_init, %entry], [%i_next, %loop]
  %a = phi i64 [0, %entry], [%b, %loop]
  %b = phi i64 [1, %entry], [%temp, %loop]

  %cmp = icmp sle i64 %i, %n
  br i1 %cmp, label %body, label %exit

body:
  %temp = add i64 %a, %b
  %i_next = add i64 %i, 1
  br label %loop
```
