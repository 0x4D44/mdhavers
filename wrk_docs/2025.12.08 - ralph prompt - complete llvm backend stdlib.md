# Ralph Wiggum Prompt: Complete LLVM Backend Standard Library

## Objective

Extend the mdhavers LLVM backend (`src/llvm/codegen.rs`) to support ALL 45 built-in functions from the JavaScript runtime, plus missing language features. The goal is feature parity between the JS compiler (`mdhavers compile`) and native LLVM compiler (`mdhavers build`).

## Current State

The LLVM backend currently implements only 6 built-ins:
- `blether` (print)
- `tae_string`, `tae_int`, `tae_float` (type conversion)
- `len` (length)
- `shove` (list append)

## Implementation Phases

### Phase 1: Math Functions (7 functions)
Location: Add to `compile_call` match in `src/llvm/codegen.rs`

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `abs(x)` | `i64 -> i64` | Use LLVM intrinsic or `(x < 0) ? -x : x` |
| `min(a, b)` | `i64, i64 -> i64` | `(a < b) ? a : b` |
| `max(a, b)` | `i64, i64 -> i64` | `(a > b) ? a : b` |
| `floor(x)` | `f64 -> i64` | Use `llvm.floor.f64` intrinsic |
| `ceil(x)` | `f64 -> i64` | Use `llvm.ceil.f64` intrinsic |
| `round(x)` | `f64 -> i64` | Use `llvm.round.f64` intrinsic |
| `sqrt(x)` | `f64 -> f64` | Use `llvm.sqrt.f64` intrinsic |

Pattern for math intrinsics:
```rust
"sqrt" => {
    let arg = self.compile_expr(&args[0])?;
    let float_val = self.extract_float_value(arg)?;
    let sqrt_fn = self.module.get_intrinsic_function("llvm.sqrt", &[self.types.f64_type.into()]).unwrap();
    let result = self.builder.build_call(sqrt_fn, &[float_val.into()], "sqrt_result")?;
    self.make_float(result.try_as_basic_value().left().unwrap().into_float_value())
}
```

### Phase 2: List Operations (9 functions)
These operate on the list memory layout: `[i64 length][{i8,i64} elem0][{i8,i64} elem1]...`

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `yank(list)` | `list -> value` | Pop last element, decrement length |
| `heid(list)` | `list -> value` | Return `list[0]` |
| `tail(list)` | `list -> list` | Return new list without first element |
| `bum(list)` | `list -> value` | Return `list[len-1]` |
| `scran(list, start, end)` | `list, i64, i64 -> list` | Slice list[start:end] |
| `slap(a, b)` | `list, list -> list` | Concatenate two lists |
| `reverse(list)` | `list -> list` | Return reversed copy |
| `sort(list)` | `list -> list` | Return sorted copy (quicksort) |
| `shuffle(list)` | `list -> list` | Return shuffled copy |

Key helper needed:
```rust
fn allocate_list(&self, length: IntValue<'ctx>) -> Result<PointerValue<'ctx>, HaversError> {
    // Allocate: 8 bytes for length + (length * 16) bytes for elements
    let elem_size = self.types.i64_type.const_int(16, false); // sizeof({i8, i64})
    let header_size = self.types.i64_type.const_int(8, false);
    let total = self.builder.build_int_add(
        header_size,
        self.builder.build_int_mul(length, elem_size, "elems_size")?,
        "total_size"
    )?;
    // Call malloc
    let ptr = self.builder.build_call(self.libc.malloc, &[total.into()], "list_ptr")?;
    // Store length at start
    // Return pointer
}
```

### Phase 3: String Operations (8 functions)

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `split(str, delim)` | `string, string -> list` | Split string into list |
| `join(list, delim)` | `list, string -> string` | Join list elements with delimiter |
| `contains(str, substr)` | `string, string -> bool` | Use `strstr()` from libc |
| `coont(str, substr)` | `string, string -> i64` | Count occurrences |
| `wheesht(str)` | `string -> string` | Trim whitespace |
| `upper(str)` | `string -> string` | Uppercase (loop with `toupper`) |
| `lower(str)` | `string -> string` | Lowercase (loop with `tolower`) |
| `sumaw(list)` | `list -> i64` | Sum all numeric elements |

Add libc functions to `LibcFunctions`:
```rust
strstr: FunctionValue<'ctx>,   // char* strstr(char*, char*)
toupper: FunctionValue<'ctx>,  // int toupper(int)
tolower: FunctionValue<'ctx>,  // int tolower(int)
isspace: FunctionValue<'ctx>,  // int isspace(int)
```

### Phase 4: Type & Utility Functions (4 functions)

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `whit_kind(x)` | `any -> string` | Return type name based on tag |
| `range(start, end)` | `i64, i64 -> list` | Generate list [start, start+1, ..., end-1] |
| `keys(dict)` | `dict -> list` | Extract dictionary keys |
| `values(dict)` | `dict -> list` | Extract dictionary values |

For `whit_kind`:
```rust
// Switch on tag value, return appropriate string
// tag 0 -> "naething", tag 1 -> "boolean", tag 2 -> "number",
// tag 3 -> "number", tag 4 -> "string", tag 5 -> "list", tag 6 -> "dict"
```

### Phase 5: Timing Functions (3 functions)

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `noo()` | `-> i64` | Current time in milliseconds |
| `tick()` | `-> i64` | High-resolution nanoseconds |
| `bide(ms)` | `i64 -> nil` | Sleep for ms milliseconds |

Add to libc:
```rust
clock_gettime: FunctionValue<'ctx>,  // int clock_gettime(clockid_t, struct timespec*)
nanosleep: FunctionValue<'ctx>,      // int nanosleep(struct timespec*, struct timespec*)
```

Implementation for `tick`:
```rust
// struct timespec { i64 tv_sec; i64 tv_nsec; }
// clock_gettime(CLOCK_MONOTONIC=1, &ts)
// return ts.tv_sec * 1_000_000_000 + ts.tv_nsec
```

### Phase 6: Higher-Order Functions (6 functions)
**Requires closure/function pointer support**

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `gaun(list, fn)` | `list, fn -> list` | Map function over list |
| `sieve(list, fn)` | `list, fn -> list` | Filter list by predicate |
| `tumble(list, init, fn)` | `list, any, fn -> any` | Reduce/fold |
| `aw(list, fn)` | `list, fn -> bool` | All elements satisfy predicate |
| `ony(list, fn)` | `list, fn -> bool` | Any element satisfies predicate |
| `hunt(list, fn)` | `list, fn -> any` | Find first matching element |

This requires implementing closures as function pointers with captured environment.

### Phase 7: I/O Functions (1 function)

| Function | Signature | Implementation |
|----------|-----------|----------------|
| `speir(prompt)` | `string -> string` | Read line from stdin |

Add to libc:
```rust
fgets: FunctionValue<'ctx>,  // char* fgets(char*, int, FILE*)
stdin: GlobalValue<'ctx>,    // extern FILE* stdin
```

### Phase 8: Language Features

1. **Dict literals**: `{ "key": value }` - Implement as hash table
2. **For-in loops**: `fer x in range(0, 10)` - Compile to iterator pattern
3. **Slice expressions**: `list[1:3:1]` - Already have IndexSet, need Slice

## Success Criteria

1. ALL 45 built-in functions compile without error
2. ALL benchmarks in `benchmarks/mdhavers/*.braw` run correctly with accurate output
3. Create test file `tests/stdlib_native_test.braw` that exercises every function
4. Performance within 3x of JavaScript backend for equivalent operations

## Test Commands

After each phase:
```bash
cargo build --release --features llvm
./target/release/mdhavers build benchmarks/mdhavers/primes.braw -o /tmp/primes && /tmp/primes
./target/release/mdhavers build benchmarks/mdhavers/mergesort.braw -o /tmp/mergesort && /tmp/mergesort
./target/release/mdhavers build benchmarks/mdhavers/quicksort.braw -o /tmp/quicksort && /tmp/quicksort
```

## Files to Modify

- `src/llvm/codegen.rs` - Main implementation file
- `src/llvm/mod.rs` - May need new modules for complex features
- `Cargo.toml` - If additional dependencies needed

## Reference

JavaScript runtime functions are defined inline in compiled output. See `/tmp/gcd_test` lines 1-154 for full implementations to match behavior.

## Completion Promise

Output `<promise>stdlib-complete</promise>` when ALL of the following are true:
1. All 45 built-in functions are implemented
2. All benchmarks produce correct output (not just compile)
3. Test coverage exists for each function
