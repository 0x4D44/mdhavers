# mdhavers Comprehensive Golden Test Suite - Detailed Implementation Prompt

## Goal
Design and create a comprehensive golden/snapshot test suite for the mdhavers language that systematically tests all language features by comparing program output against canonical expected results. This provides regression protection and documents expected behavior.

## Success Criteria
1. Create a `tests/golden/` directory with organized test structure
2. Implement a Rust-based golden test runner in `tests/golden_tests.rs`
3. Create 100+ golden tests covering all language features
4. Tests work for both interpreter and LLVM native compilation
5. All tests pass on current implementation
6. Clear documentation for adding new tests
7. Makefile integration for easy running

## Why Golden Tests?

Golden tests are ideal for language testing because:
- **Easy to write**: Just write a program and record expected output
- **Regression detection**: Catches unintended behavior changes
- **Documentation**: Tests serve as language examples
- **Comprehensive**: Can test complex interactions
- **Debugging**: Easy to see what changed when tests fail

## Directory Structure

```
tests/
├── golden_tests.rs              # Rust test runner
├── golden/
│   ├── README.md                # How to add new tests
│   ├── run_golden.sh            # Shell script runner (backup)
│   │
│   ├── basics/                  # Fundamental language features
│   │   ├── literals/
│   │   │   ├── integers.braw        + integers.expected
│   │   │   ├── floats.braw          + floats.expected
│   │   │   ├── strings.braw         + strings.expected
│   │   │   ├── booleans.braw        + booleans.expected
│   │   │   ├── nil.braw             + nil.expected
│   │   │   └── fstrings.braw        + fstrings.expected
│   │   │
│   │   ├── operators/
│   │   │   ├── arithmetic.braw      + arithmetic.expected
│   │   │   ├── comparison.braw      + comparison.expected
│   │   │   ├── logical.braw         + logical.expected
│   │   │   ├── string_ops.braw      + string_ops.expected
│   │   │   ├── unary.braw           + unary.expected
│   │   │   └── precedence.braw      + precedence.expected
│   │   │
│   │   ├── variables/
│   │   │   ├── declaration.braw     + declaration.expected
│   │   │   ├── assignment.braw      + assignment.expected
│   │   │   ├── shadowing.braw       + shadowing.expected
│   │   │   └── scope.braw           + scope.expected
│   │   │
│   │   └── comments/
│   │       └── comments.braw        + comments.expected
│   │
│   ├── control_flow/            # Control structures
│   │   ├── conditionals/
│   │   │   ├── if_basic.braw        + if_basic.expected
│   │   │   ├── if_else.braw         + if_else.expected
│   │   │   ├── if_elsif.braw        + if_elsif.expected
│   │   │   ├── nested_if.braw       + nested_if.expected
│   │   │   └── ternary.braw         + ternary.expected
│   │   │
│   │   ├── loops/
│   │   │   ├── while_basic.braw     + while_basic.expected
│   │   │   ├── while_nested.braw    + while_nested.expected
│   │   │   ├── for_range.braw       + for_range.expected
│   │   │   ├── for_list.braw        + for_list.expected
│   │   │   ├── for_string.braw      + for_string.expected
│   │   │   ├── break.braw           + break.expected
│   │   │   └── continue.braw        + continue.expected
│   │   │
│   │   └── match/
│   │       ├── match_basic.braw     + match_basic.expected
│   │       ├── match_wildcard.braw  + match_wildcard.expected
│   │       └── match_guards.braw    + match_guards.expected
│   │
│   ├── functions/               # Function features
│   │   ├── basic/
│   │   │   ├── declaration.braw     + declaration.expected
│   │   │   ├── parameters.braw      + parameters.expected
│   │   │   ├── return.braw          + return.expected
│   │   │   ├── early_return.braw    + early_return.expected
│   │   │   └── multiple_funcs.braw  + multiple_funcs.expected
│   │   │
│   │   ├── advanced/
│   │   │   ├── recursion.braw       + recursion.expected
│   │   │   ├── mutual_recursion.braw + mutual_recursion.expected
│   │   │   ├── default_params.braw  + default_params.expected
│   │   │   ├── variadic.braw        + variadic.expected (if supported)
│   │   │   └── closures.braw        + closures.expected
│   │   │
│   │   └── lambdas/
│   │       ├── lambda_basic.braw    + lambda_basic.expected
│   │       ├── lambda_closure.braw  + lambda_closure.expected
│   │       └── lambda_hof.braw      + lambda_hof.expected
│   │
│   ├── data_structures/         # Collections and data types
│   │   ├── lists/
│   │   │   ├── list_literal.braw    + list_literal.expected
│   │   │   ├── list_index.braw      + list_index.expected
│   │   │   ├── list_assign.braw     + list_assign.expected
│   │   │   ├── list_nested.braw     + list_nested.expected
│   │   │   ├── list_empty.braw      + list_empty.expected
│   │   │   ├── list_concat.braw     + list_concat.expected
│   │   │   └── list_spread.braw     + list_spread.expected
│   │   │
│   │   ├── dicts/
│   │   │   ├── dict_literal.braw    + dict_literal.expected
│   │   │   ├── dict_access.braw     + dict_access.expected
│   │   │   ├── dict_assign.braw     + dict_assign.expected
│   │   │   ├── dict_nested.braw     + dict_nested.expected
│   │   │   └── dict_keys.braw       + dict_keys.expected
│   │   │
│   │   └── ranges/
│   │       ├── range_basic.braw     + range_basic.expected
│   │       ├── range_inclusive.braw + range_inclusive.expected
│   │       └── range_step.braw      + range_step.expected (if supported)
│   │
│   ├── classes/                 # OOP features
│   │   ├── basic/
│   │   │   ├── class_def.braw       + class_def.expected
│   │   │   ├── class_fields.braw    + class_fields.expected
│   │   │   ├── class_methods.braw   + class_methods.expected
│   │   │   ├── class_self.braw      + class_self.expected
│   │   │   └── class_init.braw      + class_init.expected
│   │   │
│   │   └── inheritance/
│   │       ├── inherit_basic.braw   + inherit_basic.expected
│   │       ├── inherit_override.braw + inherit_override.expected
│   │       ├── inherit_super.braw   + inherit_super.expected
│   │       └── inherit_chain.braw   + inherit_chain.expected
│   │
│   ├── builtins/                # Built-in functions
│   │   ├── io/
│   │   │   ├── blether.braw         + blether.expected
│   │   │   └── blether_multi.braw   + blether_multi.expected
│   │   │
│   │   ├── type_conversion/
│   │   │   ├── tae_string.braw      + tae_string.expected
│   │   │   ├── tae_integer.braw     + tae_integer.expected
│   │   │   ├── tae_float.braw       + tae_float.expected
│   │   │   └── type_of.braw         + type_of.expected
│   │   │
│   │   ├── list_ops/
│   │   │   ├── len.braw             + len.expected
│   │   │   ├── shove.braw           + shove.expected
│   │   │   ├── yank.braw            + yank.expected
│   │   │   ├── keek_list.braw       + keek_list.expected
│   │   │   └── reverse.braw         + reverse.expected
│   │   │
│   │   ├── functional/
│   │   │   ├── gaun_map.braw        + gaun_map.expected
│   │   │   ├── sieve_filter.braw    + sieve_filter.expected
│   │   │   ├── tumble_reduce.braw   + tumble_reduce.expected
│   │   │   ├── ony_any.braw         + ony_any.expected
│   │   │   └── aw_all.braw          + aw_all.expected
│   │   │
│   │   ├── string_ops/
│   │   │   ├── split.braw           + split.expected
│   │   │   ├── join.braw            + join.expected
│   │   │   ├── trim.braw            + trim.expected
│   │   │   ├── upper_lower.braw     + upper_lower.expected
│   │   │   ├── contains.braw        + contains.expected
│   │   │   ├── replace.braw         + replace.expected
│   │   │   ├── starts_ends.braw     + starts_ends.expected
│   │   │   └── slice.braw           + slice.expected
│   │   │
│   │   └── math/
│   │       ├── abs.braw             + abs.expected
│   │       ├── min_max.braw         + min_max.expected
│   │       ├── floor_ceil.braw      + floor_ceil.expected
│   │       └── sqrt_pow.braw        + sqrt_pow.expected
│   │
│   ├── algorithms/              # Complex programs
│   │   ├── sorting/
│   │   │   ├── bubblesort.braw      + bubblesort.expected
│   │   │   ├── quicksort.braw       + quicksort.expected
│   │   │   └── mergesort.braw       + mergesort.expected
│   │   │
│   │   ├── math/
│   │   │   ├── fibonacci.braw       + fibonacci.expected
│   │   │   ├── factorial.braw       + factorial.expected
│   │   │   ├── gcd.braw             + gcd.expected
│   │   │   ├── primes_sieve.braw    + primes_sieve.expected
│   │   │   └── is_prime.braw        + is_prime.expected
│   │   │
│   │   └── data/
│   │       ├── reverse_list.braw    + reverse_list.expected
│   │       ├── palindrome.braw      + palindrome.expected
│   │       └── word_count.braw      + word_count.expected
│   │
│   ├── edge_cases/              # Corner cases and boundaries
│   │   ├── numbers/
│   │   │   ├── zero.braw            + zero.expected
│   │   │   ├── negative.braw        + negative.expected
│   │   │   ├── large_int.braw       + large_int.expected
│   │   │   └── float_precision.braw + float_precision.expected
│   │   │
│   │   ├── strings/
│   │   │   ├── empty_string.braw    + empty_string.expected
│   │   │   ├── unicode.braw         + unicode.expected
│   │   │   ├── escapes.braw         + escapes.expected
│   │   │   └── multiline.braw       + multiline.expected
│   │   │
│   │   ├── lists/
│   │   │   ├── empty_list.braw      + empty_list.expected
│   │   │   ├── single_element.braw  + single_element.expected
│   │   │   └── mixed_types.braw     + mixed_types.expected
│   │   │
│   │   └── control/
│   │       ├── deeply_nested.braw   + deeply_nested.expected
│   │       ├── empty_blocks.braw    + empty_blocks.expected
│   │       └── truthiness.braw      + truthiness.expected
│   │
│   └── integration/             # Complex real-world scenarios
│       ├── calculator.braw          + calculator.expected
│       ├── todo_list.braw           + todo_list.expected
│       ├── bank_account.braw        + bank_account.expected
│       ├── game_state.braw          + game_state.expected
│       └── parser.braw              + parser.expected
```

## Golden Test Runner Implementation

### Rust Test Runner (tests/golden_tests.rs)

```rust
//! Golden tests for mdhavers language
//!
//! Runs .braw files and compares output against .expected files.
//! Tests both interpreter and LLVM native compilation.

use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

use mdhavers::{parse, run_with_output, LLVMCompiler};
use tempfile::tempdir;

/// Discover all golden tests in a directory
fn discover_tests(dir: &Path) -> Vec<PathBuf> {
    let mut tests = Vec::new();

    if dir.is_dir() {
        for entry in fs::read_dir(dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();

            if path.is_dir() {
                tests.extend(discover_tests(&path));
            } else if path.extension().map_or(false, |e| e == "braw") {
                // Check if corresponding .expected file exists
                let expected = path.with_extension("expected");
                if expected.exists() {
                    tests.push(path);
                }
            }
        }
    }

    tests.sort();
    tests
}

/// Run a single golden test with interpreter
fn run_interpreter_test(braw_path: &Path) -> Result<String, String> {
    let source = fs::read_to_string(braw_path)
        .map_err(|e| format!("Failed to read {}: {}", braw_path.display(), e))?;

    let (_value, output) = run_with_output(&source)
        .map_err(|e| format!("Interpreter error: {:?}", e))?;

    Ok(output.join("\n"))
}

/// Run a single golden test with LLVM native compilation
#[cfg(feature = "llvm")]
fn run_native_test(braw_path: &Path) -> Result<String, String> {
    let source = fs::read_to_string(braw_path)
        .map_err(|e| format!("Failed to read {}: {}", braw_path.display(), e))?;

    let program = parse(&source)
        .map_err(|e| format!("Parse error: {:?}", e))?;

    let dir = tempdir()
        .map_err(|e| format!("Failed to create temp dir: {}", e))?;
    let exe_path = dir.path().join("test_exe");

    let compiler = LLVMCompiler::new();
    compiler.compile_to_native(&program, &exe_path, 2)
        .map_err(|e| format!("Compile error: {:?}", e))?;

    let output = Command::new(&exe_path)
        .output()
        .map_err(|e| format!("Failed to run executable: {}", e))?;

    if !output.status.success() {
        return Err(format!("Exit code: {:?}", output.status.code()));
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Compare actual output with expected output
fn compare_output(actual: &str, expected: &str) -> Result<(), String> {
    let actual_lines: Vec<&str> = actual.trim().lines().collect();
    let expected_lines: Vec<&str> = expected.trim().lines().collect();

    if actual_lines != expected_lines {
        let mut diff = String::new();
        diff.push_str("Output mismatch:\n");
        diff.push_str("--- Expected ---\n");
        for line in &expected_lines {
            diff.push_str(&format!("  {}\n", line));
        }
        diff.push_str("--- Actual ---\n");
        for line in &actual_lines {
            diff.push_str(&format!("  {}\n", line));
        }
        return Err(diff);
    }

    Ok(())
}

/// Main test function - runs all golden tests
#[test]
fn golden_tests_interpreter() {
    let golden_dir = Path::new("tests/golden");
    let tests = discover_tests(golden_dir);

    let mut failures = Vec::new();

    for test_path in &tests {
        let expected_path = test_path.with_extension("expected");
        let expected = fs::read_to_string(&expected_path)
            .expect("Failed to read expected file");

        match run_interpreter_test(test_path) {
            Ok(actual) => {
                if let Err(diff) = compare_output(&actual, &expected) {
                    failures.push((test_path.clone(), diff));
                }
            }
            Err(e) => {
                failures.push((test_path.clone(), e));
            }
        }
    }

    if !failures.is_empty() {
        let mut msg = format!("\n{} golden tests failed:\n\n", failures.len());
        for (path, error) in failures {
            msg.push_str(&format!("FAIL: {}\n{}\n\n", path.display(), error));
        }
        panic!("{}", msg);
    }

    println!("\n✓ {} golden tests passed (interpreter)", tests.len());
}

#[test]
#[cfg(feature = "llvm")]
fn golden_tests_native() {
    let golden_dir = Path::new("tests/golden");
    let tests = discover_tests(golden_dir);

    let mut failures = Vec::new();
    let mut skipped = 0;

    for test_path in &tests {
        // Skip tests that use interpreter-only features
        let source = fs::read_to_string(test_path).unwrap();
        if source.contains("// SKIP_NATIVE") {
            skipped += 1;
            continue;
        }

        let expected_path = test_path.with_extension("expected");
        let expected = fs::read_to_string(&expected_path)
            .expect("Failed to read expected file");

        match run_native_test(test_path) {
            Ok(actual) => {
                if let Err(diff) = compare_output(&actual, &expected) {
                    failures.push((test_path.clone(), diff));
                }
            }
            Err(e) => {
                failures.push((test_path.clone(), e));
            }
        }
    }

    if !failures.is_empty() {
        let mut msg = format!("\n{} golden tests failed:\n\n", failures.len());
        for (path, error) in failures {
            msg.push_str(&format!("FAIL: {}\n{}\n\n", path.display(), error));
        }
        panic!("{}", msg);
    }

    println!("\n✓ {} golden tests passed (native), {} skipped",
             tests.len() - skipped, skipped);
}
```

## Test Categories and Examples

### 1. Basics - Literals

**tests/golden/basics/literals/integers.braw**
```
blether 0
blether 1
blether -1
blether 42
blether 1000000
blether -999
```

**tests/golden/basics/literals/integers.expected**
```
0
1
-1
42
1000000
-999
```

### 2. Basics - Operators

**tests/golden/basics/operators/arithmetic.braw**
```
blether 5 + 3
blether 10 - 4
blether 6 * 7
blether 20 / 4
blether 17 % 5
blether 2 + 3 * 4
blether (2 + 3) * 4
```

**tests/golden/basics/operators/arithmetic.expected**
```
8
6
42
5
2
14
20
```

### 3. Control Flow - Conditionals

**tests/golden/control_flow/conditionals/if_elsif.braw**
```
dae grade(score) {
    gin score >= 90 {
        blether "A"
    } ither gin score >= 80 {
        blether "B"
    } ither gin score >= 70 {
        blether "C"
    } ither gin score >= 60 {
        blether "D"
    } ither {
        blether "F"
    }
}

grade(95)
grade(82)
grade(73)
grade(65)
grade(50)
```

**tests/golden/control_flow/conditionals/if_elsif.expected**
```
A
B
C
D
F
```

### 4. Functions - Recursion

**tests/golden/functions/advanced/recursion.braw**
```
dae factorial(n) {
    gin n <= 1 {
        gie 1
    }
    gie n * factorial(n - 1)
}

dae fibonacci(n) {
    gin n <= 1 {
        gie n
    }
    gie fibonacci(n - 1) + fibonacci(n - 2)
}

blether factorial(0)
blether factorial(1)
blether factorial(5)
blether factorial(10)

blether fibonacci(0)
blether fibonacci(1)
blether fibonacci(10)
blether fibonacci(15)
```

**tests/golden/functions/advanced/recursion.expected**
```
1
1
120
3628800
0
1
55
610
```

### 5. Data Structures - Lists

**tests/golden/data_structures/lists/list_operations.braw**
```
ken nums = [1, 2, 3, 4, 5]
blether nums
blether len(nums)
blether nums[0]
blether nums[4]

shove(nums, 6)
blether nums
blether len(nums)

ken last = yank(nums)
blether last
blether nums

nums[0] = 10
blether nums
```

**tests/golden/data_structures/lists/list_operations.expected**
```
[1, 2, 3, 4, 5]
5
1
5
[1, 2, 3, 4, 5, 6]
6
6
[1, 2, 3, 4, 5]
[10, 2, 3, 4, 5]
```

### 6. Classes - Inheritance

**tests/golden/classes/inheritance/inherit_basic.braw**
```
kin Animal {
    init(sel, name) {
        sel.name = name
    }

    dae speak(sel) {
        blether sel.name + " makes a sound"
    }
}

kin Dog : Animal {
    dae speak(sel) {
        blether sel.name + " barks: Woof!"
    }

    dae fetch(sel) {
        blether sel.name + " fetches the ball"
    }
}

kin Cat : Animal {
    dae speak(sel) {
        blether sel.name + " meows: Meow!"
    }
}

ken dog = Dog("Rex")
ken cat = Cat("Whiskers")

dog.speak()
cat.speak()
dog.fetch()
```

**tests/golden/classes/inheritance/inherit_basic.expected**
```
Rex barks: Woof!
Whiskers meows: Meow!
Rex fetches the ball
```

### 7. Built-ins - Functional Operations

**tests/golden/builtins/functional/gaun_map.braw**
```
ken nums = [1, 2, 3, 4, 5]
ken doubled = gaun(nums, |x| x * 2)
blether doubled

ken squares = gaun(nums, |x| x * x)
blether squares

ken strs = ["a", "b", "c"]
ken upper = gaun(strs, |s| tae_upper(s))
blether upper
```

**tests/golden/builtins/functional/gaun_map.expected**
```
[2, 4, 6, 8, 10]
[1, 4, 9, 16, 25]
["A", "B", "C"]
```

### 8. Algorithms - Prime Sieve

**tests/golden/algorithms/math/primes_sieve.braw**
```
dae sieve(n) {
    ken is_prime = []
    ken i = 0
    whiles i <= n {
        shove(is_prime, aye)
        i = i + 1
    }
    is_prime[0] = nae
    is_prime[1] = nae

    ken p = 2
    whiles p * p <= n {
        gin is_prime[p] {
            ken j = p * p
            whiles j <= n {
                is_prime[j] = nae
                j = j + p
            }
        }
        p = p + 1
    }

    ken primes = []
    ken k = 2
    whiles k <= n {
        gin is_prime[k] {
            shove(primes, k)
        }
        k = k + 1
    }
    gie primes
}

blether sieve(30)
blether len(sieve(100))
```

**tests/golden/algorithms/math/primes_sieve.expected**
```
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
25
```

### 9. Edge Cases - Truthiness

**tests/golden/edge_cases/control/truthiness.braw**
```
// Test what values are truthy/falsy
dae test_truthy(val, name) {
    gin val {
        blether name + " is truthy"
    } ither {
        blether name + " is falsy"
    }
}

test_truthy(aye, "aye")
test_truthy(nae, "nae")
test_truthy(1, "1")
test_truthy(0, "0")
test_truthy(-1, "-1")
test_truthy("hello", "non-empty string")
test_truthy("", "empty string")
test_truthy([1, 2], "non-empty list")
test_truthy([], "empty list")
test_truthy(naething, "naething")
```

**tests/golden/edge_cases/control/truthiness.expected**
```
aye is truthy
nae is falsy
1 is truthy
0 is falsy
-1 is truthy
non-empty string is truthy
empty string is falsy
non-empty list is truthy
empty list is falsy
naething is falsy
```

### 10. Integration - Bank Account

**tests/golden/integration/bank_account.braw**
```
kin BankAccount {
    init(sel, owner, initial_balance) {
        sel.owner = owner
        sel.balance = initial_balance
        sel.transactions = []
    }

    dae deposit(sel, amount) {
        gin amount > 0 {
            sel.balance = sel.balance + amount
            shove(sel.transactions, "Deposit: " + tae_string(amount))
            gie aye
        }
        gie nae
    }

    dae withdraw(sel, amount) {
        gin amount > 0 && amount <= sel.balance {
            sel.balance = sel.balance - amount
            shove(sel.transactions, "Withdraw: " + tae_string(amount))
            gie aye
        }
        gie nae
    }

    dae get_balance(sel) {
        gie sel.balance
    }

    dae print_statement(sel) {
        blether "Account: " + sel.owner
        blether "Balance: " + tae_string(sel.balance)
        blether "Transactions:"
        fer t in sel.transactions {
            blether "  - " + t
        }
    }
}

ken account = BankAccount("Alice", 1000)
blether "Initial balance: " + tae_string(account.get_balance())

account.deposit(500)
account.withdraw(200)
account.withdraw(100)
account.deposit(50)

account.print_statement()
```

**tests/golden/integration/bank_account.expected**
```
Initial balance: 1000
Account: Alice
Balance: 1250
Transactions:
  - Deposit: 500
  - Withdraw: 200
  - Withdraw: 100
  - Deposit: 50
```

## Implementation Order

### Phase 1: Infrastructure Setup
1. Create `tests/golden/` directory structure
2. Create `tests/golden/README.md` with instructions
3. Create `tests/golden_tests.rs` with test runner
4. Update `Makefile` with `make golden` target
5. Verify runner works with a simple test

### Phase 2: Basic Tests (30+ tests)
1. All literal types (integers, floats, strings, booleans, nil, f-strings)
2. All operators (arithmetic, comparison, logical, string)
3. Variables (declaration, assignment, shadowing, scope)
4. Comments

### Phase 3: Control Flow Tests (20+ tests)
1. Conditionals (if, if-else, if-elsif, nested, ternary)
2. Loops (while, for-range, for-list, for-string, break, continue)
3. Match expressions (basic, wildcard, guards)

### Phase 4: Function Tests (15+ tests)
1. Basic functions (declaration, parameters, return)
2. Advanced (recursion, mutual recursion, default params, closures)
3. Lambdas (basic, closure, higher-order)

### Phase 5: Data Structure Tests (20+ tests)
1. Lists (literal, index, assign, nested, concat, spread)
2. Dicts (literal, access, assign, nested, keys)
3. Ranges (basic, inclusive)

### Phase 6: Class Tests (10+ tests)
1. Basic (definition, fields, methods, self, init)
2. Inheritance (basic, override, super, chain)

### Phase 7: Built-in Function Tests (25+ tests)
1. I/O (blether)
2. Type conversion (tae_string, tae_integer, tae_float, type_of)
3. List operations (len, shove, yank, keek, reverse)
4. Functional (gaun, sieve, tumble, ony, aw)
5. String operations (split, join, trim, upper/lower, contains, replace)
6. Math (abs, min, max, floor, ceil, sqrt, pow)

### Phase 8: Algorithm Tests (10+ tests)
1. Sorting (bubble, quick, merge)
2. Math (fibonacci, factorial, gcd, prime sieve)
3. String (palindrome, word count)

### Phase 9: Edge Case Tests (15+ tests)
1. Numbers (zero, negative, large, float precision)
2. Strings (empty, unicode, escapes, multiline)
3. Lists (empty, single element, mixed types)
4. Control flow (deep nesting, empty blocks, truthiness)

### Phase 10: Integration Tests (5+ tests)
1. Calculator
2. Todo list
3. Bank account
4. Game state
5. Simple parser

## Special Markers

Tests can include special markers:

- `// SKIP_NATIVE` - Skip this test for LLVM native compilation (interpreter-only features)
- `// SKIP_INTERPRETER` - Skip this test for interpreter (native-only features)
- `// EXPECT_ERROR` - Test expects an error (create .error file instead of .expected)

## Makefile Integration

Add to Makefile:
```makefile
golden:
	@echo "Running golden tests..."
	cargo test golden_tests --features llvm -- --nocapture

golden-update:
	@echo "Updating golden test expectations..."
	./tests/golden/update_expectations.sh

golden-add:
	@echo "Usage: make golden-add NAME=test_name CATEGORY=category"
	@mkdir -p tests/golden/$(CATEGORY)
	@touch tests/golden/$(CATEGORY)/$(NAME).braw
	@touch tests/golden/$(CATEGORY)/$(NAME).expected
	@echo "Created tests/golden/$(CATEGORY)/$(NAME).braw"
```

## Updating Expectations

Create `tests/golden/update_expectations.sh`:
```bash
#!/bin/bash
# Update .expected files from current interpreter output
# Use with caution - review changes before committing!

for braw in $(find tests/golden -name "*.braw"); do
    expected="${braw%.braw}.expected"
    echo "Updating $expected..."
    cargo run --release -- "$braw" > "$expected" 2>&1
done
```

## Notes

- Always test both interpreter AND native compilation
- Keep tests focused on ONE feature each
- Use descriptive file names
- Include comments in complex tests explaining what's being tested
- For LLVM-unsupported features, use SKIP_NATIVE marker
- Run tests frequently during development
- Git-track both .braw and .expected files
- Review .expected file changes carefully in PRs

## Completion Promise

All 100+ golden tests pass for both interpreter and LLVM native compilation, providing comprehensive regression coverage for the mdhavers language.
