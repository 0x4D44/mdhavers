# 2025.12.23 - CR - Code Review Plan (mdhavers)

## Metadata
- Repo: `mdhavers` (`/home/md/language/mdhavers`)
- Review date: 2025-12-23
- Git HEAD: `e4226acbcb781d18e5fcbe97b333e4f72d3836e9`
- Working tree state: dirty (modified + untracked files present as of review start)
- Primary languages: Rust, TypeScript/JavaScript, C/C++, Shell, mdhavers (`.braw`)

## Scope and assumptions
- **In scope**: all first-party source code and build/tooling code in this repository, including Rust crates, runtime shims, installer scripts, editor tooling, playground, tests, stdlib and examples.
- **Out of scope (deep review)**: third-party / vendored dependencies that are checked in (e.g. `vendor/`, `editor/vscode/node_modules/`, build outputs under `target/`, binary blobs). These will still be inventoried and evaluated for **risk/maintainability/licensing** impact, but not reviewed line-by-line.
- **Perspective**: code review for correctness, reliability, security, performance, maintainability, portability, testability, and UX/devex.

## Code inventory (what exists)

### Top-level areas (code-ish files; excludes `.git/`, `target/`, `wrk_docs/`, `wrk_journals/`)
- `src/`: Rust language implementation (lexer/parser/AST/interpreter/backends; ~25 files in `src/` root + submodules)
- `tests/`: Rust tests (golden tests, backend coverage suites, network/DTLS/SRTP/TLS tests)
- `stdlib/`: mdhavers standard library (`.braw` modules)
- `examples/`: mdhavers examples/showcases (`.braw`) + a few scripts
- `runtime/`: runtime support shims (C + Rust staticlib + JS helpers, plus some binary artifacts)
- `playground/`: WASM bindings crate + small web app
- `editor/`: VSCode extension (TS) + Vim syntax; includes checked-in `node_modules/` and compiled `out/`
- `installer/`: shell installer/uninstaller + completions
- `benchmarks/`: Rust benchmarks and harness scripts
- `docs/`: markdown + generated book/html assets
- `vendor/`: patched `raylib-sys` source tree (C/CMake/etc)

### File type counts (tracked; excludes `target/`)
- `.ts`: 315 (mostly `editor/` tooling; includes dependencies under `editor/vscode/node_modules/`)
- `.js`: 187 (editor/out + tooling + runtime/playground)
- `.rs`: 84 (core language + tests + runtime/playground crates)
- `.braw`: 79 (stdlib + examples; additional untracked `.braw` files also exist locally)
- `.c/.h/.cpp/.m`: mostly vendored (`vendor/`) plus `runtime/` shims
- Shell/Make: `Makefile`, `*.sh`, installer scripts

### Primary Rust crates/binaries
- Root crate `mdhavers`:
  - Library: `src/lib.rs`
  - CLI binary: `src/main.rs` (feature `cli`)
  - LSP binary: `src/lsp/main.rs` (feature `cli`)
  - Optional backends/features: `llvm`, `graphics`, `audio`, `wasm_runner`
- Runtime staticlib: `runtime/mdh_runtime_rs` (`crate-type = staticlib`)
- WASM synth module: `runtime/mdh_rustysynth_wasm` (`crate-type = cdylib`)
- Playground WASM crate: `playground/` (`mdhavers` dependency with `default-features = false`)

## Review goals (what “good” looks like)
1. **Correctness & semantics**: language grammar, runtime behavior, backend parity (interpreter/JS/WAT/LLVM), determinism where expected.
2. **Safety & security**: memory safety (unsafe/FFI), crypto correctness, certificate verification, network input validation, sandbox boundaries, DOS risks.
3. **Reliability**: avoid panics from untrusted input, bounded resource usage, clear error messages, graceful failure modes.
4. **Performance**: avoid obvious hot-path inefficiencies, reduce excessive allocations, keep compilation stages efficient.
5. **Maintainability**: cohesive module boundaries, clear invariants, sensible abstractions, consistent naming and error handling.
6. **Portability/build**: feature gating, optional dependencies, reproducible builds, clear install/build docs.
7. **Test quality**: coverage of edge cases and regressions, golden tests, backend parity checks.
8. **Tooling/devex**: CLI/LSP/editor/playground correctness and ergonomics.

## Plan (how the review will be executed)

### Phase 0 — Baseline orientation (inventory + entrypoints)
- Confirm code map, key binaries, and feature flags.
- Identify third-party code islands to de-scope for deep review and document the rationale.

### Phase 1 — Build/test surfaces and CI assumptions
- Review `Cargo.toml`, features, `build.rs`, `Makefile`, installer scripts, and runtime build artifacts.
- Identify platform-specific assumptions (Linux/macOS/Windows, X11, LLVM versions, audio backends).

### Phase 2 — Core language frontend (lexer → parser → AST)
- `src/token.rs`, `src/lexer.rs`: token definitions, Unicode handling, location tracking, lexer error quality.
- `src/ast.rs`: spans, node types, invariants.
- `src/parser.rs`: grammar, precedence, error recovery, ambiguous parse cases, statement termination rules.

### Phase 3 — Runtime semantics (interpreter + values + errors)
- `src/value.rs`: value model, equality semantics, coercions, ownership/copy rules.
- `src/interpreter.rs`: evaluation rules, scope/closures, classes/structs, imports/modules, native functions, crash-handling.
- `src/error.rs`: error taxonomy, propagation, formatting/context.
- Pay special attention to: unchecked panics (`unwrap/expect`), resource lifetimes (files/sockets), and user-controlled inputs.

### Phase 4 — Backends and parity
- JS compiler: `src/compiler.rs` + `runtime/js/*`
- WAT compiler: `src/wasm_compiler.rs`; host runner (`src/wasm_runner.rs` when enabled)
- LLVM backend: `src/llvm/*` (codegen, runtime ABI, builtins, safety of `unsafe`)
- Compare feature coverage and behavioral parity across backends; identify “spec vs impl” gaps.

### Phase 5 — Subsystems: logging, networking, TLS/DTLS/SRTP, audio, graphics, tri
- `src/logging.rs`, `src/audio.rs`, `src/graphics.rs`, `src/tri.rs`
- Network and crypto usage (trust-dns, rustls, openssl, udp-dtls, libsrtp):
  - certificate verification choices, trust roots, dangerous configuration usage
  - input validation and error handling
  - resource cleanup and concurrency model safety

### Phase 6 — Tooling and distribution
- CLI UX: `src/main.rs` (subcommands, diagnostics, formatting, tracer)
- LSP: `src/lsp/*`; editor integration: `editor/vscode/src/extension.ts`; Vim syntax
- Installer: `installer/*` (idempotency, safety, path updates, uninstall behavior)
- Playground: `playground/*` (WASM boundary safety, panic hooks, API stability)

### Phase 7 — Stdlib + examples + benchmarks
- Stdlib modules: API consistency, naming, docs, testability, and risk (network/crypto helpers).
- Examples/showcases: correctness and pedagogical quality; avoid insecure patterns in samples.
- Benchmarks: correctness of harness and representativeness.

### Phase 8 — Verification and static checks
- Run targeted build/tests (as environment allows):
  - `cargo test` (and possibly feature-gated variants like `--no-default-features --features cli`)
  - `cargo clippy` (where possible)
  - `cargo fmt -- --check` (optional)
- Document any failures as **environment-dependent** vs **code issues**.

## Findings format (how issues will be recorded)
Each finding in the report will include:
- **Severity**: Critical / High / Medium / Low / Nit
- **Area**: module(s) / file(s)
- **Impact**: what breaks / exploitability / UX effect
- **Evidence**: concrete code references and reasoning
- **Recommendation**: specific fix or refactor direction
- **Effort**: S / M / L (relative)

## Deliverables
- Comprehensive report: `wrk_docs/2025.12.23 - CR - Code Review Report.md`

