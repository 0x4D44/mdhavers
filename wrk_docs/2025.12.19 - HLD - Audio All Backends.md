# High-Level Design: Audio Across All Backends

Date: 2025.12.19
Status: Draft (Goal #2)
Owner: mdhavers core

## 1. Summary
Make the Scots audio API work on **all** backends: interpreter, LLVM/native compiler, JavaScript compiler, and WASM. This design keeps the existing Scots-only API (soond/muisic/midi), preserves audio independence from graphics, and delivers consistent behavior across targets while acknowledging platform constraints (native OS audio vs browser WebAudio).

## 2. Goals
- **Parity:** Every Scots audio function works on interpreter, native (LLVM), JS, and WASM backends.
- **Same API & semantics:** No English aliases, consistent handle/state behavior, Scots errors.
- **Independent of graphics:** Audio does not require a window or graphics init.
- **WAV/MP3/MIDI support:** As defined in the current interpreter API.
- **Target platforms:** Windows + WSL for native. Browser for JS/WASM, with best-effort Node support.
- **Richer control:** Maintain volume/pan/pitch/looping/seek/status APIs.

## 3. Non-Goals
- Audio effects (reverb, EQ, DSP chains).
- 3D/spatial audio (HRTF).
- Real-time MIDI input devices.
- Perfect sample-accurate seek across every backend.
- Binary-size minimization (acceptable growth for soundfont + audio runtime).

## 4. Current State (Baseline)
- Interpreter: full audio support using raylib + rustysynth with Scots-only API.
- LLVM/native: audio builtins blocked with a compile error (stub).
- JS: no audio runtime functions emitted.
- WASM: experimental compiler with minimal host imports; no audio.

## 5. Public API (No Change)
The public API remains exactly as currently implemented in the interpreter:

### Global/Device
- `soond_stairt()`
- `soond_steek()`
- `soond_wheesht(aye|nae)`
- `soond_luid(v)`
- `soond_hou_luid() -> float`
- `soond_haud_gang()`

### SFX
- `soond_lade(path) -> int`
- `soond_spiel(handle)`
- `soond_haud(handle)`
- `soond_gae_on(handle)`
- `soond_stap(handle)`
- `soond_unlade(handle)`
- `soond_is_spielin(handle) -> aye|nae`
- `soond_pit_luid(handle, v)`
- `soond_pit_pan(handle, pan)`
- `soond_pit_tune(handle, pitch)`
- `soond_pit_rin_roond(handle, aye|nae)`

### Music
- `muisic_lade(path) -> int`
- `muisic_spiel(handle)`
- `muisic_haud(handle)`
- `muisic_gae_on(handle)`
- `muisic_stap(handle)`
- `muisic_unlade(handle)`
- `muisic_is_spielin(handle) -> aye|nae`
- `muisic_loup(handle, seconds)`
- `muisic_hou_lang(handle) -> float`
- `muisic_whaur(handle) -> float`
- `muisic_pit_luid(handle, v)`
- `muisic_pit_pan(handle, pan)`
- `muisic_pit_tune(handle, pitch)`
- `muisic_pit_rin_roond(handle, aye|nae)`

### MIDI
- `midi_lade(path, soundfont = naething) -> int`
- `midi_spiel(handle)`
- `midi_haud(handle)`
- `midi_gae_on(handle)`
- `midi_stap(handle)`
- `midi_unlade(handle)`
- `midi_is_spielin(handle) -> aye|nae`
- `midi_loup(handle, seconds)`
- `midi_hou_lang(handle) -> float`
- `midi_whaur(handle) -> float`
- `midi_pit_luid(handle, v)`
- `midi_pit_pan(handle, pan)`
- `midi_pit_rin_roond(handle, aye|nae)`

## 6. Cross-Backend Semantics (Contract)
This contract must be preserved by every backend implementation.

### 6.1 Handles
- Handles are non-negative integers (0+).
- Invalid handle -> Scots error "Thon handle isnae guid".
- Unloaded handles are reusable.

### 6.2 Playback State
Each handle tracks one of: Stopped, Playing, Paused.
- `*_spiel` -> Playing
- `*_haud` -> Paused
- `*_gae_on` -> Playing
- `*_stap` -> Stopped
- `*_is_spielin` returns aye only when Playing.

### 6.3 Looping
- `*_pit_rin_roond(handle, aye)` enables loop.
- `soond_haud_gang()` is responsible for enforcing loop + stream updates.

### 6.4 Timing & Seek
- `*_loup(handle, seconds)` clamps to [0, length].
- `*_hou_lang()` and `*_whaur()` return seconds.
- For backends with async load, return 0 until ready.

### 6.5 Pan / Pitch / Volume
- Volume: clamp to [0.0, 1.0].
- Pan: -1.0 left to +1.0 right.
- Pitch: multiplier (1.0 normal). Clamped to backend-supported range.

### 6.6 Device & Master Volume
- `soond_stairt` is idempotent.
- `soond_steek` stops playback and releases all handles.
- `soond_wheesht(aye)` mutes by setting master volume to 0.
- `soond_luid(v)` updates master volume (if not muted).

### 6.7 Errors
- Use Scots phrasing consistent with interpreter (`soond_lade needs a string path`, etc.).
- All backends must surface the same message for common errors.

## 7. Architecture Overview
Introduce a backend-agnostic **Audio Facade** and backend-specific **Audio Engines**.

```
mdhavers audio builtins
        |
        v
 Audio Facade (handles, state, errors)
        |---------------------------|
        v                           v
 Native Engine (LLVM)        Web Engine (JS/WASM)
 (raylib/miniaudio +         (WebAudio + JS/WASM synth)
  rustysynth)
```

Key idea: the **facade** provides a consistent handle + state machine. Each backend supplies an engine implementation for device control, sound/music playback, and MIDI synthesis.

## 8. Backend Designs

### 8.1 Interpreter (Rust, existing)
- Keep current implementation in `src/audio.rs`.
- Minor adjustments only if required to align with shared contract.

### 8.2 Native (LLVM) Backend
#### 8.2.1 Runtime API (C ABI)
Add runtime C ABI functions in `runtime/mdh_runtime.h`:
- `__mdh_soond_stairt()`
- `__mdh_soond_steek()`
- `__mdh_soond_wheesht(MdhValue bool)`
- `__mdh_soond_luid(MdhValue float)`
- `__mdh_soond_hou_luid()` -> `MdhValue`
- `__mdh_soond_haud_gang()`
- `__mdh_soond_lade(MdhValue path)` -> `MdhValue (int)`
- `__mdh_soond_spiel(handle)` etc...
- `__mdh_muisic_*`
- `__mdh_midi_*`

Each returns/accepts `MdhValue` so the LLVM backend can emit calls without special casing.

#### 8.2.2 Native Engine Choice
Two viable options; design selects **Option A**:

**Option A (preferred): Rust runtime engine + raylib + rustysynth**
- Implement audio engine in `runtime/mdh_runtime_rs` with `raylib` + `rustysynth`.
- Export C ABI functions from Rust (`#[no_mangle] extern "C"`) that wrap the audio facade.
- Advantages: reuse existing interpreter logic; full MIDI support; stable API.

**Option B: C engine + raylib C API + TinySoundFont**
- Use raylib C API for WAV/MP3.
- Use `tsf` (TinySoundFont) + `tml` for MIDI.
- Advantages: no Rust dependency; smaller FFI. Disadvantage: divergent MIDI behavior vs interpreter.

#### 8.2.3 Rust Runtime Integration (Option A)
- Extend `runtime/mdh_runtime_rs/Cargo.toml` with `raylib` and `rustysynth`.
- Add an `audio` module exposing the C ABI described above.
- `mdh_runtime.c` forwards audio calls to the Rust runtime via externs, mirroring JSON/regex pattern.

#### 8.2.4 Linking & Build System
- Update `build.rs` to compile audio-enabled runtime and copy staticlib that includes audio code.
- Ensure raylib is built and linked into the final native executable.
- If raylib builds a separate static library, embed that alongside `mdh_runtime_rs.a` and link in `LLVMCompiler::compile_to_native_with_source`.
- Add platform-specific linker flags (Windows: `winmm`, `gdi32`, etc. / Linux: X11 deps for raylib if still used for audio).

#### 8.2.5 LLVM Codegen Changes
- Remove the current audio guard that errors on `soond_*` and `muisic_*`.
- Map each audio builtin to the new runtime functions in `src/llvm/runtime.rs`.
- Emit runtime calls returning `MdhValue`.

#### 8.2.6 Default SoundFont
- Use the same resolution strategy as interpreter:
  - CWD → exe directory → assets fallback.
- Allow explicit `soundfont` path override.

### 8.3 JavaScript Backend
#### 8.3.1 JS Runtime Surface
Extend `emit_runtime()` with an `__havers_audio` block and expose:
- `soond_*`, `muisic_*`, `midi_*`
- `soond_haud_gang` becomes the pump for async tasks and MIDI scheduling.

#### 8.3.2 WebAudio Engine
- Create a single `AudioContext` on `soond_stairt`.
- `GainNode` for master volume.
- Each handle owns:
  - `GainNode` (per-sound volume)
  - `StereoPannerNode`
  - `AudioBufferSourceNode` or `HTMLAudioElement`

**SFX:**
- Load via `fetch` + `decodeAudioData` into an `AudioBuffer`.
- Playback by creating a new `AudioBufferSourceNode` per play.

**Music:**
- Use `HTMLAudioElement` + `MediaElementAudioSourceNode` for reliable seek/pause/resume.
- Track state and start offsets for consistency.

**MIDI:**
- JS engine uses SoundFont synthesis. Two viable approaches:
  - **WebAudioFont** (JS soundfont synth). Bundle minimal runtime and a default SF2 (or a converted JSON preset).
  - **rustysynth.wasm** compiled from Rust (shared with native). JS wraps it and streams PCM to `AudioWorklet`.

**Design choice:** Use rustysynth.wasm for parity and deterministic MIDI behavior.

#### 8.3.3 Async Load Semantics
Browser decoding is async. To preserve API:
- `soond_lade` returns a handle immediately in "loading" state.
- `soond_spiel` queues a play request; actual playback starts when decode completes.
- `*_hou_lang` / `*_whaur` return 0 until ready.
- `soond_haud_gang` processes pending promises and state transitions.

#### 8.3.4 Node.js Support
- If `AudioContext` exists (Node 20+ experimental), use it.
- Otherwise attempt optional `node-web-audio-api` if installed.
- If no backend, raise a clear Scots error instructing to run in browser or enable WebAudio in Node.

### 8.4 WASM Backend
The WASM compiler is minimal today; to support audio it must rely on a host runtime.

#### 8.4.1 Host Imports
Add audio imports to the WAT module (all functions above). The host (JS) implements them using the same WebAudio engine used by the JS backend.

#### 8.4.2 Value ABI
Two-phase plan:

**Phase 1 (fast):**
- For audio calls only, use a simple ABI: strings passed as `(ptr, len)`; ints/floats as i64.
- Extend wasm compiler to recognize audio builtins and emit direct imports with the correct signature.

**Phase 2 (full parity):**
- Adopt a host-managed value model (as per WAT runner design): every value is an opaque handle stored by host runtime. This provides uniform behavior across all builtins, including audio.

#### 8.4.3 WASM Host Runtime
- Provide a `mdh_wasm_runtime.js` (or integrated into playground) that:
  - Exposes memory access helpers.
  - Implements audio functions by forwarding to the WebAudio engine.
  - Handles string decoding from WASM memory.

## 9. Internal Data Model
All backends implement a consistent handle/state model:

```
AudioState:
  initialized: bool
  master_volume: float
  muted: bool
  sounds: Vec<Option<SoundEntry>>
  music: Vec<Option<MusicEntry>>
  midi: Vec<Option<MidiEntry>>
```

Each entry stores state, looping, volume/pan/pitch, and backend-specific handles.

## 10. Error Messages (Canonical Set)
Keep the same Scots strings across backends; examples:
- "Cannae stairt the soond device"
- "Thon handle isnae guid"
- "soond_lade needs a string path"
- "midi_lade needs a soondfont path or naething"

## 11. Assets & Packaging
- Default SoundFont: `assets/soundfonts/MuseScore_General.sf2` (existing).
- Interpreter/native: use filesystem path resolution.
- JS/WASM:
  - Treat `path` as URL relative to a configurable base (`__havers_audio_base`), defaulting to current page.
  - Provide helper in docs for hosting assets alongside compiled JS/WASM.

## 12. Build & Feature Flags
- Keep `audio` feature enabled by default (already done).
- Ensure `audio` is honored by all backends:
  - Interpreter: current behavior.
  - LLVM: compile and link audio runtime when feature is on.
  - JS/WASM: always include audio JS runtime; allow opt-out via compile flag or runtime flag (`__havers_audio_disabled`).

## 13. Testing Strategy
### 13.1 Rust Unit Tests
- Extend `src/audio.rs` tests for edge cases and state transitions.
- Add runtime tests in `runtime/mdh_runtime_rs` with mocked audio backend.

### 13.2 Native Integration Tests
- Compile a small audio program via LLVM and run in CI with a headless backend or mock.
- Validate handle/state transitions without requiring real speakers.

### 13.3 JS Runtime Tests
- Add `tests/js/audio_runtime.test.js` that stubs WebAudio and asserts state changes.
- Add a browser-based test harness for real audio decode if available.

### 13.4 WASM Tests
- Add a wasm host runner test that imports audio functions and asserts they are callable.
- Use fake audio backend in JS host for deterministic tests.

## 14. Migration Plan
1. Implement native runtime audio C ABI (Rust engine) and link in LLVM backend.
2. Remove audio guard from `src/llvm/codegen.rs` and wire runtime calls.
3. Add JS runtime audio engine + compiler bindings.
4. Extend WASM compiler and host runtime for audio imports.
5. Update docs & troubleshooting for audio on all backends.

## 15. Risks & Mitigations
- **Web async loading:** use explicit loading state and `soond_haud_gang` pump.
- **SoundFont size:** allow optional smaller SF2; provide docs for hosting externally.
- **Node audio availability:** detect and error gracefully with guidance.
- **Link complexity (native):** prefer Rust runtime to reuse existing build pipeline.
- **Behavior divergence:** enforce shared tests across backends.

## 16. Open Questions
- Adopt Rust runtime engine (Option A) or C + TinySoundFont (Option B)?
- For JS MIDI, do we bundle a minimal SF2 or rely on external hosting?
- Should we add an explicit `soond_ready(handle)` helper for web async status?

---

### Appendix A: Backend Mapping Table (Audio Builtins → Runtime)
Native (LLVM):
- `soond_*` → `__mdh_soond_*` (C ABI)
- `muisic_*` → `__mdh_muisic_*`
- `midi_*` → `__mdh_midi_*`

JS/WASM:
- `soond_*` → `__havers_audio.soond_*`
- `muisic_*` → `__havers_audio.muisic_*`
- `midi_*` → `__havers_audio.midi_*`

