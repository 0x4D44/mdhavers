# mdhavers — Code Coverage Review (LLVM source-based)

**Date:** 2025-12-23  
**Repo:** `mdhavers` (`2f4b4a0a9e927ed037b9e364c07e4b3a20d1ef9c`)  
**Tooling:** `cargo-llvm-cov 0.6.20` (LLVM `18.1.3`, `rustc 1.91.0`)  

## Scope + definition of “coverage”

This review uses **LLVM source-based coverage** via `cargo-llvm-cov`, and treats **`src/` as the measured surface area** (i.e., coverage summary entries are the Rust source files under `src/` that were compiled for the selected feature set).

Important nuances for interpreting the numbers:

- `cargo-llvm-cov` counts **executed lines in `src/`** regardless of whether they come from “production” code or `#[cfg(test)]` blocks that live inside `src/*.rs`.
- Integration tests in `tests/` are **not included in the denominator** (they do not appear as “files” in the summary), but they **do contribute to execution counts** for `src/` during the run.
- Feature selection matters: code that is `#[cfg(feature = "...")]` is only measured if it is compiled by that feature set.

## Canonical command (baseline)

The canonical baseline (and the target for improvements to 98%) is measured with:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  --summary-only --json --output-path target/llvm-cov-summary.json
```

Rationale: `cli,llvm,native` exercises the broadest “typical local dev / full backend” surface area without pulling in the optional `graphics` / `audio` feature gates explicitly (though some modules may still compile depending on crate structure).

Supporting artifacts generated for analysis:

- `target/llvm-cov-summary.json` (JSON summary used for the tables below)
- `target/llvm-cov.lcov` (LCOV export used to identify missing-line clusters)

## Baseline results (repo `2f4b4a0...`, 2025-12-23)

From `target/llvm-cov-summary.json`:

- **Lines:** 54,408 / 56,374 = **96.51%** (missed: 1,966)
- **Functions:** 2,628 / 2,773 = **94.77%** (missed: 145)
- **Regions:** 95,911 / 102,899 = **93.21%** (missed: 6,988)
- **Instantiations:** 4,192 / 5,242 = **79.97%** (missed: 1,050)

### “98% line coverage” gap

- Total lines: **56,374**
- Covered lines: **54,408**
- Required covered at 98%: **55,247**
- **Additional covered lines needed:** **839**

## File-level line coverage (src-only)

Sorted by missed lines:

| File | Lines | Missed | Coverage |
|---|---:|---:|---:|
| `src/interpreter.rs` | 12,246/13,091 | 845 | 93.55% |
| `src/llvm/codegen.rs` | 28,975/29,633 | 658 | 97.78% |
| `src/error.rs` | 694/784 | 90 | 88.52% |
| `src/wasm_compiler.rs` | 1,078/1,150 | 72 | 93.74% |
| `src/main.rs` | 704/768 | 64 | 91.67% |
| `src/compiler.rs` | 1,291/1,348 | 57 | 95.77% |
| `src/audio.rs` | 1,754/1,799 | 45 | 97.50% |
| `src/formatter.rs` | 830/866 | 36 | 95.84% |
| `src/parser.rs` | 1,583/1,611 | 28 | 98.26% |
| `src/llvm/compiler.rs` | 454/471 | 17 | 96.39% |
| `src/value.rs` | 1,019/1,033 | 14 | 98.64% |
| `src/lsp/main.rs` | 384/396 | 12 | 96.97% |
| `src/logging.rs` | 595/605 | 10 | 98.35% |
| `src/tri.rs` | 469/479 | 10 | 97.91% |
| `src/lsp/mdhavers_bindings.rs` | 764/772 | 8 | 98.96% |
| `src/ast.rs` | 630/630 | 0 | 100.00% |
| `src/llvm/runtime.rs` | 362/362 | 0 | 100.00% |
| `src/token.rs` | 215/215 | 0 | 100.00% |
| `src/lib.rs` | 140/140 | 0 | 100.00% |
| `src/lexer.rs` | 137/137 | 0 | 100.00% |
| `src/llvm/builtins.rs` | 43/43 | 0 | 100.00% |
| `src/llvm/types.rs` | 37/37 | 0 | 100.00% |
| `src/graphics.rs` | 4/4 | 0 | 100.00% |

## Hotspots (root-cause oriented)

### 1) `src/interpreter.rs` (845 missed lines)

This is the single largest lever to reach 98%: fully covering the interpreter file alone would exceed the required +839 lines.

Observed characteristics (from LCOV missing-line clustering and spot checks):

- A meaningful portion of misses are in **rare error paths / validation branches**, especially for native/runtime helpers.
- Some misses are also inside **`#[cfg(test)]` tests embedded in `src/interpreter.rs`** (typically “failure-only” `panic!`/unreachable branches). Those lines count toward the denominator but are intentionally never executed in passing test runs.

Primary remediation strategies:

- Add/extend **integration tests** that drive interpreter execution through currently-cold branches (preferred: doesn’t inflate `src/` with additional test-only code).
- Where uncovered lines are in `src/`-embedded tests, refactor the assertions to avoid counting “failure-only” lines as uncovered (or move those tests to `tests/`).

### 2) `src/llvm/codegen.rs` (658 missed lines)

LLVM codegen is already close to the target, but the file is so large that a small percentage of uncovered logic is still hundreds of lines.

Likely causes:

- Unexercised AST node kinds / niche lowering branches
- Error handling and “should never happen” defensive paths
- Optional paths triggered only by specific combinations of features/values (e.g., edge-case constant folding, container shape handling)

Primary remediation strategy:

- Add narrowly targeted LLVM compilation tests that compile crafted source snippets to IR to traverse the missing branches.

### 3) `src/error.rs` (90 missed lines)

Misses are concentrated in the `HaversError::with_line_if_zero` match arms (line ~219 onward). This is a high-ROI quick win: a small table-driven test can cover most/all of these branches.

### 4) `src/wasm_compiler.rs` (72 missed lines)

Misses cluster in the AST scanner / expression traversal for less-common constructs (e.g., `try/catch`, `match`, `assert` message, destructure, log extras). A single program string that includes these constructs and is compiled to WAT can cover the majority of the gaps.

### 5) `src/main.rs` (64 missed lines)

Misses include:

- Subcommand-specific parse/runtime error formatting branches not triggered by current CLI tests.
- REPL multiline detection (`repl_needs_more_input`) and some REPL error-handling branches (harder to cover reliably in CI because it depends on terminal/TTY behavior).

Primary remediation strategy:

- Expand `tests/cli_coverage.rs` with additional subcommand error cases (parse errors for `run`/`compile`/`wasm`/`trace`/`build`, plus a forced “bad prelude” to trigger the prelude-load error path).
- Treat REPL/TTY-dependent branches as “best effort”; prioritize deterministic improvements first.

## Next steps

See `wrk_docs/2025.12.23 - CC - Coverage Improvement Plan.md` for a staged plan targeting the biggest missed-line contributors first, and the exact command used to validate the 98% goal.

