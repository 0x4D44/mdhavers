# mdhavers — Code Coverage Review (LLVM source-based)

**Date:** 2025-12-23  
**Repo:** `mdhavers` (`505be5ef4d811c52a8ef3957b4c47633f9b73434`)  
**Tooling:** `cargo-llvm-cov 0.6.20` (`rustc 1.91.0`, LLVM `21.1.2`)  

## Scope + definition of “coverage”

This review uses **LLVM source-based coverage** via `cargo-llvm-cov`, and treats **`src/` as the measured surface area** (i.e., coverage summary entries are the Rust source files under `src/` that were compiled for the selected feature set).

Important nuances for interpreting the numbers:

- `cargo-llvm-cov` counts **executed lines in `src/`** regardless of whether they come from “production” code or `#[cfg(test)]` blocks that live inside `src/*.rs`.
- Integration tests in `tests/` are **not included in the denominator** (they do not appear as “files” in the summary), but they **do contribute to execution counts** for `src/` during the run.
- Feature selection matters: code that is `#[cfg(feature = "...")]` is only measured if it is compiled by that feature set.

## Canonical command (scoreboard)

The canonical metric (and the 98% gate used for this effort) is:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  --summary-only --json --output-path target/llvm-cov-summary.json
```

Supporting artifacts used for analysis:

- `target/llvm-cov-summary.json` (JSON summary totals)
- `target/llvm-cov-missing-lines.txt` (human-readable report via `cargo llvm-cov ... report --show-missing-lines`)

## Current results (target met)

From `target/llvm-cov-summary.json`:

- **Lines:** 55,309 / 56,395 = **98.07%** (missed: 1,086)
- **Functions:** 2,672 / 2,802 = **95.36%** (missed: 130)
- **Regions:** 97,471 / 102,816 = **94.80%** (missed: 5,345)
- **Instantiations:** 4,266 / 5,277 = **80.84%** (missed: 1,011)

✅ **The ≥98% total line coverage goal is satisfied** under the canonical feature set (`cli,llvm,native`, `--no-default-features`).

## File-level line coverage (src-only)

From `target/llvm-cov-missing-lines.txt`, sorted by missed lines:

| File | Covered/Total | Missed | Coverage |
|---|---:|---:|---:|
| `src/interpreter.rs` | 12,435 / 13,123 | 688 | 94.76% |
| `src/llvm/codegen.rs` | 29,170 / 29,380 | 210 | 99.29% |
| `src/compiler.rs` | 1,293 / 1,349 | 56 | 95.85% |
| `src/audio.rs` | 1,878 / 1,913 | 35 | 98.17% |
| `src/formatter.rs` | 831 / 866 | 35 | 95.96% |
| `src/main.rs` | 753 / 768 | 15 | 98.05% |
| `src/llvm/compiler.rs` | 470 / 481 | 11 | 97.71% |
| `src/value.rs` | 1,036 / 1,046 | 10 | 99.04% |
| `src/wasm_compiler.rs` | 1,147 / 1,157 | 10 | 99.14% |
| `src/logging.rs` | 598 / 603 | 5 | 99.17% |
| `src/parser.rs` | 1,671 / 1,675 | 4 | 99.76% |
| `src/lsp/main.rs` | 425 / 428 | 3 | 99.30% |
| `src/lsp/mdhavers_bindings.rs` | 775 / 778 | 3 | 99.61% |
| `src/error.rs` | 783 / 784 | 1 | 99.87% |
| `src/ast.rs` | 630 / 630 | 0 | 100.00% |
| `src/graphics.rs` | 4 / 4 | 0 | 100.00% |
| `src/lexer.rs` | 137 / 137 | 0 | 100.00% |
| `src/lib.rs` | 140 / 140 | 0 | 100.00% |
| `src/token.rs` | 215 / 215 | 0 | 100.00% |
| `src/tri.rs` | 476 / 476 | 0 | 100.00% |
| `src/llvm/builtins.rs` | 43 / 43 | 0 | 100.00% |
| `src/llvm/runtime.rs` | 362 / 362 | 0 | 100.00% |
| `src/llvm/types.rs` | 37 / 37 | 0 | 100.00% |

## Hotspots (what’s still “cold”)

Even with total lines ≥98%, the biggest remaining missed-line contributors are:

1) `src/interpreter.rs` (688 missed) — broad runtime surface; many error paths, uncommon builtins, and niche protocol/IO branches.  
2) `src/llvm/codegen.rs` (210 missed) — mostly niche lowering branches and defensive/rare codegen paths.  
3) `src/compiler.rs` (56 missed) — less common JS compiler paths, errors, and some AST forms.

These are the best candidates if you want to push beyond 98% or improve function/region coverage.

## What changed to reach 98%

The final gap was closed by adding targeted LLVM compilation cases that exercise cold codegen branches without relying on flaky IO or TTY behavior:

- `tests/llvm_codegen_extra_constructs_coverage.rs`
  - Added string comparison cases (string-typed non-Add fast-path branch).
  - Added unary-integer arithmetic to force `compile_binary_int_fast` fallbacks.
  - Added nested string concatenation that avoids constant folding so `compile_string_concat_fast` hits its “dynamic right length” path.

Follow-on improvements (post-98%):

- Added deterministic interpreter coverage tests for logging natives, channel/atomic error paths, and module resolution.
- Added deterministic DTLS validation/error-path tests (avoids relying on external network success).
- Removed dead/unreachable branches in `src/interpreter.rs` that inflated the line denominator.

## Next steps

See `wrk_docs/2025.12.23 - CC - Coverage Improvement Plan.md` for an updated staged plan to maintain ≥98% and (optionally) push higher.
