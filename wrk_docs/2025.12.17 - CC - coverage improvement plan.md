# Coverage Improvement Plan (Goal: 98% lines)
**Date:** 2025-12-17  
**Target metric:** `cargo llvm-cov --tests --summary-only` **line coverage >= 98%**  
**Baseline:** ~83.09% lines (34,602 / 41,642)  

## Ground rules / definitions
- “Coverage” means **LLVM source-based line coverage** for Rust sources in this workspace as reported by `cargo llvm-cov`.
- We will treat `cargo llvm-cov --tests --summary-only` as the **canonical** number (same command used in the coverage report).
- Improvements should come from:
  - adding tests that exercise real behavior, and/or
  - refactoring to make behavior testable and remove dead/unreachable code.

## Phase 0 — Tooling and feedback loop (done)
1. Establish baseline coverage and identify hotspots.
2. Capture the current report in `wrk_docs/2025.12.17 - CC - code coverage analysis report.md`.

## Phase 1 — Eliminate 0%-covered “entrypoint” drag (target: +3–5%)
**Objective:** Bring `src/main.rs` and `src/lsp/main.rs` off 0%, and cover small 0%-covered LLVM helper modules.

Actions:
1. **CLI coverage harness**
   - Add integration tests that execute the `mdhavers` binary via `Command`.
   - Exercise:
     - `--help`, `--version`
     - `run`, `check`, `fmt --check`, `tokens`, `ast`, `trace`, `wasm`, `build --emit-llvm`
     - `repl` with scripted stdin that triggers multiple branches (`help`, `:reset`, `:wisdom`, `:examples`, `:trace`, `quit`).
2. **LSP testability refactor**
   - Move `main_loop`, request/notification handlers, and helpers into a library module (e.g. `src/lsp_server.rs` behind the `cli` feature).
   - Keep `src/lsp/main.rs` minimal (stdio wiring only).
   - Add unit tests using `lsp_server::Connection::memory()` to simulate:
     - initialization + shutdown
     - hover + completion requests
     - open/change/close notifications and diagnostics publication.
3. **LLVM legacy modules**
   - Decide per file:
     - `src/llvm/runtime.rs`: either cover with a minimal inkwell test that calls `RuntimeFunctions::declare`, or remove if truly obsolete.
     - `src/llvm/builtins.rs`: cover with direct unit tests for lookup helpers, or remove if obsolete.

## Phase 2 — Interpreter gap closure (target: interpreter ~79% → 98%)
**Objective:** Reduce uncovered lines in `src/interpreter.rs` by ~1,700+.

Actions:
1. Add a **table-driven interpreter suite** (single test binary, many cases) that:
   - runs representative snippets for all expression/statement forms
   - exercises try/catch (`hae_a_bash` / `gin_it_gangs_wrang`) including intentionally-triggered runtime errors
   - covers list/dict/string builtins and edge cases (empty, negative indices, wrong types)
   - explicitly calls `Interpreter::load_prelude()` and module resolution paths.
2. Add a **small set of focused unit tests inside `src/interpreter.rs`** (where private helpers exist), targeting:
   - JSON helpers
   - error formatting and stack trace plumbing
   - rarely-hit branches (division by zero, wrong arity, not callable).

## Phase 3 — LLVM backend/codegen gap closure (target: codegen ~88% → 98%)
**Objective:** Reduce uncovered lines in `src/llvm/codegen.rs` by ~2,200+.

Actions:
1. Add **“negative” codegen tests**:
   - parse valid programs that are invalid for compilation (unsupported constructs, deliberate type errors)
   - assert compilation fails with the expected error category/message (covers error branches).
2. Add **feature-driver programs** that specifically target:
   - rarely-used builtins/inline helpers
   - class/instance edge cases
   - dict/list/string corner cases
   - try/catch/hurl control flow paths
   - code paths used only under certain type-inference results.
3. Add a **compile-to-IR inspection suite**:
   - compile snippets to LLVM IR and assert on “shape” (presence of key calls/blocks) to exercise compilation paths without executing the output.

## Phase 4 — Final convergence (target: 98% overall)
**Objective:** Use coverage data to surgically close remaining gaps.

Actions:
1. Re-run coverage and list top remaining missed files/functions.
2. Add targeted tests for the last uncovered blocks (typically small error/edge branches).
3. If any remaining gaps are genuinely dead/unreachable:
   - remove dead code, or
   - refactor to consolidate duplicated logic so existing tests cover the shared implementation.

