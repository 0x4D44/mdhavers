# mdhavers LLVM Backend Performance Optimization

## Objective

Investigate the LLVM backend performance bottlenecks, identify specific causes, design optimizations, and implement them to reduce the performance gap with Rust.

## Current State

Based on large-scale benchmarks, mdhavers LLVM backend is:
- **2,000x slower** than Rust for iterative arithmetic (Fibonacci)
- **15,000-26,000x slower** for array-heavy operations (Prime Sieve)
- **100,000-1,000,000x slower** for sorting
- **200,000-700,000x slower** for string building

## Phase 1: Investigation and Profiling

### 1.1 Understand Current LLVM Codegen Architecture
Read and analyze:
- `src/llvm/mod.rs` - Module structure
- `src/llvm/codegen.rs` - Main code generation
- `src/llvm/runtime.rs` - Runtime support functions
- `src/llvm/types.rs` - Type representation

Document:
- How values are represented (tagged unions? boxed? unboxed?)
- How type checking is performed at runtime
- How function calls are generated
- How loops are compiled
- How arrays/lists are implemented

### 1.2 Generate and Analyze LLVM IR
Create a minimal test program and examine the generated IR:
```
# test_loop.braw
ken sum = 0
ken i = 0
whiles i < 1000 {
    sum = sum + i
    i = i + 1
}
blether sum
```

Use `llc` or examine the IR to understand:
- What instructions are generated for a simple loop
- Where type checks are inserted
- How arithmetic operations are compiled
- Function call overhead

### 1.3 Profile Hot Paths
Identify the most expensive operations by:
- Adding timing instrumentation to runtime functions
- Using `perf` or similar tools on compiled binaries
- Comparing IR size and complexity between operations

## Phase 2: Identify Optimization Opportunities

### 2.1 Loop Optimization
Investigate:
- Is there a type check on every iteration?
- Are loop bounds checked repeatedly?
- Can we hoist invariant computations?
- Can we unbox loop counters when type is known?

### 2.2 Arithmetic Fast Paths
Investigate:
- How are `+`, `-`, `*`, `/` compiled?
- Is there runtime dispatch for every operation?
- Can we specialize for integer/float when types are known?

### 2.3 Array/List Operations
Investigate:
- How is array access (`arr[i]`) compiled?
- Is bounds checking performed? How expensive?
- How are arrays represented in memory?
- Can we use contiguous memory for numeric arrays?

### 2.4 String Operations
Investigate:
- How is string concatenation implemented?
- Is it creating new strings on every `+`?
- Can we implement a StringBuilder pattern internally?
- How are string slices handled?

### 2.5 Function Calls
Investigate:
- How are closures represented?
- Is there boxing/unboxing overhead on calls?
- Can we inline simple functions?
- How are built-in functions called?

## Phase 3: Design Optimizations

Based on Phase 2 findings, design specific optimizations. Likely candidates:

### 3.1 Type Specialization
- Track types through simple expressions
- Generate specialized code paths for known types
- Avoid runtime type checks when provable

### 3.2 Integer Fast Path
- Detect integer-only loops
- Generate unboxed integer operations
- Use native CPU instructions directly

### 3.3 Loop Optimizations
- Hoist invariant type checks out of loops
- Unroll small loops
- Use LLVM's loop optimization passes more effectively

### 3.4 String Builder
- Implement internal buffer for string concatenation
- Delay actual string creation until needed
- Use rope or buffer pattern for building

### 3.5 Array Optimizations
- Specialized numeric arrays (all-int, all-float)
- Unchecked array access in bounds-proven contexts
- Better memory layout for cache efficiency

### 3.6 Inline Caching / Specialization
- Cache method lookups
- Specialize hot paths at runtime
- Generate multiple code paths with guards

## Phase 4: Implementation

Implement optimizations in priority order based on expected impact:

### Priority 1: Integer Loop Fast Path
**Expected Impact**: 10-100x improvement on Fibonacci-like benchmarks
- Detect `whiles` loops with integer counter
- Generate unboxed integer path
- Skip type checks inside loop

### Priority 2: String Builder
**Expected Impact**: 100-1000x improvement on string building
- Implement `StringBuilder` type internally
- Convert string `+` to builder append
- Materialize string only when needed (print, return, etc.)

### Priority 3: Array Access Optimization
**Expected Impact**: 10-50x improvement on array-heavy code
- Reduce bounds check overhead
- Better memory layout
- Inline array access when possible

### Priority 4: Sort Algorithm Fix
**Expected Impact**: 1000x improvement on sorting
- Verify current sort implementation
- Replace with efficient O(n log n) algorithm
- Consider using native sort for numeric arrays

## Phase 5: Validation

### 5.1 Correctness Testing
- Run full test suite after each optimization
- Add regression tests for edge cases
- Verify numeric precision is maintained

### 5.2 Performance Benchmarking
Re-run the large-scale benchmarks after each optimization:
- `benchmarks/large_scale/fib_large.braw`
- `benchmarks/large_scale/primes_large.braw`
- `benchmarks/large_scale/sort_stress.braw`
- `benchmarks/large_scale/string_large.braw`

Compare before/after ratios with Rust.

### 5.3 Document Changes
- Update any relevant documentation
- Add comments explaining optimization strategies
- Note any tradeoffs or limitations

## Success Criteria

| Benchmark | Current Ratio | Target Ratio |
|-----------|---------------|--------------|
| Fibonacci | 2,000x | <100x |
| Prime Sieve | 20,000x | <500x |
| Sorting | 500,000x | <1,000x |
| String Build | 500,000x | <1,000x |

## Completion Promise

Investigation complete when:
1. All Phase 1-2 findings documented
2. At least one Priority 1 or 2 optimization implemented
3. Benchmarks show measurable improvement
4. All tests pass

## Files to Modify

Likely files:
- `src/llvm/codegen.rs` - Main code generation
- `src/llvm/runtime.rs` - Runtime functions
- `src/llvm/types.rs` - Type representation
- `src/runtime/` - If runtime functions need changes
- `src/builtins/` - Built-in function implementations

## Reference Commands

Build with LLVM:
```bash
cargo build --release
```

Run benchmark:
```bash
./target/release/mdhavers build benchmarks/large_scale/fib_large.braw -o /tmp/fib && /tmp/fib
```

View LLVM IR:
```bash
./target/release/mdhavers build --emit-llvm benchmarks/large_scale/fib_large.braw
```

Run tests:
```bash
cargo test
```
