# Ralph Wiggum Prompt: LLVM Backend Class/OOP Support

## Objective

Implement full class/OOP support in the mdhavers LLVM backend (`src/llvm/codegen.rs`) to enable compilation of programs that use classes, instances, properties, and methods. This will allow the tetris game (`games/tetris/tetris.braw`) to compile.

## Background

The mdhavers language has a working interpreter that supports classes (`kin`), but the LLVM backend currently lacks support for:

1. **`Stmt::Class`** - Class definitions (`kin TetrisGame { ... }`)
2. **`Expr::Get`** - Property/method access (`obj.property`, `masel.score`)
3. **`Expr::Set`** - Property assignment (`obj.property = value`, `masel.score = 0`)
4. **`Expr::Masel`** - Self reference (`masel` - equivalent to `self`/`this`)

## AST Definitions (from `src/ast.rs`)

```rust
// Class definition
Stmt::Class {
    name: String,
    superclass: Option<String>,
    methods: Vec<Stmt>,  // Each method is a Stmt::Function
    span: Span,
}

// Property access
Expr::Get {
    object: Box<Expr>,
    property: String,
    span: Span,
}

// Property assignment
Expr::Set {
    object: Box<Expr>,
    property: String,
    value: Box<Expr>,
    span: Span,
}

// Self reference
Expr::Masel { span: Span }
```

## Value Tags (from `src/llvm/types.rs`)

The runtime already has tags for Class and Instance:
```rust
pub enum ValueTag {
    Nil = 0,
    Bool = 1,
    Int = 2,
    Float = 3,
    String = 4,
    List = 5,
    Dict = 6,
    Function = 7,
    Class = 8,      // For class objects
    Instance = 9,   // For class instances
    Range = 10,
}
```

## Implementation Strategy

### 1. Data Structures

#### Class Object Memory Layout
```
Class: [i64 method_count][method_entry0][method_entry1]...
where method_entry = [i8* name_ptr][function_ptr]
```

#### Instance Object Memory Layout
```
Instance: [i64 class_ptr][i64 field_count][field_entry0][field_entry1]...
where field_entry = [{i8,i64} key (string)][{i8,i64} value]
```

This is similar to the Dict layout but with an additional class pointer at the start.

### 2. CodeGen Struct Additions

Add to `CodeGen<'ctx>`:
```rust
/// Class definitions: name -> (method_count, method_table_ptr)
classes: HashMap<String, (u64, PointerValue<'ctx>)>,

/// Current 'masel' instance pointer (set during method compilation)
current_masel: Option<PointerValue<'ctx>>,
```

### 3. Helper Functions to Implement

#### `make_class(ptr) -> BasicValueEnum`
Create a class value with tag=8 and data=ptr.

#### `make_instance(ptr) -> BasicValueEnum`
Create an instance value with tag=9 and data=ptr.

#### `compile_class(name, superclass, methods) -> Result<()>`
1. Compile each method as a function with name `ClassName_methodName`
2. Create a method table in memory: `[count][name0][fn0][name1][fn1]...`
3. Store class in `self.classes` HashMap
4. Create a global variable for the class

#### `compile_class_instantiation(class_name, args) -> Result<BasicValueEnum>`
Called when we see `ClassName()`:
1. Allocate instance memory
2. Set class pointer
3. Initialize field count to 0
4. Call `init` method if it exists

#### `compile_get(object, property) -> Result<BasicValueEnum>`
1. Compile the object expression
2. Check if object tag is Instance (9)
3. If Instance: search fields for property, return value (similar to dict lookup)
4. Also handle method lookup for method calls

#### `compile_set(object, property, value) -> Result<BasicValueEnum>`
1. Compile the object expression
2. Compile the value expression
3. Check if object tag is Instance
4. Search for existing field, update or add new field
5. May need to reallocate instance if adding new field

#### `compile_masel() -> Result<BasicValueEnum>`
Return `self.current_masel` (the current instance during method execution).

### 4. Changes to `compile_stmt`

Add case for `Stmt::Class`:
```rust
Stmt::Class { name, superclass, methods, .. } => {
    self.compile_class(name, superclass, methods)
}
```

### 5. Changes to `compile_expr`

Add cases:
```rust
Expr::Get { object, property, .. } => {
    self.compile_get(object, property)
}

Expr::Set { object, property, value, .. } => {
    self.compile_set(object, property, value)
}

Expr::Masel { .. } => {
    self.compile_masel()
}
```

### 6. Changes to `compile_call`

When calling a method (detected via `Expr::Get` callee):
1. Get the instance
2. Look up method in class method table
3. Set `current_masel` to the instance
4. Call the method function
5. Clear `current_masel`

When calling a class name (instantiation):
1. Look up class in `self.classes`
2. Call `compile_class_instantiation`

### 7. Instance Field Management

Fields are stored dynamically (like a dict). Operations needed:

#### `instance_get_field(instance_data, field_name) -> BasicValueEnum`
Loop through fields, compare names, return value or nil.

#### `instance_set_field(instance_data, field_name, value)`
1. Loop through fields looking for existing field
2. If found, update value
3. If not found, reallocate instance with +1 field, add new field

### 8. Method Compilation

When compiling a method:
1. Create function with name `ClassName_methodName`
2. First hidden parameter is the instance pointer
3. Set `current_masel` to this parameter
4. Compile method body
5. Clear `current_masel`

## Test Cases

After implementation, these should work:

```scots
# Simple class
kin Counter {
    dae init() {
        masel.count = 0
    }

    dae increment() {
        masel.count = masel.count + 1
    }

    dae get() {
        gie masel.count
    }
}

ken c = Counter()
c.increment()
c.increment()
blether(c.get())  # Should print 2
```

## Files to Modify

1. **`src/llvm/codegen.rs`** - Main implementation
2. **`src/llvm/types.rs`** - May need to add InferredType::Instance, InferredType::Class

## Reference Implementation

The interpreter in `src/interpreter.rs` has working class support:
- `Stmt::Class` handling at line ~4670
- `Expr::Get` handling at line ~5143
- `Expr::Set` handling at line ~5176
- `Expr::Masel` handling at line ~5573

## Complexity Notes

1. **Superclass support** can be deferred initially (just handle `superclass: None`)
2. **Dynamic field addition** is the trickiest part - may need realloc
3. **Method calls** need special handling to bind `masel`
4. Consider a simpler initial approach where all fields must be declared in `init`

## Success Criteria

The tetris game at `games/tetris/tetris.braw` should compile successfully with:
```bash
mdhavers build games/tetris/tetris.braw
```

The game uses:
- Class definition (`kin TetrisGame`)
- Instance creation (`TetrisGame()`)
- Property access (`game.score`, `masel.board`)
- Property assignment (`masel.score = 0`)
- Method calls (`game.move_left()`, `masel.spawn_piece()`)
