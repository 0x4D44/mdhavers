# Native mdhavers logger (HLD)

Date: 2025.12.20
Owner: mdhavers runtime
Status: design

## Summary
Add a native, runtime-backed logging system for mdhavers inspired by Rust's log/tracing crates. The new logger provides a unified event API, structured fields, span context, and configurable sinks and filters across interpreter, LLVM/WASM runtime, and JS output. Existing log_whisper/log_mutter/log_blether/log_holler/log_roar statements continue to work but are routed through the new logger.

## Motivation
Current logging is fragmented:
- Interpreter prints formatted lines directly to stderr.
- JS compiler emits console.error with a fixed prefix.
- LLVM/WASM runtime ignores log level and just prints messages.
- stdlib/logging.braw provides structured logging, but it is script-only, slower, and inconsistent across targets.

We want a single logging core with consistent semantics, optional structure, and the ability to extend sinks (stderr, file, memory buffer, callbacks) while keeping mdhavers ergonomics and Scottish flair.

## Goals
- Provide a native logging core with:
  - Events (level, message, target, fields, metadata).
  - Spans (enter/exit) to attach structured context.
  - Filters (level + target) similar to RUST_LOG.
  - Multiple sinks (stderr by default, optional file/memory/callback).
  - Consistent behavior across interpreter, LLVM/WASM, and JS backends.
- Keep existing log_* statements and stdlib logging APIs working.
- Provide programmatic configuration plus environment-based defaults.
- Keep overhead low when logging is disabled.

## Non-goals
- Full tracing ecosystem (async propagation, distributed tracing export, OTLP).
- Dynamic reconfiguration across processes.
- Sampling, rate limiting, or log rotation in v1 (can be future work).
- Breaking changes to existing mdhavers programs.

## Current state (relevant pieces)
- Log levels are defined in `src/ast.rs` (Wheesht, Roar, Holler, Blether, Mutter, Whisper).
- `log_whisper` ... `log_roar` are statement keywords in the parser and formatter.
- Interpreter logs with `log_message` (timestamp, thread id, file:line) to stderr.
- JS compiler emits console.error with a fixed prefix.
- LLVM codegen prints with `blether` (stdout) and ignores level.
- Runtime C provides `__mdh_get_log_level` / `__mdh_set_log_level` but no event or span support.
- stdlib/logging.braw provides structured logging but is not native and is not used by compiled targets.

## Proposed design

### 1) User-facing API (mdhavers)

#### A. Event logging (native functions)
- `log_enabled(level, target = "") -> bool`
- `log_event(level, message, fields = {}, target = "") -> naething`

Convenience wrappers (native):
- `log_whisper(msg, fields = {}, target = "")`
- `log_mutter(msg, fields = {}, target = "")`
- `log_blether(msg, fields = {}, target = "")`
- `log_holler(msg, fields = {}, target = "")`
- `log_roar(msg, fields = {}, target = "")`

Notes:
- `level` is accepted as string ("whisper") or int (0-5).
- `fields` is a dict with string keys. Values can be any mdhavers value; non-JSON types are stringified.
- `target` defaults to the current module or file name.

#### B. Span API (native functions)
- `log_span(name, level = "blether", fields = {}, target = "") -> span_handle`
- `log_span_enter(span_handle) -> naething`
- `log_span_exit(span_handle) -> naething`
- `log_span_in(span_handle, fn) -> value` (native helper that ensures exit even on error)
- `log_span_current() -> span_handle | naething`

Span handles are opaque values (native object or int id). The runtime tracks a per-thread span stack.

#### C. Logger configuration (native functions)
- `log_get_level() -> level` (keeps existing API)
- `log_set_level(level) -> naething` (keeps existing API)
- `log_set_filter(filter_string) -> naething`
- `log_get_filter() -> string`
- `log_init(config = {}) -> naething`

`log_init` accepts a dict with keys:
- `level` (string or int)
- `filter` (string)
- `format` ("text" | "json" | "compact")
- `color` (aye/nae)
- `timestamps` (aye/nae)
- `sinks` (list of sink specs, see below)

#### D. Sink specification
Sink specs are dicts, example:
```
{"kind": "stderr"}
{"kind": "stdout"}
{"kind": "file", "path": "app.log", "append": aye}
{"kind": "memory", "max": 1000}
{"kind": "callback", "fn": my_handler}
```

The callback sink is only supported in interpreter (v1). LLVM/WASM/JS ignore it or return a clear error.

#### E. Syntax compatibility
Existing `log_whisper expr` statements remain valid. They compile to:
- `log_event(level, expr, {}, target)` with level inferred from keyword.
- The compiler can guard evaluation using `log_enabled(level, target)` to avoid expensive message formatting, but this is opt-in to preserve current behavior (see compatibility section).

### 2) Event and span data model

**LogRecord** (internal):
- `level`: LogLevel
- `message`: string
- `target`: string (module or logger name)
- `fields`: map<string, LogValue>
- `timestamp`: UTC or local with millis
- `thread_id`: numeric
- `file`: string
- `line`: int
- `span_path`: list of span names (outer -> inner)

**Span** (internal):
- `id`: u64
- `name`: string
- `level`: LogLevel
- `target`: string
- `fields`: map<string, LogValue>
- `start_ts`: timestamp
- `parent`: optional span id

LogValue types: string, int, float, bool, nil, list, dict (fallback to string if unsupported).

### 3) Filtering (RUST_LOG inspired)

Filter grammar (examples):
- `info` (global level)
- `warn,my.module=debug` (global warn, module debug)
- `mdhavers::net=trace,mdhavers::parser=info`

Rules:
- Most specific target match wins.
- If no filter matches, use global level (default Blether/INFO).
- `MDH_LOG` environment variable sets filter if present.
- `MDH_LOG_LEVEL` is a fallback if no filter is provided.

### 4) Default formatting

Text (default):
```
[LEVEL] 2025-12-20 15:04:05.123 [thread:0001] target file:line | message key=value span=outer>inner
```

JSON (line-delimited):
```
{"ts":"...","level":"INFO","target":"app","file":"...","line":12,"msg":"...","fields":{...},"span":["outer","inner"]}
```

Compact: short prefix + message + fields.

### 5) Backend implementations

#### A. Interpreter (Rust)
- Add `src/logging.rs` with:
  - `LoggerCore` (filter + sinks + format + options).
  - `Sink` trait and built-in sinks (stderr, stdout, file, memory, callback).
  - `SpanRegistry` and per-thread span stack using thread_local.
- Move `log_message` logic in `src/interpreter.rs` to call `LoggerCore::log_event`.
- `log_span_in` implemented natively: enter span, call mdhavers function, exit span on success or error, then rethrow.
- Keep `set_log_level/get_log_level` mapped to `LoggerCore` filter.

#### B. LLVM/WASM C runtime
- Extend `runtime/mdh_runtime.c` and `runtime/mdh_runtime.h` with:
  - `__mdh_log_event(level, msg, fields, target, file, line)`
  - `__mdh_log_enabled(level, target)`
  - `__mdh_log_span_begin(name, level, fields, target) -> span_id`
  - `__mdh_log_span_enter(span_id)` / `__mdh_log_span_exit(span_id)`
  - `__mdh_log_set_filter(string)` / `__mdh_log_get_filter()`
- Implement a minimal core:
  - Simple filter parser (shared with Rust via generated table or small parser).
  - Span stack stored in thread-local (pthread TLS).
  - Default sink: stderr with text format.
  - JSON stringify uses existing `__mdh_json_stringify` for fields.
- File sink uses standard C file IO; errors are printed once to stderr and then disabled.

#### C. JS output/runtime
- Add `runtime/js/logging.js` with a LoggerCore mirror:
  - filter parser, span stack, sinks (console.error, console.log, file is not supported).
- Update `src/compiler.rs` to emit calls to runtime logger for log statements.

### 6) Interaction with existing stdlib/logging.braw
- Keep stdlib API stable.
- Update stdlib logger to delegate to native `log_event` when available:
  - `Logger.log` calls `log_event` with structured fields rather than `blether`.
  - `StructuredLogger` becomes a thin wrapper around native JSON formatting (or uses `log_event` with fields).
- If native logger is unavailable (older runtime), stdlib falls back to current behavior.

### 7) Compatibility and behavior
- Existing log_* statements continue to work and are routed to the new logger.
- For compatibility, `log_*` statements will still evaluate their message expression even if the level is disabled (current behavior). A new optional optimization can be added:
  - compiler/interpreter can guard evaluation using `log_enabled` for new functions, not for existing statements, to avoid breaking programs that rely on side effects in log expressions.
- `set_log_level/get_log_level` map to the new filter and remain as-is.
- `MDH_LOG_LEVEL` still works; `MDH_LOG` overrides it when present.

### 8) Error handling
- Invalid filter strings: ignore and fall back to default level, but emit a one-time warning to stderr.
- File sink open failure: emit a one-time warning and disable that sink.
- Callback sink errors: swallowed by default, optionally rethrown if `config.strict` is true.

### 9) Performance considerations
- `log_enabled` is fast and uses cached filter matches per target.
- Early-out when level is disabled; avoid formatting fields unless enabled.
- Minimal allocations in hot path by reusing buffers for formatting.

### 10) Testing plan
- Unit tests:
  - Filter parsing and matching.
  - Level mapping (string/int) and invalid inputs.
  - Span stack behavior and nesting.
  - Formatting output (text, JSON).
- Integration tests:
  - Interpreter logging with fields and spans.
  - LLVM-compiled logging output.
  - JS-compiled logging output.
  - stdlib logging module compatibility.

### 11) Rollout plan
Phase 1:
- Implement LoggerCore in interpreter and C runtime.
- Route log statements to LoggerCore.
- Add `log_event`, `log_enabled`, `log_set_filter`, spans.

Phase 2:
- Update stdlib/logging.braw to delegate to native logger.
- Add JS runtime logging and compiler updates.

Phase 3:
- Optional enhancements: sampling, rate limiting, custom format templates.

## Open questions
- Should log statements gain optional `fields` and `target` syntax (requires parser change)?
- Do we want a dedicated `fatal` level, or should it remain a stdlib-only concept?
- Should `log_span_in` be part of the native API or a stdlib helper built on enter/exit?
- Do we want to expose span IDs as integers or opaque native objects?
- How strict should `callback` sink support be across compiled targets?
