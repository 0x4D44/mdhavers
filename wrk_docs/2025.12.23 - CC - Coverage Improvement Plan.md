# mdhavers — Coverage Improvement Plan (to 98% lines)

**Date:** 2025-12-23  
**Baseline (lines):** 54,408 / 56,374 = **96.51%** (missed: 1,966)  
**Target:** ≥ **98% line coverage** under the canonical `cargo-llvm-cov` feature set  
**Additional lines to cover:** **839** (to reach 55,247 / 56,374)  

## Success criteria (explicit + reproducible)

We consider the goal met when this command reports **total line coverage ≥ 98%**:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  --summary-only --json --output-path target/llvm-cov-summary.json
```

Notes:

- This is intentionally a **feature-pinned** metric; changing features changes the compiled surface area.
- We keep improvements primarily in `tests/` (integration tests) to avoid inflating the `src/` denominator with additional `#[cfg(test)]` code.

## Strategy (high ROI first)

The baseline shows that three files dominate missed lines:

1) `src/interpreter.rs` (845 missed)  
2) `src/llvm/codegen.rs` (658 missed)  
3) `src/error.rs` (90 missed)  

Because we need +839 covered lines, **`src/interpreter.rs` alone can carry the full delta** if we can either:

- execute the missing code paths (preferred), and/or
- remove “uncoverable-by-design” lines inside `#[cfg(test)]` code embedded in `src/interpreter.rs` (e.g., failure-only `panic!` branches).

## Stage 1 — Deterministic quick wins (expected: +150 to +250 lines)

Goal: cover cheap, stable, low-flake missing branches.

### 1.1 Cover `HaversError::with_line_if_zero` (`src/error.rs`)

Add a table-driven integration test that constructs each error variant with `line: 0`, calls `with_line_if_zero(123)`, and asserts the returned variant now reports `line() == Some(123)` (or equivalently, `format!()` contains the line).

Expected gain: ~80–90 lines.

### 1.2 Expand CLI integration tests for per-subcommand parse/runtime errors (`src/main.rs`)

Extend `tests/cli_coverage.rs` to cover:

- parse error branches for `run`, `compile`, `wasm`, `trace`, and `build` using an intentionally invalid `.braw` file
- “bad prelude” branch: create a temp `stdlib/prelude.braw` with invalid syntax, then run a subcommand that calls `load_prelude` and asserts it errors
- `build` native error branch under `feature=llvm` by passing an output path that is a directory (forces `compile_to_native_with_source` error)

Expected gain: ~10–30 lines (REPL-related code remains best-effort).

### 1.3 Add WAT compilation coverage for less-common AST constructs (`src/wasm_compiler.rs`)

Add a compilation test that includes these constructs in one snippet:

- function params with defaults
- `try/catch`
- `match` with several arms
- `assert` with and without message
- destructuring
- `log` with extras
- index set / slice paths

Expected gain: ~40–70 lines.

## Stage 2 — Interpreter heavy lift (expected: +500 to +900 lines)

Goal: move `src/interpreter.rs` from 93.55% to ~99%+.

### 2.1 Convert “failure-only” branches inside `src/interpreter.rs` tests into coverage-neutral assertions

Where tests currently use patterns like:

- `let Value::List(list) = result else { panic!(...) };`
- `match value { ... _ => panic!(...) }`

Refactor to avoid uncovered “else” lines while preserving test quality. A reliable pattern:

```rust
assert!(matches!(&result, Value::List(_)), "...");
if let Value::List(list) = result {
    // assertions
}
```

This keeps failures as failures, but prevents “unreachable in passing tests” lines from counting as uncovered in `src/interpreter.rs`.

Expected gain: highly variable; can be a large fraction of the 845 missed lines if many misses are inside embedded tests.

### 2.2 Add targeted integration tests for cold interpreter branches

Use `mdhavers::{parse, Interpreter}` and short `.braw` snippets to trigger:

- native builtin validation branches (type mismatches, config dict errors)
- bytes helper offset/length error paths
- numeric edge cases (NaN handling, overflow/underflow)
- module resolution corner cases and “no-op” fast paths

Expected gain: fills remaining production-code misses after 2.1.

## Stage 3 — LLVM codegen mop-up (expected: +50 to +300 lines)

Goal: if Stage 1–2 aren’t enough to reach 98%, target the next biggest file (`src/llvm/codegen.rs`).

Approach:

- Add a small set of `tests/llvm_codegen_*_coverage.rs` tests that compile crafted snippets to IR.
- Focus on AST constructs not already covered by compiling stdlib/examples, plus deliberate error paths that return `Err(...)` rather than panic.

Expected gain: modest improvements can still net dozens/hundreds of lines due to file size.

## Stage 4 — Iterate + verify

After each stage:

1) Re-run the canonical coverage command (above).
2) Confirm the delta in:
   - total line coverage percent
   - top missed-line contributors
3) Continue until total lines ≥ 98%.

## Work tracking

Implementation will record progress by re-running `cargo llvm-cov` after each stage and using the JSON summary to confirm improvements.

