# mdhavers — Coverage Improvement Plan (to 98% lines)

**Date:** 2025-12-23  
**Status:** ✅ Achieved (98.07% total line coverage)  

## Success criteria (explicit + reproducible)

We consider the goal met when this command reports **total line coverage ≥ 98%**:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  --summary-only --json --output-path target/llvm-cov-summary.json
```

Notes:

- This is intentionally a **feature-pinned** metric; changing features changes the compiled surface area and therefore the score.
- Integration tests in `tests/` are not counted in the line denominator, but they do drive execution in `src/`.

## Baseline → final (this implementation)

Measured with the canonical command above:

- **Baseline:** 55,264 / 56,401 = **97.984%**
- **Final:** 55,309 / 56,395 = **98.074%**
- **Delta:** **+45** covered lines, **-6** total lines (net)

## Multi-stage plan (used to reach 98%)

### Stage 0 — Lock the measurement

1) Use the canonical command (above) as the only “scoreboard”.
2) Save the JSON output to `target/llvm-cov-summary.json` each run.
3) Use a missing-lines report when narrowing in on small gaps:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  report --show-missing-lines > target/llvm-cov-missing-lines.txt
```

### Stage 1 — Find the smallest reachable deltas

When the gap to 98% is single-digit lines, prioritize:

- hot code paths that are already near-covered (one new branch can cover multiple missed lines),
- stable tests (no reliance on TTY/REPL behavior),
- “compile-only” tests (compile to IR/object, not runtime execution) to avoid flakiness.

In this repo, `src/llvm/codegen.rs` is a high-leverage target because it is large but already ~99% line-covered.

### Stage 2 — Add targeted tests

Implementation focus: exercise cold LLVM codegen branches with minimal, deterministic snippets.

Changes applied:

- `tests/llvm_codegen_extra_constructs_coverage.rs`
  - Added string comparisons to enter the “string-typed but not concat” branch.
  - Added unary integer arithmetic to force `compile_binary_int_fast` to take its fallback path (no `compile_int_expr` optimization).
  - Added nested string concatenation involving a variable so the “dynamic right length” (`strlen`) branch is exercised (avoids constant folding).
- `tests/interpreter_gap_coverage.rs`
  - Added deterministic logging-native coverage (`log_enabled`, `log_event`, `log_set_filter`, `log_init`) including validation error paths and defaults.
  - Added interpreter error-path cases for channels/atomics and module resolution (including `lib/` modules).
- `tests/interpreter_dtls.rs`
  - Added deterministic DTLS validation/error-path tests without relying on external network success paths.
- `src/interpreter.rs`
  - Removed dead/unreachable branches in `apply_log_config()` and module-load current-dir handling, reducing the line denominator and improving execution coverage.

### Stage 3 — Verify and iterate

1) Re-run the canonical command.
2) Confirm:
   - `percent >= 98.0` in `target/llvm-cov-summary.json`
   - if the total lines (`count`) changes, it is due to intentional code changes (not feature drift)
3) If still short, repeat Stage 1–2 focusing on the next-easiest missed lines.

## If you want to push beyond 98% (optional)

The largest remaining missed-line contributors (as of this run) are:

1) `src/interpreter.rs` (~688 missed lines)  
2) `src/llvm/codegen.rs` (~210 missed lines)  
3) `src/compiler.rs` (~56 missed lines)  

Next logical stages:

- Add targeted interpreter integration tests for cold error/validation branches and uncommon builtins.
- Expand CLI tests for non-REPL paths (avoid TTY-dependent REPL branches).
- Add LLVM codegen snippets only when they cover multiple missed lines per test (to avoid test-suite bloat).
