# mdhavers — Coverage Improvement Plan (maintain ≥98% lines; improve depth)

**Date:** 2025-12-24  
**Status:** ✅ Line-coverage gate met with margin (98.51% total lines under canonical command)  

## Success criteria (explicit + reproducible)

Primary gate (this effort): **total line coverage ≥ 98%** as reported by:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  --summary-only --json --output-path target/llvm-cov-summary.json
```

Helpful triage view:

```bash
cargo llvm-cov --no-default-features --features cli,llvm,native \
  report --show-missing-lines > target/llvm-cov-missing-lines.txt
```

## Current scoreboard (2025-12-24)

From `target/llvm-cov-summary.json`:

- **Lines:** 55,930 / 56,747 = **98.56%**
- **Functions:** 2,723 / 2,840 = **95.88%**
- **Regions:** 98,573 / 103,488 = **95.25%**
- **Instantiations:** 4,336 / 5,320 = **81.50%**

## Principles (what “good coverage work” means here)

- Prefer **deterministic** tests (no timing races, no external network, no TTY assumptions).
- Prefer **compilation-only** LLVM tests when the goal is codegen coverage (fast + stable).
- For syntax/constructs the parser cannot produce, use **AST-constructed tests** sparingly (and label them clearly).
- Avoid test-suite bloat: prioritize changes that cover **many missed lines per test**.
- When a branch is “should never happen”, consider converting to an **invariant** (`debug_assert!` + unwrap) or consolidating multi-line error construction, rather than writing contorted tests.

## Multi-stage plan

### Stage 0 — Lock the measurement (do first, always)

1) Use the canonical command above as the only scoreboard.  
2) Keep the output artifacts in `target/` so regressions are easy to spot.  
3) When numbers change, confirm it’s due to **intentional code or test changes**, not feature drift.

### Stage 1 — Add margin above 98% (cheap wins)

Goal: keep a comfortable buffer above 98% so small future changes don’t dip below the gate.

High-leverage targets (current missed-line leaders):

- `src/interpreter.rs` (580 missed lines)
- `src/llvm/codegen.rs` (151 missed lines)
- `src/audio.rs` (35 missed lines)
- `src/main.rs` (5 missed lines)

Tactics:

- Add 1–3 focused tests that each cover **10–50** previously missed lines.
- Prefer improving `src/main.rs` and `src/llvm/codegen.rs` first (lower risk than deep protocol/IO paths).

### Stage 2 — Raise LLVM codegen coverage (stable, compile-only)

Goal: cover “cold” codegen branches without runtime execution.

Actions:

- Extend `tests/llvm_codegen_extra_constructs_coverage.rs` with:
  - additional valid snippets that touch rare lowering paths,
  - small, targeted error snippets for specific compile errors,
  - AST-based coverage for constructs the parser cannot express (only when needed).

Stop when ROI drops (i.e., each new test covers only ~1–2 lines).

### Stage 3 — Raise interpreter coverage (deterministic edges)

Goal: shrink the biggest missed-line contributor while keeping tests stable.

Actions:

- Add tests that exercise:
  - validation failures,
  - parsing/encoding edges,
  - “unsupported” branches that return predictable errors.
- Avoid relying on “successful network IO”; instead cover **error surfaces** (timeouts, invalid inputs, invalid certs) deterministically.

### Stage 4 — Improve function/region coverage (optional stretch)

Line coverage is already strong; improving function/region coverage typically requires:

- calling “leaf” helpers that are otherwise unused,
- testing more match/branch combinations,
- splitting out unreachable code paths.

If this becomes a priority, consider tracking an explicit target for functions/regions separately (e.g., ≥97%).

### Stage 5 — Prevent regressions

- Add a CI/local “coverage gate” script (or Make target) that runs the canonical command and fails if lines < 98%.
- Keep a short “coverage playbook” in `docs/` or `wrk_docs/` with the canonical command and known gotchas.

## Implementation note (this repo)

The repo already includes multiple integration tests that spawn the `mdhavers` and `mdhavers-lsp` binaries in a way that works under `cargo llvm-cov` (using the instrumented binaries under `target/llvm-cov-target` when `LLVM_PROFILE_FILE` is set). Reusing that pattern is recommended for any new CLI coverage gaps.
