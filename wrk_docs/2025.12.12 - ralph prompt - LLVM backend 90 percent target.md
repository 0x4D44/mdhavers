# LLVM Backend 90% Build Success Target

## Current State
- **Build success:** 28/106 (26.4%)
- **Target:** 90%+ (96+ successful builds)
- **Gap:** ~68 more builds needed

## Error Analysis (by frequency)

### Missing Builtins (HIGH IMPACT)
These builtins are called but not implemented in the LLVM backend:

| Builtin | Count | Priority | Implementation Notes |
|---------|-------|----------|---------------------|
| `dram` | 8 | HIGH | Dictionary/map type - complex |
| `ord` | 3 | HIGH | Get ASCII value of char - simple |
| `replace` | 3 | HIGH | String replace - use strstr+string ops |
| `repeat` | 2 | MEDIUM | Repeat string N times - loop + concat |
| `index_of` | 2 | MEDIUM | Find substring index - use strstr |
| `dict_has` | 2 | MEDIUM | Check if dict has key |
| `creel` | 2 | LOW | Alias for list/array - may be stdlib |
| `chars` | 2 | HIGH | Split string into char list |
| `char_at` | 2 | HIGH | Get character at index |
| `PI` | 2 | HIGH | Math constant - trivial |
| `get_log_level` | 2 | LOW | Logging - stdlib function |

### TryCatch Statements (6 files)
**Error:** `Statement not yet supported in LLVM backend: TryCatch`

Implementation approach using setjmp/longjmp:
1. Declare `setjmp` and `longjmp` from libc
2. Create a global jmp_buf stack for nested try/catch
3. On `try`: push jmp_buf, call setjmp, if 0 execute try block
4. On error (or explicit throw): longjmp back
5. On `catch`: pop jmp_buf, bind error variable, execute catch block

### Slice Expressions (1 file)
**Error:** `Expression not yet supported in LLVM backend: Slice`

```rust
Expr::Slice { object, start, end, step, span }
```

Implementation:
1. Compile object (must be list or string)
2. Handle optional start/end/step (default: 0, len, 1)
3. For lists: create new list with elements in range
4. For strings: create substring

### Default Parameter Values (causes verification errors)
**Error:** `Incorrect number of arguments passed to called function`

Functions with default parameters are declared with full param count but called with fewer args.

Fix options:
1. **Wrapper approach**: Generate wrapper functions that fill in defaults
2. **Call-site fix**: Detect default params and fill in at call site
3. **Varargs**: Use variadic functions (complex)

Recommended: Call-site fix - when calling a function with fewer args than declared, check for defaults and compile them.

### Other Undefined Variables
Many are stdlib functions that need imports to work:
- `wee`, `y` - likely typos or missing local context
- `__current_suite`, `_test_suites` - testing framework
- `snooze`, `scrieve`, `stacktrace` - runtime utilities

## Implementation Order (by impact)

### Phase 1: Quick Wins (Est. +15 builds)
1. **PI constant** - Add to builtins, return 3.14159265358979
2. **ord(char)** - Return ASCII value: `char.bytes()[0]`
3. **char_at(str, idx)** - Return character at index
4. **chars(str)** - Split string into list of single chars
5. **repeat(str, n)** - Repeat string n times
6. **index_of(str, substr)** - Find substring, return index or -1

### Phase 2: String Operations (Est. +10 builds)
1. **replace(str, old, new)** - Replace all occurrences
2. **starts_wi(str, prefix)** - Check string prefix
3. **ends_wi(str, suffix)** - Check string suffix

### Phase 3: Default Parameters (Est. +15 builds)
1. Track default values in function declarations
2. At call sites, if args < params, fill in defaults
3. Store defaults in a new field: `function_defaults: HashMap<String, Vec<Option<Expr>>>`

### Phase 4: Slice Expression (Est. +5 builds)
1. Add case in `compile_expr` for `Expr::Slice`
2. Handle list slicing (create new list)
3. Handle string slicing (create substring)

### Phase 5: TryCatch (Est. +10 builds)
1. Add libc declarations for setjmp/longjmp
2. Create global error state (jmp_buf stack, error value)
3. Implement `compile_try_catch`:
   - Push jmp_buf
   - setjmp - if 0, try block; else catch block
   - Pop jmp_buf after either path

### Phase 6: Dictionary Support (Est. +10 builds)
1. **dram(pairs)** - Create dictionary from key-value pairs
2. **dict_has(dict, key)** - Check if key exists
3. Dictionary indexing and assignment

## Key Files
- `src/llvm/codegen.rs` - Main implementation file
  - `compile_expr` - Add Slice case
  - `compile_stmt` - Add TryCatch case
  - `compile_call` - Add new builtins
  - Add `function_defaults` tracking

## Testing Strategy
After each phase:
1. Run `cargo build --release`
2. Run `./examples/build_all.sh`
3. Track progress toward 90% target
4. Fix any regressions

## Implementation Details

### ord(char) Implementation
```rust
"ord" => {
    if args.len() != 1 {
        return Err(HaversError::CompileError("ord expects 1 argument".to_string()));
    }
    let arg = self.compile_expr(&args[0])?;
    let data = self.extract_data(arg)?;
    let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());
    let str_ptr = self.builder.build_int_to_ptr(data, i8_ptr, "str_ptr").unwrap();
    let first_byte = self.builder.build_load(self.context.i8_type(), str_ptr, "first_byte").unwrap();
    let byte_val = self.builder.build_int_z_extend(first_byte.into_int_value(), self.types.i64_type, "byte_i64").unwrap();
    return self.make_int(byte_val);
}
```

### char_at(str, idx) Implementation
```rust
"char_at" => {
    if args.len() != 2 {
        return Err(HaversError::CompileError("char_at expects 2 arguments".to_string()));
    }
    let str_arg = self.compile_expr(&args[0])?;
    let idx_arg = self.compile_expr(&args[1])?;
    let str_data = self.extract_data(str_arg)?;
    let idx_data = self.extract_data(idx_arg)?;

    let i8_ptr = self.context.i8_type().ptr_type(AddressSpace::default());
    let str_ptr = self.builder.build_int_to_ptr(str_data, i8_ptr, "str_ptr").unwrap();
    let char_ptr = unsafe {
        self.builder.build_gep(self.context.i8_type(), str_ptr, &[idx_data], "char_ptr").unwrap()
    };

    // Allocate 2 bytes for single char + null terminator
    let two = self.types.i64_type.const_int(2, false);
    let new_str = self.builder.build_call(self.libc.malloc, &[two.into()], "char_str").unwrap()
        .try_as_basic_value().left().unwrap().into_pointer_value();

    let char_val = self.builder.build_load(self.context.i8_type(), char_ptr, "char_val").unwrap();
    self.builder.build_store(new_str, char_val).unwrap();

    let null_ptr = unsafe {
        self.builder.build_gep(self.context.i8_type(), new_str, &[self.types.i64_type.const_int(1, false)], "null_ptr").unwrap()
    };
    self.builder.build_store(null_ptr, self.context.i8_type().const_int(0, false)).unwrap();

    let str_int = self.builder.build_ptr_to_int(new_str, self.types.i64_type, "str_int").unwrap();
    return self.make_string(str_int);
}
```

### PI Constant
```rust
"PI" => {
    // PI as a float constant
    let pi_bits = 3.14159265358979f64.to_bits();
    let pi_val = self.types.i64_type.const_int(pi_bits, false);
    return self.make_float(pi_val);
}
```

### Default Parameters Approach
In `declare_function`, store default values:
```rust
// In CodeGen struct:
function_defaults: HashMap<String, Vec<Option<Expr>>>,

// When parsing function with defaults:
// params: [(name, Option<default_expr>), ...]
// Store the defaults for later use at call sites
```

At call site in `compile_call`:
```rust
// If calling with fewer args than declared params
if args.len() < expected_param_count {
    if let Some(defaults) = self.function_defaults.get(name) {
        // Fill in missing args from defaults
        for i in args.len()..expected_param_count {
            if let Some(Some(default_expr)) = defaults.get(i) {
                compiled_args.push(self.compile_expr(default_expr)?);
            }
        }
    }
}
```

## Success Criteria
- `./examples/build_all.sh` shows 96+ successful builds (90%+)
- No LLVM verification errors
- All showcase demos continue to work
