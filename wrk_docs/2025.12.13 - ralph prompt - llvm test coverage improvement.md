# Ralph Wiggum Prompt: LLVM Backend Test Coverage Improvement

## Objective

Significantly improve test coverage for the LLVM backend (`src/llvm/`) by adding comprehensive tests for undertested and untested functionality. The goal is to achieve thorough coverage of all code paths, edge cases, and error conditions.

## Current State

- **Location**: `src/llvm/` (codegen.rs, compiler.rs, types.rs, builtins.rs, runtime.rs)
- **Current Tests**: ~136 tests across `tests/llvm_comprehensive_tests.rs` and `tests/llvm_standalone_tests.rs`
- **Coverage Gaps**: Many advanced features, edge cases, and error paths are untested

## Test File Location

Add new tests to: `tests/llvm_comprehensive_tests.rs`

Follow the existing pattern in that file - tests are organized into modules by category.

## Testing Pattern

All tests follow this pattern:
```rust
#[test]
fn test_name() {
    let source = r#"
        // braw source code here
    "#;
    let result = compile_and_run(source);
    assert!(result.success, "Test failed: {}", result.stderr);
    assert_eq!(result.stdout.trim(), "expected output");
}
```

## Priority Areas to Test

### 1. Exception/Error Handling (HIGH PRIORITY - 0 current tests)

Test `compile_try_catch()` functionality:

```braw
# Basic try-catch
try
    error("Something went wrong")
catch e
    blether(e)
end

# Try-catch with successful execution (no error)
try
    blether("No error here")
catch e
    blether("This should not print")
end

# Nested try-catch
try
    try
        error("Inner error")
    catch e
        blether("Caught inner: " + e)
        error("Outer error")
    end
catch e
    blether("Caught outer: " + e)
end

# Try-catch in function
fn risky()
    try
        error("Function error")
    catch e
        return "Handled: " + e
    end
end
blether(risky())

# Error propagation (uncaught)
fn throws()
    error("Uncaught")
end
try
    throws()
catch e
    blether("Caught from function: " + e)
end
```

### 2. Assertions (HIGH PRIORITY - 0 current tests)

Test `compile_assert()`:

```braw
# Basic assertion (passing)
assert(true)
blether("Passed")

# Assertion with message (passing)
assert(1 == 1, "Math still works")
blether("Math works")

# Assertion with expression
x = 5
assert(x > 0, "x should be positive")
blether("x is positive")

# Failing assertion (capture error)
try
    assert(false, "This should fail")
catch e
    blether("Caught: " + e)
end
```

### 3. Import System (HIGH PRIORITY - 0 current tests)

Test `compile_import()`:

```braw
# Basic import (test with stdlib modules)
import "math"
blether(floor(3.7))

# Import with alias or specific functions if supported
# Test import path resolution
# Test cross-module function calls
```

### 4. Advanced Dictionary Operations (MEDIUM PRIORITY)

Test `inline_dram()`, `inline_birl()`, `inline_ceilidh()`:

```braw
# dram (dict_map) - map over dictionary values
d = {"a": 1, "b": 2, "c": 3}
result = dram(d, fn(k, v) v * 2 end)
blether(result["a"])  # Should be 2

# birl (dict_filter) - filter dictionary
d = {"a": 1, "b": 2, "c": 3}
result = birl(d, fn(k, v) v > 1 end)
blether(len(keys(result)))  # Should be 2

# ceilidh (dict_merge) - merge dictionaries
d1 = {"a": 1, "b": 2}
d2 = {"c": 3, "d": 4}
result = ceilidh(d1, d2)
blether(len(keys(result)))  # Should be 4

# Nested dictionary operations
nested = {"outer": {"inner": 42}}
blether(nested["outer"]["inner"])

# Dictionary with complex values (lists, other dicts)
complex = {"list": [1, 2, 3], "dict": {"x": 1}}
blether(complex["list"][0])
blether(complex["dict"]["x"])
```

### 5. Closure/Lambda Capture (MEDIUM PRIORITY)

Test free variable capture in closures:

```braw
# Basic closure capture
fn make_counter()
    count = 0
    return fn()
        count = count + 1
        return count
    end
end
counter = make_counter()
blether(counter())  # 1
blether(counter())  # 2

# Multiple captured variables
fn make_adder(x)
    y = 10
    return fn(z) x + y + z end
end
add = make_adder(5)
blether(add(3))  # 18

# Nested closure captures
fn outer(a)
    fn middle(b)
        fn inner(c)
            return a + b + c
        end
        return inner
    end
    return middle
end
f = outer(1)(2)
blether(f(3))  # 6

# Closure in loop
fns = []
for i in range(3)
    shove(fns, fn() i end)
end
# Test closure semantics (by value or by reference?)

# Lambda with capture in higher-order function
base = 10
nums = [1, 2, 3]
result = ilk(nums, fn(x) x + base end)
blether(result[0])  # 11
```

### 6. Pattern Matching Advanced Cases (MEDIUM PRIORITY)

Test `compile_match()` and `compile_pattern_test()`:

```braw
# Match with multiple literal patterns
x = 2
match x
    1 => blether("one")
    2 => blether("two")
    3 => blether("three")
    _ => blether("other")
end

# Match with string patterns
s = "hello"
match s
    "hi" => blether("greeting hi")
    "hello" => blether("greeting hello")
    _ => blether("unknown")
end

# Match with list patterns (if supported)
lst = [1, 2, 3]
match lst
    [] => blether("empty")
    [x] => blether("single: " + tae_string(x))
    [x, y] => blether("pair")
    _ => blether("many")
end

# Nested match
x = [1, "hello"]
match x[0]
    1 => match x[1]
            "hi" => blether("1 and hi")
            "hello" => blether("1 and hello")
            _ => blether("1 and other")
         end
    _ => blether("not 1")
end
```

### 7. Destructuring (MEDIUM PRIORITY)

Test `compile_destructure()`:

```braw
# List destructuring
[a, b, c] = [1, 2, 3]
blether(a)
blether(b)
blether(c)

# Destructuring with rest (if supported)
[first, ...rest] = [1, 2, 3, 4]
blether(first)
blether(len(rest))

# Nested destructuring
[[a, b], [c, d]] = [[1, 2], [3, 4]]
blether(a + d)  # 5

# Destructuring in for loop
pairs = [[1, "a"], [2, "b"], [3, "c"]]
for [num, letter] in pairs
    blether(tae_string(num) + ": " + letter)
end

# Dict destructuring (if supported)
{x, y} = {"x": 10, "y": 20}
blether(x + y)
```

### 8. Advanced String Operations (MEDIUM PRIORITY)

```braw
# coont (count occurrences)
s = "banana"
blether(coont(s, "a"))  # 3

# pad (padding)
s = "hi"
blether(pad(s, 5, " "))  # "hi   " or "   hi"

# Advanced slice operations
s = "hello world"
blether(slice(s, 0, 5))   # "hello"
blether(slice(s, -5, -1)) # "worl"
blether(slice(s, 6))      # "world"

# wheesht (strip/trim)
s = "  hello  "
blether(wheesht(s))  # "hello"

# repeat
blether(repeat("ab", 3))  # "ababab"

# index_of with start position
s = "hello hello"
blether(index_of(s, "hello", 1))  # 6
```

### 9. Advanced List Operations (MEDIUM PRIORITY)

```braw
# scran (take n elements)
lst = [1, 2, 3, 4, 5]
blether(scran(lst, 3))  # [1, 2, 3]

# slap (concat lists)
lst1 = [1, 2]
lst2 = [3, 4]
blether(slap(lst1, lst2))  # [1, 2, 3, 4]

# shuffle (randomness test - just check length preserved)
lst = [1, 2, 3, 4, 5]
shuffled = shuffle(lst)
blether(len(shuffled))  # 5

# Advanced slice
lst = [1, 2, 3, 4, 5]
blether(slice(lst, 1, 3))  # [2, 3]
blether(slice(lst, -2))    # [4, 5]

# List spread operator
lst1 = [1, 2]
lst2 = [0, ...lst1, 3]
blether(len(lst2))  # 4
```

### 10. Advanced Math Functions (LOW PRIORITY)

```braw
# atan2
blether(atan2(1, 1))  # ~0.785 (pi/4)

# Trigonometric (if available)
# blether(sin(0))
# blether(cos(0))
# blether(tan(0))

# radians/degrees conversion
blether(radians(180))  # ~3.14159
blether(degrees(3.14159))  # ~180
```

### 11. Edge Cases and Error Conditions (HIGH PRIORITY)

```braw
# Division by zero
try
    x = 1 / 0
catch e
    blether("Caught division by zero")
end

# Empty list operations
lst = []
blether(len(lst))  # 0
# try: heid(lst) should error or return nil

# Negative index boundary
lst = [1, 2, 3]
blether(lst[-1])  # 3
blether(lst[-3])  # 1
# lst[-4] should error or wrap

# String index out of bounds
s = "hi"
try
    x = s[10]
catch e
    blether("Index out of bounds")
end

# Type coercion edge cases
blether(tae_int("42"))      # 42
blether(tae_int("3.14"))    # 3 or error?
blether(tae_float("3.14"))  # 3.14
blether(tae_string(nil))    # "nil" or ""?

# Empty string operations
s = ""
blether(len(s))       # 0
blether(upper(s))     # ""
blether(split(s, ",")) # [""]?

# Very large numbers (if applicable)
big = 9999999999999
blether(big + 1)

# Boolean edge cases
blether(nae true)   # false
blether(nae false)  # true
blether(nae nil)    # true (nil is falsy)
blether(nae 0)      # depends on truthiness rules
```

### 12. Complex Integration Tests (MEDIUM PRIORITY)

```braw
# Class with try-catch in methods
class SafeCalculator
    fn init()
        self.result = 0
    end

    fn divide(a, b)
        try
            self.result = a / b
            return self.result
        catch e
            return "Error: " + e
        end
    end
end

calc = SafeCalculator()
blether(calc.divide(10, 2))  # 5
blether(calc.divide(10, 0))  # "Error: ..."

# Functional programming with closures
fn compose(f, g)
    return fn(x) f(g(x)) end
end

double = fn(x) x * 2 end
add_one = fn(x) x + 1 end
double_then_add = compose(add_one, double)
blether(double_then_add(5))  # 11

# Complex pipeline
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = data
    |> sieve(fn(x) x % 2 == 0 end)
    |> ilk(fn(x) x * x end)
    |> tumble(fn(acc, x) acc + x end, 0)
blether(result)  # 220 (4+16+36+64+100)

# Nested data structure manipulation
users = [
    {"name": "Alice", "scores": [85, 90, 92]},
    {"name": "Bob", "scores": [70, 75, 80]}
]
for user in users
    avg = sumaw(user["scores"]) / len(user["scores"])
    blether(user["name"] + ": " + tae_string(avg))
end
```

### 13. Optimization Path Tests (LOW PRIORITY)

These test that optimized paths produce correct results:

```braw
# Integer fast path
x = 5
y = 3
blether(x + y)  # Should use inline_add with int fast path

# Boolean list optimization
bools = [true, false, true]
shove(bools, false)  # Should use inline_shove_bool_fast

# String concat optimization
s = "hello"
s = s + " world"  # Should use compile_string_self_append
blether(s)

# Many string concats (tests efficient path)
s = ""
for i in range(100)
    s = s + "x"
end
blether(len(s))  # 100
```

## Test Organization

Add tests in the following module structure within `tests/llvm_comprehensive_tests.rs`:

```rust
mod try_catch_tests { ... }
mod assertion_tests { ... }
mod import_tests { ... }
mod dict_advanced_tests { ... }
mod closure_capture_tests { ... }
mod pattern_match_advanced_tests { ... }
mod destructuring_tests { ... }
mod string_advanced_tests { ... }
mod list_advanced_tests { ... }
mod math_advanced_tests { ... }
mod edge_case_tests { ... }
mod integration_advanced_tests { ... }
```

## Success Criteria

1. All new tests pass when run with `cargo test llvm`
2. Each undertested area has at least 3-5 tests covering:
   - Basic/happy path functionality
   - Edge cases
   - Error conditions (where applicable)
3. Tests are well-documented with comments explaining what they test
4. No regressions in existing tests

## Completion Promise

When the test file compiles and all tests (old and new) pass with `cargo test llvm_comprehensive`, the task is complete. Report the number of new tests added and which categories they cover.

## Notes

- The language uses Scottish dialect for some builtins (blether=print, speir=input, nae=not, etc.)
- Check existing tests in `tests/llvm_comprehensive_tests.rs` for syntax examples
- Some features may not be implemented - if a test fails because a feature doesn't exist, note it and move on
- Focus on testing what IS implemented, not on features that may not exist yet
