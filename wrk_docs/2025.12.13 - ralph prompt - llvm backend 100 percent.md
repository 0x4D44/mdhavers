# LLVM Backend Completion: 100% Build Success

## Current Status
- **Current**: 133/136 (97.8%)
- **Target**: 136/136 (100%) or 135/136 (99.3% - excluding intentional test)

## Remaining Failures

### 1. Spread in Function Calls (2 files)
**Files**: `examples/basics/spread.braw`, `examples/stdlib/collections_demo.braw`

**Error**: `Spread operator can only be used inside list literals`

**The Problem**: Code like `add_three(...nums)` uses spread to unpack a list into function arguments. Currently, spread is only handled in list literals.

**Implementation Strategy**:

In `compile_call` (around line 8800-9000 in codegen.rs), when processing arguments:

1. **Detect spread in arguments**: Check if any argument is `Expr::Spread`
2. **Handle mixed args**: Some args may be normal, some spread
3. **Runtime unpacking**: For spread args, extract list elements at runtime

**Pseudo-implementation**:
```rust
// In compile_call, when building args:
let mut has_spread = false;
for arg in arguments {
    if matches!(arg, Expr::Spread { .. }) {
        has_spread = true;
        break;
    }
}

if has_spread {
    // Build a dynamic args list at runtime
    // 1. Create a temporary list to hold all args
    // 2. For each argument:
    //    - If normal: append to list
    //    - If spread: iterate the spread expr and append each element
    // 3. Call function with unpacked args (need variadic support or fixed arity check)

    // For fixed-arity functions, we can:
    // - Build the combined list
    // - Extract elements by index
    // - Pass as regular args
}
```

**Simpler approach for fixed-arity functions**:
```rust
// Example: add_three(...nums) where nums = [10, 20, 30]
// 1. Compile nums to get list value
// 2. Extract nums[0], nums[1], nums[2] using runtime list access
// 3. Pass extracted values as args

// This requires knowing the function's arity at compile time
// and that spread expands to exactly the right number of args
```

**Key code locations**:
- `compile_call`: ~line 8800-9000
- `compile_builtin_call`: ~line 9100+
- List element access: `runtime_list_get` or similar

### 2. try_catch.braw (1 file - by design)
**File**: `examples/features/try_catch.braw`

**Error**: Uses intentionally undefined variable to test error handling

**Decision**: This file tests runtime error behavior. Options:
1. Skip it (accept 135/136 = 99.3%)
2. Implement try/catch with proper error handling
3. Modify the test to not require undefined variable detection

**If implementing try/catch**:
- Need to wrap code in exception-safe blocks
- Catch runtime errors and branch to catch block
- This is complex and may require setjmp/longjmp or similar

**Recommendation**: Accept 135/136 as "complete" since this is a test of error handling, not a language feature bug.

## Implementation Steps

### Phase 1: Analyze spread usage patterns
```bash
grep -n "\.\.\.nums\|\.\.\.rest\|\.\.\.names" examples/basics/spread.braw
grep -n "Spread" examples/stdlib/collections_demo.braw
```

### Phase 2: Modify compile_call for spread args

1. Find `compile_call` in codegen.rs
2. Before compiling args, check for spread expressions
3. If spread found:
   - Compile the spread expression to get a list
   - Get list length at runtime
   - Extract each element
   - Build final args array

### Phase 3: Handle edge cases
- Spread at beginning: `func(...list, x)`
- Spread at end: `func(x, ...list)`
- Spread in middle: `func(x, ...list, y)`
- Multiple spreads: `func(...a, ...b)`

### Phase 4: Test
```bash
./target/release/mdhavers build examples/basics/spread.braw
./target/release/mdhavers run examples/basics/spread.braw

./target/release/mdhavers build examples/stdlib/collections_demo.braw
./target/release/mdhavers run examples/stdlib/collections_demo.braw
```

## Test Command
```bash
find examples -name "*.braw" -exec sh -c './target/release/mdhavers build "$1" >/dev/null 2>&1 && echo "P"' _ {} \; 2>/dev/null | grep -c "P"
```

Target: 135 or 136 passing.

## Code Reference

The spread expression is defined in ast.rs:
```rust
Expr::Spread {
    expr: Box<Expr>,
    span: Span,
}
```

Current spread handling in compile_list (works):
```rust
// In compile_list, spread elements are unpacked into the list
Expr::Spread { expr, .. } => {
    let spread_val = self.compile_expr(expr)?;
    // Iterate spread_val and add each element to list
}
```

Need similar logic in compile_call for function arguments.

## Success Criteria
- `examples/basics/spread.braw` builds and runs correctly
- `examples/stdlib/collections_demo.braw` builds and runs correctly
- Total passing: 135/136 (99.3%) or 136/136 (100%)
