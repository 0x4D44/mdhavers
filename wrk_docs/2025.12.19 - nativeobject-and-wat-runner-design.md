# mdhavers NativeObject + WAT Host Runner Design

Date: 2025-12-19
Author: Codex (design draft)

## 1. Purpose
Define the runtime design for:
- **NativeObject**: interpreter-level object hooks for property get/set/call (three.js semantics).
- **WAT host runner**: native runner that executes WAT/WASM with full 3D support via wgpu, meeting the “single complete binary” requirement.

This design aligns with the tri 3D spec and supports all targets.

## 2. NativeObject design (interpreter)

### 2.1 Core trait
Add a native object trait that supports property access and method calls.

```rust
pub trait NativeObject {
    fn type_name(&self) -> &str;
    fn get(&self, prop: &str) -> HaversResult<Value>;
    fn set(&self, prop: &str, value: Value) -> HaversResult<Value>;
    fn call(&self, method: &str, args: Vec<Value>) -> HaversResult<Value>;
    fn to_string(&self) -> String { format!("<native {}>", self.type_name()) }
}
```

- `get` and `set` use `&self` with interior mutability (typical `RefCell` / `Mutex`).
- `call` is used for `obj.method(...)` when `obj` is NativeObject.

### 2.2 Value integration
Extend `Value` with a new variant:

```rust
pub enum Value {
    ...
    NativeObject(Rc<dyn NativeObject>),
}
```

Supporting changes:
- `Value::type_name()` returns something like `native:<type>` or uses `type_name()`.
- `Display` prints `<native TypeName>`.
- `ValueKey` for dict keys should support NativeObject (use pointer identity).

### 2.3 Interpreter changes
Property access and method call changes to route through NativeObject.

**Get**
```
Expr::Get { object, property, .. }
```
- Evaluate object.
- If `Value::NativeObject(o)` -> `o.get(property)`.
- Else follow existing instance/dict logic.

**Set**
```
Expr::Set { object, property, value, .. }
```
- Evaluate object and value.
- If `Value::NativeObject(o)` -> `o.set(property, value)`.
- Else follow existing instance/dict logic.

**Call**
For `obj.method(args)` when callee is a `Get`:
- If `obj` is NativeObject -> `o.call(method, args)`.
- Else keep current method binding behavior.

### 2.4 Tri object model (interpreter)
NativeObject implementations wrap wgpu engine handles.

Example internal types:
- `TriScene`, `TriMesh`, `TriCamera`, `TriRenderer` (native objects)
- `Vec3Proxy`, `EulerProxy`, `QuatProxy` for `position`, `rotation`, `quaternion`

`mesch.position` returns `Vec3Proxy` tied to the mesh handle. Setting `x/y/z` updates the underlying transform.

### 2.5 Error behavior
Errors should mirror mdhavers conventions:
- Unknown property => `UndefinedVariable` (or `TypeError` if appropriate).
- Invalid property type => `TypeError`.
- Invalid method name => `UndefinedVariable`.

## 3. NativeObject in LLVM runtime
To keep parity, introduce a new runtime tag for native objects in the LLVM runtime:
- Add `MDH_TAG_NATIVE = 14` (or next available).

Runtime API:
- `__mdh_native_type(val) -> MdhValue` (string)
- `__mdh_native_get(obj, key) -> MdhValue`
- `__mdh_native_set(obj, key, value) -> MdhValue`
- `__mdh_native_call(obj, method, argc, argv_ptr) -> MdhValue`

LLVM codegen updates:
- `compile_get`/`compile_set` should detect native tag and call runtime native accessors.
- `compile_method_call` should route to `__mdh_native_call` for native objects.

## 4. WAT target design

### 4.1 Constraint recap
- WAT/WASM cannot be standalone; it always requires a host runtime.
- Requirement: **single complete binary** -> ship a **native host runner** that embeds the WASM module and provides all imports.

### 4.2 Strategy
- Provide a new binary/subcommand (e.g., `mdhavers wasm-run`) built into the standard release.
- The host runner embeds a WASM runtime (recommend `wasmtime`) and the same wgpu engine used by interpreter/LLVM.
- The host implements all required runtime imports, including tri operations.

### 4.3 Value representation for WAT
The current WAT compiler uses raw i64 math and does not support objects.
To support tri, we need a **boxed value model** that can represent dicts, objects, and native handles.

**Pragmatic plan (phase 1):**
- Make every mdhavers value a host-managed handle.
- WASM code passes opaque `i64` handles for all values.
- All operations (add, compare, dict access, etc.) are host imports.

This is slower but drastically simpler and makes tri feasible.

**Optional future optimization (phase 2):**
- Tagged value model with inline ints/floats in wasm + host calls for heap objects.

### 4.4 Host runtime (WASM runner)
The host runner needs:
- **Value store:** arena for strings, lists, dicts, closures, native objects.
- **GC policy:** reference counting or manual retain/release; simple refcount is sufficient for phase 1.
- **Runtime imports:**
  - Creation: `__mdh_make_int`, `__mdh_make_float`, `__mdh_make_string`, `__mdh_make_dict`, etc.
  - Arithmetic: `__mdh_add`, `__mdh_sub`, ... (all as host calls).
  - Dict/List ops: `__mdh_dict_set`, `__mdh_dict_get`.
  - Control: `__mdh_truthy`, `__mdh_eq`, etc.
  - Printing: `__mdh_blether`.
  - **Native object ops:** `__mdh_native_get`, `__mdh_native_set`, `__mdh_native_call`.

### 4.5 tri module exposure in WAT
Given module strategy A:
- `fetch "tri"` compiles to a runtime call that returns a dict of constructors and helpers.
- The WAT compiler can emit:
  - `__mdh_tri_module()` -> MdhValue (dict)

The host implements `__mdh_tri_module` by constructing the module dict with native constructors bound to host functions.

### 4.6 WAT compiler changes (minimum viable)
- Add dict support (as host handles).
- Add property access and assignment semantics.
- Add call semantics for native objects.
- Add `fetch "tri"` special-case to return `__mdh_tri_module()`.

These are the minimum features required for tri usage.

## 5. tri NativeObject ABI (host + runtime)

### 5.1 Object handles
- Native objects are stored in a host registry.
- `MdhValue` for native object uses tag `MDH_TAG_NATIVE` and data = handle ID.

### 5.2 Uniform call surface
Generic calls (preferred):
- `__mdh_native_get(obj, key_string)`
- `__mdh_native_set(obj, key_string, value)`
- `__mdh_native_call(obj, method_string, argc, argv_ptr)`

Alternative (tri-specific):
- `__mdh_tri_set_pos(mesh, x, y, z)`
- `__mdh_tri_render(renderer, scene, camera)`

Generic access keeps language semantics consistent. Tri-specific calls can be used internally for performance.

## 6. Implementation checklist

### Interpreter (NativeObject)
- Add Value::NativeObject.
- Implement trait and update interpreter get/set/call.
- Add tests for get/set/call routing.

### LLVM runtime
- Add native tag + runtime functions.
- Update codegen to handle native in get/set/call paths.

### WAT runtime + host
- Add host runner with wasmtime.
- Implement host runtime functions (value store, dict/list, etc.).
- Add tri module construction and native object registry.

### WAT compiler
- Add dict/object/value model (host handles).
- Emit host calls for arithmetic and property access.
- Special-case `fetch "tri"` -> `__mdh_tri_module()`.

## 7. Risks and mitigations
- **Event loop conflicts:** run renderer on the main thread; avoid interpreter callbacks from render loop.
- **WASM host complexity:** start with handle-only model to reduce compiler work.
- **Memory leaks:** define explicit `dyspos()` and refcount in host runtime.

## 8. Open items
- Finalize MDH_TAG_NATIVE placement and representation across runtimes.
- Decide whether to expose generic NativeObject APIs to stdlib.
- Determine whether the wasm runner ships as a subcommand or separate binary.

