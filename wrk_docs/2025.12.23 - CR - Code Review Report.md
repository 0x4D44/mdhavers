# 2025.12.23 - CR - Code Review Report (mdhavers)

## Metadata
- Repo: `mdhavers` (`/home/md/language/mdhavers`)
- Review date: 2025-12-23
- Git HEAD: `e4226acbcb781d18e5fcbe97b333e4f72d3836e9`
- Plan: `wrk_docs/2025.12.23 - CR - Code Review Plan.md`

## Executive summary
mdhavers is an ambitious, feature-rich language implementation with multiple backends (interpreter, JS transpiler, WAT/WASM, LLVM native), a surprisingly large stdlib, and a broad automated test suite. The repo also includes real networking/TLS/DTLS/SRTP and audio/graphics subsystems, which is powerful but increases both reliability and security stakes.

The biggest issues found are structural rather than stylistic:
- The interpreter mutates internal state (environment, current directory, shadow stack) without ensuring restoration on error paths; REPL sessions can become inconsistent after runtime errors.
- Core numeric operations can panic or behave inconsistently (integer overflow, `i64::MIN / -1`, negative string repeat casting), making crashes user-triggerable.
- Module import caching/circular import handling appears incorrect (re-imports are silently skipped, and circular imports are not surfaced as errors).
- The advertised browser playground path is currently not buildable with `wasm32-unknown-unknown` due to native/unix/system dependencies and wasm-incompatible transitive deps (`getrandom` configuration).

Addressing these first will significantly improve correctness, stability, portability, and maintainability.

## Scope and code map
See the plan’s “Code inventory” section for counts and the high-level map of directories.

### First-party areas reviewed in depth
- `src/` (Rust language implementation)
- `tests/` (Rust tests)
- `stdlib/`, `examples/` (`.braw` code)
- `runtime/` (C/Rust/JS runtimes)
- `playground/` (WASM bindings + web)
- `installer/` (shell scripts)
- `editor/vscode/src/` + `editor/vim/` (editor tooling source)

### Third-party / generated areas (reviewed for risk, not line-by-line)
- `vendor/` (patched `raylib-sys` and raylib sources)
- `editor/vscode/node_modules/`, `editor/vscode/out/`
- `target/` build outputs, binary artifacts under `runtime/`

## Findings (by severity)
This is a condensed summary; details and context are in the per-phase sections below.

### Critical
- _None recorded_

### High
- **Interpreter state can be corrupted after errors** (missing RAII restoration for env/current_dir/shadow stack; affects REPL and long-lived interpreter usage).
- **User-triggerable panics / inconsistent semantics in integer arithmetic** (overflow, `i64::MIN / -1`, unary negation overflow, negative repeat casting).
- **Module import semantics likely incorrect** (re-imports skipped; circular imports silently skipped; implicit re-exports from module env).
- **Playground wasm build fails for `wasm32-unknown-unknown`** (native/unix deps + `getrandom` wasm support configuration).

### Medium
- **Build system mismatches and portability** (`Makefile` “auto-detect” doesn’t disable default features; `build.rs` writes artifacts into repo and shells out to `gcc` + nested cargo builds).
- **Lexer performance/position tracking issues** (O(n²) scanning per line; incorrect columns with multiline tokens).
- **Backend parity drift risk** (JS numeric semantics; string indexing inconsistencies; WAT compiler imports huge host surface by default; LLVM codegen size/unwrap usage).
- **LSP re-implements lexer/parser** (`src/lsp/mdhavers_bindings.rs`), increasing divergence risk.
- **Test fragility around features** (`tests/cli_coverage.rs` assumes LLVM build behavior even when `llvm` disabled; several tests spawn binaries via hardcoded `target/debug/...` paths).

### Low / Nit
- **tri module errors often use `line: 0`**, reducing diagnostics quality.
- **Some error variants are currently unused**, suggesting drift between taxonomy and implementation.
- **Graphics frame lifecycle is implicit**, which may be fine but is harder to reason about for users.

## Detailed review (driven by the plan)

### Phase 1 — Build/test surfaces and project structure
**What’s strong**
- Clear project orientation in `README.md` and `agents.md`, plus Makefile targets for common tasks.
- Feature flags are documented in `Cargo.toml` comments (CLI vs LLVM vs graphics vs audio vs wasm runner).

**Key risks / issues**
1) **Makefile auto-detection does not actually disable default features**
   - `Cargo.toml` enables heavy features by default (`default = ["cli", "llvm", "graphics", "graphics3d", "audio"]`), but `Makefile` never uses `--no-default-features`.
   - As written, `make build`/`make test` will still attempt to build default features even when LLVM is “disabled” in Make’s detection output, which is misleading and likely to fail on machines without LLVM/raylib deps.
   - Recommendation: either (a) reduce `default` features in `Cargo.toml` (common default is just `cli`), or (b) make Makefile explicitly pass `--no-default-features` and re-add the desired set (`cli`, optionally `audio`, `graphics`, etc.).

2) **`build.rs` performs non-portable, repo-mutating builds**
   - `build.rs` directly shells out to `gcc` and writes outputs into the source tree (`runtime/mdh_runtime.o`, `runtime/gc_stub.o`, `runtime/mdh_runtime_rs.a`), rather than using Cargo’s `OUT_DIR` and emitting `cargo:rustc-link-*` directives.
   - It also invokes nested `cargo build` for `runtime/mdh_runtime_rs`, which can complicate cross-compiles, caching, and reproducibility.
   - Recommendation: migrate runtime compilation to the `cc` crate + `OUT_DIR`, avoid writing into the repo, and gate native runtime compilation for non-native targets (e.g. `wasm32`) where it is unnecessary.

3) **Large vendored / generated surfaces committed**
   - `vendor/` (raylib sources) and `editor/vscode/node_modules/` and `editor/vscode/out/` are checked in, which increases repo size and audit burden.
   - Recommendation: if practical, prefer lockfiles + package manager installs during CI/release, and keep only minimal vendored code required for reproducible native builds.

### Phase 2 — Core language frontend (lexer → parser → AST)
**AST design (`src/ast.rs`)**
- Clear separation of statement vs expression nodes; spans included on all nodes.
- Nice ergonomics: `Expr::span()` / `Stmt::span()` helpers.

**Tokenization (`src/token.rs`, `src/lexer.rs`)**
1) **Lexer position tracking is inefficient and potentially incorrect for multiline tokens**
   - `Lexer::tokenize()` rescans from the start of the current line to each token start to update internal counters, even though it ultimately computes `column` using `span.start - last_newline_pos + 1`.
   - This pattern is **O(n²) per long line** and becomes costly for large files or long lines.
   - Additionally, strings currently permit embedded newlines (regex does not exclude `\n`), and the current “scan until span.start” logic updates `last_newline_pos` to `span.start` when it sees `\n`, which will produce wrong columns after multiline string literals.
   - Recommendation: decide whether multiline quoted strings are intended. If not, disallow `\n` in quoted-string regexes; if yes, rework lexing to track positions incrementally (scan only new text and set `last_newline_pos` to the actual newline position + 1).

2) **Several error variants appear unused by the lexer**
   - `HaversError::InvalidNumber`, `HaversError::IntegerOverflow`, and `HaversError::UnterminatedString` exist but lexer callbacks return `None` on parse failure, which currently becomes `UnkentToken` instead of a more specific error.
   - Recommendation: map numeric parse failures and unterminated-string cases to the dedicated error variants for better diagnostics.

**Parsing (`src/parser.rs`)**
1) **Range syntax appears intentionally limited**
   - The parser only recognizes `..` ranges via `maybe_range()` directly after an integer literal (so `1..10` works, but `start..end` does not).
   - The AST and interpreter support general `Expr::Range { start, end, inclusive }`, so this looks like an inconsistency between grammar and runtime capability.
   - Recommendation: either document the restriction explicitly or extend parsing so `..` is a real infix operator with appropriate precedence.

2) **F-string expression extraction is brace-depth based and may mis-handle braces inside strings**
   - `parse_fstring()` counts `{`/`}` to extract interpolated expressions. This is likely to break for expressions containing braces within string literals or other contexts where braces should not affect nesting.
   - Recommendation: either restrict what can appear inside `{...}` (and document it), or implement a small tokenizer for the f-string expression portion that understands string literals and escaping well enough to ignore braces inside strings.

3) **Span sourcing is inconsistent in some constructs**
   - Some nodes capture spans from `previous()` tokens, while others use `current_span()` after consuming a token (which points at the next token). This can shift reported locations.
   - Recommendation: standardize span semantics (e.g., “span is location of the operator/keyword” or “span is start of construct”) and consistently record from `previous()` or from the first token in the construct.

### Phase 3 — Runtime semantics (interpreter + values + errors)
**Value model (`src/value.rs`)**
1) **Equality semantics are inconsistent across reference types**
   - Lists are compared structurally (`Value::List` deep-compares elements), but dicts/sets/classes/instances are compared by identity (`Rc::ptr_eq`).
   - This can surprise users (e.g., two separately-constructed dicts with the same entries compare “nae”).
   - Recommendation: explicitly define equality semantics in language docs, and (if desired) implement deep equality for dict/set with cycle detection.

2) **Range support is half-implemented**
   - `Value::Range` / `RangeValue` exist, and `for`-loops support iterating a `Value::Range`, but `Expr::Range` currently evaluates to a **materialized list**, and the `range()` builtin also returns a list.
   - Recommendation: either remove dead code, or (preferably) use `Value::Range` for lazy iteration to avoid allocating large lists for `1..N` and improve performance.

**Interpreter core (`src/interpreter.rs`)**
1) **Interpreter state restoration is not error-safe (RAII missing)**
   - Multiple routines mutate interpreter state (e.g., `self.environment`, `self.current_dir`, shadow stack frames) and then use `?` inside the “critical section” without a `Drop` guard.
   - Concrete examples:
     - `execute_block(...)` restores `self.environment` on normal completion and on control-flow returns, but **does not restore it on runtime errors**, because the `?` early-return bypasses the restore.
     - `load_module(...)` switches `current_dir` and `environment` and restores them only on success; runtime errors inside the module leave the interpreter in the module’s env/dir.
     - `call_function_with_env(...)` pushes a shadow stack frame and pops it only on success; errors in the function body skip `pop_stack_frame()`, leaving stale frames in the crash-report stack.
   - Impact: REPL sessions can become corrupted after an error, and stack traces can become misleading or grow without bound.
   - Recommendation: introduce small RAII guards (e.g., `EnvGuard`, `DirGuard`, `StackFrameGuard`) so restoration happens in `Drop` regardless of how the function exits.

2) **Import/module semantics likely incorrect for repeated imports and circular imports**
   - `loaded_modules: HashSet<PathBuf>` is treated as “already loaded → skip entirely”, which means a second `fetch` of an already-loaded module does not inject exports/alias into the importing scope.
   - Circular imports are not reported as `HaversError::CircularImport`; instead the second import is silently skipped, risking partially initialized modules.
   - Additionally, `get_exports()` exports **all names defined in the module env**, including names imported into the module, which creates implicit re-exports and namespace pollution.
   - Recommendation: maintain a module cache `PathBuf -> exports` and a separate “in-progress” stack/set for circular detection; always inject cached exports into the importing scope.

3) **Integer arithmetic can panic or behave inconsistently across debug/release**
   - `binary_op()` uses `+`, `-`, `*`, `/`, `%` on `i64` directly (and unary negation uses `-n`), which can overflow and panic in debug builds; `i64::MIN / -1` can trap at runtime.
   - This is user-triggerable via source code and is a stability issue (DoS via crash).
   - Recommendation: use `checked_*` ops and convert overflow to `HaversError::IntegerOverflow` (or define wrapping semantics explicitly and implement consistently).

4) **Some numeric/string edge cases can panic or allocate unexpectedly**
   - `"some_string" * n` casts `n` to `usize` without checking for negativity; negative values become huge `usize` and can attempt enormous allocations.
   - `median()` sorts floats via `partial_cmp(...).unwrap()`, which panics if any element is `NaN`.
   - Recommendation: validate inputs and return a user-facing error instead of panicking.

5) **Comparison of integers via `f64` risks incorrect results for large values**
   - `compare()` converts integers to `f64` and compares, which loses precision above ~2^53 and can yield wrong ordering results.
   - Recommendation: compare `i64` as integers when both operands are integers; only use `f64` when a float is involved.

6) **String indexing uses byte-length for negative indices**
   - For strings, negative index conversion uses `s.len()` (bytes) but indexing uses `chars().nth(...)` (Unicode scalar index), so negative indices can behave incorrectly for non-ASCII strings.
   - Recommendation: define and implement consistent string indexing semantics (bytes vs Unicode scalar values) across interpreter/JS/WASM/LLVM backends.

**Error taxonomy (`src/error.rs`)**
- The error enum is rich and user-friendly, but several variants appear unused in the current implementation (e.g., `InvalidNumber`, `UnterminatedString`, `InfiniteLoop`, `KeyNotFound`), and many native-function errors are wrapped as `InternalError` even when they represent user misuse.
- Recommendation: align error variants with actual production of those errors (or remove dead variants), and consider letting native functions return structured `HaversError` instead of `String`.

### Phase 4 — Backends and parity (JS / WAT / LLVM)
**JavaScript compiler (`src/compiler.rs` + `runtime/js/*`)**
- The JS backend is a full transpiler with an embedded runtime (`include_str!("../runtime/js/*")`), which is convenient for single-file outputs.
- Parity risks:
  - JS number semantics are `f64` and cannot exactly represent all `i64` values, so large-integer behavior will diverge from the interpreter.
  - String indexing/length semantics in JS (UTF‑16 code units) differ from Rust’s `chars()` / byte-length usage; cross-backend consistency should be explicitly defined and tested.

**WAT/WASM compiler (`src/wasm_compiler.rs`)**
- The file is explicitly marked “experimental” and not feature-complete.
- The generated modules import a very large surface area from the host environment (including audio and other subsystems) even for small programs.
  - Impact: larger outputs, more brittle host/ABI expectations, and harder versioning.
  - Recommendation: reduce imports to only what is required by the compiled program, or centralize via a smaller ABI with indirect dispatch.

**LLVM backend (`src/llvm/*`)**
- Strengths:
  - Embeds runtime object/staticlib payloads and writes them to uniquely-named temp files for linking (good parallel-test hygiene).
  - Includes a progress/status UI that degrades gracefully when stderr isn’t a TTY.
- Risks:
  - Platform/linker assumptions: `cc`, `-pthread`, and `-static-libgcc` are not portable across all targets/OSes.
  - Complexity: `src/llvm/codegen.rs` is extremely large (~37k LOC) with heavy use of `unwrap()` and `unsafe`, increasing the likelihood of compiler panics on edge cases.
  - Recommendation: invest in error plumbing (avoid `unwrap()` in codegen paths that can be triggered by user input), and consider splitting codegen into smaller modules with stronger invariants and helper types.

**Native runtime shims (`runtime/mdh_runtime.c`, `runtime/mdh_runtime_rs`)**
- The LLVM backend relies on a large C runtime shim (~8.6k LOC) plus an embedded Rust staticlib.
- The C runtime uses manual memory management and unsafe string APIs (e.g., `strcpy`/`strcat`), which raises the risk of memory-safety defects.
- Recommendation: add sanitizer builds (ASan/UBSan) and fuzzing for the C runtime boundary, and prefer bounded string operations (`snprintf`, `strlcpy`-style patterns) where possible.

**Parity/testing**
- The repo contains many backend-specific tests (notably LLVM coverage suites). What’s still needed is a **cross-backend parity harness** (same `.braw` inputs executed via interpreter + JS + LLVM + WASM where supported, comparing outputs/errors) to prevent semantic drift.

### Phase 5 — Subsystems (logging, networking, TLS/DTLS/SRTP, audio, graphics, tri)
**Logging (`src/logging.rs`)**
- Solid structure: global log level + filter rules, multiple sinks (stderr/stdout/file/memory), text/json/compact formats, and span-path support.
- Minor risks:
  - Poisoned mutex handling is mixed (`unwrap_or_else(|e| e.into_inner())` in some places; explicit errors in others). This is acceptable but should be consistent.

**Networking + DNS + TLS/DTLS/SRTP (primarily `src/interpreter.rs`, plus `runtime/mdh_runtime_rs`)**
- This repo contains substantial network/crypto functionality (DNS lookups, raw sockets, TLS, DTLS, SRTP).
- Security posture observations:
  - TLS client config defaults to system roots (`webpki-roots`) and safe defaults, which is good.
  - There is explicit support for **insecure** modes:
    - TLS: `rustls::ClientConfig::dangerous().set_certificate_verifier(InsecureVerifier)`
    - DTLS: `danger_accept_invalid_certs(true)` and `danger_accept_invalid_hostnames(true)`
  - Recommendation: keep these options, but make them very explicit in API names/docs (e.g., `*_insecure_*`) and ensure they are never the default; consider emitting a loud warning log when used.
- Reliability/maintainability:
  - There is duplicated logic between `src/interpreter.rs` and `runtime/mdh_runtime_rs/src/lib.rs` for TLS/DTLS/SRTP config parsing and verification behavior. Divergence risk is high.
  - Recommendation: extract shared code into a crate/module and reuse from both interpreter and runtime, or generate from a single source of truth.

**Audio (`src/audio.rs`, `runtime/mdh_rustysynth_wasm`, `runtime/js/*`)**
- Positive: test-only shims (`#[cfg(test)]`) for miniaudio/rustysynth enable exercising logic without real audio devices—good for CI stability.
- Watch-outs:
  - The audio surface spans Rust interpreter natives, JS runtime helpers, and WASM synth code; ensure ABI/versioning is documented so the playground/runtime stays compatible.

**Graphics (`src/graphics.rs`)**
- Feature-gated cleanly with a stub registrar when `graphics` is disabled.
- Uses thread-local handles for raylib state; this matches raylib’s typical single-thread model.
- Potential improvements:
  - The API currently treats `screen_begin`/`screen_end` as no-ops and performs draw contexts inside individual draw calls; this is simple but may add overhead and can make frame lifecycle unclear. Consider moving to an explicit begin/end frame model.

**tri module (`src/tri.rs`)**
- Implemented as a `NativeObject` stub with constructors/constants; errors often use `line: 0`, which reduces diagnostic value.
- Recommendation: plumb spans/line numbers through native object calls where feasible, so errors from tri usage point to user code locations.

### Phase 6 — Tooling and distribution (CLI/LSP/editor/install/playground)
**CLI (`src/main.rs`)**
- Good: clear subcommands (`run`, `compile`, `repl`, `check`, `fmt`, `tokens`, `ast`, `trace`, `wasm`, `build`), plus friendly diagnostics and a crash/panic hook for nicer “unexpected crash” UX.
- Maintainability/build note: `src/main.rs` declares `mod ...` for many modules that are also part of `src/lib.rs`, which causes the same code to be compiled separately for the lib and the binary. This increases compile time and can cause subtle divergence if the two crates start to differ in cfg/feature settings.
  - Recommendation: make the binary depend on the library crate (`use mdhavers::...`) and keep modules defined once.

**REPL**
- The REPL parses one line at a time and does not provide multiline input support for blocks/functions; this is a UX limitation.
- Given the interpreter’s current “state not restored on error” behavior, REPL sessions are at risk of becoming inconsistent after runtime errors unless users manually `:reset`.

**LSP (`src/lsp/*`)**
- The server is a straightforward stdio LSP implementation with diagnostics/hover/completions/goto-definition basics.
- Major maintainability risk: `src/lsp/mdhavers_bindings.rs` re-implements a simplified lexer/token enum (and parsing helpers) instead of using the real `mdhavers` lexer/parser.
  - Impact: diagnostics can drift from actual language behavior over time.
  - Recommendation: reuse the real lexer/parser from the library crate, and map `HaversError` into LSP diagnostics.

**VSCode extension (`editor/vscode/src/extension.ts`)**
- The extension is minimal and uses `vscode-languageclient` correctly in principle.
- Bug: the “try common locations” logic does not actually test for existence; it always keeps the original `serverPath` (`possiblePaths[0]`).
  - Recommendation: use `fs.existsSync` (or async fs checks) to pick the first existing path, falling back to PATH lookup only if none exist.

**Installer (`installer/*`)**
- Local install path is clear and idempotent-ish, but “remote install from releases” is explicitly TODO and currently errors out.
- Recommendation: either implement remote install or adjust documentation/comments to avoid implying `curl | sh` works today.

**Playground (`playground/*`)**
- The WASM bindings API is clean (returns JSON payloads with `success/result/output/error`), and uses a panic hook for better browser diagnostics.
- Major portability concern: the core `mdhavers` crate currently depends unconditionally on native/network/crypto crates and Unix-specific APIs (e.g., `std::os::unix::io` and OpenSSL/DTLS/SRTP deps), which is incompatible with `wasm-pack --target web`.
  - Recommendation: make native/network subsystems optional via Cargo features and `cfg(target_arch)` gating, so the “core language” can compile to `wasm32-unknown-unknown`.

### Phase 7 — Stdlib + examples + benchmarks
**Stdlib (`stdlib/*.braw`)**
- Strengths:
  - The standard library is unusually rich for a young language: collections, functional helpers, testing/benchmarking harnesses, UI utilities, and a substantial networking/media stack.
  - `stdlib/README.md` is well-organized and provides a clear module index and examples.
- Risks / review notes:
  - Several stdlib modules wrap powerful native capabilities (file I/O, sockets, DNS, TLS/DTLS/SRTP, audio). If mdhavers is ever used to run untrusted code, the stdlib + native surface makes sandboxing a priority.
  - Given the interpreter’s module-import behavior (implicit re-exports, “already loaded → skip”), stdlib composition may behave unexpectedly as modules grow more interdependent.
  - Recommendation: add a “stdlib contract” section (naming conventions, stability guarantees, which modules are safe for sandboxed environments, etc.) and expand backend-parity tests for stdlib modules that are expected to work under JS/WASM/LLVM.

**Examples (`examples/`)**
- Examples are useful and cover basics + showcases, but should be checked periodically for:
  - consistency with current language features
  - avoiding insecure patterns (especially in networking/TLS examples)

**Benchmarks (`benchmarks/`)**
- Benchmarks exist in both Rust and `.braw` forms; ensure benchmark harnesses pin feature sets (LLVM vs interpreter) so comparisons are meaningful.

### Phase 8 — Verification and static checks
Commands were run on 2025-12-23 in `/home/md/language/mdhavers`.

**Unit/integration tests**
- `cargo test --tests --no-default-features --features cli`
  - ✅ Library unit tests: 1052 passed
  - ✅ LSP unit tests: 8 passed
  - ❌ `tests/cli_coverage.rs`: 2 failures (notably assumes LLVM-backed `build` subcommand works even when `llvm` feature is disabled)
- `cargo test --test lsp_coverage --no-default-features --features cli`
  - ✅ 1 passed
- `cargo test --test cli_coverage --no-default-features --features cli,llvm`
  - ✅ 8 passed

**Formatting**
- `cargo fmt -- --check`
  - ✅ Pass

**Clippy**
- `cargo clippy --no-default-features --features cli`
  - ✅ Pass
- `cargo clippy --no-default-features --features cli -- -D warnings`
  - ❌ Fails because `build.rs` invokes a nested `cargo build` for `runtime/mdh_runtime_rs`, and that crate triggers a `dead_code` warning under `-D warnings` (example: `MDH_TAG_NATIVE` unused).
  - Recommendation: avoid nested cargo builds in `build.rs`, and keep runtime crates warning-clean if strict linting is a goal.

**WASM portability (playground)**
- `cd playground && cargo build --target wasm32-unknown-unknown`
  - ❌ Fails due to `getrandom` lacking wasm JS support by default (requires enabling the `js` feature) and, more broadly, because the dependency graph includes native/system-focused crates not suited for `wasm32-unknown-unknown`.

## Recommendations (prioritized)
1) **Make interpreter state restoration error-safe (RAII guards)** (High)
   - Add `Drop` guards for environment swaps, directory swaps, and shadow stack frames in `src/interpreter.rs`.
   - Goal: after any error, REPL can continue safely without requiring `:reset`.

2) **Define and implement consistent numeric semantics** (High)
   - Use `checked_*` integer ops (and checked negation) and raise `HaversError::IntegerOverflow` (or clearly define wrapping semantics and implement consistently).
   - Validate `string * n` for negative `n` and handle NaN-sensitive paths (e.g., `median()`).
   - Fix integer comparisons to avoid `i64 -> f64` precision loss.

3) **Fix module system correctness (imports + circular detection + caching)** (High)
   - Replace `loaded_modules: HashSet<PathBuf>` “skip” behavior with:
     - an “in progress” stack/set for circular detection (surface `HaversError::CircularImport`)
     - a cache from module path → exports value, injected on every `fetch`.
   - Consider an explicit export mechanism to avoid accidental re-exports.

4) **Unblock browser playground builds** (High)
   - Make native/network/crypto subsystems optional via features and `cfg(target_arch)` gating so `mdhavers` can compile for `wasm32-unknown-unknown`.
   - Address wasm RNG requirements (`getrandom` “js” feature) and remove/replace wasm-incompatible transitive deps.

5) **Fix build ergonomics and portability** (Medium)
   - Align `Makefile` with feature strategy (`--no-default-features` + explicit features) or reduce default features in `Cargo.toml`.
   - Refactor `build.rs` to use `OUT_DIR` + `cc` crate and avoid nested cargo invocations (improves reproducibility, cross-compiles, linting).

6) **Reduce divergence in tooling** (Medium)
   - LSP: reuse the real mdhavers lexer/parser and map `HaversError` to LSP diagnostics.
   - VSCode extension: fix LSP binary path selection by checking for existing binaries before falling back to PATH.

7) **Add a backend parity harness** (Medium)
   - Run the same `.braw` fixtures through interpreter + JS + LLVM + WASM (where supported) and compare outputs/errors to prevent semantic drift.

8) **Repository hygiene for third-party code** (Medium/Long-term)
   - Consider de-vendoring `editor/vscode/node_modules/` and documenting the provenance/license/security posture of vendored `vendor/` code.
