# LLVM Backend Completion - Ralph Wiggum Loop

## Objective
Achieve 95%+ build success rate for the mdhavers LLVM backend (129+/136 files).

**Current Status:** 68/136 (50%)
**Target:** 129/136 (95%)

## Test Command
```bash
find examples -name "*.braw" -exec sh -c './target/release/mdhavers build "$1" >/dev/null 2>&1 && echo "PASS"' _ {} \; 2>/dev/null | grep -c "PASS"
```

## Categorized Remaining Issues

### Phase 1: Callable Fields (HIGH IMPACT - ~8 files)
Files failing with "Method 'X' not found" where X is actually a field containing a callable:
- `thunk` - in promise.braw, promise_demo.braw
- `reducer` - in store.braw, store_demo.braw
- `on_enter_callback`, `on_exit_callback`, `on_transition` - in adventure.braw, fsm_demo.braw, highland_adventure.braw
- `before_each_fn`, `after_each_fn` - in test_framework_demo.braw

**Fix:** In `compile_method_call`, when no method is found:
1. Check if object has a field with that name via `inline_get_field`
2. If field exists, get its value and call it as a function
3. This handles patterns like `masel.callback()` where `callback` is a stored lambda

**Code location:** `src/llvm/codegen.rs` around line 15206 where "Method not found" error is returned.

**Implementation approach:**
```rust
// Before returning "Method not found" error, try callable field pattern:
// 1. Get the field value from the instance
// 2. Check if it's callable (tag == Lambda or Function)
// 3. If so, build a call to that value with the provided args
```

### Phase 2: Scots Set/Creel Builtins (~6 files)
Missing Scots-dialect set operations. In the interpreter these are defined around line 3453-3520.

| Scots Name | English Equivalent | Args | Description |
|------------|-------------------|------|-------------|
| `toss_in` | set.add | (set, item) | Add item to set |
| `heave_oot` | set.remove | (set, item) | Remove item from set |
| `is_in_creel` | contains | (set, item) | Check if item in set |
| `empty_creel` | {} | () | Create empty set/dict |
| `make_creel` | set() | (list) | Create set from list |

**Implementation:** Add these as builtin dispatches in `compile_call`. Since sets are implemented as dicts:
- `toss_in(set, item)` → set dict key to item
- `is_in_creel(set, item)` → same as `contains(set, item)`
- `empty_creel()` → return empty dict `{}`

### Phase 3: File I/O Builtins (~4 files)

**Required functions:**
1. `file_exists(path)` - Returns bool
2. `slurp(path)` - Read entire file to string
3. `scrieve(path, content)` - Write string to file
4. `lines(path)` - Read file as list of lines (can use slurp + split)

**Runtime implementation (mdh_runtime.c):**
```c
#include <sys/stat.h>

MdhValue __mdh_file_exists(MdhValue path) {
    const char* p = (const char*)path.data;
    struct stat st;
    return __mdh_make_bool(stat(p, &st) == 0);
}

MdhValue __mdh_slurp(MdhValue path) {
    const char* p = (const char*)path.data;
    FILE* f = fopen(p, "r");
    if (!f) return __mdh_make_string("");
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    char* buf = malloc(size + 1);
    fread(buf, 1, size, f);
    buf[size] = '\0';
    fclose(f);
    return __mdh_make_string(buf);
}

MdhValue __mdh_scrieve(MdhValue path, MdhValue content) {
    const char* p = (const char*)path.data;
    const char* c = (const char*)content.data;
    FILE* f = fopen(p, "w");
    if (!f) return __mdh_make_bool(0);
    fputs(c, f);
    fclose(f);
    return __mdh_make_bool(1);
}
```

### Phase 4: Missing Math/Utility Builtins (~5 files)

| Function | Args | Description | Implementation |
|----------|------|-------------|----------------|
| `average` | (list) | Average of numeric list | Sum / len |
| `tae_binary` | (n) | Int to binary string | Bit manipulation |
| `pair_up` | (a, b) | Zip two lists | Create list of pairs |
| `tak` | (list, n) | Take first n elements | Slice [0:n] |

### Phase 5: Logging/Debug Builtins (~3 files)

These are used in logging.braw and related files:
- `get_log_level()` - Return global log level (int 0-5)
- `set_log_level(level)` - Set global log level
- `_global_logger` - Global variable for logger instance
- `blether_format(fmt, args...)` - Formatted print

**Simple implementation:** Create global variables for log level, return constants.

### Phase 6: Spread Operator Enhancement (~2 files)

Current limitation: Spread only works in list literals `[...x]`

**Files affected:** examples/basics/spread.braw

**Fix needed:** Handle `Expr::Spread` in function call argument compilation. When compiling call args:
```rust
for arg in args {
    if let Expr::Spread { expr, .. } = arg {
        // Compile expr (should be a list)
        // Iterate and add each element as separate arg
    } else {
        call_args.push(self.compile_expr(arg)?.into());
    }
}
```

### Phase 7: Test Framework Internals (~3 files)

Used in test_example.braw, test_framework_demo.braw, proptesting_demo.braw:
- `__current_suite` - Global string for current test suite name
- `skip(reason)` - Mark test as skipped (can just print and return)
- `_tick_counter`, `_msg_counter` - Global counters

**Implementation:** Initialize these as global variables at module startup.

### Phase 8: Scots Word Aliases (~5 files)

Map to existing builtins or simple implementations:

| Scots | Maps To | Notes |
|-------|---------|-------|
| `slainte` | nil | Greeting, returns nil |
| `scots_greetin` | error string | Return error message |
| `braw_time` | time() | Current timestamp |
| `wee` | min | Smaller of two |
| `och` | print | Warning/error print |
| `chynge` | replace | String replace |
| `poetry_seed` | random seed | For poetry generator |

## Implementation Order

1. **Phase 1 (Callable Fields)** - Highest impact, fixes 8 files
2. **Phase 3 (File I/O)** - Required by multiple demos
3. **Phase 2 (Scots Sets)** - Common pattern
4. **Phase 4 (Math Utils)** - Quick wins
5. **Phase 5-8** - Remaining gaps

## Key Code Locations

- **Builtin dispatch:** `src/llvm/codegen.rs` around line 7300-7900
- **Method call compilation:** `src/llvm/codegen.rs` around line 15070-15250
- **Runtime functions:** `runtime/mdh_runtime.c`
- **Runtime declarations:** Look for `LibcFunctions` struct and initialization

## Verification

After each phase:
```bash
# Count passing
find examples -name "*.braw" -exec sh -c './target/release/mdhavers build "$1" >/dev/null 2>&1 && echo "P"' _ {} \; 2>/dev/null | grep -c "P"

# List remaining failures
find examples -name "*.braw" -exec sh -c './target/release/mdhavers build "$1" >/dev/null 2>&1 || echo "FAIL: $1"' _ {} \; 2>/dev/null | grep FAIL
```

## Success Criteria

- 129+ of 136 files compile successfully (95%+)
- No regressions in previously working files
- All executables that build also run without crashing

## Completion Promise

"I will systematically implement each phase, testing after each one, until 95%+ build success is achieved."
