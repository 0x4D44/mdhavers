# List Operations and Sieve Optimization for mdhavers LLVM Backend

## Current Performance Status (2025-12-11)

### Benchmark Results vs Rust

| Benchmark | mdhavers | Rust | Ratio | Priority |
|-----------|----------|------|-------|----------|
| **Fibonacci iterative** | 1 μs | 3 μs | **0.3x faster** | ✅ Done |
| **String concat** | 0 μs | 2 μs | **Faster** | ✅ Done |
| **String upper** | 34 μs | 9 μs | 3.8x slower | ✅ Acceptable |
| **String split** | 324 μs | 75 μs | 4.3x slower | ✅ Acceptable |
| **String join** | 44 μs | 15 μs | 2.9x slower | ✅ Acceptable |
| **Primes sieve(20K)** | 284 μs | 40 μs | **7x slower** | CRITICAL |
| **List build 10K** | 101 μs | N/A | - | HIGH |
| **List slice 1000x** | 510 μs | N/A | - | MEDIUM |

## Priority 1: Primes Sieve - 7x Slower (CRITICAL)

### Root Cause Analysis
The sieve algorithm exercises these operations heavily:
```
ken is_prime = []           # Empty list creation
whiles i <= n {
    shove(is_prime, aye)    # 20K+ boolean pushes
    i = i + 1
}
is_prime[0] = nae           # Index assignment
gin is_prime[p] { ... }     # Index access in condition
is_prime[j] = nae           # Index assignment in inner loop
shove(primes, k)            # Integer pushes to result
```

### Performance Bottlenecks
1. **MdhValue overhead**: Each boolean/integer stored as 16-byte tagged value
   - Rust: `Vec<bool>` uses 1 byte per element
   - mdhavers: 16 bytes per element (8x memory, cache misses)

2. **Index operations**: Each `list[i]` involves:
   - Bounds check
   - Tag extraction
   - Pointer arithmetic
   - Value extraction

3. **Index assignment**: Each `list[i] = val` involves:
   - Bounds check
   - Tag creation
   - Value boxing
   - Store

### Optimization Strategies

#### Strategy A: Loop-Invariant Code Motion for Index Operations
Hoist repeated calculations out of loops:
```rust
// Before: inside loop
let elem_offset = header_size + idx * elem_size;
let elem_ptr = gep(list_ptr, elem_offset);

// After: cache base pointer before loop
let elements_base = gep(list_ptr, header_size);
// Inside loop: just offset from base
let elem_ptr = gep(elements_base, idx * elem_size);
```

#### Strategy B: Strength Reduction for Sequential Access
For patterns like `whiles i < n { list[i] = val; i = i + 1 }`:
```rust
// Instead of computing offset each iteration
// Use pointer increment
let mut ptr = elements_base;
while i < n {
    store(ptr, val);
    ptr = gep(ptr, elem_size);
    i += 1;
}
```

#### Strategy C: Specialized Boolean List Operations
Detect boolean-only lists and use packed representation:
```rust
// If all elements are Bool type, use bit array
// 8 booleans per byte instead of 16 bytes per boolean
// 128x memory reduction!
```

#### Strategy D: Pre-sized List Allocation
For `range(0, n)` or detected loop patterns:
```rust
// Detect: ken list = []; whiles i < n { shove(list, val); i++ }
// Optimize to: allocate list with capacity n upfront
```

#### Strategy E: Remove Redundant Bounds Checks
In tight loops where index is provably valid:
```rust
// Pattern: whiles i < len(list) { list[i] ... }
// Index i is always valid, skip bounds check
```

## Priority 2: List Index Assignment Optimization

### Current Implementation Issues
The `compile_index_assign` function likely:
1. Extracts list pointer
2. Checks bounds
3. Calculates offset
4. Stores value

### Optimization: Fast Path for Known-Valid Indices
```rust
// If we can prove index < len at compile time, skip bounds check
// Common patterns:
// - Loop index in whiles i < len(list) { list[i] = ... }
// - Constant indices list[0], list[1]
```

## Priority 3: Shove (Push) Optimization

### Current State
`inline_shove` already has capacity-based growth (doubling).

### Further Optimizations
1. **Inline the common case**: No-grow path should be very fast
2. **Avoid tag checks**: If we know it's a list, skip tag check
3. **Pre-warm capacity**: Start with capacity 16 instead of 8

## Implementation Order

### Phase 1: Profile and Measure
1. Add timing to identify exact bottlenecks in sieve
2. Count how many index operations occur
3. Measure time in shove vs index access vs index assign

### Phase 2: Index Operation Fast Paths
1. Optimize `compile_index` for list access
2. Optimize `compile_index_assign` for list assignment
3. Remove redundant pointer arithmetic

### Phase 3: Loop Optimizations
1. Detect sequential index patterns
2. Use pointer arithmetic instead of index calculation
3. Hoist loop-invariant code

### Phase 4: Specialized Collections (Advanced)
1. Detect homogeneous boolean lists
2. Implement packed bit array representation
3. Add type specialization for integer-only lists

## Testing Commands

```bash
# Build and run benchmarks
cargo build --release

# Primes benchmark (main target)
./target/release/mdhavers build benchmarks/stress/computational/primes_stress.braw -o /tmp/primes_stress && /tmp/primes_stress

# List operations benchmark
./target/release/mdhavers build benchmarks/stress/memory/list_stress.braw -o /tmp/list_stress && /tmp/list_stress

# Compare with Rust
./benchmarks/stress/rust/primes_stress
```

## Key Code Locations

Search in `src/llvm/codegen.rs`:
- `compile_index` or `Expr::Index` - List index access
- `compile_index_assign` or index assignment handling
- `inline_shove` - Line ~2981
- `compile_while` - Line ~6584 (loop compilation)
- `compile_for` - For loop compilation

## Target Goals

| Operation | Current | Target | Improvement |
|-----------|---------|--------|-------------|
| sieve(20K) | 284 μs | 100 μs | 2.8x faster |
| sieve(10K) | 139 μs | 50 μs | 2.8x faster |
| List build 10K | 101 μs | 50 μs | 2x faster |

## Completion Criteria

The optimization work is complete when:
1. Primes sieve(20K) is under 120 μs (from 284 μs)
2. All existing tests pass
3. Correctness verified (sieve returns correct prime counts)

Primary target: **Primes sieve(20K) under 120 μs** (currently 284 μs, 7x slower than Rust's 40 μs)

## Debugging Tips

To see generated LLVM IR:
```bash
# Add debug output to codegen if needed
RUST_LOG=debug ./target/release/mdhavers build file.braw -o /tmp/out
```

To profile:
```bash
perf record /tmp/primes_stress
perf report
```
