# Code Coverage Analysis Report (mdhavers)
**Date:** 2025-12-17  
**Repo:** `mdhavers`  
**Tooling:** `cargo-llvm-cov 0.6.20` (`rustc 1.91.0`)  

## 1) Scope, methodology, and reproduction

### What this report measures
This report measures **Rust source coverage** for the `mdhavers` workspace as reported by LLVM source-based coverage via `cargo llvm-cov`.

Notes:
- **C runtime** (`runtime/*.c`) is **not** included in these Rust coverage numbers.
- `cargo llvm-cov --tests` includes coverage for **binary targets** compiled during the run (e.g. `src/main.rs`, `src/lsp/main.rs`). If those binaries are never executed by tests, they show up as **0%** and drag down totals.

### Commands used
- High-level summary:
  - `cargo llvm-cov --tests --summary-only`
- LCOV export (used to compute per-file line coverage table below):
  - `cargo llvm-cov --tests --lcov --output-path /tmp/mdhavers_llvm_cov.lcov`
  - `python3 analyze_coverage.py /tmp/mdhavers_llvm_cov.lcov`

## 2) Executive summary

### Current baseline (as of 2025-12-17)
From `cargo llvm-cov --tests --summary-only` totals:
- **Line coverage:** **83.09%** (34,602 / 41,642)
- **Function coverage:** **65.05%** (1,658 / 2,549)
- **Region coverage:** **83.98%** (66,852 / 79,606)

### Key takeaways
1. **Core parsing/AST/compiler modules are already strong** (mid/high 90s).
2. The overall percentage is dominated by a few large/0%-covered targets:
   - `src/interpreter.rs` (~79%)
   - `src/llvm/codegen.rs` (~88%)
   - `src/main.rs` (0%)
   - `src/lsp/main.rs` (0%)
   - `src/llvm/runtime.rs` and `src/llvm/builtins.rs` (both 0%, appear to be “legacy/unused” modules under `#[allow(dead_code)]`)
3. Getting to **98%** requires:
   - Covering **thousands** of currently-unexecuted lines in `interpreter.rs` and `llvm/codegen.rs`, and
   - Either executing (or refactoring away) the **0%** entrypoints/modules.

## 3) Per-file line coverage (project files)

Source: LCOV export (`/tmp/mdhavers_llvm_cov.lcov`) parsed with `analyze_coverage.py`.

| File | Lines | Covered | Coverage |
|---|---:|---:|---:|
| `src/llvm/codegen.rs` | 22824 | 20147 | 88.27% |
| `src/interpreter.rs` | 9126 | 7226 | 79.18% |
| `src/main.rs` | 674 | 0 | 0.00% |
| `src/lsp/main.rs` | 238 | 0 | 0.00% |
| `src/llvm/runtime.rs` | 203 | 0 | 0.00% |
| `src/parser.rs` | 1502 | 1440 | 95.87% |
| `src/llvm/compiler.rs` | 234 | 176 | 75.21% |
| `src/lsp/mdhavers_bindings.rs` | 577 | 520 | 90.12% |
| `src/compiler.rs` | 1068 | 1017 | 95.22% |
| `src/formatter.rs` | 848 | 808 | 95.28% |
| `src/wasm_compiler.rs` | 615 | 579 | 94.15% |
| `src/ast.rs` | 605 | 571 | 94.38% |
| `src/llvm/builtins.rs` | 25 | 0 | 0.00% |
| `src/llvm/types.rs` | 37 | 19 | 51.35% |
| `src/error.rs` | 667 | 659 | 98.80% |
| `src/token.rs` | 209 | 203 | 97.13% |
| `src/lib.rs` | 138 | 132 | 95.65% |
| `src/value.rs` | 750 | 745 | 99.33% |
| `src/lexer.rs` | 117 | 112 | 95.73% |
| `src/graphics.rs` | 4 | 4 | 100.00% |
| **TOTAL (project files)** | **40461** | **34358** | **84.92%** |

## 4) Biggest coverage “holes” (by missed lines)

Top contributors to uncovered lines (LCOV):
1. `src/llvm/codegen.rs`: **2,677** missed lines
2. `src/interpreter.rs`: **1,900** missed lines
3. `src/main.rs`: **674** missed lines (0% executed)
4. `src/lsp/main.rs`: **238** missed lines (0% executed)
5. `src/llvm/runtime.rs`: **203** missed lines (0% executed)

These five account for **~96%** of all uncovered lines in project files.

## 5) Likely root causes

### `src/main.rs` (CLI) @ 0%
- No tests currently execute the CLI binary.
- The file contains a large REPL loop and multiple subcommands (run/compile/check/fmt/tokens/ast/trace/wasm/build).

### `src/lsp/main.rs` (LSP binary) @ 0%
- No tests currently exercise the LSP binary entrypoint or message loop.
- The code is testable (the upstream `lsp_server::Connection::memory()` helper exists), but the current architecture keeps almost all logic inside the binary crate.

### `src/llvm/runtime.rs` + `src/llvm/builtins.rs` @ 0%
- These are compiled (and show up in coverage) but are not referenced by the current LLVM backend implementation (`src/llvm/codegen.rs` implements its own mapping/declarations).
- Options: (a) add unit tests for these modules, or (b) refactor/remove if truly obsolete.

### `src/interpreter.rs` @ ~79%
- Interpreter coverage is currently constrained by a lack of integration-style interpreter tests; most existing heavy coverage is on the LLVM backend test suite.
- Large untested surface area is likely: less-common builtins, error branches, module/prelude loading paths, and JSON/string helpers.

### `src/llvm/codegen.rs` @ ~88%
- Large file with many helper paths: uncommon AST nodes, “error” compilation paths, and rarely-used builtins/type-coercion branches.
- Existing LLVM tests are comprehensive but still don’t hit significant slices (especially error/unsupported cases).

## 6) Recommendations (high leverage)

1. **Add coverage-driving tests for 0% binaries**
   - CLI: integration tests that run `mdhavers` with multiple subcommands and scripted REPL input.
   - LSP: refactor server loop into a library module so it can be unit-tested with `Connection::memory()`.
2. **Add a targeted interpreter coverage suite**
   - Table-driven tests that execute many language snippets through the interpreter (including try/catch error paths).
   - Ensure `Interpreter::load_prelude()` is exercised in tests.
3. **Add codegen “negative tests”**
   - Tests that compile invalid/unsupported programs and assert on compiler errors (covers otherwise-never-hit branches).
4. **Retire or test legacy LLVM modules**
   - Either remove dead modules (`llvm/runtime.rs`, `llvm/builtins.rs`) or add small unit tests to cover them.

