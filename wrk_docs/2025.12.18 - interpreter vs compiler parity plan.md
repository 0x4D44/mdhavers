# Interpreter ↔ Compiler Feature Gap Review + Plan (mdhavers)
**Date:** 2025-12-18  
**Scope:** mdhavers **Rust interpreter** (`src/interpreter.rs` + `src/value.rs`) vs **LLVM native compiler backend** (`src/llvm/codegen.rs` + `runtime/mdh_runtime.c`).  

This document inventories the highest-impact feature/semantic gaps and proposes a staged plan to close them in the **compiler backend**.

> Note: there is also a JS transpiler (`src/compiler.rs`) and a wasm compiler, but this plan focuses on the **LLVM native backend**, since that is what the main “compile and run” path and comprehensive tests target.

---

## 1) Summary (what’s “gappy” today)

### 1.1 Builtin parity snapshot (static inventory)

Using a simple static inventory:
- Interpreter “native builtins” = `NativeFunction::new("…")` definitions in `src/interpreter.rs`
- Compiler builtins = match-arm patterns in `CodeGen::compile_call` (`src/llvm/codegen.rs`)

Results:
- Interpreter native builtins: **184**
- Interpreter builtins missing in LLVM backend: **45**
- Interpreter builtins present but **stubbed/placeholder/partial** in LLVM backend (explicit “placeholder” cases): **~45** (see list; some names appear in duplicate match arms, so these must be verified per-case).

The compiler has many *additional* builtin names beyond the interpreter (including placeholders), but those are out of scope for parity.

### 1.2 Biggest semantic divergences (not just “missing functions”)

These are the **highest-risk** parity gaps because they change program meaning:

1) **Dict key semantics**
   - **Interpreter:** dict keys are **strings only**; non-string keys are stringified via `format!("{}", key)` in `Expr::Dict` evaluation.
   - **LLVM backend:** dict keys are stored as **typed `MdhValue` keys** (tag+data), so `1` and `"1"` are different keys.
   - **Impact:** `{1: "a", "1": "b"}` overwrites in interpreter but becomes a 2-entry dict in compiled code.

2) **Set (“creel”) element semantics**
   - **Interpreter:** `Value::Set(HashSet<String>)`, elements are stringified (same mismatch as dict keys).
   - **LLVM backend:** set is represented as dict-like structure where keys are typed `MdhValue` (currently).

3) **Name/behavior mismatch: `creel`**
   - **Interpreter:** `creel(list)` creates a **set**; no 0-arg “make empty list” `creel()`.
   - **LLVM backend:** `creel()` currently creates an **empty list**, and `empty_creel()` creates an empty set/dict.
   - **Impact:** the same program can do different things between backends.

4) **Range representation**
   - **Interpreter:** ranges are a dedicated `Value::Range` iterator type.
   - **LLVM backend:** `Expr::Range` is materialized to a list when used as a value (for-loops still have a special range fast-path).

These divergences must be addressed early, otherwise “builtin parity” won’t guarantee behavioral parity.

---

## 2) Gap inventory

### 2.1 Interpreter builtins missing in LLVM backend (45)

Grouped by domain:

**A) OS / environment / filesystem**
- `args` (needs argv support)
- `cwd`, `chdir`
- `list_dir`, `make_dir`, `is_dir`
- `path_join`
- `env_get`, `env_set`, `env_all`
- `file_size`, `file_delete`
- `scrieve_append`
- `shell`, `shell_status`
- `stopwatch`

**B) Date/time**
- `timestamp`, `timestamp_millis`
- `braw_date`
- `date_now`, `date_parse`, `date_format`, `date_add`, `date_diff`

**C) Regex**
- `regex_test`
- `regex_match`, `regex_match_all`
- `regex_replace`, `regex_split`

**D) Math / random**
- `hypot`
- `random_int`, `random_choice`

**E) String / formatting**
- `substring`
- `trim_start`, `trim_end`
- `blether_format` (named-placeholder formatting via dict)

**F) Scots “fun” / misc**
- `blooter`, `dreich`, `jings`, `stooshie`

**G) Constants exposed as functions in interpreter**
- `pi`, `e`, `tau` (LLVM backend currently exposes `PI`, `E`, `TAU` as constants, not `pi()`/`e()`/`tau()` functions)

### 2.2 Interpreter builtins present in LLVM backend but stubbed/placeholder/partial (≈45)

These are **already callable** in the compiler, but do not match interpreter behavior (many explicitly say “placeholder”):

**A) Dict helpers (critical)**
- `dict_get` / `get` (currently returns nil/default without lookup)
- `dict_merge` / `merge` / `thegither` (returns first dict)
- `dict_remove` (returns dict unchanged)
- `dict_invert` (returns dict unchanged)
- `fae_pairs` (dict from list-of-pairs; placeholder)

**B) Set operations (critical)**
- `creels_baith` (intersection; placeholder)
- `creels_differ` (difference; placeholder)
- `is_subset`, `is_superset`, `is_disjoint` (placeholders)

**C) Assertions**
- `assert`, `assert_equal`, `assert_nae_equal` (no-ops in compiler; interpreter fails fast)

**D) String helpers**
- `strip_left`, `strip_right` (compiler currently returns input as-is)
- `swapcase`
- `char_at`, `chr`, `ord`
- `tae_binary`
- `skelp` (truncate)
- `scottify` (placeholder)

**E) List helpers**
- `dicht` (remove-at)
- `chunks`, `interleave`, `grup_runs` (group runs)
- `split_by`

**F) JSON**
- `json_parse`, `json_stringify`

**G) Misc/fun**
- `bampot_mode`, `crivvens`, `clarty`, `geggie`, `glaikit`, `redd_up`, `range_o`, `scunner`, `scunner_check`, `sporran_fill`, `tattie_scone`, `haggis_hunt`

> Implementation note: `src/llvm/codegen.rs` contains duplicate match arms and a global `#![allow(unreachable_patterns)]`, so a few symbols can appear in both “real” and “placeholder” arms. Before implementing, confirm which arm is actually used (the first match arm wins).

---

## 3) Proposed plan (staged, compiler-focused)

### Stage 0 — Decide & document canonical semantics (required)

**Goal:** remove major “meaning changes” between backends before chasing builtin counts.

1) **Decide canonical dict/set semantics**
   - Option A (match interpreter): dict keys + set elements are **stringified** values.
   - Option B (upgrade interpreter): dict keys + set elements become **Value-based** (typed), matching the compiler’s `MdhValue` semantics.

   Recommendation:
   - Prefer **Option B** long-term (typed keys), because stringification creates collisions and loses type information.
   - If immediate parity is required with existing interpreter behavior, implement **Option A** first but record it as a “compatibility mode” and plan migration.

2) **Resolve `creel` naming/behavior**
   - Either align the compiler to interpreter (`creel(list) -> set`, and add an explicit `list()`/`copy_list()` helper), or align interpreter to compiler.
   - Provide a deprecation window with aliases if this would break existing examples/tests.

3) **Decide range representation**
   - Keep current compiler behavior (range materializes to list) *or* implement a real range object tag in runtime so ranges can stay lazy and match interpreter.
   - If keeping list-materialization, document it as a backend behavior difference.

Deliverable: a short “Semantics” section in docs + a set of focused parity tests for dict/set/range behaviors.

---

### Stage 1 — Close correctness-critical placeholders (dict + set + assertions)

These unlock a large portion of interpreter parity with relatively contained runtime/codegen work.

**A) Dict parity**
1) Implement `dict_get(dict, key[, default])`
   - Use existing runtime `__mdh_dict_get` (already present) and only return `default` when result is nil.
   - If Stage 0 chooses “stringified keys”, ensure `key` is converted to string before lookup.

2) Implement `dict_merge(dict1, dict2)`
   - Runtime approach: add `__mdh_dict_merge` that iterates keys and `__mdh_dict_set`s into a fresh dict.
   - Codegen approach: build from `dict_keys(dict2)` + `dict_get` + `dict_set`.
   - Prefer runtime for speed + fewer IR blocks.

3) Implement `dict_remove(dict, key)`
   - Add runtime `__mdh_dict_remove` or implement via `dict_keys` rebuild.

4) Implement `dict_invert(dict)`
   - Decide behavior for collisions (last write wins vs error).

5) Implement `fae_pairs(list_of_pairs)`
   - Define accepted pair format (2-element list).

**B) Set parity**
1) Implement `creels_baith(a, b)` (intersection), `creels_differ(a, b)` (difference)
2) Implement `is_subset`, `is_superset`, `is_disjoint`
   - Runtime is ideal (iterate dict entry arrays efficiently).
   - If Stage 0 picks “stringified elements”, ensure the set representation is consistent.

**C) Assertions**
1) Implement `assert(cond[, msg])` (or match interpreter’s arity)
2) Implement `assert_equal(a, b)` and `assert_nae_equal(a, b)` using runtime equality
   - Leverage existing `__mdh_assert` and `__mdh_eq`.

Deliverables:
- New runtime C functions as needed + `LibcFunctions` wiring + codegen match arms.
- Tests comparing interpreter and LLVM output for these functions.

---

### Stage 2 — Cheap wins: aliases + small helpers (high ROI)

**A) Alias builtins to existing implementations**
- `substring` → existing substring implementation (`substr`/`scance`/`inline_substring_range`)
- `trim_start` / `trim_end` → `ltrim` / `rtrim` (or implement real `strip_left/right`)
- `pi()` / `e()` / `tau()` → constants `PI` / `E` / `TAU`

**B) Small math/random helpers**
- `hypot(a, b)` → `sqrt(a*a + b*b)` (use existing math functions)
- `random_int(min, max)` → reuse existing random (`jammy`) or runtime RNG
- `random_choice(list)` → pick index via random_int and return list[index]

**C) Formatting**
- `blether_format(template, dict)`
  - Implement via dict iteration + replace (may need a “replace_all” runtime helper for performance).

Deliverables: no/low runtime changes; mostly codegen additions and tests.

---

### Stage 3 — OS + filesystem + environment parity (requires ABI decisions)

These are “feature parity” wins but require careful API choices.

**A) `args()`**
- Best: change LLVM codegen to emit `main(i32 argc, i8** argv)` and store argv in a global runtime slot.
- Alternative (Linux-only): parse `/proc/self/cmdline` (avoid if portability matters).

**B) `cwd()`, `chdir(path)`**
- Add runtime helpers using `getcwd` + `chdir`.

**C) Directory ops**
- `list_dir(path)` via `opendir`/`readdir` (return list of strings)
- `is_dir(path)` via `stat`
- `make_dir(path)` via `mkdir` (recursive vs non-recursive should match interpreter)

**D) File ops**
- `file_size(path)` via `stat`
- `file_delete(path)` via `unlink`
- `scrieve_append(path, content)` via `fopen(..., "ab")` + write

**E) Environment ops**
- `env_get(key)`, `env_set(key, value)`, `env_all()`
  - `env_all` requires iterating `environ`; define stable output ordering (sort keys) if tests compare strings.

**F) Shell execution**
- `shell(cmd)` and `shell_status(cmd)`
  - Decide whether to capture stdout (via `popen`) or just run (via `system`).
  - Document security implications; keep it opt-in if needed.

Deliverables:
- Runtime additions + compiler wiring + explicit tests that skip on restricted environments if necessary.

---

### Stage 4 — Time/date parity (incremental)

Start with the simple/time-since-epoch pieces first:

1) `timestamp()` and `timestamp_millis()`
   - Use `clock_gettime(CLOCK_REALTIME, …)` (already linked) or `time(NULL)`.

2) `date_now()` / `braw_date()`
   - Define format (ISO-8601 recommended) and match interpreter output.

3) `date_parse`, `date_format`
   - Prefer `strptime`/`strftime` if portability is acceptable; otherwise implement a restricted parser.

4) `date_add`, `date_diff`
   - Decide the unit (days vs seconds) and timezone behavior.

Deliverables: runtime additions + deterministic tests (avoid local timezone dependence by forcing UTC in formatting).

---

### Stage 5 — Regex + JSON parity (choose strategy)

These are the “hard” parity pieces if staying in C-only runtime:

**Regex**
- Option A: POSIX regex (`regcomp`/`regexec`) for a limited subset.
- Option B: ship a small regex engine (not ideal).
- Define interpreter-compat subset and document differences.

**JSON**
- Option A: implement minimal JSON handling in C (costly).
- Option B (recommended): add a **Rust staticlib runtime** (FFI) for complex features:
  - `json_parse` via `serde_json`
  - `json_stringify` via `serde_json`
  - (potentially also regex/date, to reuse Rust crates)

Deliverables: a clear runtime architecture decision + tests.

---

## 4) Test strategy (how we verify parity)

1) **Parity microtests** (new)
   - For each builtin (or cluster), add tiny `.braw` snippets whose output is stable.
   - Run snippet through interpreter and LLVM and compare normalized output.

2) **Semantic parity tests** (new, Stage 0 blockers)
   - Dict key stringification vs typed keys
   - Set element semantics
   - `creel` behavior
   - Range representation + inclusive/exclusive edges

3) **CI gates**
   - `cargo test` passes (all targets)
   - `cargo clippy --all-targets -- -D warnings`
   - `cargo fmt --all --check`

---

## 5) Recommended execution order (pragmatic)

If the goal is “maximum parity per unit effort”, do:
1) Stage 0 (decide semantics) + Stage 1 (dict/set/assert)
2) Stage 2 (aliases + helpers)
3) Stage 3 (OS/env/filesystem) *only after agreeing on portability + security expectations*
4) Stage 4 (timestamp/date)
5) Stage 5 (regex/JSON) via Rust staticlib runtime (preferred)

