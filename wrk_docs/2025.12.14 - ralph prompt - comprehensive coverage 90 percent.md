# Ralph Wiggum Prompt: Comprehensive Test Coverage to 90%+

## Objective

Add comprehensive tests to achieve 90%+ code coverage in:
- `src/llvm/codegen.rs` (currently ~63%)
- `src/llvm/compiler.rs` (currently ~60%)
- `src/parser.rs` (currently ~72%)

## Current Coverage State

| File | Current Coverage | Target | Lines to Cover |
|------|-----------------|--------|----------------|
| llvm/codegen.rs | 63.12% | 90%+ | ~4,500 more lines |
| llvm/compiler.rs | 60.32% | 90%+ | ~60 more lines |
| parser.rs | 72.27% | 90%+ | ~200 more lines |

## Strategy

1. Run coverage analysis to identify uncovered code paths
2. Group uncovered paths by feature area
3. Write targeted tests for each uncovered feature
4. Run tests after each batch to verify coverage improvement
5. Repeat until 90%+ coverage is achieved

## Workflow for Each Batch

```bash
# Run coverage to see current state
cargo llvm-cov --features llvm --test llvm_comprehensive_tests 2>&1 | tail -30

# After adding tests, verify they pass
cargo test --features llvm --test llvm_comprehensive_tests -- --test-threads=4
```

## Uncovered Code Paths to Test

### 1. Import System (codegen.rs:17190-17276)
Currently 0% coverage. Tests needed:
```braw
# Import a module with functions
import "math"
blether floor(3.7)

# Import a module with variables
import "config"
blether default_value

# Import a module with classes
import "models"
ken obj = Model()
blether obj.value
```

**Test file structure required:**
Create test import files in a temp directory and compile with source path set.

### 2. Class System (codegen.rs:18613-18892)
Tests for class features:
```braw
# Basic class with methods
cless Counter {
    dae init() {
        masel.value = 0
    }
    dae increment() {
        masel.value = masel.value + 1
        gie masel.value
    }
    dae get() {
        gie masel.value
    }
}
ken c = Counter()
c.increment()
blether c.get()

# Class with constructor parameters
cless Point {
    dae init(x, y) {
        masel.x = x
        masel.y = y
    }
    dae sum() {
        gie masel.x + masel.y
    }
}
ken p = Point(3, 4)
blether p.sum()

# Method calling another method
cless Calc {
    dae double(n) {
        gie n * 2
    }
    dae quadruple(n) {
        gie masel.double(masel.double(n))
    }
}
ken calc = Calc()
blether calc.quadruple(5)
```

### 3. Pattern Matching (codegen.rs:17485-17592)
Tests for match expressions:
```braw
# Match with literal patterns
ken x = 2
keek x {
    1 => blether "one",
    2 => blether "two",
    3 => blether "three",
    _ => blether "other"
}

# Match with range patterns
ken y = 50
keek y {
    0..10 => blether "small",
    10..100 => blether "medium",
    _ => blether "large"
}

# Match with identifier binding
ken z = 42
keek z {
    1 => blether "one",
    n => blether n
}
```

### 4. Destructuring (codegen.rs:17595-17686)
Tests for destructure patterns:
```braw
# Basic destructure
ken [a, b, c] = [1, 2, 3]
blether a + b + c

# Destructure with rest
ken [first, ...rest] = [1, 2, 3, 4, 5]
blether first
blether len(rest)

# Destructure with ignore
ken [x, _, z] = [10, 20, 30]
blether x + z

# Destructure in for loop
fer [x, y] in [[1, 2], [3, 4], [5, 6]] {
    blether x + y
}
```

### 5. List Spread Operator (codegen.rs:11462-11663)
Tests for spread in lists:
```braw
# Spread list into list
ken a = [1, 2, 3]
ken b = [0, ...a, 4]
blether b

# Multiple spreads
ken x = [1, 2]
ken y = [3, 4]
ken z = [...x, ...y]
blether z

# Spread empty list
ken empty = []
ken result = [...empty, 1, 2]
blether result

# Spread string into list
ken chars = [..."hello"]
blether len(chars)
```

### 6. Advanced String Operations (codegen.rs)
Tests for string functions not yet covered:
```braw
# String repeat
blether repeat("ab", 3)

# String pad (if available)
blether pad("hi", 5, " ")

# String slice
blether slice("hello world", 0, 5)

# char_at function
blether char_at("hello", 1)

# chars function (string to list of chars)
blether chars("hello")
```

### 7. Advanced List Operations (codegen.rs)
Tests for less common list functions:
```braw
# scran (take n elements)
blether scran([1, 2, 3, 4, 5], 3)

# slap (concatenate lists)
blether slap([1, 2], [3, 4])

# shuffle (random order)
ken shuffled = shuffle([1, 2, 3, 4, 5])
blether len(shuffled)

# uniq (unique elements)
blether uniq([1, 2, 2, 3, 3, 3])
```

### 8. Dictionary Advanced Operations (codegen.rs:21161-21466)
Tests for dict map/filter/merge:
```braw
# dram (map dict values)
ken d = {"a": 1, "b": 2}
ken doubled = dram(d, |k, v| v * 2)
blether doubled

# birl (filter dict)
ken nums = {"a": 1, "b": 10, "c": 5}
ken big = birl(nums, |k, v| v > 3)
blether big

# ceilidh (merge dicts)
ken d1 = {"a": 1}
ken d2 = {"b": 2}
ken merged = ceilidh(d1, d2)
blether merged
```

### 9. Math Functions (codegen.rs:20107-20317)
Tests for math intrinsics:
```braw
# atan2
blether atan2(1.0, 1.0)

# radians/degrees
blether radians(180.0)
blether degrees(3.14159)

# pow with negative exponent
blether pow(2.0, -1.0)
```

### 10. Higher-Order Functions Edge Cases (codegen.rs)
Tests for edge cases in map/filter/reduce:
```braw
# Empty list with ilk
blether ilk([], |x| x * 2)

# Empty list with sieve
blether sieve([], |x| x > 0)

# Empty list with tumble
blether tumble([], 0, |acc, x| acc + x)

# Nested ilk
blether ilk([[1, 2], [3, 4]], |inner| ilk(inner, |x| x * 2))
```

### 11. Pipe Operator (codegen.rs:17113-17188)
Tests for pipe chaining:
```braw
# Basic pipe
ken result = [1, 2, 3] |> ilk(|x| x * 2) |> sumaw()
blether result

# Multi-step pipe
ken nums = range(1, 10) |> sieve(|x| x % 2 == 0) |> ilk(|x| x * x) |> sumaw()
blether nums

# Pipe with string
ken upper = "hello" |> upper()
blether upper
```

### 12. Assert Statement (codegen.rs:17324-17404)
Tests for assertions:
```braw
# Assert true
check aye

# Assert with message
check 1 + 1 == 2, "Math is broken"

# Assert equality
check len([1, 2, 3]) == 3

# Assert in function
dae test_func(x) {
    check x > 0, "x must be positive"
    gie x * 2
}
blether test_func(5)
```

### 13. Try-Catch Edge Cases (codegen.rs:17405-17484)
Tests for error handling edge cases:
```braw
# Nested try-catch
hae_a_bash {
    hae_a_bash {
        ken x = 1 / 0
    } gin_it_gangs_wrang e {
        blether "Inner caught"
    }
    blether "Outer continues"
} gin_it_gangs_wrang e {
    blether "Outer caught"
}

# Try-catch with function call
dae risky() {
    ken x = 1 / 0
    gie x
}

hae_a_bash {
    risky()
} gin_it_gangs_wrang e {
    blether "Caught"
}
```

### 14. While Loop Edge Cases (codegen.rs:10790-10844)
Tests for while with break/continue:
```braw
# While with early break
ken i = 0
ken found = -1
fae i < 100 {
    gin i == 42 {
        found = i
        brak
    }
    i = i + 1
}
blether found

# While with continue
ken sum = 0
ken j = 0
fae j < 10 {
    j = j + 1
    gin j % 2 == 0 {
        haud
    }
    sum = sum + j
}
blether sum
```

### 15. For Loop Variations (codegen.rs:10845-11122)
Tests for for loop edge cases:
```braw
# For with range step
fer i in range(0, 10, 2) {
    blether i
}

# For with negative range
fer i in range(10, 0, -1) {
    blether i
}

# Nested for loops
fer i in range(1, 4) {
    fer j in range(1, 4) {
        blether i * j
    }
}
```

### 16. Ternary Expression (codegen.rs:11248-11290)
Tests for conditional expressions:
```braw
# Simple ternary
ken x = 10
ken result = gin x > 5 syne "big" ither "small"
blether result

# Nested ternary
ken y = 50
ken size = gin y < 10 syne "tiny" ither gin y < 100 syne "medium" ither "huge"
blether size

# Ternary in expression
blether "Value: " + (gin aye syne "true" ither "false")
```

### 17. Logical Operators (codegen.rs:7027-7068)
Tests for && and || short-circuit:
```braw
# And short-circuit
ken result = naw && (1/0)  # Should not error
blether gin result syne "yes" ither "no"

# Or short-circuit
ken result2 = aye || (1/0)  # Should not error
blether gin result2 syne "yes" ither "no"

# Complex logical
ken a = 5
ken b = 10
blether (a < b) && (b < 20) || (a == 5)
```

### 18. Function Default Parameters (codegen.rs)
Tests for default arguments:
```braw
dae greet(name, greeting = "Hello") {
    gie greeting + ", " + name + "!"
}

blether greet("World")
blether greet("World", "Hi")

# Multiple defaults
dae calc(a, b = 10, c = 100) {
    gie a + b + c
}
blether calc(1)
blether calc(1, 2)
blether calc(1, 2, 3)
```

### 19. Closures with Mutable Captures (codegen.rs)
Tests for closures modifying captured variables:
```braw
# Counter closure
dae make_counter() {
    ken count = 0
    gie || {
        count = count + 1
        gie count
    }
}
ken counter = make_counter()
blether counter()
blether counter()
blether counter()

# Closure capturing loop variable
ken funcs = []
fer i in range(0, 3) {
    shove(funcs, |x| x + i)
}
```

### 20. Slice Expression (codegen.rs:20514-21103)
Tests for slice syntax:
```braw
# List slice with start and end
ken list = [0, 1, 2, 3, 4, 5]
blether list[1:4]

# List slice from start
blether list[:3]

# List slice to end
blether list[3:]

# List slice with step
blether list[::2]

# Negative indices
blether list[-2:]

# String slice
ken s = "hello world"
blether s[0:5]
```

### 21. Binary Comparison Edge Cases (codegen.rs:1400-1458)
Tests for direct integer comparison paths:
```braw
# Compare integers directly
ken a = 42
ken b = 42
blether a == b
blether a != 0
blether a < 100
blether a <= 42
blether a > 10
blether a >= 42

# Compare with negative numbers
blether -5 < 0
blether -10 >= -10
```

### 22. Type Conversion Edge Cases (codegen.rs)
Tests for type conversion:
```braw
# String to int
blether tae_int("42")
blether tae_int("-123")

# String to float
blether tae_float("3.14")
blether tae_float("-2.5")

# Float to int
blether tae_int(3.7)
blether tae_int(-2.9)

# whit_kind (type introspection)
blether whit_kind(42)
blether whit_kind("hello")
blether whit_kind([1, 2, 3])
blether whit_kind({"a": 1})
blether whit_kind(aye)
blether whit_kind(3.14)
```

### 23. Snooze/Sleep (codegen.rs:20317-20383)
Tests for sleep function:
```braw
# Small sleep
snooze(1)  # 1 millisecond
blether "done"
```

### 24. Get Key (codegen.rs:19104-19121)
Tests for keyboard input (may need mock or skip):
```braw
# Note: get_key is interactive, may need special handling
# blether get_key()
```

### 25. Terminal Dimensions (codegen.rs:19122-19169)
Tests for terminal size:
```braw
# Get terminal dimensions
blether term_width()
blether term_height()
```

## Parser Coverage Improvements

### 1. Error Recovery
Test parser error messages for:
- Missing closing braces
- Missing semicolons
- Invalid tokens
- Unexpected EOF

### 2. Edge Cases
```braw
# Empty function body
dae empty() {
}

# Empty class
cless Empty {
}

# Multiple statements on one line (if supported)
ken a = 1; ken b = 2

# Deeply nested expressions
blether ((((1 + 2) * 3) - 4) / 5)
```

## Test File Organization

Add new test modules to `tests/llvm_comprehensive_tests.rs`:

```rust
// New modules to add
mod imports { ... }
mod classes { ... }
mod pattern_matching { ... }
mod destructuring { ... }
mod spread_operator { ... }
mod advanced_strings { ... }
mod advanced_lists { ... }
mod dict_advanced { ... }
mod math_advanced { ... }
mod higher_order_edge_cases { ... }
mod pipe_advanced { ... }
mod assert_tests { ... }
mod try_catch_edge_cases { ... }
mod while_edge_cases { ... }
mod for_variations { ... }
mod ternary_tests { ... }
mod logical_operators { ... }
mod default_params { ... }
mod closures_mutable { ... }
mod slice_tests { ... }
mod comparison_edge_cases { ... }
mod type_conversion_edge { ... }
mod timing_tests { ... }
mod terminal_tests { ... }
```

## Execution Plan

### Phase 1: Quick Wins (get to 75%)
1. Add class tests
2. Add pattern matching tests
3. Add default parameter tests
4. Add ternary expression tests

### Phase 2: Medium Effort (get to 85%)
1. Add destructuring tests
2. Add spread operator tests
3. Add slice expression tests
4. Add higher-order function edge cases
5. Add pipe operator tests

### Phase 3: Full Coverage (get to 90%+)
1. Add import system tests (requires file setup)
2. Add all remaining edge cases
3. Add error path tests
4. Add terminal function tests

## Verification

After each phase, run:
```bash
cargo llvm-cov --features llvm --test llvm_comprehensive_tests 2>&1 | grep -E "codegen|compiler|parser"
```

Target metrics:
- codegen.rs: 90%+
- compiler.rs: 90%+
- parser.rs: 90%+

## Completion Promise

When `cargo llvm-cov --features llvm --test llvm_comprehensive_tests` shows:
- codegen.rs at 90%+ line coverage
- compiler.rs at 90%+ line coverage (note: JS compiler, may be lower priority)
- parser.rs at 90%+ line coverage

The task is complete.

## Notes

- Scottish dialect keywords: blether=print, ken=let, gin=if, ither=else, gie=return, dae=function, cless=class, masel=self, aye=true, naw=false, fae=while, fer=for, keek=match, hae_a_bash=try, gin_it_gangs_wrang=catch, brak=break, haud=continue
- Run tests with `--test-threads=4` for faster execution
- Some tests may need temp files for imports
- Terminal tests may need to be skipped in CI

## Hints

- If a test fails with "Undefined variable", check if the function exists in the LLVM backend
- If a test produces empty output, check if the value type is being printed correctly
- Focus on codegen.rs first as it has the most uncovered lines
- The compiler.rs file is the JavaScript compiler - lower priority than LLVM backend
