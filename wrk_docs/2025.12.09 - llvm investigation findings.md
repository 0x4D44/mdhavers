# LLVM Backend Investigation Findings

## Date: December 9, 2025

## Value Representation

The mdhavers LLVM backend uses a **tagged union** representation:

```llvm
{ i8 tag, i64 data }
```

- `tag` (i8): Type discriminator (0=Nil, 1=Bool, 2=Int, 3=Float, 4=String, 5=List, etc.)
- `data` (i64): The value data (integer, or pointer/float bitcast to i64)

This is stored in every variable via `alloca { i8, i64 }`.

## Problem Analysis: Simple Loop

For a simple loop:
```
ken sum = 0
ken i = 0
whiles i < 1000 {
    sum = sum + i
    i = i + 1
}
```

### Loop Condition Check (`i < 1000`)

The generated IR shows:
1. Load the tagged value from `%i`
2. Extract data for comparison
3. Do the comparison `icmp slt i64 %data, 1000`
4. **Create a new tagged bool**: `insertvalue { i8, i64 } { i8 1, i64 undef }, i64 %bool_ext, 1`
5. **Then extract the tag and check is_truthy via a switch statement**:
   - switch on tag to is_nil, is_bool, is_int, is_other
   - Each branch goes to truthy_merge with phi

**Issue**: The comparison result is already a boolean, but we box it into MdhValue then immediately unbox it via is_truthy. This adds ~10+ instructions of overhead.

### Addition (`sum = sum + i`)

Each addition generates:
1. Load sum tagged value
2. Load i tagged value
3. Extract both tags
4. Extract both data
5. **6 comparisons** to check types (is_int, is_float, is_string for both operands)
6. **3 logical AND/OR** operations
7. **Branch cascade**: check_int -> check_float -> check_string -> error
8. In the int+int case:
   - One `add i64` instruction (the actual work!)
   - `insertvalue` to create new tagged value
9. Branch to merge
10. Store result

**Issue**: For `int + int`, we execute 15+ instructions of type checking for 1 instruction of actual work.

### Increment (`i = i + 1`)

Same pattern as above, but slightly optimized since `1` is a literal:
- Still checks if `i` is int/float/string
- The right operand type checks are partially constant-folded
- Still ~10+ instructions of overhead

## Key Performance Bottlenecks

### 1. Redundant Type Checks in Loops

Every iteration repeats all type checks, even though:
- Variables don't change type during the loop
- Literal values have known types

### 2. is_truthy Switch Statement

Every condition check goes through a 4-way switch:
```llvm
switch i8 %tag, label %is_other [
    i8 0, label %is_nil
    i8 1, label %is_bool
    i8 2, label %is_int
]
```

For a simple `i < 1000` where both are known ints, this could be a single `icmp slt`.

### 3. Boxing/Unboxing Overhead

Every operation:
1. Extracts tag and data from MdhValue
2. Does the operation
3. Creates a new MdhValue via insertvalue
4. Stores it back

For integer arithmetic, we could work directly with i64 values.

### 4. No Type Inference/Specialization

The codegen doesn't track that:
- `ken sum = 0` means sum is Int
- `ken i = 0` means i is Int
- `i < 1000` is always Bool
- `sum + i` where both are Int is always Int

## Comparison: for vs whiles

The `for_range` implementation IS optimized:
```rust
// Create counter
let counter_alloca = self.builder.build_alloca(self.types.i64_type, "counter").unwrap();
```

It uses an **unboxed i64 counter** and only boxes when updating the loop variable for user code access. This is much faster.

But `whiles` loops use the generic path with full type checking.

## Optimization Strategy

### Quick Win: Optimize whiles for Integer Conditions

Detect pattern: `while VAR < LITERAL` where VAR is initialized as integer.

Generate:
```llvm
loop:
  %counter = load i64, ptr %counter_alloca
  %cmp = icmp slt i64 %counter, 1000
  br i1 %cmp, label %body, label %after
```

Instead of the switch-based is_truthy.

### Medium Win: Add Type Tracking

Track `InferredType` for variables during codegen:
- Literal assignments: `ken x = 0` → x is Int
- Arithmetic on ints: `x + y` where both Int → result is Int
- Use fast path when types are known

### Big Win: Loop Fast Path

When a loop counter is known-integer with integer bounds:
1. Use unboxed i64 for counter internally
2. Use direct i64 arithmetic for increment
3. Only box when needed for function calls or prints

## Estimated Impact

| Optimization | Complexity | Impact |
|-------------|-----------|--------|
| Skip is_truthy for comparisons | Low | 2-3x for loops |
| Unboxed integer arithmetic | Medium | 5-10x for integer math |
| Loop counter fast path | Medium | 10-50x for simple loops |
| Full type inference | High | Variable |

## Next Steps

1. Implement comparison optimization (skip boxing bool result)
2. Add InferredType tracking to CodeGen
3. Generate specialized integer fast paths
4. Benchmark improvements
