# mdhavers tri 3D Graphics Library Spec

Date: 2025-12-19
Author: Codex (drafted for mdhavers)

## 1. Overview
"tri" is a three.js-semantics 3D graphics library for mdhavers with Scots naming. It must work across all targets (interpreter, JS, LLVM, WAT) and provide full native linkage (single complete binaries) when running outside the browser. The API mirrors three.js behavior, while class/method names use Scots words where possible; property names remain English for compatibility (e.g., position/rotation/scale).

Module usage (fixed decision):
```
fetch "tri" tae tri
```

## 2. Goals
- Provide three.js-equivalent semantics: scene graph, transforms, materials, lights, renderer, textures, animation, loaders.
- Strict Scots naming for types/functions, English for common properties.
- Consistent behavior across all targets (interpreter, JS, LLVM, WAT).
- Native integration: interpreter and LLVM targets do not depend on external runtimes.
- JS target uses installed three.js (assumed available).
- WAT target supported via a native host runner with wgpu (single-binary runtime).

## 3. Non-goals (initially)
- Perfect feature parity with every three.js addon or post-processing pass.
- Browser-only APIs (DOM, CSS) outside of JS target.
- Instant full WAT compiler parity with the interpreter (handled in phases).

## 4. Naming policy (Scots-first)
- Use real Scots words where available; fallback to English when unclear.
- Keep English property names for three.js familiarity and compatibility.

Suggested mapping (editable but serves as baseline):
- Scene -> Sicht
- Object3D -> Thing3D
- Group -> Clump
- Mesh -> Mesch
- Camera -> Kamera
- PerspectiveCamera -> PerspectivKamera
- OrthographicCamera -> OrthograffikKamera
- Geometry -> Geometrie
- BoxGeometry -> BoxGeometrie
- SphereGeometry -> SpherGeometrie
- Material -> Maiterial
- MeshBasicMaterial -> MeshBasicMaiterial
- MeshStandardMaterial -> MeshStandardMaiterial
- Light -> Licht
- AmbientLight -> AmbiantLicht
- DirectionalLight -> DireksionalLicht
- PointLight -> PyntLicht
- Texture -> Textur
- Color -> Colour
- Renderer -> Renderar

Method naming examples:
- add -> adde
- remove -> remuiv
- clone -> cloan
- dispose -> dyspos
- lookAt -> luik_at
- setSize -> set_sise
- setPixelRatio -> set_pixel_ratio
- render -> render
- loop -> loop (or Scots alias if desired later)

Properties remain English:
- position, rotation, scale, matrix, matrixWorld, quaternion, visible, children, material, geometry, etc.

## 5. Module shape and API surface
### 5.1 Module export (tri)
`fetch "tri" tae tri` returns a dict-like module with constructors and helpers.

Exports (initial set):
- Classes: Sicht, Thing3D, Clump, Mesch, Kamera, PerspectivKamera, OrthograffikKamera,
  Geometrie, BoxGeometrie, SpherGeometrie, Maiterial, MeshBasicMaiterial,
  MeshStandardMaiterial, Licht, AmbiantLicht, DireksionalLicht, PyntLicht, Textur,
  Renderar, Colour
- Functions: load_gltf (later), make_colour (alias), maybe new_vec3 if needed
- Constants: DEG_TO_RAD, RAD_TO_DEG (optional)

### 5.2 Example usage
```scots
fetch "tri" tae tri

ken sicht = tri.Sicht()
ken kamera = tri.PerspectivKamera(75, 16/9, 0.1, 1000)
ken renderar = tri.Renderar({ width: 800, height: 600, antialias: aye })

ken geom = tri.BoxGeometrie(1, 1, 1)
ken mat = tri.MeshStandardMaiterial({ color: "#44aaff" })
ken mesch = tri.Mesch(geom, mat)

sicht.adde(mesch)
kamera.position.z = 5

renderar.loop(|dt| {
  mesch.rotation.y += 0.01
  renderar.render(sicht, kamera)
})
```

### 5.3 Semantics alignment with three.js
- Right-handed coordinate system, +Y up, +Z out of screen (matches three.js).
- Rotations are radians.
- Object3D defaults: matrixAutoUpdate = true, visible = true.
- Materials default to three.js-style parameters.
- Colour uses sRGB conversion if needed (renderer config handles output encoding).

## 6. Runtime architecture (native)
### 6.1 Core engine
- WGPU-based engine managing device, queue, surface, pipelines, bind groups.
- Resource registry with handles for geometry, material, texture, mesh, light, camera, scene.
- Scene graph with Object3D nodes, hierarchical transforms, and lazy world-matrix updates.

### 6.2 NativeObject hooks (interpreter)
Introduce a native object interface to fully support property semantics:
- Value::NativeObject(Arc<dyn NativeObject>)
- NativeObject trait:
  - type_name() -> &str
  - get(prop: &str) -> Option<Value>
  - set(prop: &str, val: Value) -> Result<Value, HaversError>
  - call(method: &str, args: Vec<Value>) -> Result<Value, HaversError>
  - optional: to_string(), equals(), clone_handle()

Interpreter changes:
- Expr::Get: if object is NativeObject, call get(prop) before dict/instance handling.
- Expr::Set: if object is NativeObject, call set(prop, val) before dict/instance.
- Expr::Call: if callee is Get on NativeObject, route to call(method,...).

This makes `mesch.position.x = 1` a live update, not a stored field.

### 6.3 Render loop
- renderar.render(scene, camera): draw one frame + poll events.
- renderar.poll_events() or renderar.tick(): optional event pump (manual control).
- renderar.loop(fn): helper implemented in stdlib (calls renderar.render in a loop).

## 7. Target-specific implementation
### 7.1 Interpreter (Rust)
- New feature flag: `graphics3d` (wgpu + winit + glam).
- New module: `src/graphics3d.rs` (or `src/tri.rs`) with function registration into globals.
- `fetch "tri"` returns a module dict (native) in interpreter; not a .braw file.

### 7.2 JavaScript target
- Compiler injects adapter that maps Scots names to THREE classes.
- Assumes `three` is available globally or via require:
  - `const THREE = globalThis.THREE ?? require('three');`
- `tri` module created as a JS object with Scots constructors and helper methods.

### 7.3 LLVM target
- Extend runtime C/Rust to host wgpu engine, same as interpreter.
- Add new runtime functions for tri module creation and object operations.
- Extend `src/llvm/builtins.rs` and `runtime.rs` to declare tri functions.
- Implement module resolution for `fetch "tri"` by linking to native runtime calls.

### 7.4 WAT target (full native linkage requirement)
WAT cannot run standalone; it needs a host. To satisfy "single complete binaries":
- Provide a native **mdhavers WASM runner** that embeds the WASM module and implements all imports.
- The runner includes the same wgpu engine used by interpreter/LLVM.

Plan:
- Expand WAT compiler to support objects/dicts/property access needed by tri usage.
- Provide a set of imports such as:
  - __mdh_tri_new_scene
  - __mdh_tri_new_mesh
  - __mdh_tri_get_prop / __mdh_tri_set_prop
  - __mdh_tri_render
- Bundle a host runner that loads WAT/WASM and wires these imports.

## 8. Proposed file layout
- src/graphics3d.rs (new)
- src/tri.rs (optional wrapper)
- stdlib/tri.braw (optional pure-stdlib helpers / aliases)
- runtime/mdh_runtime_rs/src/tri.rs (native runtime bridge)
- runtime/mdh_runtime.c (if C runtime needs hooks)
- src/compiler.rs (JS adapter injection for tri)
- src/wasm_compiler.rs (new import support)
- src/llvm/{builtins.rs,runtime.rs,codegen.rs} (tri runtime hooks)

## 9. Phased roadmap
### Phase 1: Core plumbing (2-4 weeks)
- NativeObject support in interpreter.
- WGPU engine bootstrap + window creation.
- tri module with Sicht, Thing3D, Mesch, Kamera, Renderar.
- Render loop (render + loop).

### Phase 2: Materials, lights, textures (2-4 weeks)
- MeshStandardMaiterial, AmbiantLicht, DireksionalLicht.
- Texture loading, basic PBR pipeline.

### Phase 3: Loaders + animation (4-6 weeks)
- GLTF loader, animation mixer, skinning.

### Phase 4: WAT expansion + host runner (4-8 weeks)
- WAT object support + tri imports.
- Native WASM runner with wgpu.

## 10. Testing and validation
- Unit tests for NativeObject get/set/call routing.
- Integration test: spinning cube in interpreter (headless smoke test if possible).
- JS output test: compile tri example and run with three.js.
- LLVM runtime test: minimal scene renders and exits cleanly.
- WAT runner test: load WAT module and render basic scene.

## 11. Risks and mitigations
- WGPU event loop: ensure cross-platform support (winit run_return).
- Interpreter callback patterns: avoid calling into mdhavers from native render thread.
- WAT compiler expansion complexity: isolate tri support if needed.
- Resource cleanup: enforce explicit dyspos() and avoid leaks.

## 12. Open questions (to resolve as we implement)
- Final Scots lexicon for any ambiguous names.
- Exact renderer defaults (sRGB, tone mapping).
- Whether to include post-processing in v1.
- Mobile platform support (optional).

---

Decision log (as of 2025-12-19)
- Module strategy: explicit `fetch "tri"` (namespaced).
- Scots naming: actual Scots where possible, English fallback; property names remain English.
- JS target: assume three.js available.
- WAT target: supported via native host runner with wgpu.
- Interpreter hooks: approved and required for three.js semantics.
