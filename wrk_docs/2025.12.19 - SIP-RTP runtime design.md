# mdhavers runtime changes for a multi-threaded SIP/RTP stack

Date: 2025.12.19
Author: Codex (design draft)

## 0. Summary

This document defines a full runtime design to make mdhavers capable of building a real multi-threaded SIP/RTP stack. The current runtime is single-threaded, lacks real sockets, lacks an event loop, and offers only simulated async/scheduler constructs. To support SIP/RTP we need:

- Real UDP/TCP sockets and DNS resolution.
- Non-blocking I/O + event loop with timers.
- Threads and synchronization primitives.
- A thread-safe memory model and GC integration.
- Efficient byte buffers with slicing and endian helpers.
- Monotonic time, timer wheels, and jitter-friendly scheduling.
- Production-grade crypto bindings (for TLS/DTLS/SRTP).
- A consistent FFI layer (C + Rust) for system calls.

This is a runtime architecture change spanning C runtime, LLVM codegen, interpreter, and stdlib.

---

## 1. Requirements and constraints

### 1.1 SIP/RTP runtime requirements

- UDP sockets for SIP and RTP/RTCP transport.
- TCP/TLS support for SIP over TCP/TLS and WebSocket variants (optional but common).
- DNS A/AAAA/SRV/NAPTR resolution for SIP endpoints and failover.
- Non-blocking I/O and event multiplexing.
- Timers and timer cancellation for SIP transactions, retransmits, and RTP scheduling.
- High-resolution monotonic clock for jitter/RTT and RTP timestamps.
- Concurrency for call handling, media mixing, and control-plane tasks.
- Efficient packet parsing/serialization (byte buffers, zero-copy where possible).
- Crypto for TLS and SRTP (DTLS-SRTP or SDES).

### 1.2 Current limitations

- No real network sockets (stdlib provides simulated network).
- No async/await and only synchronous sleep in interpreter/LLVM.
- No threads or synchronization primitives exposed to mdhavers.
- Runtime uses GC but is not explicitly thread-safe.
- No byte buffer type; lists of integers are too slow.

### 1.3 Goals

- Introduce a minimal but complete runtime API enabling real network I/O and concurrency.
- Keep language surface small: build primitives in runtime and compose in stdlib.
- Preserve deterministic behavior when running on single thread.
- Ensure portability across Linux and macOS (Windows optional but design-ready).

### 1.4 Non-goals

- Rewriting the whole compiler.
- Implementing a full SIP/RTP stack in stdlib.
- Guaranteeing lock-free performance on all targets.

---

## 2. High-level architecture

### 2.1 Runtime layering

1) Core runtime (C)
   - Value model, GC, threading primitives, socket I/O, event loop, timers.

2) Rust runtime shim (existing JSON/regex; extend or optional)
   - Optional: DNS, TLS/DTLS, SRTP crypto implemented in Rust for safety.

3) LLVM backend
   - Adds new builtins and intrinsic bindings to runtime functions.

4) Interpreter
   - Mirrors builtins and concurrency behavior (with real threads).

5) Stdlib
   - SIP primitives, RTP helpers, timers, channels, queue/actor patterns.

### 2.2 Concurrency model

Adopt a hybrid model:

- Runtime-managed threads: explicit spawn/join for long-lived tasks.
- Event loop: non-blocking I/O + timer scheduling + callbacks.
- Channels: message passing between threads and event loop.

This matches SIP/RTP needs: the I/O plane is event-driven; CPU-heavy tasks (e.g., codec/transcoding) run in threads.

---

## 3. Runtime API design (C)

### 3.1 Threading and synchronization

Add a new header section to runtime/mdh_runtime.h:

```
// Thread handles
typedef struct MdhThread MdhThread;

MdhValue __mdh_thread_spawn(MdhValue func, MdhValue args_list);
MdhValue __mdh_thread_join(MdhValue thread_handle);
MdhValue __mdh_thread_detach(MdhValue thread_handle);

// Mutex
typedef struct MdhMutex MdhMutex;
MdhValue __mdh_mutex_new(void);
MdhValue __mdh_mutex_lock(MdhValue mutex);
MdhValue __mdh_mutex_unlock(MdhValue mutex);
MdhValue __mdh_mutex_try_lock(MdhValue mutex);

// Condvar
typedef struct MdhCondvar MdhCondvar;
MdhValue __mdh_condvar_new(void);
MdhValue __mdh_condvar_wait(MdhValue condvar, MdhValue mutex);
MdhValue __mdh_condvar_timed_wait(MdhValue condvar, MdhValue mutex, MdhValue timeout_ms);
MdhValue __mdh_condvar_signal(MdhValue condvar);
MdhValue __mdh_condvar_broadcast(MdhValue condvar);

// Atomics
MdhValue __mdh_atomic_new(MdhValue initial_int);
MdhValue __mdh_atomic_load(MdhValue atomic);
MdhValue __mdh_atomic_store(MdhValue atomic, MdhValue value);
MdhValue __mdh_atomic_add(MdhValue atomic, MdhValue delta);
MdhValue __mdh_atomic_cas(MdhValue atomic, MdhValue expected, MdhValue desired);
```

Design notes:

- Thread handles are boxed runtime objects stored in MdhValue tag MDH_TAG_INSTANCE or a new tag.
- Only integer atomics initially; later extend to pointer-like values if needed.
- spawn accepts a function and argument list; runtime creates a new interpreter/VM context.

### 3.2 Channels (message passing)

```
// Channel
typedef struct MdhChan MdhChan;
MdhValue __mdh_chan_new(MdhValue capacity_int); // capacity 0 = unbounded
MdhValue __mdh_chan_send(MdhValue chan, MdhValue value);
MdhValue __mdh_chan_recv(MdhValue chan); // blocks
MdhValue __mdh_chan_try_recv(MdhValue chan); // returns nil if empty
MdhValue __mdh_chan_close(MdhValue chan);
MdhValue __mdh_chan_is_closed(MdhValue chan);
```

Channels should be thread-safe and support blocking receive (for worker threads). Provide try_recv for non-blocking event loop integration.

### 3.3 Sockets (UDP/TCP)

```
// Socket handle
typedef struct MdhSocket MdhSocket;

MdhValue __mdh_socket_udp(void);
MdhValue __mdh_socket_tcp(void);
MdhValue __mdh_socket_bind(MdhValue sock, MdhValue host, MdhValue port);
MdhValue __mdh_socket_connect(MdhValue sock, MdhValue host, MdhValue port);
MdhValue __mdh_socket_listen(MdhValue sock, MdhValue backlog);
MdhValue __mdh_socket_accept(MdhValue sock); // returns dict {sock, addr}
MdhValue __mdh_socket_set_nonblocking(MdhValue sock, MdhValue on);
MdhValue __mdh_socket_close(MdhValue sock);

// UDP send/recv
MdhValue __mdh_udp_send_to(MdhValue sock, MdhValue buf, MdhValue host, MdhValue port);
MdhValue __mdh_udp_recv_from(MdhValue sock, MdhValue max_len); // returns dict {buf, addr}

// TCP send/recv
MdhValue __mdh_tcp_send(MdhValue sock, MdhValue buf);
MdhValue __mdh_tcp_recv(MdhValue sock, MdhValue max_len);

// Socket options
MdhValue __mdh_socket_set_reuseaddr(MdhValue sock, MdhValue on);
MdhValue __mdh_socket_set_reuseport(MdhValue sock, MdhValue on);
MdhValue __mdh_socket_set_ttl(MdhValue sock, MdhValue ttl);
MdhValue __mdh_socket_set_nodelay(MdhValue sock, MdhValue on);
MdhValue __mdh_socket_set_rcvbuf(MdhValue sock, MdhValue bytes);
MdhValue __mdh_socket_set_sndbuf(MdhValue sock, MdhValue bytes);
```

### 3.4 DNS resolution

```
MdhValue __mdh_dns_lookup(MdhValue host);        // returns list of IPs
MdhValue __mdh_dns_srv(MdhValue service, MdhValue domain); // list of {priority, weight, port, target}
MdhValue __mdh_dns_naptr(MdhValue domain);       // list of naptr entries
```

Implementation can use getaddrinfo for A/AAAA and res_nquery or a Rust DNS library for SRV/NAPTR.

### 3.5 Event loop and timers

```
typedef struct MdhEventLoop MdhEventLoop;

MdhValue __mdh_event_loop_new(void);
MdhValue __mdh_event_loop_run(MdhValue loop);
MdhValue __mdh_event_loop_stop(MdhValue loop);

// Register readable/writable interest
MdhValue __mdh_event_watch_read(MdhValue loop, MdhValue sock, MdhValue callback);
MdhValue __mdh_event_watch_write(MdhValue loop, MdhValue sock, MdhValue callback);
MdhValue __mdh_event_unwatch(MdhValue loop, MdhValue sock);

// Timers
MdhValue __mdh_timer_after(MdhValue loop, MdhValue ms, MdhValue callback);
MdhValue __mdh_timer_every(MdhValue loop, MdhValue ms, MdhValue callback);
MdhValue __mdh_timer_cancel(MdhValue loop, MdhValue timer_id);
```

Implementation strategy:

- Use epoll on Linux, kqueue on macOS, fallback to poll if needed.
- Use a timer wheel or min-heap for timers (heap is fine for MVP).
- All callbacks execute on the event loop thread.

### 3.6 Byte buffer type

Introduce a new runtime-backed buffer type MDH_TAG_BYTES:

```
typedef struct MdhBytes {
    uint8_t *data;
    int64_t len;
    int64_t cap;
} MdhBytes;

MdhValue __mdh_bytes_new(MdhValue size);
MdhValue __mdh_bytes_from_string(MdhValue str); // UTF-8
MdhValue __mdh_bytes_len(MdhValue bytes);
MdhValue __mdh_bytes_slice(MdhValue bytes, MdhValue start, MdhValue end);
MdhValue __mdh_bytes_get(MdhValue bytes, MdhValue idx);
MdhValue __mdh_bytes_set(MdhValue bytes, MdhValue idx, MdhValue val);
MdhValue __mdh_bytes_append(MdhValue bytes, MdhValue other);

// Endian helpers
MdhValue __mdh_bytes_read_u16be(MdhValue bytes, MdhValue off);
MdhValue __mdh_bytes_read_u32be(MdhValue bytes, MdhValue off);
MdhValue __mdh_bytes_write_u16be(MdhValue bytes, MdhValue off, MdhValue val);
MdhValue __mdh_bytes_write_u32be(MdhValue bytes, MdhValue off, MdhValue val);
```

RTP and SIP use network byte order. These helpers avoid manual shifts in mdhavers.

### 3.7 Time and clocks

Add monotonic time APIs in runtime:

```
MdhValue __mdh_mono_ms(void);   // CLOCK_MONOTONIC ms
MdhValue __mdh_mono_ns(void);   // CLOCK_MONOTONIC ns
```

noo() remains wall-clock for timestamps; mono_* used for RTT/jitter.

### 3.8 Crypto and TLS/DTLS/SRTP hooks

Expose runtime functions as stubs initially, implemented via Rust/FFI:

```
// TLS (SIP over TLS)
MdhValue __mdh_tls_client_new(MdhValue config);
MdhValue __mdh_tls_connect(MdhValue tls, MdhValue sock);
MdhValue __mdh_tls_send(MdhValue tls, MdhValue buf);
MdhValue __mdh_tls_recv(MdhValue tls, MdhValue max_len);
MdhValue __mdh_tls_close(MdhValue tls);

// DTLS + SRTP
MdhValue __mdh_dtls_server_new(MdhValue config);
MdhValue __mdh_dtls_handshake(MdhValue dtls, MdhValue sock);
MdhValue __mdh_srtp_create(MdhValue keys);
MdhValue __mdh_srtp_protect(MdhValue srtp, MdhValue rtp_packet);
MdhValue __mdh_srtp_unprotect(MdhValue srtp, MdhValue rtp_packet);
```

Implementation is likely in Rust using rustls/openssl or ring/srtp bindings. The C runtime can call into Rust with an FFI boundary.

---

## 4. GC and thread safety

### 4.1 Boehm GC integration

Current runtime uses Boehm GC without thread registration. For threads:

- Call GC_init() once at startup.
- Ensure each new runtime thread calls GC_register_my_thread (or GC_register_my_thread on creation and GC_unregister_my_thread on exit).
- Ensure the GC is compiled with --enable-threads and linked appropriately.

### 4.2 Shared data structures

- MdhList, MdhDict, MdhString are not thread-safe; concurrent access must be locked or restricted to thread-local use.
- For SIP/RTP, prefer message passing with MdhChan and per-thread ownership of buffers.
- Provide a bytes type to reduce shared mutable structures.

### 4.3 Interpreter state per thread

- Each thread should have its own interpreter Environment and stack.
- Globals can be shared as read-only; mutable shared globals require explicit locks.

---

## 5. LLVM backend changes

### 5.1 New runtime declarations

Update src/llvm/runtime.rs to declare all new runtime functions listed above.

### 5.2 Builtin bindings

Update src/llvm/codegen.rs to compile new builtins:

- spawn, join, detach
- mutex_new, mutex_lock, mutex_unlock, mutex_try_lock
- condvar_new, condvar_wait, condvar_timed_wait, condvar_signal, condvar_broadcast
- chan_new, chan_send, chan_recv, chan_try_recv, chan_close, chan_is_closed
- Socket family: udp_socket, tcp_socket, bind, connect, listen, accept, send, recv, send_to, recv_from
- event_loop, watch_read, watch_write, timer_after, timer_every, timer_cancel
- bytes_* operations
- mono_ms, mono_ns

For each builtin, validate argument count and types, then call runtime function. Use type errors consistent with current style.

### 5.3 Value tagging

- Add MDH_TAG_BYTES (e.g., tag 13) in src/llvm/types.rs, runtime/mdh_runtime.h, and any value switch statements.
- Ensure __mdh_to_string handles bytes sensibly (e.g., hex dump or UTF-8 attempt).

---

## 6. Interpreter changes

### 6.1 Add builtins matching runtime

Implement new native functions in src/interpreter.rs:

- Threading primitives using std::thread and std::sync.
- Channels with std::sync::mpsc or crossbeam_channel.
- Sockets with std::net (UDP/TCP) and DNS using ToSocketAddrs or trust-dns.
- Event loop: optional implementation in interpreter using mio or a simpler poll loop.
- Bytes type: implement as a new Value::Bytes(Vec<u8>) with slices and endian ops.
- Monotonic time: std::time::Instant plus conversion to ms/ns.

### 6.2 Interpreter API shape

Keep API names identical across interpreter and LLVM to avoid mismatched behavior.

---

## 7. Stdlib changes

### 7.1 New network_real.braw

Provide a real networking stdlib wrapper with:

- udp_socket(), tcp_socket()
- send_to(sock, buf, host, port), recv_from(sock, max_len)
- connect, listen, accept helpers
- set_nonblocking, set_ttl, set_nodelay

### 7.2 New concurrency.braw

Provide ergonomic wrappers:

- spawn(fn, args)
- channel(capacity) returning {send, recv, close}
- mutex and with_lock helpers

### 7.3 New bytes.braw

Expose byte buffer helpers:

- bytes(n)
- bytes_from_string(s)
- read_u16be, write_u16be, etc.
- concat_bytes(a, b)

### 7.4 SIP/RTP utility modules (optional)

- sip.braw: parsing and message construction using bytes/string helpers.
- rtp.braw: header encode/decode, sequence, timestamp helpers.
- rtcp.braw: minimal receiver reports.

---

## 8. Event loop details

### 8.1 Data structures

- MdhEventLoop holds:
  - OS selector handle (epoll/kqueue/poll).
  - Map of fd -> callbacks (read/write).
  - Timer min-heap (deadline, periodic interval, callback).

### 8.2 Callback invocation

Callbacks run on the loop thread and receive structured dictionaries:

- Read event: {sock, readable: aye}
- Write event: {sock, writable: aye}
- Timer: {timer_id, due_at, now}

### 8.3 Cancellation and safety

- __mdh_event_unwatch removes all watchers for fd.
- Timers are cancelable by ID.
- All callbacks are executed with panic/exception protection; errors should not kill the loop.

---

## 9. Socket I/O semantics

### 9.1 UDP

- udp_recv_from returns {buf, addr} where addr is {host, port}.
- buf is a bytes value; zero-copy slice can be returned from a pooled buffer.

### 9.2 TCP

- tcp_recv returns bytes. For EOF return empty bytes or naething and set eof in dict.
- accept returns {sock, addr}.

### 9.3 Error handling

Use consistent error returns:

- If an I/O operation fails, return a dict: {ok: nae, error: "message", code: errno}
- On success: {ok: aye, value: ...}

Alternatively use exceptions; for SIP/RTP a result dict is often easier to handle in an event loop.

---

## 10. DNS and SIP specifics

SIP uses NAPTR/SRV for service discovery.

- Implement dns_naptr and dns_srv in Rust using trust-dns-resolver.
- Provide a helper in stdlib sip_resolve(domain, transport) that performs NAPTR->SRV->A/AAAA resolution.

---

## 11. Crypto and security

### 11.1 TLS for SIP

- Use Rust rustls or openssl for TLS client/server.
- Provide a tls_config dict with cert/key and cipher suites.
- TLS socket wraps an existing TCP socket.

### 11.2 SRTP

- Add minimal SRTP interface for protect/unprotect.
- Keys negotiated via DTLS or SDES (DTLS recommended).

### 11.3 Randomness

Use OS CSPRNG in runtime (getrandom or rand in Rust) for key material and RTP SSRC.

---

## 12. Backwards compatibility

- Existing synchronous functions remain.
- network.braw remains as simulated module for toy programs.
- New runtime functions are additive.

---

## 13. Testing strategy

### 13.1 Unit tests

- Thread creation, join, mutex, condvar, atomic operations.
- Channels: send/recv, close behavior, try_recv.
- Bytes: endian helpers and bounds checks.
- Socket: UDP loopback send/recv; TCP accept/connect.
- DNS: local resolver stub or integration test with known domain.

### 13.2 Integration tests

- SIP: send REGISTER to a local mock server (loopback UDP) with timers.
- RTP: send/recv packets on loopback; validate sequence/timestamp.
- Event loop: timer + socket readability mix.

---

## 14. Milestone plan

1) M1: Bytes + monotonic time
   - Add MDH_TAG_BYTES, helpers, and mono_ms/mono_ns in runtime and interpreter.

2) M2: UDP/TCP sockets + DNS (A/AAAA)
   - Implement sockets; minimal DNS getaddrinfo.

3) M3: Event loop + timers
   - Add epoll/kqueue/poll selector and timers.

4) M4: Threads + channels
   - Thread spawn/join + mutex/condvar/atomic, channels.

5) M5: TLS/DTLS/SRTP
   - Rust-based crypto bindings.

6) M6: Stdlib SIP/RTP helpers
   - Protocol parsing and message building.

---

## 15. Open questions

- Should the event loop be a first-class runtime singleton, or multiple loops per thread?
- Do we require async/await syntax in the language, or keep explicit callback-based APIs?
- Should bytes be mutable (for performance) or immutable (for safety)?
- Should the runtime provide a memory pool for packet buffers to reduce GC pressure?

---

## 16. Appendix: mdhavers API sketch (user-facing)

```
ken loop = event_loop()
ken sock = udp_socket()
bind(sock, "0.0.0.0", 5060)
set_nonblocking(sock, aye)

watch_read(loop, sock, |ev| {
    ken pkt = recv_from(sock, 2048)
    gin pkt["ok"] {
        handle_sip(pkt["value"]["buf"], pkt["value"]["addr"])
    }
})

timer_every(loop, 50, |t| { sip_tick() })

run(loop)
```

---

End of design.
