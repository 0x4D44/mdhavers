# Ralph Wiggum Prompt: LLVM Backend Fixes and Full Test Coverage

## Objective

Fix all 42 failing tests in the LLVM backend and add comprehensive tests to achieve near-100% code coverage of `src/llvm/codegen.rs`.

## Current State

- **Total tests:** 183
- **Passing:** 141
- **Failing:** 42

## Failing Tests to Fix

### Category 1: List Operations (15 tests)
```
lists::test_empty_list
lists::test_list_assignment
lists::test_list_contains
lists::test_list_heid_tail
lists::test_list_index_of
lists::test_list_literal
lists::test_list_min_max
lists::test_list_negative_index
lists::test_list_pop
lists::test_list_push
lists::test_list_reverse
lists::test_list_slice
lists::test_list_sort
lists::test_list_sum
lists::test_list_uniq
```

**Root Cause:** List operations return empty output. The issue is likely in:
- `compile_list()` in codegen.rs
- `make_list()` function
- List printing via `blether`

**Fix Strategy:**
1. Check `compile_list()` - ensure list values are properly constructed
2. Check `inline_blether()` - ensure lists are printed correctly
3. Check `make_list()` - ensure list construction is correct
4. Verify runtime functions for list operations exist and are called correctly

### Category 2: Dictionary Operations (5 tests)
```
dicts::test_dict_assignment
dicts::test_dict_contains
dicts::test_dict_keys
dicts::test_dict_values
dicts::test_empty_dict
```

**Root Cause:** Similar to lists - dict operations not producing output.

**Fix Strategy:**
1. Check `compile_dict()`
2. Check dict printing in `inline_blether()`
3. Verify dict runtime functions

### Category 3: Control Flow (6 tests)
```
control_flow::test_if_false
control_flow::test_match_literal
control_flow::test_match_wildcard
control_flow::test_ternary
control_flow::test_while_break
control_flow::test_while_continue
```

**Root Cause:** Parse errors and control flow compilation issues.

**Fix Strategy:**
1. Check `compile_if()` for else branch handling
2. Check `compile_match()` for pattern matching
3. Check `compile_ternary()` for conditional expressions
4. Check `compile_while()` for break/continue handling
5. Verify break (`brek`) and continue (`haud_gaun`) keyword handling

### Category 4: Type Conversions (3 tests)
```
conversions::test_to_float
conversions::test_to_int
conversions::test_type_of
```

**Root Cause:** Conversion functions not working correctly.

**Fix Strategy:**
1. Check `inline_tae_int()`, `inline_tae_float()`, `inline_whit_kind()`
2. Verify string-to-number conversion
3. Check type introspection

### Category 5: Functional Operations (2 tests)
```
functional::test_ilk_map
functional::test_sieve_filter
```

**Root Cause:** Higher-order functions with lists not working.

**Fix Strategy:**
1. Check `inline_ilk()` (map)
2. Check `inline_sieve()` (filter)
3. These depend on list operations working first

### Category 6: Math Functions (2 tests)
```
math::test_pow
math::test_sqrt
```

**Root Cause:** Math functions returning incorrect values.

**Fix Strategy:**
1. Check `inline_pow()` - ensure correct calling convention
2. Check `inline_sqrt()` - verify float handling

### Category 7: Range (2 tests)
```
range::test_range_basic
range::test_range_with_step
```

**Root Cause:** Range functions return empty.

**Fix Strategy:**
1. Check `compile_range()` or `inline_range()`
2. Verify range-to-list conversion

### Category 8: Other (7 tests)
```
functions::test_lambda_multiline
integration::test_binary_search
integration::test_bubble_sort
integration::test_nested_functions
logical::test_not
pipe::test_pipe_chain
strings::test_string_split
```

**Fix Strategy:**
1. `test_lambda_multiline` - check multiline lambda compilation
2. `test_binary_search/bubble_sort` - depend on list operations
3. `test_nested_functions` - check closure/scope handling
4. `test_not` - check `inline_not()` or `nae` handling
5. `test_pipe_chain` - check `compile_pipe()`
6. `test_string_split` - check `inline_split()`

## Debugging Approach

For each failing test:

1. **Identify the exact error:**
   ```bash
   cargo test --features llvm --test llvm_comprehensive_tests <test_name> -- 2>&1
   ```

2. **Add debug output to codegen.rs:**
   - Add `eprintln!` statements to trace execution
   - Check if functions are being called
   - Verify values at key points

3. **Check the generated LLVM IR:**
   - Use `compile_to_ir()` to see the generated IR
   - Look for missing function calls or incorrect types

4. **Fix the issue:**
   - Most likely issues: incorrect function calls, missing runtime bindings, type mismatches

## Key Files to Modify

1. **`src/llvm/codegen.rs`** - Main code generation logic (~22,000 lines)
   - `compile_list()` - Line ~12000
   - `compile_dict()` - Line ~12500
   - `compile_if()` - Line ~8000
   - `compile_match()` - Line ~18190
   - `compile_ternary()` - Line ~9000
   - `compile_while()` - Line ~8500
   - `compile_pipe()` - Line ~17000
   - `inline_*` functions for builtins

2. **`src/llvm/runtime.rs`** - Runtime function declarations
   - Ensure all required runtime functions are declared

3. **`runtime/mdh_runtime.c`** - C runtime implementation
   - Verify implementations match declarations

## Testing Workflow

After each fix:

```bash
# Test specific module
cargo test --features llvm --test llvm_comprehensive_tests lists -- --test-threads=4

# Test all
cargo test --features llvm --test llvm_comprehensive_tests -- --test-threads=4
```

## Priority Order for Fixes

1. **Lists first** - Many other tests depend on lists working
2. **Control flow** - Core language feature
3. **Dicts** - After lists work
4. **Math/Conversions** - Independent fixes
5. **Functional ops** - Depend on lists
6. **Range** - Depend on lists
7. **Integration tests** - Should pass once components work

## Additional Tests for Full Coverage

After fixing the 42 failures, add tests for these uncovered areas:

### Import System
```braw
import "math"
blether floor(3.7)
```

### Advanced Pattern Matching
```braw
keek x {
    1 => blether "one",
    2 | 3 => blether "two or three",
    n gin n > 10 => blether "big",
    _ => blether "other"
}
```

### Destructuring
```braw
[a, b, c] = [1, 2, 3]
blether a + b + c
```

### For Loop with Destructuring
```braw
fer [x, y] in [[1, 2], [3, 4]] {
    blether x + y
}
```

### Advanced Closures (after fixing nested functions)
```braw
dae make_counter() {
    ken count = 0
    gie || {
        count = count + 1
        gie count
    }
}
```

### Error Throwing
```braw
hurl "Something went wrong"
```

### Advanced String Operations
```braw
blether wheesht("  hello  ")  # trim
blether repeat("ab", 3)       # "ababab"
blether slice("hello", 1, 4)  # "ell"
```

### Advanced List Operations
```braw
blether scran([1,2,3,4,5], 3)  # take first 3
blether slap([1,2], [3,4])    # concat
```

### Dictionary Advanced Operations
```braw
d = {"a": 1, "b": 2}
blether dram(d, |k,v| v * 2)   # map values
blether birl(d, |k,v| v > 1)   # filter
blether ceilidh(d1, d2)        # merge
```

## Success Criteria

1. All 183 existing tests pass
2. Add at least 30 more tests for full coverage
3. Test file compiles without warnings
4. `cargo test --features llvm --test llvm_comprehensive_tests` shows 0 failures

## Completion Promise

When `cargo test --features llvm --test llvm_comprehensive_tests` shows ALL tests passing (0 failures), the task is complete. Report the final test count and all passing.

## Hints for Common Issues

### Issue: Empty output from list/dict
- Check if `blether` correctly handles List/Dict value tags
- Check if `mdh_value_to_string` runtime function exists and works

### Issue: Parse errors
- The test syntax might not match current parser expectations
- Check if keywords like `ither` (else) are being tokenized correctly

### Issue: "Undefined variable" errors
- Variable scoping issue in closures/nested functions
- Check `find_free_variables()` and capture handling

### Issue: Incorrect numeric results
- Type mismatch (int vs float)
- Check if values are being extracted with correct type

### Issue: Segfaults
- Null pointer from failed allocation
- Check runtime function return values

## Notes

- The language uses Scottish dialect keywords (blether=print, ken=let, gin=if, ither=else, etc.)
- The LLVM backend uses tagged unions for values (ValueTag enum)
- Runtime functions are in C and linked at compile time
- Use `cargo test --features llvm` to run with LLVM backend enabled
