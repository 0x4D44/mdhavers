# HLD - tri Native Renderer in Rust Runtime (LLVM Backend)

Date: 2025-12-20
Author: Codex

## 1. Purpose
Move the tri native runtime from C to Rust (Option B) and deliver a **fully functional 3D renderer** for LLVM-native builds using **wgpu + winit + glam**. The design preserves current Scots naming semantics and tri module behavior, while enabling real GPU-backed rendering and a proper event loop.

This doc focuses on the **LLVM backend native compile** path, but the Rust runtime architecture will also serve the interpreter and WAT host runner later.

## 2. Goals
- Replace C-based tri runtime logic with a **Rust runtime** while keeping the LLVM ABI stable.
- Provide real GPU rendering with wgpu on native targets.
- Keep tri API semantics identical across targets (Scots names, English props).
- Support **single-binary** output (no external runtimes).
- Allow future reuse of the same runtime in interpreter/WAT host runner.

## 3. Non-goals (for this phase)
- Full three.js feature parity (post-processing, loaders, skinned animation, physics).
- Perfect material system or advanced PBR (basic + standard only).
- Offscreen rendering or headless GPU support.

## 4. Key Decisions
- **Option B**: Move native runtime to Rust; C runtime becomes a thin ABI shim or is removed.
- **wgpu + winit + glam** as the native rendering stack.
- **tri objects are live handles** into a Rust engine registry; property access mutates engine state.
- **Scots constructor and method names** remain unchanged.

## 5. Architecture Overview

### 5.1 Components
1) **tri_engine (Rust module)**
   - The actual renderer and scene graph.
   - Owns GPU resources and window/surface.

2) **tri_runtime (Rust FFI layer)**
   - Exposes `extern "C"` functions callable from LLVM-generated code.
   - Handles conversion between `MdhValue` and Rust engine handles.

3) **LLVM codegen integration**
   - Continues to call `__mdh_native_get/set/call` or new tri-specific FFI functions.

4) **Optional C shim (temporary)**
   - If needed, keep a minimal C layer that forwards to Rust.

### 5.2 Data Flow
```
LLVM program -> FFI calls -> tri_runtime -> tri_engine -> wgpu
```

## 6. Runtime Types & Handles

### 6.1 Native Handles
- Use **opaque integer handles** for all tri objects in LLVM ABI.
- Handles are indices into a Rust-managed arena/slot map.

### 6.2 Core Engine Data
- **Scene graph**: nodes with transforms + parent/child relationships.
- **Resources**: geometry buffers, materials, textures.
- **Renderer**: wgpu device, queue, surface, swapchain.

### 6.3 Handle Categories
- Scene / Object3D / Group / Mesh / Camera / Geometry / Material / Light / Renderer / Texture / Color

Each category is a Rust struct stored in arenas:
- `Arena<Scene>`
- `Arena<Node>`
- `Arena<Mesh>`
- `Arena<Geometry>`
- `Arena<Material>`
- `Arena<Texture>`
- `Arena<Camera>`
- `Arena<Light>`
- `Arena<Renderer>`

## 7. FFI API Design

### 7.1 Native Object Tagging
Keep LLVM ABI stable by exposing Rust functions that implement the existing generic ABI:
- `__mdh_native_get`
- `__mdh_native_set`
- `__mdh_native_callN`

But tri-specific behavior is performed in Rust.

### 7.2 Proposed Rust Exports
Minimum viable functions:
```
tri_module() -> MdhValue
tri_new_object(kind, args...) -> MdhValue
tri_get(handle, prop) -> MdhValue
tri_set(handle, prop, value) -> MdhValue
tri_call(handle, method, argc, argv_ptr) -> MdhValue
```

Internally these map to Rust functions:
- `tri_module_value()`
- `tri_object_get(handle, prop)`
- `tri_object_set(handle, prop, value)`
- `tri_object_call(handle, method, args)`

### 7.3 ABI for MdhValue
- Reuse the existing `MdhValue` struct layout in Rust (matching C layout).
- Provide conversion utilities in Rust:
  - `mdh_to_string`
  - `mdh_to_float`
  - `mdh_to_int`
  - `mdh_make_int/float/bool/string/nil`

## 8. Scene Graph & Transforms

### 8.1 Transform Model
Each `Node` has:
- position: `Vec3`
- rotation: `Euler` (stored as radians)
- scale: `Vec3`
- parent: optional handle
- children: Vec<handle>

### 8.2 World Matrix Updates
- Track dirty flags per node.
- On render, compute world matrices top-down.

## 9. Rendering Pipeline

### 9.1 Renderer
- winit window creation at first renderer instantiation.
- wgpu device/queue/surface created once per renderer.

### 9.2 Rendering Flow
- `render(scene, camera)`:
  1) Update transforms.
  2) Build render list of meshes.
  3) Upload uniform buffers (camera + lights).
  4) Encode wgpu commands.
  5) Present swapchain frame.

### 9.3 Materials
- Start with:
  - `MeshBasicMaiterial` (unlit)
  - `MeshStandardMaiterial` (basic PBR/lambert)

### 9.4 Geometry
- `BoxGeometrie`, `SpherGeometrie` generate vertex/index buffers in Rust.
- `Geometrie` for custom buffers later.

### 9.5 Lights
- Ambient, Directional, Point lights.
- Stored in scene; aggregated into GPU uniform buffers.

## 10. Property & Method Semantics

### 10.1 Properties
- Preserve English names: `position`, `rotation`, `scale`, `material`, `geometry`, `children`, `parent`.
- Provide **Vec3/Euler proxy objects** for position/rotation/scale when accessed.
- Proxy updates reflect into the engine immediately.

### 10.2 Methods
- `adde`, `remuiv`: modify scene graph children
- `cloan`: deep clone node with children
- `dyspos`: release resources (geometry, textures, renderer)
- `luik_at`: updates rotation toward target
- `set_sise`, `set_pixel_ratio`: update renderer surface config
- `render`, `loop`: renderer operations

## 11. Threading & Event Loop

### 11.1 Main Thread Ownership
- wgpu + winit must run on the main thread.
- `render` runs on main thread; `loop(fn)` enters a blocking event loop.

### 11.2 Callback Execution
- `loop(fn)` should call back into mdhavers **synchronously** on the main thread.
- Avoid calling into mdhavers from a non-main thread.

## 12. Error Handling
- Prop/method errors return `HaversError::TypeError` or `UndefinedVariable`.
- FFI functions return `MdhValue::Nil` and/or raise runtime errors via `__mdh_hurl`.

## 13. Build & Feature Flags
- New feature: `graphics3d` (wgpu + winit + glam).
- Tri runtime compiled only if `graphics3d` is enabled.
- LLVM build depends on `graphics3d` to enable native tri rendering.

## 14. Migration Plan

### Phase 1: Rust runtime scaffolding
- Create `src/tri_runtime/` module with Rust ABI and stub engine.
- Keep C runtime tri logic but forward to Rust for selected paths.

### Phase 2: Engine integration
- Build minimal wgpu renderer (triangle â†’ cube).
- Map tri objects to engine handles.
- Implement `render` & `loop`.

### Phase 3: Replace C tri logic
- Remove C-side tri object storage.
- Route `__mdh_native_get/set/call` into Rust tri runtime.
- Keep other C runtime functions unchanged.

### Phase 4: Full parity polish
- Materials, lights, textures, proper transforms, cloning, dispose.
- Add native showcase example.

## 15. Testing Plan
- Unit tests for property access and defaults.
- Integration test: compile LLVM, render a cube for a few frames, exit cleanly.
- Smoke test for `tri` constructors and `render` path.

## 16. Risks & Mitigations
- **ABI mismatch**: ensure `MdhValue` layout matches in Rust + C.
- **Event loop blocking**: provide `render` for single-frame render and `loop` for continuous.
- **Platform windowing**: winit + wgpu defaults; fallback to headless if needed later.
- **Resource leaks**: implement `dyspos` and cleanup on exit.

## 17. Open Questions
- Should `Renderar.loop` always own the event loop, or should we expose a poll API?
- How to handle multiple renderers / windows?
- Do we need a global engine singleton or per-renderer engine?

---

This HLD defines the Rust runtime architecture needed to deliver **fully functional 3D rendering** in LLVM-native builds, with a migration plan that minimizes ABI risk and preserves current tri semantics.
