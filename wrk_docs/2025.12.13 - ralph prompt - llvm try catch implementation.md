# LLVM Backend: Try-Catch Implementation

## Goal
Implement try-catch error handling (`hae_a_bash`/`gin_it_gangs_wrang`) in the LLVM backend to achieve 136/136 (100%) build success.

## Current Status
- **Current**: 135/136 (99.3%)
- **Target**: 136/136 (100%)
- **Failing file**: `examples/features/try_catch.braw`

## The Feature

mdhavers uses Scottish-flavored try-catch:
```
hae_a_bash {
    # code that might fail
    ken result = 10 / 0
} gin_it_gangs_wrang err {
    # handle error
    blether "Caught: " + err
}
```

- `hae_a_bash` = "have a bash" = try
- `gin_it_gangs_wrang` = "if it goes wrong" = catch
- `err` = the error message variable

## Implementation Strategy

### Option A: setjmp/longjmp (Recommended)
Use C's setjmp/longjmp for non-local jumps:

1. **Declare libc functions**:
   ```rust
   // In LibcFunctions struct
   setjmp: FunctionValue<'ctx>,
   longjmp: FunctionValue<'ctx>,
   ```

2. **Create jmp_buf type**:
   ```rust
   // jmp_buf is typically an array - size varies by platform
   // On x86_64 Linux, it's usually 200 bytes
   let jmp_buf_type = context.i8_type().array_type(200);
   ```

3. **Maintain error context stack**:
   ```rust
   // Global or thread-local stack of jmp_buf pointers
   error_handlers: Vec<PointerValue<'ctx>>,  // Stack of jmp_buf allocas
   current_error_msg: PointerValue<'ctx>,    // Pointer to current error string
   ```

4. **Compile try block**:
   ```rust
   fn compile_try_catch(&mut self, try_body: &[Stmt], catch_var: &str, catch_body: &[Stmt]) {
       // Allocate jmp_buf on stack
       let jmp_buf = self.builder.build_alloca(jmp_buf_type, "jmp_buf");

       // Push to error handler stack
       self.error_handlers.push(jmp_buf);

       // Call setjmp - returns 0 on first call, non-zero when longjmp called
       let setjmp_result = self.builder.build_call(self.libc.setjmp, &[jmp_buf.into()], "setjmp_result");

       // Branch based on setjmp result
       let try_block = self.context.append_basic_block(function, "try");
       let catch_block = self.context.append_basic_block(function, "catch");
       let after_block = self.context.append_basic_block(function, "after_try_catch");

       let is_normal = self.builder.build_int_compare(EQ, setjmp_result, 0, "is_normal");
       self.builder.build_conditional_branch(is_normal, try_block, catch_block);

       // Try block
       self.builder.position_at_end(try_block);
       for stmt in try_body {
           self.compile_stmt(stmt)?;
       }
       self.builder.build_unconditional_branch(after_block);

       // Catch block
       self.builder.position_at_end(catch_block);
       // Bind error message to catch_var
       let err_msg = self.builder.build_load(current_error_msg, "err_msg");
       self.variables.insert(catch_var.to_string(), err_msg_alloca);
       for stmt in catch_body {
           self.compile_stmt(stmt)?;
       }
       self.builder.build_unconditional_branch(after_block);

       // Pop error handler
       self.error_handlers.pop();

       self.builder.position_at_end(after_block);
   }
   ```

5. **Modify runtime error handling**:
   Instead of calling `exit()` on errors, check if there's an error handler:
   ```rust
   fn emit_runtime_error(&mut self, error_msg: BasicValueEnum<'ctx>) {
       if let Some(jmp_buf) = self.error_handlers.last() {
           // Store error message
           self.builder.build_store(self.current_error_msg, error_msg);
           // longjmp back to the handler
           self.builder.build_call(self.libc.longjmp, &[jmp_buf.into(), i32_one.into()], "");
       } else {
           // No handler - print and exit as before
           self.builder.build_call(self.runtime.print_error, &[error_msg.into()], "");
           self.builder.build_call(self.libc.exit, &[i32_one.into()], "");
       }
   }
   ```

### Option B: Return-based Error Handling
Simpler but more invasive - every function returns an error tuple.

### Option C: LLVM Exceptions
Use LLVM's native exception handling (invoke/landingpad) - complex and platform-specific.

## Key Code Locations

1. **AST for try-catch** - Check `src/ast.rs`:
   ```rust
   Stmt::TryCatch {
       try_block: Box<Stmt>,
       catch_var: String,
       catch_block: Box<Stmt>,
       span: Span,
   }
   ```

2. **compile_stmt** - Add case for `Stmt::TryCatch`

3. **Runtime error points** - Places that need modification:
   - Division by zero check
   - Undefined variable access (compile-time â†’ runtime)
   - Index out of bounds
   - Type errors

## Implementation Steps

### Phase 1: Setup
1. Add setjmp/longjmp to libc declarations
2. Create jmp_buf type
3. Add error handler stack and error message storage

### Phase 2: Compile TryCatch
1. Find `Stmt::TryCatch` in ast.rs
2. Add `compile_try_catch` function
3. Handle the setjmp/longjmp branching

### Phase 3: Runtime Errors
1. Create helper `emit_runtime_error` function
2. Modify division to use it
3. Modify index access to use it
4. Handle undefined variables at runtime (tricky)

### Phase 4: Test
```bash
./target/release/mdhavers build examples/features/try_catch.braw
./target/release/mdhavers run examples/features/try_catch.braw
```

## Challenges

1. **Undefined variables**: Currently caught at compile time. Need to defer to runtime OR compile with placeholder that errors.

2. **jmp_buf size**: Platform-dependent. May need runtime detection or conservative sizing.

3. **Cleanup**: setjmp/longjmp don't run destructors. Need to be careful with resources.

4. **Nested try-catch**: Stack of handlers must be managed correctly.

## Test Command
```bash
find examples -name "*.braw" -exec sh -c './target/release/mdhavers build "$1" >/dev/null 2>&1 && echo "P"' _ {} \; 2>/dev/null | grep -c "P"
```

Target: 136/136 passing.

## Success Criteria
- `examples/features/try_catch.braw` builds successfully
- Runtime errors (div by zero, index OOB) are catchable
- Error message is accessible in catch block
- Nested try-catch works correctly
- Total: 136/136 (100%)
