# mdhavers Runtime Extensions: Logging, SEGV Handling, Graphics & Audio

## Goal
Extend the mdhavers language with production-ready runtime features: structured logging, crash handling with stack traces, graphics (via raylib), and audio support. All features should be ON by default with runtime control.

## Success Criteria
1. Logging system with 5 levels (whisper/mutter/blether/holler/roar) working in both interpreter and LLVM
2. SEGV handler with readable stack traces for native executables
3. Graphics API using raylib for window, drawing, and input
4. Audio API for sound effects and music
5. All new APIs follow Scots naming convention
6. Golden tests for new features
7. Example programs demonstrating each feature

## Phase 1: Logging System

### New Keywords
Add to lexer/parser:
- `log_whisper` - TRACE level (most verbose)
- `log_mutter` - DEBUG level
- `log_blether` - INFO level
- `log_holler` - WARN level
- `log_roar` - ERROR level
- `set_log_level` - function to change level at runtime

### Log Output Format
```
[WHISPER] 2024-12-12 14:32:01.234 [thread:0001] main.braw:42 | Message here
[MUTTER]  2024-12-12 14:32:01.235 [thread:0001] main.braw:43 | Debug info
[BLETHER] 2024-12-12 14:32:01.300 [thread:0001] main.braw:50 | Normal info
[HOLLER]  2024-12-12 14:32:02.100 [thread:0002] worker.braw:12 | Warning
[ROAR]    2024-12-12 14:32:05.500 [thread:0001] db.braw:88 | Error!
```

Components:
- Level name (padded to 7 chars)
- ISO timestamp with milliseconds
- Thread ID (4 digits, zero-padded)
- Source file and line number
- Pipe separator
- User message (supports f-strings)

### Log Levels (numeric)
```
WHEESHT = 0   # Silent (no output)
ROAR    = 1   # Errors only
HOLLER  = 2   # Warnings and above
BLETHER = 3   # Info and above (DEFAULT)
MUTTER  = 4   # Debug and above
WHISPER = 5   # Everything
```

### Environment Variable
```bash
MDH_LOG_LEVEL=whisper ./my_program   # See everything
MDH_LOG_LEVEL=holler ./my_program    # Only warnings and errors
MDH_LOG_LEVEL=wheesht ./my_program   # Silent
```

### Implementation Details

#### Token Changes (src/token.rs)
Add new token kinds:
```rust
#[token("log_whisper")]
LogWhisper,
#[token("log_mutter")]
LogMutter,
#[token("log_blether")]
LogBlether,
#[token("log_holler")]
LogHoller,
#[token("log_roar")]
LogRoar,
```

#### AST Changes (src/ast.rs)
Add new statement type:
```rust
Log {
    level: LogLevel,
    message: Box<Expr>,
    span: Span,
},
```

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum LogLevel {
    Whisper,  // TRACE
    Mutter,   // DEBUG
    Blether,  // INFO
    Holler,   // WARN
    Roar,     // ERROR
}
```

#### Parser Changes (src/parser.rs)
Parse log statements like blether but with level:
```rust
TokenKind::LogWhisper => self.parse_log_statement(LogLevel::Whisper),
TokenKind::LogMutter => self.parse_log_statement(LogLevel::Mutter),
// etc.
```

#### Interpreter Changes (src/interpreter.rs)
Add log level state and implement logging:
```rust
struct Interpreter {
    log_level: LogLevel,
    // ...
}

fn execute_log(&mut self, level: LogLevel, message: &Expr, span: &Span) {
    if self.should_log(level) {
        let msg = self.evaluate(message)?;
        let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S%.3f");
        let thread_id = std::thread::current().id(); // format as 4 digits
        eprintln!("[{:7}] {} [thread:{:04}] {}:{} | {}",
            level.name(), timestamp, thread_id,
            self.current_file, span.line, msg);
    }
}
```

#### LLVM Runtime Changes (src/llvm/runtime.c or .rs)
Add runtime functions:
```c
static int g_log_level = 3;  // Default: BLETHER

void __mdh_set_log_level(int level) {
    g_log_level = level;
}

void __mdh_log(int level, const char* file, int line, MdhValue* message) {
    if (level > g_log_level) return;

    const char* level_names[] = {"WHEESHT", "ROAR", "HOLLER", "BLETHER", "MUTTER", "WHISPER"};

    // Get timestamp
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    struct tm* tm = localtime(&ts.tv_sec);

    // Get thread ID
    pthread_t tid = pthread_self();

    // Format and print
    fprintf(stderr, "[%-7s] %04d-%02d-%02d %02d:%02d:%02d.%03ld [thread:%04lu] %s:%d | ",
        level_names[level],
        tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
        tm->tm_hour, tm->tm_min, tm->tm_sec, ts.tv_nsec / 1000000,
        (unsigned long)(tid % 10000),
        file, line);
    __mdh_print(message);
    fprintf(stderr, "\n");
}

// Called at startup
void __mdh_init_logging() {
    const char* env = getenv("MDH_LOG_LEVEL");
    if (env) {
        if (strcmp(env, "wheesht") == 0) g_log_level = 0;
        else if (strcmp(env, "roar") == 0) g_log_level = 1;
        else if (strcmp(env, "holler") == 0) g_log_level = 2;
        else if (strcmp(env, "blether") == 0) g_log_level = 3;
        else if (strcmp(env, "mutter") == 0) g_log_level = 4;
        else if (strcmp(env, "whisper") == 0) g_log_level = 5;
    }
}
```

#### LLVM Codegen Changes (src/llvm/codegen.rs)
Emit calls to runtime log function:
```rust
Stmt::Log { level, message, span } => {
    let level_int = match level {
        LogLevel::Whisper => 5,
        LogLevel::Mutter => 4,
        LogLevel::Blether => 3,
        LogLevel::Holler => 2,
        LogLevel::Roar => 1,
    };
    let msg_val = self.compile_expr(message)?;
    let file_str = self.builder.build_global_string_ptr(&self.current_file, "file");
    let line_int = self.context.i32_type().const_int(span.line as u64, false);
    self.builder.build_call(
        self.runtime.log,
        &[level_int.into(), file_str.into(), line_int.into(), msg_val.into()],
        "log"
    );
}
```

### Test Cases
Create `tests/golden/logging/` with:
- `log_levels.braw` - Test all 5 levels
- `log_fstring.braw` - Test f-string interpolation in logs
- `set_level.braw` - Test runtime level changes

---

## Phase 2: SEGV Handling & Stack Traces

### Shadow Stack Design
Maintain a parallel stack for readable crash reports:

```c
#define MAX_STACK_DEPTH 1024
#define MAX_FUNC_NAME 128
#define MAX_FILE_NAME 256

typedef struct {
    char function_name[MAX_FUNC_NAME];
    char file_name[MAX_FILE_NAME];
    int line;
} StackFrame;

static StackFrame g_shadow_stack[MAX_STACK_DEPTH];
static int g_stack_depth = 0;

void __mdh_push_frame(const char* func, const char* file, int line) {
    if (g_stack_depth < MAX_STACK_DEPTH) {
        strncpy(g_shadow_stack[g_stack_depth].function_name, func, MAX_FUNC_NAME - 1);
        strncpy(g_shadow_stack[g_stack_depth].file_name, file, MAX_FILE_NAME - 1);
        g_shadow_stack[g_stack_depth].line = line;
        g_stack_depth++;
    }
}

void __mdh_pop_frame() {
    if (g_stack_depth > 0) {
        g_stack_depth--;
    }
}
```

### Log Ring Buffer
Keep last N log messages for crash context:

```c
#define LOG_RING_SIZE 16
#define LOG_MSG_SIZE 256

typedef struct {
    char message[LOG_MSG_SIZE];
    int level;
} LogEntry;

static LogEntry g_log_ring[LOG_RING_SIZE];
static int g_log_ring_idx = 0;

void __mdh_log_to_ring(int level, const char* msg) {
    strncpy(g_log_ring[g_log_ring_idx].message, msg, LOG_MSG_SIZE - 1);
    g_log_ring[g_log_ring_idx].level = level;
    g_log_ring_idx = (g_log_ring_idx + 1) % LOG_RING_SIZE;
}
```

### Signal Handler

```c
#include <signal.h>
#include <execinfo.h>

const char* signal_name(int sig) {
    switch (sig) {
        case SIGSEGV: return "SIGSEGV (Segmentation fault)";
        case SIGBUS:  return "SIGBUS (Bus error)";
        case SIGFPE:  return "SIGFPE (Floating point exception)";
        case SIGABRT: return "SIGABRT (Abort)";
        default:      return "Unknown signal";
    }
}

void __mdh_crash_handler(int sig, siginfo_t* info, void* context) {
    fprintf(stderr, "\n");
    fprintf(stderr, "================================================================================\n");
    fprintf(stderr, "ðŸ”¥ Och! Yer program's fell ower!\n");
    fprintf(stderr, "================================================================================\n\n");

    fprintf(stderr, "Signal: %s\n", signal_name(sig));
    if (sig == SIGSEGV || sig == SIGBUS) {
        fprintf(stderr, "Address: %p\n", info->si_addr);
    }
    fprintf(stderr, "\n");

    // Print shadow stack
    fprintf(stderr, "Stack trace (most recent call last):\n");
    for (int i = 0; i < g_stack_depth; i++) {
        fprintf(stderr, "  #%d  %s (%s:%d)\n",
            i,
            g_shadow_stack[i].function_name,
            g_shadow_stack[i].file_name,
            g_shadow_stack[i].line);
    }
    fprintf(stderr, "\n");

    // Print recent log messages
    fprintf(stderr, "Recent log messages:\n");
    const char* level_names[] = {"", "ROAR", "HOLLER", "BLETHER", "MUTTER", "WHISPER"};
    for (int i = 0; i < LOG_RING_SIZE; i++) {
        int idx = (g_log_ring_idx + i) % LOG_RING_SIZE;
        if (g_log_ring[idx].message[0] != '\0') {
            fprintf(stderr, "  [%-7s] %s\n",
                level_names[g_log_ring[idx].level],
                g_log_ring[idx].message);
        }
    }
    fprintf(stderr, "\n");

    // Hints based on signal
    fprintf(stderr, "Hints:\n");
    if (sig == SIGSEGV) {
        if (info->si_addr == NULL) {
            fprintf(stderr, "  - Looks like a nil pointer dereference\n");
            fprintf(stderr, "  - Check fer uninitialised variables or missing return values\n");
        } else {
            fprintf(stderr, "  - Possible oot-o-bounds array access\n");
            fprintf(stderr, "  - Check yer list indices are within range\n");
        }
    }
    fprintf(stderr, "\n");

    _exit(128 + sig);
}

void __mdh_init_crash_handler() {
    struct sigaction sa;
    sa.sa_sigaction = __mdh_crash_handler;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);

    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGBUS, &sa, NULL);
    sigaction(SIGFPE, &sa, NULL);
    sigaction(SIGABRT, &sa, NULL);
}
```

### Codegen Instrumentation
At every function entry/exit:

```rust
fn compile_function(&mut self, func: &Function) -> Result<()> {
    // At function entry
    let func_name = self.builder.build_global_string_ptr(&func.name, "func_name");
    let file_name = self.builder.build_global_string_ptr(&self.current_file, "file_name");
    let line = self.context.i32_type().const_int(func.span.line as u64, false);
    self.builder.build_call(self.runtime.push_frame, &[func_name, file_name, line], "");

    // Compile function body...

    // At every return point (including implicit returns)
    self.builder.build_call(self.runtime.pop_frame, &[], "");
}
```

---

## Phase 3: Graphics (raylib)

### Dependencies
Add raylib as a dependency. Options:
1. **raylib-rs** crate for interpreter
2. **Static linking** raylib.a for LLVM native builds

For Cargo.toml:
```toml
[dependencies]
raylib = { version = "5.0", optional = true }

[features]
graphics = ["raylib"]
```

### New Built-in Functions

#### Window Management
```
mak_windae(width: int, height: int, title: string)
shut_windae()
windae_open() -> bool
windae_width() -> int
windae_height() -> int
set_target_fps(fps: int)
toggle_fullscreen()
```

#### Drawing
```
dicht(colour)                                    # Clear screen
pent_pixel(x, y, colour)
pent_line(x1, y1, x2, y2, colour)
pent_rect(x, y, w, h, colour)
pent_rect_outline(x, y, w, h, colour)
pent_circle(x, y, radius, colour)
pent_circle_outline(x, y, radius, colour)
pent_triangle(x1, y1, x2, y2, x3, y3, colour)
scrieve(text, x, y, colour)
scrieve_sized(text, x, y, colour, size)
shaw()                                           # Present frame
```

#### Colours
```
# Constants: BLACK, WHITE, RED, GREEN, BLUE, YELLOW,
#            ORANGE, PURPLE, PINK, CYAN, GREY, BROWN
rgb(r, g, b) -> colour
rgba(r, g, b, a) -> colour
```

#### Input - Keyboard
```
key_doon(key) -> bool        # Currently held
key_pressed(key) -> bool     # Just pressed this frame
key_released(key) -> bool    # Just released this frame

# Key constants: KEY_A..KEY_Z, KEY_0..KEY_9, KEY_SPACE, KEY_ENTER,
#                KEY_ESCAPE, KEY_TAB, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT,
#                KEY_SHIFT, KEY_CTRL, KEY_ALT, KEY_F1..KEY_F12
```

#### Input - Mouse
```
moose_x() -> int
moose_y() -> int
moose_doon(button) -> bool
moose_pressed(button) -> bool
moose_released(button) -> bool
moose_wheel() -> int

# Button constants: MOOSE_LEFT, MOOSE_RIGHT, MOOSE_MIDDLE
```

#### Timing
```
delta_time() -> float        # Seconds since last frame
get_time() -> float          # Seconds since program start
get_fps() -> int
wait(seconds: float)
```

#### Images
```
load_image(path: string) -> image
pent_image(image, x, y)
pent_image_scaled(image, x, y, scale)
pent_image_rotated(image, x, y, angle)
image_width(image) -> int
image_height(image) -> int
```

### Interpreter Implementation

Create `src/graphics.rs`:
```rust
use raylib::prelude::*;

pub struct GraphicsContext {
    rl: RaylibHandle,
    thread: RaylibThread,
    // cached resources
    textures: HashMap<String, Texture2D>,
}

impl GraphicsContext {
    pub fn new(width: i32, height: i32, title: &str) -> Self {
        let (rl, thread) = raylib::init()
            .size(width, height)
            .title(title)
            .build();
        Self { rl, thread, textures: HashMap::new() }
    }

    pub fn is_open(&self) -> bool {
        !self.rl.window_should_close()
    }

    pub fn clear(&mut self, color: Color) {
        // Called within begin_drawing/end_drawing
    }

    // ... etc
}
```

Add to interpreter:
```rust
struct Interpreter {
    graphics: Option<GraphicsContext>,
    // ...
}
```

### LLVM Implementation

Create runtime functions that call raylib C API:
```c
#include "raylib.h"

static bool g_window_open = false;

void __mdh_mak_windae(int width, int height, const char* title) {
    InitWindow(width, height, title);
    g_window_open = true;
}

void __mdh_shut_windae() {
    CloseWindow();
    g_window_open = false;
}

bool __mdh_windae_open() {
    return g_window_open && !WindowShouldClose();
}

void __mdh_dicht(uint32_t color) {
    BeginDrawing();
    ClearBackground(GetColor(color));
}

void __mdh_shaw() {
    EndDrawing();
}

void __mdh_pent_circle(int x, int y, int radius, uint32_t color) {
    DrawCircle(x, y, (float)radius, GetColor(color));
}

// ... etc for all graphics functions
```

---

## Phase 4: Audio

### New Built-in Functions

#### Sound Effects
```
load_soond(path: string) -> sound
play_soond(sound)
play_soond(sound, volume: float)  # 0.0-1.0
stop_soond(sound)
soond_playing(sound) -> bool
```

#### Music (Streaming)
```
load_music(path: string) -> music
play_music(music)
pause_music(music)
resume_music(music)
stop_music(music)
set_music_volume(music, volume: float)
music_playing(music) -> bool
update_music(music)              # Call each frame for streaming
```

#### Global Audio
```
set_master_volume(volume: float)
mute_aw()
unmute_aw()
```

### Implementation

raylib includes audio support, so this integrates naturally:

```c
#include "raylib.h"

static bool g_audio_init = false;

void __mdh_init_audio() {
    if (!g_audio_init) {
        InitAudioDevice();
        g_audio_init = true;
    }
}

MdhValue __mdh_load_soond(const char* path) {
    __mdh_init_audio();
    Sound sound = LoadSound(path);
    // Store in resource table and return handle
    return mdh_sound_value(register_sound(sound));
}

void __mdh_play_soond(MdhValue sound_handle, float volume) {
    Sound* sound = get_sound(sound_handle);
    SetSoundVolume(*sound, volume);
    PlaySound(*sound);
}

MdhValue __mdh_load_music(const char* path) {
    __mdh_init_audio();
    Music music = LoadMusicStream(path);
    return mdh_music_value(register_music(music));
}

void __mdh_play_music(MdhValue music_handle) {
    Music* music = get_music(music_handle);
    PlayMusicStream(*music);
}

void __mdh_update_music(MdhValue music_handle) {
    Music* music = get_music(music_handle);
    UpdateMusicStream(*music);
}
```

---

## File Structure

New files to create:
```
src/
â”œâ”€â”€ logging.rs          # Logging implementation for interpreter
â”œâ”€â”€ graphics.rs         # Graphics wrapper for interpreter
â”œâ”€â”€ audio.rs            # Audio wrapper for interpreter
â”œâ”€â”€ llvm/
â”‚   â”œâ”€â”€ runtime/
â”‚   â”‚   â”œâ”€â”€ logging.c   # Logging runtime for native
â”‚   â”‚   â”œâ”€â”€ crash.c     # SEGV handler for native
â”‚   â”‚   â”œâ”€â”€ graphics.c  # Graphics runtime for native
â”‚   â”‚   â””â”€â”€ audio.c     # Audio runtime for native

tests/golden/
â”œâ”€â”€ logging/
â”‚   â”œâ”€â”€ log_levels.braw
â”‚   â”œâ”€â”€ log_fstring.braw
â”‚   â””â”€â”€ set_level.braw
â”œâ”€â”€ graphics/
â”‚   â””â”€â”€ (manual testing - graphics are hard to golden test)
â””â”€â”€ audio/
    â””â”€â”€ (manual testing)

examples/
â”œâ”€â”€ logging_demo.braw
â”œâ”€â”€ pong.braw           # Simple game demonstrating graphics + audio
â”œâ”€â”€ paint.braw          # Drawing program
â””â”€â”€ music_player.braw   # Audio demonstration
```

---

## Build System Changes

### Cargo.toml Updates
```toml
[dependencies]
raylib = { version = "5.0", optional = true }
chrono = "0.4"

[features]
default = ["graphics", "audio"]
graphics = ["raylib"]
audio = ["raylib"]  # raylib includes audio

[build-dependencies]
cc = "1.0"  # For compiling C runtime
```

### Linking raylib for LLVM
When compiling native executables, link against:
- libraylib.a (static)
- Platform libs: -lm -lpthread -ldl -lrt -lX11 (Linux)
                 -framework CoreVideo -framework IOKit -framework Cocoa -framework GLUT -framework OpenGL (macOS)

---

## Testing Strategy

### Logging Tests (Automated)
- Test each log level outputs correctly
- Test level filtering (set to HOLLER, verify WHISPER doesn't print)
- Test environment variable parsing
- Test f-string interpolation in log messages

### Graphics Tests (Manual + Screenshots)
- Create example programs
- Visual verification
- Input testing

### Audio Tests (Manual)
- Create example programs
- Verify sound plays correctly

---

## Example Programs

### logging_demo.braw
```
log_whisper "This is trace level - very verbose"
log_mutter "This is debug level"
log_blether "This is info level - normal operation"
log_holler "This is a warning!"
log_roar "This is an error!"

blether "Changing log level to HOLLER..."
set_log_level("holler")

log_whisper "You should NOT see this"
log_mutter "You should NOT see this"
log_blether "You should NOT see this"
log_holler "You SHOULD see this warning"
log_roar "You SHOULD see this error"
```

### pong.braw
```
# Simple Pong game with sound

mak_windae(800, 600, "Scots Pong!")
set_target_fps(60)

ken boing = load_soond("assets/boing.wav")
ken music = load_music("assets/game.mp3")
play_music(music)

ken paddle_y = 250
ken ball_x = 400.0
ken ball_y = 300.0
ken ball_dx = 300.0
ken ball_dy = 200.0
ken score = 0

log_blether "Game started!"

whiles windae_open() {
    update_music(music)
    ken dt = delta_time()

    # Input
    gin key_doon(KEY_UP) an paddle_y > 0 {
        paddle_y = paddle_y - 400 * dt
    }
    gin key_doon(KEY_DOWN) an paddle_y < 500 {
        paddle_y = paddle_y + 400 * dt
    }
    gin key_pressed(KEY_ESCAPE) {
        brak
    }

    # Update ball
    ball_x = ball_x + ball_dx * dt
    ball_y = ball_y + ball_dy * dt

    # Bounce off top/bottom
    gin ball_y < 10 or ball_y > 590 {
        ball_dy = -ball_dy
        play_soond(boing, 0.3)
        log_whisper f"Ball bounced at y={ball_y}"
    }

    # Bounce off paddle
    gin ball_x < 40 an ball_x > 20 an ball_y > paddle_y an ball_y < paddle_y + 100 {
        ball_dx = -ball_dx
        ball_dx = ball_dx * 1.05  # Speed up slightly
        score = score + 1
        play_soond(boing)
        log_mutter f"Score: {score}"
    }

    # Ball out of bounds - reset
    gin ball_x < 0 {
        log_holler "Ball lost! Resetting..."
        ball_x = 400.0
        ball_y = 300.0
        ball_dx = 300.0
    }

    # Bounce off right wall
    gin ball_x > 790 {
        ball_dx = -ball_dx
    }

    # Draw
    dicht(BLACK)
    pent_rect(20, paddle_y, 20, 100, WHITE)
    pent_circle(ball_x, ball_y, 10, WHITE)
    scrieve(f"Score: {score}", 350, 20, WHITE)
    scrieve("Press ESC to quit", 300, 570, GREY)
    shaw()
}

stop_music(music)
log_blether f"Game over! Final score: {score}"
```

---

## Implementation Order

### Phase 1: Logging (Do First)
1. Add tokens to lexer
2. Add AST nodes
3. Implement parser
4. Implement in interpreter
5. Add runtime functions for LLVM
6. Add environment variable support
7. Write tests and examples

### Phase 2: SEGV Handling (Do Second)
1. Create C runtime with shadow stack
2. Create signal handler
3. Add log ring buffer
4. Instrument codegen for function entry/exit
5. Test with intentional crashes

### Phase 3: Graphics Core (Do Third)
1. Add raylib dependency
2. Implement window functions
3. Implement drawing primitives
4. Implement input handling
5. Add colour constants
6. Create example programs

### Phase 4: Audio (Do Fourth)
1. Implement sound loading/playing
2. Implement music streaming
3. Add volume controls
4. Integrate with graphics examples

---

## Completion Promise
All four phases complete:
- Logging works in interpreter and LLVM with all 5 levels
- SEGV handler produces readable stack traces
- Graphics API creates windows, draws shapes, handles input
- Audio plays sounds and streams music
- Example programs (logging_demo.braw, pong.braw) run successfully
