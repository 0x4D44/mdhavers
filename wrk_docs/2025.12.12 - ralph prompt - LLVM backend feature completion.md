# LLVM Backend Feature Completion

## Objective
Extend the mdhavers LLVM backend (`src/llvm/codegen.rs`) to support all language features currently missing, enabling compilation of the full examples suite.

## Missing Features (by priority)

### 1. FString (String Interpolation) - HIGH PRIORITY
**Error:** `Expression not yet supported in LLVM backend: FString`

FStrings have parts that are either `Text(string)` or `Expr(expression)`. Implementation:
- Compile each part
- For Text parts: create string literal
- For Expr parts: compile expression, convert to string using `tae_string` logic
- Concatenate all parts using string concatenation

**AST:**
```rust
Expr::FString { parts, span }
// parts: Vec<FStringPart> where FStringPart is Text(String) or Expr(Expr)
```

**Implementation approach:**
1. Start with empty string result
2. For each part:
   - Text: concatenate the literal string
   - Expr: compile expr, call internal stringify, concatenate
3. Return final concatenated string

### 2. Import Statements - HIGH PRIORITY
**Error:** `Statement not yet supported in LLVM backend: Import`

For LLVM compilation, imports need to be resolved at compile time. Options:
- **Simple approach:** Inline the imported module's code during compilation
- **Complex approach:** Separate compilation + linking

**Recommended:** Simple inlining approach
1. When encountering Import, read the target .braw file
2. Parse it
3. Compile its top-level declarations (functions, classes) into the current module
4. Track imported modules to avoid duplicate imports

**AST:**
```rust
Stmt::Import { path, alias, span }
```

### 3. Match Statements - MEDIUM PRIORITY
**Error:** `Statement not yet supported in LLVM backend: Match`

Pattern matching compiles to a series of conditional branches.

**AST:**
```rust
Stmt::Match { value, arms, span }
// arms: Vec<MatchArm> { pattern, body, span }
// Pattern: Literal, Identifier (binding), Wildcard, Range, etc.
```

**Implementation:**
1. Compile the match value once, store in temp
2. For each arm:
   - Generate condition check for the pattern
   - If match: execute body, jump to end
   - Else: try next arm
3. Wildcard `_` always matches (default case)
4. Identifier patterns bind the value to a variable

### 4. Destructure Statements - MEDIUM PRIORITY
**Error:** `Statement not yet supported in LLVM backend: Destructure`

List destructuring: `ken [a, b, c] = some_list`

**AST:**
```rust
Stmt::Destructure { patterns, value, span }
// patterns: Vec<DestructurePattern> - Variable(name), Wildcard, Nested
```

**Implementation:**
1. Compile the value (should be a list)
2. For each pattern at index i:
   - Extract element at index i from list
   - If Variable: create variable and assign
   - If Wildcard: skip
   - If Nested: recurse

### 5. Assert Statements - MEDIUM PRIORITY
**Error:** `Statement not yet supported in LLVM backend: Assert`

**AST:**
```rust
Stmt::Assert { condition, message, span }
```

**Implementation:**
1. Compile condition
2. Branch: if false, call panic/abort with message
3. If true, continue

### 6. TryCatch Statements - LOW PRIORITY
**Error:** `Statement not yet supported in LLVM backend: TryCatch`

Exception handling is complex in LLVM. Options:
- Use LLVM's exception handling intrinsics (complex)
- Use setjmp/longjmp (simpler, less elegant)
- Return error values (simplest)

**AST:**
```rust
Stmt::TryCatch { try_block, error_name, catch_block, span }
```

**Recommended:** setjmp/longjmp approach for simplicity

### 7. Spread Expressions - LOW PRIORITY
**Error:** `Expression not yet supported in LLVM backend: Spread`

Used in list literals: `[1, 2, ...other_list, 3]`

**AST:**
```rust
Expr::Spread { expr, span }
```

**Implementation:**
- When building a list and encountering Spread:
  - Compile the spread expression (should be a list)
  - Iterate and append each element to result list

### 8. Pipe Expressions - LOW PRIORITY
**Error:** `Expression not yet supported in LLVM backend: Pipe`

`value |> func` is equivalent to `func(value)`

**AST:**
```rust
Expr::Pipe { left, right, span }
// right is typically a Lambda or function reference
```

**Implementation:**
1. Compile left (the value)
2. Compile right (should be callable)
3. Call right with left as argument

## Implementation Order

1. **FString** - Unblocks most examples, straightforward string manipulation
2. **Import** - Unblocks library-dependent examples
3. **Match** - Common pattern, moderate complexity
4. **Destructure** - Useful but less common
5. **Assert** - Simple conditional + abort
6. **Pipe** - Simple desugaring
7. **Spread** - List manipulation
8. **TryCatch** - Most complex, can defer

## Key Files
- `src/llvm/codegen.rs` - Main LLVM codegen (add cases to `compile_expr` and `compile_stmt`)
- `src/ast.rs` - AST definitions (reference for structure)
- `src/parser.rs` - Parser (reference for how features are parsed)

## Testing Strategy
After each feature:
1. Run `./examples/build_all.sh` to check progress
2. Test specific examples that use the feature
3. Verify no regressions in existing functionality

## Success Criteria
- `./examples/build_all.sh` shows significantly more successful builds
- All showcase demos continue to work
- No LLVM verification errors or runtime crashes
