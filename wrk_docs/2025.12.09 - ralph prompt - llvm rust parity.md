# mdhavers LLVM Backend: Closing the Gap to Rust

## Objective

Push the LLVM backend as close to Rust performance as possible. Current state: ~947x slower than Rust on fib_iter(100000). Target: <100x slower (ideally <50x).

## Current State Analysis

### What We Have
- Int shadow variables for known-integer local variables
- Direct condition compilation (skip bool boxing)
- Integer fast path for arithmetic
- Type tracking via `var_types` HashMap

### Current Bottleneck: The Loop Body Still Does Too Much

Looking at the current fib_iter IR, the loop body still:
1. Loads from MdhValue for `a` and `b` (not using shadows for temp = a + b)
2. Stores to BOTH shadow AND MdhValue on every assignment
3. Function parameter `n` has no shadow (marked Unknown)

### Rust vs mdhavers

Rust's fib_iter loop is essentially:
```llvm
loop:
  %cmp = icmp sle i64 %i, %n
  br i1 %cmp, label %body, label %exit
body:
  %temp = add i64 %a, %b
  ; phi nodes handle a=b, b=temp, i++ - NO memory operations
  br label %loop
```

Our loop still has ~6 loads and ~6 stores per iteration.

## Phase 1: Analyze Current Hot Path (Do First)

```bash
./target/release/mdhavers build benchmarks/large_scale/fib_large.braw --emit-llvm
cat benchmarks/large_scale/fib_large.ll | grep -A 80 "define.*fib_iter"
```

Count:
- How many `load` instructions in the loop body?
- How many `store` instructions in the loop body?
- Are shadows being used for ALL integer operations?

## Phase 2: Eliminate Redundant MdhValue Stores

### 2.1 Lazy MdhValue Sync

Currently we store to both shadow AND MdhValue on every assignment. Instead:
- Only store to shadow during loop body
- Sync to MdhValue only when:
  - Exiting the loop
  - Variable is used in a non-integer context (print, function call, etc.)

Implementation:
```rust
// Track which shadows are "dirty" (ahead of MdhValue)
dirty_shadows: HashSet<String>,

// In Expr::Assign for int shadow:
// - Update shadow only
// - Mark as dirty
// - DON'T update MdhValue

// Before loop exit, function call, or print:
// - Sync all dirty shadows to MdhValue
// - Clear dirty set
```

### 2.2 Use Shadows in Binary Operations

The `temp = a + b` line should use shadows for `a` and `b`, not load from MdhValue.

Check `compile_binary` and ensure it calls `compile_int_expr` which uses shadows.

## Phase 3: Function Parameter Type Inference

### 3.1 Infer Parameter Types from Call Sites

For internal functions, analyze all call sites:
```rust
// During first pass, collect:
// fib_iter is called with: Integer (from literal 1000, 10000, etc.)
// Therefore, parameter n can be treated as Int

param_types: HashMap<(String, usize), VarType>, // (func_name, param_idx) -> type
```

### 3.2 Create Shadow for Integer Parameters

```rust
// In compile_function, after setting up parameters:
if param_types.get(&(name.clone(), i)) == Some(&VarType::Int) {
    let shadow = create_entry_block_alloca_i64(&format!("{}_shadow", param.name));
    let data = extract_data(param_val)?;
    builder.build_store(shadow, data);
    int_shadows.insert(param.name.clone(), shadow);
    var_types.insert(param.name.clone(), VarType::Int);
}
```

## Phase 4: PHI Node Optimization (Advanced)

The ultimate optimization: use PHI nodes instead of memory for loop variables.

### 4.1 Detect Simple Loop Pattern

```rust
// Detect: while COND { BODY }
// Where BODY only modifies integer variables in simple ways
// And variables don't escape (no function calls, no prints in loop)
```

### 4.2 Generate PHI-based Loop

```llvm
loop:
  %i = phi i64 [%i_init, %entry], [%i_next, %body]
  %a = phi i64 [0, %entry], [%b_val, %body]
  %b = phi i64 [1, %entry], [%temp, %body]
  %cmp = icmp sle i64 %i, %n
  br i1 %cmp, label %body, label %exit
body:
  %temp = add i64 %a, %b
  %i_next = add i64 %i, 1
  br label %loop
exit:
  ; box %b back to MdhValue for return
```

This eliminates ALL loads and stores from the hot path.

## Phase 5: LLVM Optimization Passes

### 5.1 Check Current Pass Configuration

```rust
// In compiler.rs, verify optimization passes
```

### 5.2 Add Missing Passes

Consider adding:
- `add_loop_unroll_pass()` - unroll small loops
- `add_licm_pass()` - loop-invariant code motion
- `add_ind_var_simplify_pass()` - induction variable simplification
- `add_aggressive_dce_pass()` - dead code elimination

## Phase 6: Benchmark After Each Change

After EVERY change:

```bash
cargo build --release
./target/release/mdhavers build benchmarks/large_scale/fib_large.braw -o /tmp/fib_test
for i in 1 2 3; do /tmp/fib_test 2>&1 | grep "fib_iter(100000)"; done
```

Also run the stress test:
```bash
./target/release/mdhavers build benchmarks/stress/computational/fib_stress.braw -o /tmp/fib_stress
/tmp/fib_stress
```

Compare to Rust:
```bash
./benchmarks/stress/rust/fib_stress
```

Track in table:
| Optimization | fib(100K) | vs Rust | Notes |
|--------------|-----------|---------|-------|
| Current | 36,000 μs | 947x | baseline |
| Lazy sync | ? | ? | |
| Param shadows | ? | ? | |
| PHI nodes | ? | ? | |

## Phase 7: Other Benchmarks

Don't forget to test other benchmarks to ensure we don't regress:
```bash
./target/release/mdhavers build benchmarks/stress/computational/primes_stress.braw -o /tmp/primes
/tmp/primes
```

## Success Criteria

1. **Minimum**: Get fib_iter(100000) under 10,000 μs (<263x Rust)
2. **Good**: Get under 5,000 μs (<132x Rust)
3. **Excellent**: Get under 1,000 μs (<26x Rust)
4. **Amazing**: Get under 100 μs (<3x Rust)

## Key Files

- `src/llvm/codegen.rs` - Main code generation (int_shadows, compile_int_expr, etc.)
- `src/llvm/compiler.rs` - LLVM pass configuration
- `benchmarks/large_scale/fib_large.braw` - Main benchmark
- `benchmarks/stress/computational/fib_stress.braw` - Stress benchmark

## Iteration Strategy

1. Start with Phase 2 (lazy sync) - quick win
2. Then Phase 3 (param shadows) - moderate effort
3. Then Phase 4 (PHI nodes) - high effort but biggest win
4. Check Phase 5 passes throughout

Each iteration should:
1. Implement ONE optimization
2. Benchmark
3. Document results
4. Commit if improvement, revert if regression

## Completion Promise Template

"Achieved fib_iter(100000) in X μs (Y times Rust)"

Aim for the best you can achieve. Even incremental progress counts!
