# mdhavers Standard Library Expansion

## Overview

This prompt implements a comprehensive expansion of the mdhavers standard library, adding essential functionality for file I/O, networking, regular expressions, date/time handling, and more. All new functions follow the Scots-themed naming convention where appropriate.

## Implementation Phases

### Phase 1: File I/O Functions

Add file operations to `src/interpreter.rs` in `define_natives()`:

#### Functions to Implement:

1. **`read_file(path)`** - Read entire file contents as string
   ```
   ken contents = read_file("data.txt")
   ```

2. **`scrieve(path, contents)`** - Write string to file (Scots for "write")
   ```
   scrieve("output.txt", "Hello, World!")
   ```

3. **`scrieve_append(path, contents)`** - Append to file
   ```
   scrieve_append("log.txt", "New log entry\n")
   ```

4. **`file_exists(path)`** - Check if file exists
   ```
   gin file_exists("config.braw") {
       blether "Config found!"
   }
   ```

5. **`file_delete(path)`** - Delete a file
   ```
   file_delete("temp.txt")
   ```

6. **`list_dir(path)`** - List directory contents as list of strings
   ```
   ken files = list_dir("./src")
   fer f in files {
       blether f
   }
   ```

7. **`make_dir(path)`** - Create directory (and parents)
   ```
   make_dir("output/reports/2024")
   ```

8. **`is_dir(path)`** - Check if path is a directory
   ```
   gin is_dir("./src") {
       blether "It's a directory"
   }
   ```

9. **`file_size(path)`** - Get file size in bytes
   ```
   ken size = file_size("data.bin")
   ```

10. **`path_join(...parts)`** - Join path components
    ```
    ken full_path = path_join("home", "user", "file.txt")
    # Returns: "home/user/file.txt"
    ```

#### Implementation Notes:
- Use `std::fs` for all file operations
- Return meaningful error messages with Scots flavor
- Handle permissions errors gracefully
- Paths should be relative to current working directory

### Phase 2: String Functions

Add to `define_natives()`:

1. **`trim(s)`** - Remove leading/trailing whitespace
   ```
   trim("  hello  ")  # Returns "hello"
   ```

2. **`trim_start(s)`** - Remove leading whitespace
3. **`trim_end(s)`** - Remove trailing whitespace

4. **`starts_with(s, prefix)`** - Check if string starts with prefix
   ```
   starts_with("hello world", "hello")  # Returns aye
   ```

5. **`ends_with(s, suffix)`** - Check if string ends with suffix

6. **`replace(s, old, new)`** - Replace all occurrences
   ```
   replace("hello world", "world", "Scotland")
   ```

7. **`replace_first(s, old, new)`** - Replace first occurrence only

8. **`pad_left(s, width, char)`** - Left pad string
   ```
   pad_left("42", 5, "0")  # Returns "00042"
   ```

9. **`pad_right(s, width, char)`** - Right pad string

10. **`char_at(s, index)`** - Get character at index (0-based)
    ```
    char_at("hello", 1)  # Returns "e"
    ```

11. **`index_of(s, substr)`** - Find first index of substring (-1 if not found)
    ```
    index_of("hello world", "world")  # Returns 6
    ```

12. **`last_index_of(s, substr)`** - Find last index of substring

13. **`substring(s, start, end)`** - Extract substring (end is exclusive)
    ```
    substring("hello world", 0, 5)  # Returns "hello"
    ```

14. **`repeat(s, n)`** - Repeat string n times
    ```
    repeat("ab", 3)  # Returns "ababab"
    ```

15. **`chars(s)`** - Convert string to list of characters
    ```
    chars("abc")  # Returns ["a", "b", "c"]
    ```

16. **`lines(s)`** - Split string by newlines
    ```
    lines("a\nb\nc")  # Returns ["a", "b", "c"]
    ```

17. **`is_empty(s)`** - Check if string is empty
18. **`is_blank(s)`** - Check if string is empty or only whitespace

### Phase 3: Math Functions

Add mathematical functions:

1. **Trigonometry:**
   - `sin(x)` - Sine (radians)
   - `cos(x)` - Cosine (radians)
   - `tan(x)` - Tangent (radians)
   - `asin(x)` - Arc sine
   - `acos(x)` - Arc cosine
   - `atan(x)` - Arc tangent
   - `atan2(y, x)` - Two-argument arc tangent

2. **Exponential/Logarithmic:**
   - `exp(x)` - e^x
   - `log(x)` - Natural logarithm
   - `log10(x)` - Base-10 logarithm
   - `log2(x)` - Base-2 logarithm
   - `pow(base, exp)` - Power function

3. **Rounding (some exist, verify):**
   - `floor(x)` - Round down
   - `ceil(x)` - Round up
   - `round(x)` - Round to nearest
   - `trunc(x)` - Truncate toward zero

4. **Random:**
   - `random()` - Random float 0.0 to 1.0
   - `random_int(min, max)` - Random integer in range (inclusive)
   - `random_choice(list)` - Random element from list

5. **Constants:**
   - `pi()` - Returns 3.14159...
   - `e()` - Returns 2.71828...
   - `tau()` - Returns 2*pi

6. **Other:**
   - `sign(x)` - Returns -1, 0, or 1
   - `clamp(x, min, max)` - Clamp value to range
   - `lerp(a, b, t)` - Linear interpolation

### Phase 4: Date/Time Functions

Add date and time handling:

1. **`noo()`** - Current timestamp (already exists, verify)

2. **`date_now()`** - Current date as dict
   ```
   ken d = date_now()
   # Returns {"year": 2024, "month": 12, "day": 15, "hour": 14, ...}
   ```

3. **`date_format(timestamp, format)`** - Format timestamp
   ```
   date_format(noo(), "%Y-%m-%d %H:%M:%S")
   ```

   Format specifiers:
   - `%Y` - 4-digit year
   - `%m` - 2-digit month
   - `%d` - 2-digit day
   - `%H` - 24-hour hour
   - `%M` - Minute
   - `%S` - Second
   - `%a` - Abbreviated weekday
   - `%A` - Full weekday
   - `%b` - Abbreviated month
   - `%B` - Full month

4. **`date_parse(string, format)`** - Parse string to timestamp
   ```
   ken ts = date_parse("2024-12-15", "%Y-%m-%d")
   ```

5. **`date_add(timestamp, amount, unit)`** - Add time
   ```
   ken tomorrow = date_add(noo(), 1, "days")
   ken next_hour = date_add(noo(), 1, "hours")
   ```
   Units: "seconds", "minutes", "hours", "days", "weeks"

6. **`date_diff(ts1, ts2, unit)`** - Difference between timestamps
   ```
   ken days_between = date_diff(start, end, "days")
   ```

7. **`timestamp()`** - Unix timestamp in seconds (float)

8. **`timestamp_millis()`** - Unix timestamp in milliseconds (integer)

### Phase 5: Regular Expressions

Add regex support (use Rust's `regex` crate):

1. **`regex_match(text, pattern)`** - Find first match, returns dict or naething
   ```
   ken m = regex_match("hello123world", "\\d+")
   # Returns {"match": "123", "start": 5, "end": 8} or naething
   ```

2. **`regex_match_all(text, pattern)`** - Find all matches, returns list
   ```
   ken matches = regex_match_all("a1b2c3", "\\d")
   # Returns [{"match": "1", ...}, {"match": "2", ...}, {"match": "3", ...}]
   ```

3. **`regex_test(text, pattern)`** - Test if pattern matches (returns bool)
   ```
   gin regex_test(email, "^[\\w.]+@[\\w]+\\.[a-z]+$") {
       blether "Valid email!"
   }
   ```

4. **`regex_replace(text, pattern, replacement)`** - Replace all matches
   ```
   regex_replace("hello world", "world", "Scotland")
   ```

5. **`regex_replace_first(text, pattern, replacement)`** - Replace first match

6. **`regex_split(text, pattern)`** - Split by regex pattern
   ```
   regex_split("a1b2c3", "\\d")  # Returns ["a", "b", "c"]
   ```

#### Add to Cargo.toml:
```toml
regex = "1.10"
```

### Phase 6: JSON Handling

JSON parsing and generation:

1. **`json_parse(string)`** - Parse JSON string to mdhavers value
   ```
   ken data = json_parse('{"name": "Alice", "age": 30}')
   blether data["name"]  # Alice
   ```

2. **`json_stringify(value)`** - Convert value to JSON string
   ```
   ken obj = {"name": "Bob", "scores": [95, 87, 92]}
   blether json_stringify(obj)
   ```

3. **`json_stringify_pretty(value)`** - Pretty-printed JSON
   ```
   blether json_stringify_pretty(obj)
   ```

Note: Use existing `serde_json` dependency.

### Phase 7: Environment & System

1. **`env_get(name)`** - Get environment variable (or naething)
   ```
   ken home = env_get("HOME")
   gin home != naething {
       blether "Home: " + home
   }
   ```

2. **`env_set(name, value)`** - Set environment variable
   ```
   env_set("MY_APP_DEBUG", "true")
   ```

3. **`env_all()`** - Get all environment variables as dict
   ```
   ken vars = env_all()
   fer name in keys(vars) {
       blether name + "=" + vars[name]
   }
   ```

4. **`shell(command)`** - Execute shell command, return output
   ```
   ken files = shell("ls -la")
   blether files
   ```

5. **`shell_status(command)`** - Execute and return exit code
   ```
   ken code = shell_status("make build")
   gin code != 0 {
       blether "Build failed!"
   }
   ```

6. **`exit(code)`** - Exit program with code
   ```
   exit(1)  # Exit with error
   ```

7. **`args()`** - Get command line arguments as list
   ```
   ken arguments = args()
   gin len(arguments) < 2 {
       blether "Usage: program <filename>"
       exit(1)
   }
   ```

8. **`cwd()`** - Get current working directory
9. **`chdir(path)`** - Change current directory

### Phase 8: Error Handling Enhancement

Add the `hurl` keyword for throwing exceptions:

#### Token Addition (token.rs):
```rust
#[token("hurl")]
Hurl,
```

#### AST Addition (ast.rs):
```rust
/// Throw/raise an exception: hurl "message"
Throw {
    message: Expr,
    span: Span,
},
```

#### Parser Addition (parser.rs):
- Add `hurl` to statement parsing
- Parse: `hurl <expression>`

#### Interpreter Addition:
- `Stmt::Throw` creates a new error that can be caught by `hae_a_bash`

#### Usage:
```
dae divide(a, b) {
    gin b == 0 {
        hurl "Cannae divide by zero!"
    }
    gie a / b
}

hae_a_bash {
    ken result = divide(10, 0)
} gin_it_gangs_wrang e {
    blether "Caught: " + e
}
```

### Phase 9: HTTP/Networking (Optional/Advanced)

If time permits, add basic HTTP support using `ureq` crate:

1. **`http_get(url)`** - GET request
   ```
   ken response = http_get("https://api.example.com/data")
   ken data = json_parse(response)
   ```

2. **`http_post(url, body)`** - POST request with JSON body
   ```
   ken response = http_post("https://api.example.com/submit", {"name": "Alice"})
   ```

3. **`http_request(method, url, headers, body)`** - Full control
   ```
   ken response = http_request("PUT", url, {"Authorization": "Bearer token"}, data)
   ```

#### Add to Cargo.toml:
```toml
ureq = { version = "2.9", features = ["json"] }
```

## Testing Requirements

### Create Golden Tests

For each function category, create test files in `tests/golden/stdlib/`:

#### File I/O Tests (`tests/golden/stdlib/file_io.braw`):
```
# Test file operations
ken test_file = "test_output.txt"

# Write and read
scrieve(test_file, "Hello, World!")
ken contents = read_file(test_file)
mak_siccar contents == "Hello, World!", "File read/write failed"

# Append
scrieve_append(test_file, "\nLine 2")
ken contents2 = read_file(test_file)
mak_siccar contains(contents2, "Line 2"), "Append failed"

# File exists
mak_siccar file_exists(test_file), "file_exists failed"
mak_siccar !file_exists("nonexistent.txt"), "file_exists false positive"

# Delete
file_delete(test_file)
mak_siccar !file_exists(test_file), "file_delete failed"

# Directory operations
make_dir("test_dir")
mak_siccar is_dir("test_dir"), "make_dir failed"
ken files = list_dir(".")
mak_siccar len(files) > 0, "list_dir failed"

blether "File I/O tests passed!"
```

#### String Tests (`tests/golden/stdlib/strings.braw`):
```
# String function tests
mak_siccar trim("  hello  ") == "hello", "trim failed"
mak_siccar starts_with("hello", "hel"), "starts_with failed"
mak_siccar ends_with("hello", "lo"), "ends_with failed"
mak_siccar replace("hello world", "world", "Scotland") == "hello Scotland", "replace failed"
mak_siccar pad_left("42", 5, "0") == "00042", "pad_left failed"
mak_siccar char_at("hello", 1) == "e", "char_at failed"
mak_siccar index_of("hello", "ll") == 2, "index_of failed"
mak_siccar substring("hello", 1, 4) == "ell", "substring failed"
mak_siccar repeat("ab", 3) == "ababab", "repeat failed"

ken c = chars("abc")
mak_siccar len(c) == 3, "chars length failed"
mak_siccar c[0] == "a", "chars content failed"

blether "String tests passed!"
```

#### Math Tests (`tests/golden/stdlib/math.braw`):
```
# Math function tests
ken pi_val = pi()
mak_siccar pi_val > 3.14 an pi_val < 3.15, "pi failed"

mak_siccar abs(sin(0)) < 0.0001, "sin(0) failed"
mak_siccar abs(cos(0) - 1) < 0.0001, "cos(0) failed"

mak_siccar pow(2, 10) == 1024, "pow failed"
mak_siccar abs(log(e()) - 1) < 0.0001, "log(e) failed"

mak_siccar sign(-5) == -1, "sign negative failed"
mak_siccar sign(0) == 0, "sign zero failed"
mak_siccar sign(5) == 1, "sign positive failed"

mak_siccar clamp(5, 0, 10) == 5, "clamp in range failed"
mak_siccar clamp(-5, 0, 10) == 0, "clamp below failed"
mak_siccar clamp(15, 0, 10) == 10, "clamp above failed"

# Random tests (just check range)
ken r = random()
mak_siccar r >= 0 an r < 1, "random range failed"

ken ri = random_int(1, 10)
mak_siccar ri >= 1 an ri <= 10, "random_int range failed"

blether "Math tests passed!"
```

#### Date/Time Tests (`tests/golden/stdlib/datetime.braw`):
```
# Date/time function tests
ken ts = timestamp()
mak_siccar ts > 0, "timestamp failed"

ken now = date_now()
mak_siccar now["year"] >= 2024, "date_now year failed"
mak_siccar now["month"] >= 1 an now["month"] <= 12, "date_now month failed"

ken formatted = date_format(noo(), "%Y-%m-%d")
mak_siccar len(formatted) == 10, "date_format failed"

ken tomorrow = date_add(noo(), 1, "days")
mak_siccar tomorrow > noo(), "date_add failed"

blether "Date/time tests passed!"
```

#### Regex Tests (`tests/golden/stdlib/regex.braw`):
```
# Regex function tests
mak_siccar regex_test("hello123", "\\d+"), "regex_test failed"
mak_siccar !regex_test("hello", "\\d+"), "regex_test false positive"

ken m = regex_match("hello123world", "\\d+")
mak_siccar m != naething, "regex_match failed"
mak_siccar m["match"] == "123", "regex_match content failed"

ken all = regex_match_all("a1b2c3", "\\d")
mak_siccar len(all) == 3, "regex_match_all count failed"

ken replaced = regex_replace("a1b2c3", "\\d", "X")
mak_siccar replaced == "aXbXcX", "regex_replace failed"

ken parts = regex_split("a,b;c", "[,;]")
mak_siccar len(parts) == 3, "regex_split failed"

blether "Regex tests passed!"
```

#### JSON Tests (`tests/golden/stdlib/json.braw`):
```
# JSON function tests
ken obj = json_parse('{"name": "Alice", "age": 30}')
mak_siccar obj["name"] == "Alice", "json_parse name failed"
mak_siccar obj["age"] == 30, "json_parse age failed"

ken arr = json_parse('[1, 2, 3]')
mak_siccar len(arr) == 3, "json_parse array failed"

ken str = json_stringify({"x": 1, "y": 2})
mak_siccar contains(str, "\"x\""), "json_stringify failed"

blether "JSON tests passed!"
```

#### Environment Tests (`tests/golden/stdlib/env.braw`):
```
# Environment function tests
ken path = env_get("PATH")
mak_siccar path != naething, "env_get PATH failed"

env_set("MDH_TEST_VAR", "test_value")
mak_siccar env_get("MDH_TEST_VAR") == "test_value", "env_set failed"

ken all_vars = env_all()
mak_siccar len(keys(all_vars)) > 0, "env_all failed"

ken cur = cwd()
mak_siccar len(cur) > 0, "cwd failed"

blether "Environment tests passed!"
```

#### Hurl/Exception Tests (`tests/golden/stdlib/exceptions.braw`):
```
# Exception handling tests
dae may_fail(should_fail) {
    gin should_fail {
        hurl "Intentional error"
    }
    gie "success"
}

# Test successful path
ken result = may_fail(nae)
mak_siccar result == "success", "may_fail success failed"

# Test error path
ken caught = nae
hae_a_bash {
    may_fail(aye)
} gin_it_gangs_wrang e {
    caught = aye
    mak_siccar contains(e, "Intentional"), "Error message wrong"
}
mak_siccar caught, "Exception not caught"

blether "Exception tests passed!"
```

## Implementation Order

1. **Phase 1: File I/O** - Most fundamental
2. **Phase 2: String Functions** - High utility
3. **Phase 3: Math Functions** - Quick wins
4. **Phase 4: Date/Time** - Common need
5. **Phase 5: Regex** - Powerful text processing
6. **Phase 6: JSON** - Data interchange
7. **Phase 7: Environment/System** - Shell integration
8. **Phase 8: Hurl keyword** - Better error handling
9. **Phase 9: HTTP** - If time permits

## Completion Criteria

- All functions implemented and working
- All golden tests passing for both interpreter and native (where applicable)
- Functions documented with Scots-themed error messages
- No regression in existing tests
