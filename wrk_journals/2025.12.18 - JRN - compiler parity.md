# Journal — Compiler Parity Work
**Date:** 2025-12-18
**Repo:** `mdhavers`
**Focus:** Close feature/semantic gaps between the Rust interpreter and the LLVM native backend.

## 09:15 — Handoff + current state
- Full test suite is currently green (`cargo test -q`) and LLVM comprehensive suite is large (~7k tests).
- Recent LLVM fixes already in tree (try/catch stability, set-union runtime function wiring, default `__current_suite`, etc.).
- Coverage work is already complete for the 98% target (see `wrk_docs/2025.12.18 - CC - code coverage analysis report.md`).

## 09:20 — Parity direction (decision)
I’m treating the **Rust interpreter as canonical semantics** for user code and aligning the LLVM backend to it.

Immediate priorities:
1) **Dict keys:** interpreter stringifies dict literal keys; LLVM currently stores typed keys. Plan: make LLVM dict literals and dict/set mutators use **stringified keys** (via `tae_string`-style conversion).
2) **Creel (set) semantics:** interpreter’s `creel(list)` constructs a set; LLVM’s `creel()` currently constructs an empty list and `creel(list)` copies lists. Plan: make LLVM `creel(...)` match interpreter and move list-copy semantics to existing list helpers (e.g. `copy()`), updating E2E tests accordingly.
3) **Range inclusive:** LLVM materialization of `a..=b` into a list currently ignores inclusivity. Plan: fix the inclusive case by materializing end as `end + 1` for the list-path.

## 09:25 — Next implementation tranche
- Implement correctness-critical placeholders called out in the parity plan:
  - Dict: `dict_get`, `dict_merge`, `dict_remove`, `dict_invert`, `fae_pairs`
  - Set: `creels_baith`, `creels_differ`, `is_subset`, `is_superset`, `is_disjoint`
  - Assertions: `assert`, `assert_equal`, `assert_nae_equal`
- Implement missing interpreter builtins in LLVM backend (inventory currently shows 52 missing names), including:
  - OS/env/fs: `args`, `cwd`, `chdir`, `env_*`, `list_dir`, `make_dir`, `is_dir`, `path_join`, `file_size`, `file_delete`, `scrieve_append`, `shell`, `shell_status`
  - Time/date: `timestamp`, `timestamp_millis`, `braw_date`, `date_*`
  - Regex: `regex_*`
  - JSON: `json_pretty`, `json_stringify_pretty` (plus replacing LLVM placeholder implementations)

## 09:55 — Stage 0 parity changes landed (compiler + runtime)
- **Ranges:** LLVM materialized range values now respect inclusivity (`..=`) by translating to an end-exclusive runtime call with `end + 1`.
- **Dict literals:** LLVM dict literal keys are now **stringified** (matches interpreter behavior).
- **Dict index-set:** LLVM `dict[key] = value` now stringifies non-string keys (matches interpreter).
- **Creels/sets:** Implemented runtime `__mdh_make_creel(list)` and rewired LLVM `creel(x)` to match interpreter semantics:
  - list → set (stringified elements)
  - dict/creel → passthrough (best-effort; LLVM runtime uses a single dict tag for both)
  - other → runtime type error
- **Set ops:** `toss_in`, `heave_oot`, and `is_in_creel` now stringify the element/key before interacting with the runtime dict-backed set.
- **E2E updates:** updated LLVM comprehensive tests to stop calling `creel()` (0-arg) and instead use `empty_creel()` / `creel([])` depending on intent.

## 11:30 — Runtime JSON repair + LLVM builtin parity tranche
- **Runtime build blocker:** `runtime/mdh_runtime.c` had a corrupted JSON “mega-line” chunk that broke compilation; wrapped the broken section in `#if 0` and reimplemented JSON parsing/stringifying/pretty-printing cleanly.
- **New/filled runtime functions:** added missing parity helpers in `runtime/mdh_runtime.c` (and prototypes in `runtime/mdh_runtime.h`), including:
  - JSON: `__mdh_json_parse`, `__mdh_json_stringify`, `__mdh_json_pretty`
  - Misc/string/list helpers: `__mdh_is_a`, `__mdh_numpty_check`, `__mdh_indices_o`, `__mdh_chunks`, `__mdh_grup`, `__mdh_interleave`, `__mdh_pair_adjacent`, `__mdh_skelp`, `__mdh_strip_left`, `__mdh_strip_right`, `__mdh_swapcase`, `__mdh_sporran_fill`, `__mdh_scottify`
  - Scots “fun”: `__mdh_mutter`, `__mdh_blooter`, `__mdh_stooshie`, `__mdh_dreich`, `__mdh_geggie`, `__mdh_jings`, `__mdh_crivvens`
- **LLVM codegen wiring:** expanded `LibcFunctions` + `declare_libc_functions` in `src/llvm/codegen.rs` and replaced many placeholders with real runtime calls (filesystem/env/date/regex/json + parity helpers).
- **ABI fix for args():** LLVM `main` is now generated as `main(i32 argc, i8** argv)` and seeds runtime args via `__mdh_set_args(argc, argv)`.
- **Semantic alignments:** updated `pair_up` to match interpreter (`pair_up(list)` only; 2-list pairing uses `zip`), and aligned `strip_left/right` arity to interpreter (2 args).

## 12:10 — Test + build validation
- Updated LLVM comprehensive tests for new semantics:
  - `pair_up(a, b)` → `zip(a, b)`
  - `strip_left/right(s)` → `strip_left/right(s, " ")`
  - `tae_json("hello")` expectation updated to proper JSON output (`"\"hello\""`).
  - `jings/crivvens/stooshie` now pass required message/string args.
  - `mutter("…")` test now uses `blether mutter("…")` (mutter returns a string; it does not print).
- Validation runs:
  - `cargo test --features llvm` ✅
  - `cargo fmt --all` ✅
  - `cargo clippy --all-targets --features llvm -- -D warnings` ✅
  - `cargo build --features llvm` ✅

## 19:40 — Final LLVM parity sweep (runtime + tests)
- **Empty dict vs creel printing:** fixed `blether {}` output mismatch (`creel{}` vs `{}`).
  - Root cause: runtime `__mdh_to_string`’s dict formatting treated “all entries key==value” as a set, and for empty dicts the loop never ran (so it always printed `creel{}`).
  - Fix: added a creel sentinel marker for *empty* creels, added `__mdh_empty_dict()`, updated dict-producing runtime paths to use it, and made stringification consult the marker (via `__mdh_dict_is_creel`).
- **Truthiness:** aligned tests with interpreter semantics that **empty strings are falsy**.
- **Fun Scots builtins:** updated LLVM E2E tests to match interpreter arities/return types for `och`, `help_ma_boab`, `banter`, `clype`, `stoater`, and `slainte`.
- **Runtime cleanup:** removed an old disabled “corrupted patch artifact” JSON block that still triggered `gcc` warnings even under `#if 0`.
- **Validation (re-run):**
  - `cargo test --features llvm` ✅
  - `cargo fmt --all` ✅
  - `cargo clippy --all-targets --features llvm -- -D warnings` ✅

## 20:58 — Type names + catchable errors + stricter len (LLVM parity)
- **Type names:** LLVM `whit_kind` now calls runtime `__mdh_type_of`, matching interpreter names (`integer`, `naething`, and `creel` vs `dict` when representable).
- **Catchable type errors:** runtime `__mdh_type_error` now throws via `__mdh_hurl` so `hae_a_bash` / `gin_it_gangs_wrang` can catch type errors (closer tae interpreter semantics).
  - Uncaught `__mdh_hurl` now prints tae **stderr** (via `__mdh_to_string`) and exits.
- **len strictness:** LLVM `len(x)` now errors on unsupported tags (previously returned 0 silently), which exposed a few missing codegen/runtime paths.
- **Backend gaps fixed (exposed by strictness):**
  - `list + list` now concatenates (LLVM `+` operator parity).
  - Implemented/wired `words`, `chunk(s)`/`batch`, and `window` builtins.
  - Dict indexing now requires string keys and throws on missing key (catchable), while a present key with `naething` value does not throw.
- **Validation (re-run):**
  - `cargo fmt --all -- --check` ✅
  - `cargo build --all-targets --features llvm` ✅
  - `cargo clippy --all-targets --features llvm -- -D warnings` ✅
  - `cargo test --features llvm` ✅

## 21:20 — Coverage guardrail (restore ≥98% after parity expansion)
- `cargo llvm-cov --tests --summary-only` now reports **98.01%** line coverage (874 missed / 43,847 total).
- Filled the regression by adding targeted WASM compiler unit tests to cover previously-unhit branches:
  - `WasmCompiler::default()`
  - local decl emission inside functions (`(local $x i64)`)
  - `ken x` (no initializer) default-to-zero
  - `brak` / `haud` (break/continue) codegen
  - unary `nae` (not) codegen
  - function calls + grouping expr codegen
  - non-direct call + unsupported-expr error paths
  - `escape_wat_string` special char escaping
- Validation (re-run): `cargo fmt --all -- --check`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo test --features llvm` ✅

## 22:35 — Stage 5 Rust FFI hardening (no longjmp across Rust)
- **Problem:** the Rust staticlib runtime (`runtime/mdh_runtime_rs`) was calling `__mdh_hurl`/`__mdh_type_error` directly from Rust on error, which can `longjmp` across Rust stack frames (UB).
- **Fix:** changed the Rust ABI to return a `MdhRsResult { ok, value, error }` struct and moved all `__mdh_hurl`/`__mdh_type_error` calls back into the C runtime wrappers in `runtime/mdh_runtime.c`.
- **JSON compatibility:** added a small “lenient unknown escape” normalizer before `serde_json::from_str` so `json_parse("\"\\q\"")` matches the interpreter’s behavior (unknown escapes become the literal char).
- **Tests:** added `tests/llvm_runtime_rs_tests.rs` to cover:
  - JSON invalid input is catchable via `hae_a_bash`/`gin_it_gangs_wrang`
  - regex invalid pattern is catchable
  - regex replacement supports `$1` capture expansion
  - JSON unknown escape leniency parity
- Validation: `cargo test --features llvm`, `cargo fmt --all -- --check`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo build --all-targets --features llvm` ✅

## 2025-12-19 — Parity cleanup (timing + randomness + error surfaces)
- **tick() parity:** LLVM tick now uses `CLOCK_REALTIME` to match interpreter’s epoch-based nanoseconds.
- **roar() parity:** LLVM roar now enforces string-only input, uppercases, and appends `!` (errors with interpreter message on bad types).
- **snooze() parity:** LLVM snooze now rejects non-integers and negative milliseconds with interpreter error messages.
- **bide() parity:** LLVM bide now accepts int/float millisecond inputs and errors for non-numeric input (float negative clamps to 0, matching Rust cast semantics).
- **stopwatch() parity:** LLVM stopwatch now enforces function-only inputs and includes function names when possible (matches interpreter message shape).
- **dram/random_choice parity:** LLVM now type-checks list inputs and emits interpreter-matching error strings for non-lists.
- Validation: `cargo fmt --all`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo test --features llvm`, `cargo build --all-targets --features llvm` ✅

## 2025-12-19 — Closure tagging parity (functions vs lists)
- **New Closure tag:** added `Closure`/`MDH_TAG_CLOSURE` to keep captured lambdas distinct from lists.
- **Codegen:** captured lambdas and captured named functions now emit Closure-tagged values; `call_function_value` checks Closure explicitly and errors on non-callables.
- **Runtime:** `__mdh_type_name`, `__mdh_is_function`, and `__mdh_is_a` treat Closure as `function`; type errors show “function” for closure tags.
- **Rust runtime:** JSON stringify treats Closure/Function via fallback (same as other non-JSONable types).
- **Tests:** ValueTag coverage now asserts `Set` and `Closure` tag values.
- Validation: `cargo fmt --all`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo test --features llvm`, `cargo build --all-targets --features llvm` ✅

## 2025-12-19 — tae_string parity for complex values
- **LLVM `tae_string`:** removed bespoke list formatting and empty-string fallback; non-primitive values now call runtime `__mdh_to_string`, matching interpreter recursion for lists/dicts/sets/bools.
- **Runtime linkage:** added `__mdh_to_string` to LLVM runtime function table.
- Validation: `cargo fmt --all`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo test --features llvm`, `cargo build --all-targets --features llvm` ✅

## 2025-12-19 — tae_int/tae_float strict parsing parity
- **Runtime:** `__mdh_to_int`/`__mdh_to_float` now reject nil/unsupported types, validate full-string parses (no leading whitespace/trailing junk), and emit interpreter-matching errors for invalid strings.
- **LLVM:** `inline_tae_int`/`inline_tae_float` now delegate to runtime `__mdh_to_int`/`__mdh_to_float` for exact error parity.
- Validation: `cargo fmt --all`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo test --features llvm`, `cargo build --all-targets --features llvm` ✅

## 2025-12-19 — grup_up/pairt_by parity (LLVM HOFs)
- **LLVM:** added `grup_up(list, fn)` (group-by) and `pairt_by(list, fn)` (partition) implementations, matching interpreter behavior and list order semantics.
- **Tests:** added LLVM runtime tests for both builtins.
- Validation: `cargo fmt --all`, `cargo clippy --all-targets --features llvm -- -D warnings`, `cargo test --features llvm`, `cargo build --all-targets --features llvm` ✅
